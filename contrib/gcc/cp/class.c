begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building classes and their related objects.    Copyright (C) 1987, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is how we tell when two virtual member functions are really the    same. */
end_comment

begin_define
define|#
directive|define
name|SAME_FN
parameter_list|(
name|FN1DECL
parameter_list|,
name|FN2DECL
parameter_list|)
value|(DECL_ASSEMBLER_NAME (FN1DECL) == DECL_ASSEMBLER_NAME (FN2DECL))
end_define

begin_decl_stmt
specifier|extern
name|void
name|set_class_shadows
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking class types.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|current_class_base
decl_stmt|,
modifier|*
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_class_stacksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|class_level
block|{
comment|/* The previous class level.  */
name|struct
name|class_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* The class instance variable, as a PARM_DECL.  */
name|tree
name|decl
decl_stmt|;
comment|/* The class instance variable, as an object.  */
name|tree
name|object
decl_stmt|;
comment|/* The virtual function table pointer      for the class instance variable.  */
name|tree
name|vtable_decl
decl_stmt|;
comment|/* Name of the current class.  */
name|tree
name|name
decl_stmt|;
comment|/* Type of the current class.  */
name|tree
name|type
decl_stmt|;
comment|/* Flags for this class level.  */
name|int
name|this_is_variable
decl_stmt|;
name|int
name|memoized_lookups
decl_stmt|;
name|int
name|save_memoized
decl_stmt|;
name|int
name|unused
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|tree
name|current_class_decl
decl_stmt|,
name|C_C_D
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PARM_DECL: the class instance variable */
end_comment

begin_comment
comment|/* The following two can be derived from the previous one */
end_comment

begin_decl_stmt
name|tree
name|current_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IDENTIFIER_NODE: name of current class */
end_comment

begin_decl_stmt
name|tree
name|current_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the type of the current class */
end_comment

begin_decl_stmt
name|tree
name|previous_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the previous type that was a class */
end_comment

begin_decl_stmt
name|tree
name|previous_class_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TREE_LIST: copy of the class_shadowed list 				   when leaving an outermost class scope.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|get_vfield_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|the_null_vtable_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking language names.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_lang_stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of languages we recognize.  */
end_comment

begin_decl_stmt
name|tree
name|lang_name_c
decl_stmt|,
name|lang_name_cplusplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_lang_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dont_allow_type_definitions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When layout out an aggregate type, the size of the    basetypes (virtual and non-virtual) is passed to layout_record    via this node.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|base_layout_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables shared between class.c and call.c.  */
end_comment

begin_decl_stmt
name|int
name|n_vtables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_searches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_elems
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_convert_harshness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_compute_conversion_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_build_method_call
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inner_fields_searched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual baseclass things.  */
end_comment

begin_function
name|tree
name|build_vbase_pointer
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Is the type of the EXPR, the complete type of the object?    If we are going to be wrong, we must be conservative, and return 0. */
end_comment

begin_function
name|int
name|complete_type_p
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|expr
argument_list|)
condition|)
break|break;
comment|/* fall through... */
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|type
condition|)
return|return
literal|1
return|;
comment|/* fall through... */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|type
condition|)
return|return
literal|1
return|;
comment|/* fall through... */
case|case
name|PLUS_EXPR
case|:
default|default:
break|break;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build multi-level access to EXPR using hierarchy path PATH.    CODE is PLUS_EXPR if we are going with the grain,    and MINUS_EXPR if we are not (in which case, we cannot traverse    virtual baseclass links).     TYPE is the type we want this path to have on exit.     ALIAS_THIS is non-zero if EXPR in an expression involving `this'.  */
end_comment

begin_function
name|tree
name|build_vbase_path
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|expr
parameter_list|,
name|path
parameter_list|,
name|alias_this
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|,
name|path
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|,
name|last_virtual
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|nonnull
init|=
literal|0
decl_stmt|;
name|int
name|fixed_type_p
init|=
name|resolves_to_fixed_type_p
argument_list|(
name|expr
argument_list|,
operator|&
name|nonnull
argument_list|)
decl_stmt|;
name|tree
name|null_expr
init|=
literal|0
decl_stmt|,
name|nonnull_expr
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
operator|(
name|alias_this
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
operator|)
condition|)
name|nonnull
operator|=
literal|1
expr_stmt|;
comment|/* We need additional logic to convert back to the unconverted type      (the static type of the complete object), and then convert back      to the type we want.  Until that is done, or until we can      recognize when that is, we cannot do the short cut logic. (mrs) */
comment|/* Do this, until we can undo any previous conversions.  See net35.C      for a testcase. */
name|fixed_type_p
operator|=
name|complete_type_p
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_type_p
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|tree
name|reverse_path
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|path
condition|)
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|reverse_path
expr_stmt|;
name|reverse_path
operator|=
name|r
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|reverse_path
expr_stmt|;
block|}
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|last_virtual
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
name|changed
operator|=
operator|!
name|fixed_type_p
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
specifier|extern
name|int
name|flag_assume_nonnull_objects
decl_stmt|;
name|tree
name|ind
decl_stmt|;
comment|/* We already check for ambiguous things in the caller, just 		     find a path. */
if|if
condition|(
name|last
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nonnull_expr
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|build_indirect_ref
argument_list|(
name|nonnull_expr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|build_vbase_pointer
argument_list|(
name|ind
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
operator|!
name|flag_assume_nonnull_objects
operator|)
operator|&&
name|null_expr
operator|==
name|NULL_TREE
condition|)
block|{
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else we'll figure out the offset below.  */
comment|/* Happens in the case of parse errors.  */
if|if
condition|(
name|nonnull_expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot cast up from virtual baseclass `%T'"
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|last
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* LAST is now the last basetype assoc on the path.  */
comment|/* A pointer to a virtual base member of a non-null object      is non-null.  Therefore, we only need to test for zeroness once.      Make EXPR the canonical expression to deal with here.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|nonnull_expr
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|nonnull_expr
expr_stmt|;
comment|/* If we go through any virtual base pointers, make sure that      casts to BASETYPE from the last virtual base class use      the right value for BASETYPE.  */
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_virtual
condition|)
block|{
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo_member
argument_list|(
name|last_virtual
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
condition|)
block|{
comment|/* Bash types to make the backend happy.  */
name|offset
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* For multiple inheritance: if `this' can be set by any 	 function, then it could be 0 on entry to any function. 	 Preserve such zeroness here.  Otherwise, only in the 	 case of constructors need we worry, and in those cases, 	 it will be zero, or initialized to some valid value to 	 which we may add.  */
if|if
condition|(
name|nonnull
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|null_expr
condition|)
name|TREE_TYPE
argument_list|(
name|null_expr
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Cannot change the TREE_TYPE of a NOP_EXPR here, since it may      be used multiple times in initialization of multiple inheritance.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Virtual function things.  */
end_comment

begin_comment
comment|/* Virtual functions to be dealt with after laying out our base    classes.  We do all overrides after we layout virtual base classes.    */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_hard_virtuals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doing_hard_virtuals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build an entry in the virtual function table.    DELTA is the offset for the `this' pointer.    PFN is an ADDR_EXPR containing a pointer to the virtual function.    Note that the index (DELTA2) in the virtual function table    is always 0.  */
end_comment

begin_function
name|tree
name|build_vtable_entry
parameter_list|(
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|delta
decl_stmt|,
name|pfn
decl_stmt|;
block|{
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
name|HOST_WIDE_INT
name|idelta
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
decl_stmt|;
specifier|extern
name|tree
name|make_thunk
parameter_list|()
function_decl|;
if|if
condition|(
name|idelta
condition|)
block|{
name|pfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|make_thunk
argument_list|(
name|pfn
argument_list|,
name|idelta
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|pfn
return|;
block|}
else|else
block|{
specifier|extern
name|int
name|flag_huge_objects
decl_stmt|;
name|tree
name|elems
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|pfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|entry
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
decl_stmt|;
comment|/* DELTA is constructed by `size_int', which means it may be an 	 unsigned quantity on some platforms.  Therefore, we cannot use 	 `int_fits_type_p', because when DELTA is really negative, 	 `force_fit_type' will make it look like a very large number.  */
if|if
condition|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|delta_type_node
argument_list|)
argument_list|)
operator|<
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
operator|)
operator|||
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
operator|<
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|delta_type_node
argument_list|)
argument_list|)
operator|)
condition|)
if|if
condition|(
name|flag_huge_objects
condition|)
name|sorry
argument_list|(
literal|"object size exceeds built-in limit for virtual function table implementation"
argument_list|)
expr_stmt|;
else|else
name|sorry
argument_list|(
literal|"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects"
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    virtual function corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|ptr_to_instptr
parameter_list|,
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
modifier|*
name|ptr_to_instptr
decl_stmt|,
name|instance
decl_stmt|;
name|tree
name|idx
decl_stmt|;
block|{
specifier|extern
name|int
name|building_cleanup
decl_stmt|;
name|tree
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|C_C_D
condition|)
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Try to figure out what a reference refers to, and 	     access its virtual function table directly.  */
name|tree
name|ref
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|instance
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|instance
operator|=
name|init
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|vtbl
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Save the intermediate result in a SAVE_EXPR so we don't have to      compute each component of the virtual function pointer twice.  */
if|if
condition|(
operator|!
name|building_cleanup
operator|&&
name|TREE_CODE
argument_list|(
name|aref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_thunks
condition|)
return|return
name|aref
return|;
else|else
block|{
if|if
condition|(
name|ptr_to_instptr
condition|)
operator|*
name|ptr_to_instptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|ptr_to_instptr
argument_list|)
argument_list|,
operator|*
name|ptr_to_instptr
argument_list|,
name|convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type_id
init|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|type_id
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|type_id
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
index|[
name|i
index|]
operator|==
name|OPERATOR_TYPENAME_FORMAT
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|#
directive|if
literal|0
comment|/* We don't take off the numbers; prepare_fresh_vtable uses the      DECL_ASSEMBLER_NAME for the type, which includes the number      in `3foo'.  If we were to pull them off here, we'd end up with      something like `_vt.foo.3bar', instead of a uniform definition.  */
block|while (ptr[i]>= '0'&& ptr[i]<= '9')     i += 1;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|ptr
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a virtual function for type TYPE.    If BINFO is non-NULL, build the vtable starting with the initial    approximation that it is the same as the one which is the head of    the association list.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|name
init|=
name|get_vtable_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|virtuals
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|virtuals
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|WRITABLE_VTABLES
comment|/* Make them READONLY by default. (mrs) */
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* At one time the vtable info was grabbed 2 words at a time.  This      fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Why is this conditional? (mrs) */
if|if
condition|(
name|binfo
operator|&&
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given a base type PARENT, and a derived type TYPE, build    a name which distinguishes exactly the PARENT member of TYPE's type.     FORMAT is a string which controls how sprintf formats the name    we have generated.     For example, given  	class A; class B; class C : A, B;     it is possible to distinguish "A" from "C's A".  And given  	class L; 	class A : L; class B : L; class C : A, B;     it is possible to distinguish "L" from "A's L", and also from    "C's L from A".     Make sure to use the DECL_ASSEMBLER_NAME of the TYPE_NAME of the    type, as template have DECL_NAMEs like: X<int>, whereas the    DECL_ASSEMBLER_NAME is set to be something the assembler can handle.   */
end_comment

begin_function
specifier|static
name|tree
name|build_type_pathname
parameter_list|(
name|format
parameter_list|,
name|parent
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|tree
name|parent
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
name|char
modifier|*
name|first
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|parent
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* Remember where to cut the obstack to.  */
name|first
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
comment|/* Put on TYPE+PARENT.  */
name|obstack_grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOINER
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|JOINER
argument_list|)
expr_stmt|;
else|#
directive|else
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obstack_grow0
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|parent
argument_list|)
argument_list|,
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|base
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
comment|/* Put on FORMAT+TYPE+PARENT.  */
name|obstack_blank
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|strlen
argument_list|(
name|format
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_base
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|format
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Update the rtti info for this class.  */
end_comment

begin_function
specifier|static
name|void
name|set_rtti_entry
parameter_list|(
name|virtuals
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|tree
name|virtuals
decl_stmt|,
name|offset
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_vtable_thunks
condition|)
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|offset
argument_list|,
operator|(
name|flag_rtti
condition|?
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
else|:
name|integer_zero_node
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|vfn
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
comment|/* The second slot is for the tdesc pointer when thunks are used.  */
name|vfn
operator|=
name|flag_rtti
condition|?
name|build_t_desc
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
else|:
name|integer_zero_node
expr_stmt|;
name|vfn
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Give TYPE a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the derived type which caused this table to    be needed.     BINFO is the type association which provided TYPE for FOR_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_fresh_vtable
parameter_list|(
name|binfo
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|for_type
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|orig_decl
init|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* This name is too simplistic.  We can have multiple basetypes for      for_type, and we really want different names.  (mrs) */
name|tree
name|name
init|=
name|build_type_pathname
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|,
name|basetype
argument_list|,
name|for_type
argument_list|)
decl_stmt|;
name|tree
name|new_decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|path
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Remember which class this vtable is really for.  */
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|for_type
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|pushdecl_top_level
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|WRITABLE_VTABLES
comment|/* Make them READONLY by default. (mrs) */
name|TREE_READONLY
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|DECL_ALIGN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|for_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|offset
argument_list|)
argument_list|,
name|for_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|new_decl
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|binfo
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
literal|170
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Access the virtual function table entry that logically    contains BASE_FNDECL.  VIRTUALS is the virtual function table's    initializer.  We can run off the end, when dealing with virtual    destructors in MI situations, return NULL_TREE in that case.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_entry
parameter_list|(
name|virtuals
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|virtuals
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|n
init|=
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|BITS_PER_WORD
condition|?
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_searches
operator|+=
name|n
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|virtuals
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Put new entry ENTRY into virtual function table initializer    VIRTUALS.     Also update DECL_VINDEX (FNDECL).  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|old_entry_in_list
parameter_list|,
name|new_entry
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|old_entry_in_list
decl_stmt|,
name|new_entry
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"replaced %D with %D"
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
operator|=
name|new_entry
expr_stmt|;
comment|/* Now assign virtual dispatch information, if unset.  */
comment|/* We can dispatch this, through any overridden base function. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Access the virtual function table entry i.  VIRTUALS is the virtual    function table's initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_entry_n
parameter_list|(
name|virtuals
parameter_list|,
name|n
parameter_list|)
name|tree
name|virtuals
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Add a virtual function to all the appropriate vtables for the class    T.  DECL_VINDEX(X) should be error_mark_node, if we want to    allocate a new slot in our table.  If it is error_mark_node, we    know that no other function from another vtable is overridden by X.    HAS_VIRTUAL keeps track of how many virtuals there are in our main    vtable for the type, and we build upon the PENDING_VIRTUALS list    and return it.  */
end_comment

begin_function
specifier|static
name|tree
name|add_virtual_function
parameter_list|(
name|pending_virtuals
parameter_list|,
name|has_virtual
parameter_list|,
name|fndecl
parameter_list|,
name|t
parameter_list|)
name|tree
name|pending_virtuals
decl_stmt|;
name|int
modifier|*
name|has_virtual
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Structure type. */
block|{
comment|/* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely      convert to void *.  Make such a conversion here.  */
name|tree
name|vfn
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|DUMB_USER
if|if
condition|(
name|current_class_type
operator|==
literal|0
condition|)
name|cp_warning
argument_list|(
literal|"internal problem, current_class_type is zero when adding `%D', please report"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|t
operator|!=
name|current_class_type
condition|)
name|cp_warning
argument_list|(
literal|"internal problem, current_class_type differs when adding `%D', please report"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the virtual function is a redefinition of a prior one,      figure out in which base class the new definition goes,      and if necessary, make a fresh virtual function table      to hold that entry.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|tree
name|entry
decl_stmt|;
if|if
condition|(
name|flag_rtti
operator|&&
operator|*
name|has_virtual
operator|==
literal|0
condition|)
block|{
comment|/* CLASSTYPE_RTTI is only used as a Boolean (NULL or not). */
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|integer_one_node
expr_stmt|;
block|}
comment|/* If we are using thunks, use two slots at the front, one 	 for the offset pointer, one for the tdesc pointer.  */
if|if
condition|(
operator|*
name|has_virtual
operator|==
literal|0
operator|&&
name|flag_vtable_thunks
condition|)
block|{
operator|*
name|has_virtual
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Build a new INT_CST for this DECL_VINDEX.  */
block|{
specifier|static
name|tree
name|index_table
index|[
literal|256
index|]
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* We skip a slot for the offset/tdesc entry.  */
name|int
name|i
init|=
operator|++
operator|(
operator|*
name|has_virtual
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
operator|||
name|index_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|index
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|256
condition|)
name|index_table
index|[
name|i
index|]
operator|=
name|index
expr_stmt|;
block|}
else|else
name|index
operator|=
name|index_table
index|[
name|i
index|]
expr_stmt|;
comment|/* Now assign virtual dispatch information. */
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|index
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
name|entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Might already be INTEGER_CST if declared twice in class.  We will      give error later or we've already given it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* Need an entry in some other virtual function table.          Deal with this after we have laid out our virtual base classes.  */
name|pending_hard_virtuals
operator|=
name|temp_tree_cons
argument_list|(
name|fndecl
argument_list|,
name|vfn
argument_list|,
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|pending_virtuals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Obstack on which to build the vector of class methods.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add method METHOD to class TYPE.  This is used when a method    has been defined which did not initially appear in the class definition,    and helps cut down on spurious error messages.     FIELDS is the entry in the METHOD_VEC vector entry of the class type where    the method should be added.  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|type
parameter_list|,
name|fields
parameter_list|,
name|method
parameter_list|)
name|tree
name|type
decl_stmt|,
decl|*
name|fields
decl_stmt|,
name|method
decl_stmt|;
end_function

begin_block
block|{
comment|/* We must make a copy of METHOD here, since we must be sure that      we have exclusive title to this method's DECL_CHAIN.  */
name|tree
name|decl
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
block|{
name|decl
operator|=
name|copy_node
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|processing_template_decl
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|method
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fields
operator|&&
operator|*
name|fields
condition|)
block|{
comment|/* Take care not to hide destructor.  */
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
operator|*
name|fields
argument_list|)
expr_stmt|;
name|DECL_CHAIN
argument_list|(
operator|*
name|fields
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|method_vec
init|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Is it possible for there to have been enough room in the 	     current chunk for the tree_vec structure but not a tree_vec 	     plus a tree*?  Will this work in that case?  */
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|2
expr_stmt|;
name|obstack_finish
argument_list|(
name|current_obstack
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
block|}
else|else
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
comment|/* Adding a new ctor or dtor.  This is easy because our          METHOD_VEC always has a slot for such entries.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* TREE_VEC_ELT (method_vec, 0) = decl; */
if|if
condition|(
name|decl
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is trickier.  We try to extend the TREE_VEC in-place, 	     but if that does not work, we copy all its data to a new 	     TREE_VEC that's large enough.  */
name|struct
name|obstack
modifier|*
name|ob
init|=
operator|&
name|class_obstack
decl_stmt|;
name|tree
modifier|*
name|end
init|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|ob
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|)
block|{
name|ob
operator|=
name|current_obstack
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|method_vec
operator|=
name|copy_node
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tmp_vec
init|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
name|ob
argument_list|)
decl_stmt|;
if|if
condition|(
name|obstack_room
argument_list|(
name|ob
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
condition|)
block|{
name|obstack_blank
argument_list|(
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_VEC
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_vec
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|method_vec
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp_vec
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_VEC
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|tmp_vec
expr_stmt|;
block|}
else|else
name|obstack_blank
argument_list|(
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obstack_finish
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* ??? May be better to know whether these can be extended?  */
name|tree
name|baselink_vec
init|=
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|copy_node
argument_list|(
name|baselink_vec
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Look through the list of fields for this struct, deleting    duplicates as we go.  This must be recursive to handle    anonymous unions.     FIELD is the field which may not appear anywhere in FIELDS.    FIELD_PTR, if non-null, is the starting point at which    chained deletions may take place.    The value returned is the first acceptable entry found    in FIELDS.     Note that anonymous fields which are not of UNION_TYPE are    not duplicates, they are just anonymous fields.  This happens    when we have unnamed bitfields, for example.  */
end_comment

begin_function
specifier|static
name|tree
name|delete_duplicate_fields_1
parameter_list|(
name|field
parameter_list|,
name|fields
parameter_list|)
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
return|return
name|fields
return|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|fields
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|fields
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|field
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate enum value `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as enum and non-enum)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate nested type `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as type and non-type)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"duplicate member `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|fields
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_duplicate_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the access of FDECL to ACCESS in T.    Return 1 if change was legit, otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_access
parameter_list|(
name|t
parameter_list|,
name|fdecl
parameter_list|,
name|access
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fdecl
decl_stmt|;
name|enum
name|access_type
name|access
decl_stmt|;
block|{
name|tree
name|elem
init|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem
operator|&&
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
operator|(
name|tree
operator|)
name|access
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"conflicting access specifications for method `%D', ignored"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"conflicting access specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
operator|!=
name|access_private
condition|)
name|cp_error_at
argument_list|(
literal|"cannot make private `%D' non-private"
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
goto|goto
name|alter
goto|;
block|}
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
operator|!=
name|access_protected
condition|)
name|cp_error_at
argument_list|(
literal|"cannot make protected `%D' non-protected"
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
goto|goto
name|alter
goto|;
block|}
comment|/* ARM 11.3: an access declaration may not be used to restrict access      to a member that is accessible in the base class.  */
elseif|else
if|if
condition|(
name|access
operator|!=
name|access_public
condition|)
name|cp_error_at
argument_list|(
literal|"cannot reduce access of public member `%D'"
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|==
name|NULL_TREE
condition|)
block|{
name|alter
label|:
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
operator|(
name|tree
operator|)
name|access
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the offset to the main vtable for a given base BINFO.  */
end_comment

begin_function
name|tree
name|get_vfield_offset
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the offset to the start of the original binfo that we derived    this binfo from.  If we find TYPE first, return the offset only    that far.  The shortened search is useful because the this pointer    on method calling is expected to point to a DECL_CONTEXT (fndecl)    object, and not a baseclass of it.  */
end_comment

begin_function
specifier|static
name|tree
name|get_derived_offset
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|offset1
init|=
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|offset2
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|type
condition|)
break|break;
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|offset2
operator|=
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset1
argument_list|,
name|offset2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If FOR_TYPE needs to reinitialize virtual function table pointers    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.    Returns BASE_INIT_LIST appropriately modified.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fixup_vptrs
parameter_list|(
name|for_type
parameter_list|,
name|binfo
parameter_list|,
name|base_init_list
parameter_list|)
name|tree
name|for_type
decl_stmt|,
name|binfo
decl_stmt|,
name|base_init_list
decl_stmt|;
block|{
comment|/* Now reinitialize any slots that don't fall under our virtual      function table pointer.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
name|tree
name|basetype
init|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
condition|?
name|TYPE_MAIN_VARIANT
argument_list|(
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
else|:
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Punt until this is implemented. */
if|if
condition|(
literal|1
comment|/* BINFO_MODIFIED (base_binfo) */
condition|)
block|{
name|tree
name|base_offset
init|=
name|get_vfield_offset
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|base_offset
argument_list|,
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|for_type
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|base_offset
argument_list|,
name|get_vfield_offset
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
return|return
name|base_init_list
return|;
block|}
end_function

begin_comment
comment|/* If TYPE does not have a constructor, then the compiler must    manually deal with all of the initialization this type requires.     If a base initializer exists only to fill in the virtual function    table pointer, then we mark that fact with the TREE_VIRTUAL bit.    This way, we avoid multiple initializations of the same field by    each virtual function table up the class hierarchy.     Virtual base class pointers are not initialized here.  They are    initialized only at the "top level" of object creation.  If we    initialized them here, we would have to skip a lot of work.  */
end_comment

begin_function
specifier|static
name|void
name|build_class_init_list
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|base_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Since we build member_init_list and base_init_list using      tree_cons, backwards fields the all through work.  */
name|tree
name|x
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|x
argument_list|,
name|type
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|member_init_list
operator|=
name|nreverse
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
comment|/* We will end up doing this last.  Need special marker      to avoid infinite regress.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Each base class which needs to have initialization      of some kind gets to make such requests known here.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|blist
decl_stmt|;
comment|/* Don't initialize virtual baseclasses this way.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* ...and the last shall come first...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|blist
operator|=
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL_TREE
condition|)
comment|/* Nothing to initialize.  */
continue|continue;
comment|/* ...ditto...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* This is normally true for single inheritance. 	 The win is we can shrink the chain of initializations 	 to be done by only converting to the actual type 	 we are interested in.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|base_init_list
condition|)
block|{
comment|/* Does it do more than just fill in a 		 virtual function table pointer?  */
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|blist
argument_list|)
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* Can we get by just with the virtual function table 		 pointer that it fills in?  */
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|blist
expr_stmt|;
comment|/* Maybe, but it is not obvious as the previous case.  */
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|base_init_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|last
operator|=
name|tree_last
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|base_init_list
operator|=
name|blist
expr_stmt|;
block|}
else|else
block|{
comment|/* The function expand_aggr_init knows how to do the 	     initialization of `basetype' without getting 	     an explicit `blist'.  */
if|if
condition|(
name|base_init_list
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
else|else
name|base_init_list
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_init_list
condition|)
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|base_init_list
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|base_init_list
expr_stmt|;
elseif|else
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|member_init_list
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|base_info
block|{
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|int
name|n_ancestors
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|char
name|cant_have_default_ctor
decl_stmt|;
name|char
name|cant_have_const_ctor
decl_stmt|;
name|char
name|cant_synth_copy_ctor
decl_stmt|;
name|char
name|cant_synth_asn_ref
decl_stmt|;
name|char
name|no_const_asn_ref
decl_stmt|;
name|char
name|needs_virtual_dtor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about type T derived from its base classes.    Store most of that information in T itself, and place the    remaining information in the struct BASE_INFO.     Propagate basetype offsets throughout the lattice.  Note that the    lattice topped by T is really a pair: it's a DAG that gives the    structure of the derivation hierarchy, and it's a list of the    virtual baseclasses that appear anywhere in the DAG.  When a vbase    type appears in the DAG, it's offset is 0, and it's children start    their offsets from that point.  When a vbase type appears in the list,    its offset is the offset it has in the hierarchy, and its children's    offsets include that offset in theirs.     Returns the index of the first base class to have virtual functions,    or -1 if no such base class.     Note that at this point TYPE_BINFO (t) != t_binfo.  */
end_comment

begin_function
specifier|static
name|int
name|finish_base_struct
parameter_list|(
name|t
parameter_list|,
name|b
parameter_list|,
name|t_binfo
parameter_list|)
name|tree
name|t
decl_stmt|;
name|struct
name|base_info
modifier|*
name|b
decl_stmt|;
name|tree
name|t_binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|first_vfn_base_index
init|=
operator|-
literal|1
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|base_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* If the type of basetype is incomplete, then 	 we already complained about that fact 	 (and we should have fixed it up as well).  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
operator|-
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|basetype
argument_list|)
operator|||
operator|(
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|basetype
argument_list|)
operator|==
literal|2
operator|&&
operator|!
name|is_friend_type
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|)
operator|)
condition|)
name|b
operator|->
name|cant_synth_copy_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|b
operator|->
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"base `%T' with only non-default constructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"in class without a constructor"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|||
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|||
operator|(
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|==
literal|2
operator|&&
operator|!
name|is_friend_type
argument_list|(
name|t
argument_list|,
name|basetype
argument_list|)
operator|)
condition|)
name|b
operator|->
name|cant_synth_asn_ref
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|n_ancestors
operator|+=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
if|#
directive|if
literal|0
comment|/* This cannot be done, as prepare_fresh_vtable wants to modify 	     binfos associated with vfields anywhere in the hierarchy, not 	     just immediate base classes.  Due to unsharing, the compiler 	     might consume 3% more memory on a real program. 	     */
expr|&& ! BINFO_OFFSET_ZEROP (base_binfo)
endif|#
directive|endif
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|tree
name|base_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|chain
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Now unshare the structure beneath BASE_BINFO.  */
for|for
control|(
name|j
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|base_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_base_binfo
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|base_base_binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|base_base_binfo
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_base_binfo
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|chain
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
block|}
comment|/* Completely unshare potentially shared data, and 	     update what is ours.  */
name|propagate_binfo_offsets
argument_list|(
name|base_binfo
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* If there's going to be a destructor needed, make 	     sure it will be virtual.  */
name|b
operator|->
name|needs_virtual_dtor
operator|=
literal|1
expr_stmt|;
comment|/* Don't borrow virtuals from virtual baseclasses.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
name|tree
name|vfields
decl_stmt|;
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
comment|/* Update these two, now that we know what vtable we are 		 going to extend.  This is so that we can add virtual 		 functions, and override them properly.  */
name|BINFO_VTABLE
argument_list|(
name|t_binfo
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|t_binfo
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfields
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|vfields
operator|=
name|b
operator|->
name|vfields
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
else|else
block|{
comment|/* Only add unique vfields, and flatten them out as we go.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
name|b
operator|->
name|vfields
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|value
argument_list|,
name|b
operator|->
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|has_virtual
operator|==
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
comment|/* Update these two, now that we know what vtable we are 		     going to extend.  This is so that we can add virtual 		     functions, and override them properly.  */
name|BINFO_VTABLE
argument_list|(
name|t_binfo
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|t_binfo
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
comment|/* When we install the first one, set the VF_NORMAL_VALUE 		     to be the current class, as this it is the most derived 		     class.  Hopefully, this is not set to something else 		     later.  (mrs) */
name|vfields
operator|=
name|b
operator|->
name|vfields
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* There should only be one of them!  And it should 			     always be found, if we get into here.  (mrs)  */
break|break;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Must come after offsets are fixed for all bases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|t_binfo
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
name|cp_warning
argument_list|(
literal|"direct base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|b
operator|->
name|cant_synth_asn_ref
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|cant_synth_copy_ctor
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|{
name|tree
name|v
init|=
name|get_vbase_types
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|t_binfo
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
name|cp_warning
argument_list|(
literal|"virtual base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|b
operator|->
name|cant_synth_asn_ref
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|cant_synth_copy_ctor
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Find the base class with the largest number of virtual functions.  */
for|for
control|(
name|vfields
operator|=
name|b
operator|->
name|vfields
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|->
name|vfield
operator|==
literal|0
condition|)
comment|/* If all virtual functions come only from virtual baseclasses.  */
return|return
operator|-
literal|1
return|;
return|return
name|first_vfn_base_index
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|typecode_p
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later use.    MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|t
parameter_list|,
name|max_has_virtual
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
comment|/* These fields are in the _TYPE part of the node, not in 	 the TYPE_LANG_SPECIFIC component, so they are not shared.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_VIRTUAL_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy whatever these are holding today.  */
name|TYPE_MIN_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|max_has_virtual
condition|)
block|{
comment|/* Done by `finish_struct' for classes without baseclasses.  */
name|int
name|might_have_abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|might_have_abstract_virtuals
operator||=
operator|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|might_have_abstract_virtuals
condition|)
break|break;
block|}
if|if
condition|(
name|might_have_abstract_virtuals
condition|)
block|{
comment|/* We use error_mark_node from override_one_vtable to signal 	     an artificial abstract. */
if|if
condition|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|get_abstract_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined.  */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|basetype
argument_list|)
operator|>=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this type has a copy constructor, force its mode to be BLKmode, and      force its TREE_ADDRESSABLE bit to be nonzero.  This will cause it to      be passed by invisible reference and prevent it from being returned in      a register.  */
if|if
condition|(
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|variants
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|DECL_MODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|variants
operator|=
name|t
init|;
name|variants
condition|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
control|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add FN to the method_vec growing on the class_obstack.  Used by    finish_struct_methods.  */
end_comment

begin_function
specifier|static
name|void
name|grow_method
parameter_list|(
name|fn
parameter_list|,
name|method_vec_ptr
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
modifier|*
name|method_vec_ptr
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|testp
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|testp
operator|==
name|NULL_TREE
condition|)
name|testp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|testp
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|)
operator|&&
name|DECL_NAME
argument_list|(
operator|*
name|testp
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
condition|)
name|testp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|HOST_WIDE_INT
operator|)
name|testp
operator|<
operator|(
name|HOST_WIDE_INT
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
condition|)
block|{
name|tree
name|x
decl_stmt|,
name|prev_x
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|*
name|testp
init|;
name|x
condition|;
name|x
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|||
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
block|{
comment|/* ANSI C++ June 5 1992 WP 12.5.5.1 */
name|cp_error_at
argument_list|(
literal|"`%D' overloaded"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous declaration as `%D' here"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We complain about multiple destructors on sight, 		 so we do not repeat the warning here.  Friend-friend 		 ambiguities are warned about outside this loop.  */
if|if
condition|(
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"ambiguous method `%#D' in structure"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev_x
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|testp
condition|)
name|DECL_CHAIN
argument_list|(
name|prev_x
argument_list|)
operator|=
name|fn
expr_stmt|;
else|else
operator|*
name|testp
operator|=
name|fn
expr_stmt|;
block|}
block|}
else|else
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|fn
argument_list|)
expr_stmt|;
operator|*
name|method_vec_ptr
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about duplicate methods in fn_fields.  Also compact method    lists so that lookup can be made faster.     Algorithm: Outer loop builds lists by method name.  Inner loop    checks for redundant method names within a list.     Data Structure: List of method lists.  The outer list is a    TREE_LIST, whose TREE_PURPOSE field is the field name and the    TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN    links the entire list of methods for TYPE_METHODS.  Friends are    chained in the same way as member functions (? TREE_CHAIN or    DECL_CHAIN), but they live in the TREE_TYPE field of the outer    list.  That allows them to be quickly deleted, and requires no    extra storage.     If there are any constructors/destructors, they are moved to the    front of the list.  This makes pushclass more efficient.     We also link each field which has shares a name with its baseclass    to the head of the list of fields for that base class.  This allows    us to reduce search time in places like `build_method_call' to    consider only reasonably likely functions.  */
end_comment

begin_function
specifier|static
name|tree
name|finish_struct_methods
parameter_list|(
name|t
parameter_list|,
name|fn_fields
parameter_list|,
name|nonprivate_method
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fn_fields
decl_stmt|;
name|int
name|nonprivate_method
decl_stmt|;
block|{
name|tree
name|method_vec
decl_stmt|;
name|tree
name|save_fn_fields
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|fn_fields
argument_list|)
decl_stmt|;
name|tree
name|lastp
decl_stmt|;
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Now prepare to gather fn_fields into vector.  */
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|method_vec
operator|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
expr_stmt|;
comment|/* Room has been saved for constructors and destructors.  */
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
comment|/* Now make this a live vector.  */
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First fill in entry 0 with the constructors, and the next few with      type conversion operators (if any).  */
for|for
control|(
name|lastp
operator|=
name|save_fn_fields
init|;
name|fn_fields
condition|;
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|lastp
argument_list|)
control|)
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL_TREE
condition|)
name|fn_name
operator|=
name|name
expr_stmt|;
comment|/* Clear out this flag.  	 @@ Doug may figure out how to break 	 @@ this with nested classes and friends.  */
name|DECL_IN_AGGR_P
argument_list|(
name|fn_fields
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Note here that a copy ctor is private, so we don't dare generate  	 a default copy constructor for a class that has a member  	 of this type without making sure they have access to it.  */
if|if
condition|(
name|fn_name
operator|==
name|name
condition|)
block|{
name|tree
name|parmtypes
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Constructors are handled easily in search routines.  */
name|DECL_CHAIN
argument_list|(
name|fn_fields
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|fn_name
argument_list|)
condition|)
block|{
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|INTEGER_TYPE
argument_list|)
operator|||
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|BOOLEAN_TYPE
argument_list|)
operator|||
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|ENUMERAL_TYPE
argument_list|)
condition|)
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|REAL_TYPE
argument_list|)
condition|)
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grow_method
argument_list|(
name|fn_fields
argument_list|,
operator|&
name|method_vec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastp
operator|=
name|fn_fields
expr_stmt|;
continue|continue;
block|}
name|TREE_CHAIN
argument_list|(
name|lastp
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|save_fn_fields
argument_list|)
expr_stmt|;
while|while
condition|(
name|fn_fields
condition|)
block|{
name|tree
name|nextp
decl_stmt|;
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL_TREE
condition|)
name|fn_name
operator|=
name|name
expr_stmt|;
name|nextp
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy_assignment_arg_p
argument_list|(
name|parmtype
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|grow_method
argument_list|(
name|fn_fields
argument_list|,
operator|&
name|method_vec
argument_list|)
expr_stmt|;
name|fn_fields
operator|=
name|nextp
expr_stmt|;
block|}
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|-
operator|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_PROTECTED
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
condition|)
name|cp_warning
argument_list|(
literal|"all member functions in class `%T' are private"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If there are constructors (and destructors), they are at the      front.  Place destructors at very front.  Also warn if all      constructors and/or destructors are private (in which case this      class is effectively unusable.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|dtor
decl_stmt|,
name|prev
decl_stmt|;
for|for
control|(
name|dtor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|dtor
condition|;
name|prev
operator|=
name|dtor
operator|,
name|dtor
operator|=
name|DECL_CHAIN
argument_list|(
name|dtor
argument_list|)
control|)
block|{
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|dtor
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|dtor
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|warn_ctor_dtor_privacy
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' only defines a private destructor and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Wild parse errors can cause this to happen.  */
if|if
condition|(
name|dtor
operator|==
name|NULL_TREE
condition|)
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dtor
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DECL_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|dtor
argument_list|)
expr_stmt|;
name|DECL_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|dtor
expr_stmt|;
block|}
block|}
comment|/* Now for each member function (except for constructors and      destructors), compute where member functions of the same      name reside in base classes.  */
if|if
condition|(
name|n_baseclasses
operator|!=
literal|0
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|tree
name|baselink_vec
init|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|int
name|any_links
init|=
literal|0
decl_stmt|;
name|tree
name|baselink_binfo
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|=
name|get_baselinks
argument_list|(
name|baselink_binfo
argument_list|,
name|t
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|any_links
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|any_links
operator|!=
literal|0
condition|)
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|baselink_vec
expr_stmt|;
else|else
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|baselink_vec
argument_list|)
expr_stmt|;
block|}
comment|/* Now add the methods to the TYPE_METHODS of T, arranged in a chain.  */
block|{
name|tree
name|x
decl_stmt|,
name|last_x
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|limit
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|last_x
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|x
expr_stmt|;
name|last_x
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* Put ctors and dtors at the front of the list.  */
name|x
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
while|while
condition|(
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Let's avoid being circular about this.  */
if|if
condition|(
name|x
operator|==
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|DECL_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>
literal|1
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
return|return
name|method_vec
return|;
block|}
end_function

begin_comment
comment|/* Emit error when a duplicate definition of a type is seen.  Patch up. */
end_comment

begin_function
name|void
name|duplicate_tag_error
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|cp_error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous definition here"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pretend we haven't defined this type.  */
comment|/* All of the component_decl's were TREE_CHAINed together in the parser.      finish_struct_methods walks these chains and assembles all methods with      the same base name into DECL_CHAINs. Now we don't need the parser chains      anymore, so we unravel them.    */
comment|/*    * This used to be in finish_struct, but it turns out that the    * TREE_CHAIN is used by dbxout_type_methods and perhaps some other things...    */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tv
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tv
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|unchain
init|=
name|TREE_VEC_ELT
argument_list|(
name|tv
argument_list|,
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|unchain
operator|!=
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|unchain
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|unchain
operator|=
name|DECL_CHAIN
argument_list|(
name|unchain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|as_list
init|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfo_as_list
init|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_only
init|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_unknown
init|=
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|as_list
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|binfo_as_list
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TYPE_REDEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* finish up all new vtables. */
end_comment

begin_function
specifier|static
name|void
name|finish_vtbls
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|;
name|int
name|do_self
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|context
decl_stmt|;
name|decl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_vtbls
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True if we should override the given BASE_FNDECL with the given    FNDECL.  */
end_comment

begin_function
specifier|static
name|int
name|overrides
parameter_list|(
name|fndecl
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
comment|/* Destructors have special names. */
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&&
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|base_fndecl
argument_list|)
condition|)
block|{
name|tree
name|rettype
decl_stmt|,
name|base_rettype
decl_stmt|,
name|types
decl_stmt|,
name|base_types
decl_stmt|;
if|#
directive|if
literal|0
block|retypes = TREE_TYPE (TREE_TYPE (fndecl));       base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));
endif|#
directive|endif
name|types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|base_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_types
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|base_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_class_offset_1
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|context
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|,
name|context
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|parent
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|nrval
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|nrval
operator|=
name|get_class_offset_1
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|,
name|context
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* See if we have a new value */
if|if
condition|(
name|nrval
operator|&&
operator|(
name|nrval
operator|!=
name|error_mark_node
operator|||
name|rval
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Only compare if we have two offsets */
if|if
condition|(
name|rval
operator|&&
name|rval
operator|!=
name|error_mark_node
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|nrval
argument_list|,
name|rval
argument_list|)
condition|)
block|{
comment|/* Only give error if the two offsets are different */
name|error
argument_list|(
literal|"every virtual function must have a unique final overrider"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  found two (or more) `%T' class subobjects in `%T'"
argument_list|,
name|context
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  with virtual `%D' from virtual base class"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
name|rval
operator|=
name|nrval
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|rval
operator|==
name|error_mark_node
operator|||
name|tree_int_cst_equal
argument_list|(
name|rval
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|rval
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Get the offset to the CONTEXT subobject that is related to the    given BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_offset
parameter_list|(
name|context
parameter_list|,
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|context
decl_stmt|,
name|t
decl_stmt|,
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|first_binfo
init|=
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|context
operator|==
name|t
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
comment|/* Check less derived binfos first.  */
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
block|}
comment|/* Ok, not found in the less derived binfos, now check the more      derived binfos. */
name|offset
operator|=
name|get_class_offset_1
argument_list|(
name|first_binfo
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|context
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|my_friendly_abort
argument_list|(
literal|999
argument_list|)
expr_stmt|;
comment|/* we have to find it.  */
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Skip RTTI information at the front of the virtual list.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|skip_rtti_stuff
parameter_list|(
name|virtuals
parameter_list|)
name|tree
modifier|*
name|virtuals
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|virtuals
condition|)
block|{
comment|/* We always reserve a slot for the offset/tdesc entry.  */
operator|++
name|n
expr_stmt|;
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_vtable_thunks
operator|&&
operator|*
name|virtuals
condition|)
block|{
comment|/* The second slot is reserved for the tdesc pointer when thunks          are used.  */
operator|++
name|n
expr_stmt|;
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|modify_one_vtable
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_rtti
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
comment|/* update rtti entry */
if|if
condition|(
name|flag_rtti
condition|)
block|{
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|current_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|current_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|current_fndecl
argument_list|)
expr_stmt|;
name|current_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|current_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_fndecl
operator|&&
name|overrides
argument_list|(
name|fndecl
argument_list|,
name|current_fndecl
argument_list|)
condition|)
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|this_offset
decl_stmt|;
name|offset
operator|=
name|get_class_offset
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Find the right offset for the this pointer based on the 	     base class we just found.  We have to take into 	     consideration the virtual base class pointers that we 	     stick in before the virtual function table pointer.  	     Also, we want just the delta between the most base class 	     that we derived this vfield from and us.  */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|get_derived_offset
argument_list|(
name|binfo
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|current_fndecl
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 		 We start with the approximation that it's vtable is that 		 of the immediate base class.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 		 Later, we will fill in all the virtual functions 		 that override the virtual functions in these base classes 		 which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"in %D"
argument_list|,
name|DECL_NAME
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry_n
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the ones that are not through virtual base classes. */
end_comment

begin_function
specifier|static
name|void
name|modify_all_direct_vtables
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
name|int
name|do_self
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|modify_one_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|modify_all_direct_vtables
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup all the delta entries in this one vtable that need updating.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_vtable_deltas1
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|tree
name|pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|delta
init|=
name|DELTA_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|this_offset
decl_stmt|;
name|offset
operator|=
name|get_class_offset
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Find the right offset for the this pointer based on the 	     base class we just found.  We have to take into 	     consideration the virtual base class pointers that we 	     stick in before the virtual function table pointer.  	     Also, we want just the delta between the most base class 	     that we derived this vfield from and us.  */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|get_derived_offset
argument_list|(
name|binfo
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|this_offset
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 		     We start with the approximation that it's vtable is that 		     of the immediate base class.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 		     Later, we will fill in all the virtual functions 		     that override the virtual functions in these base classes 		     which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry_n
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup all the delta entries in all the direct vtables that need updating.    This happens when we have non-overridden virtual functions from a    virtual base class, that are at a different offset, in the new    hierarchy, because the layout of the virtual bases has changed.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_vtable_deltas
parameter_list|(
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|;
name|int
name|init_self
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|fixup_vtable_deltas
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|fixup_vtable_deltas1
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the ones that are through virtual base classes. */
end_comment

begin_function
specifier|static
name|void
name|modify_all_indirect_vtables
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|via_virtual
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
name|int
name|do_self
decl_stmt|,
name|via_virtual
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|via_virtual
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|modify_one_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|via_virtual
operator|=
literal|1
expr_stmt|;
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|modify_all_indirect_vtables
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|via_virtual
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|modify_all_vtables
parameter_list|(
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|vfn
parameter_list|)
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|vfn
decl_stmt|;
block|{
comment|/* Do these first, so that we will make use of any non-virtual class's      vtable, over a virtual classes vtable. */
name|modify_all_direct_vtables
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|modify_all_indirect_vtables
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here, we already know that they match in every respect.    All we have to check is where they had their declarations.  */
end_comment

begin_function
specifier|static
name|int
name|strictly_overrides
parameter_list|(
name|fndecl1
parameter_list|,
name|fndecl2
parameter_list|)
name|tree
name|fndecl1
decl_stmt|,
name|fndecl2
decl_stmt|;
block|{
name|int
name|distance
init|=
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl2
argument_list|)
argument_list|,
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|2
operator|||
name|distance
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Merge overrides for one vtable.    If we want to merge in same function, we are fine.    else      if one has a DECL_CLASS_CONTEXT that is a parent of the        other, than choose the more derived one      else        potentially ill-formed (see 10.3 [class.virtual])        we have to check later to see if there was an        override in this class.  If there was ok, if not        then it is ill-formed.  (mrs)     We take special care to reuse a vtable, if we can.  */
end_comment

begin_function
specifier|static
name|void
name|override_one_vtable
parameter_list|(
name|binfo
parameter_list|,
name|old
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|old
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|old
argument_list|)
decl_stmt|;
enum|enum
block|{
name|REUSE_NEW
block|,
name|REUSE_OLD
block|,
name|UNDECIDED
block|,
name|NEITHER
block|}
name|choose
init|=
name|UNDECIDED
enum|;
comment|/* If we have already committed to modifying it, then don't try and      reuse another vtable. */
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|choose
operator|=
name|NEITHER
expr_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|old_virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|tree
name|old_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
decl_stmt|;
name|fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|old_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|old_fndecl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|old_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First check to see if they are the same. */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|old_fndecl
argument_list|)
condition|)
block|{
comment|/* No need to do anything. */
block|}
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|fndecl
argument_list|,
name|old_fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|choose
operator|==
name|UNDECIDED
condition|)
name|choose
operator|=
name|REUSE_NEW
expr_stmt|;
elseif|else
if|if
condition|(
name|choose
operator|==
name|REUSE_OLD
condition|)
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|old_fndecl
argument_list|,
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|choose
operator|==
name|UNDECIDED
condition|)
name|choose
operator|=
name|REUSE_OLD
expr_stmt|;
elseif|else
if|if
condition|(
name|choose
operator|==
name|REUSE_NEW
condition|)
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|choose
operator|==
name|NEITHER
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
comment|/* This MUST be overridden, or the class is ill-formed.  */
comment|/* For now, we just make it abstract.  */
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|vfn
decl_stmt|;
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make sure we search for it later. */
if|if
condition|(
operator|!
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|vfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can use integer_zero_node, as we will will core dump 	       if this is used anyway. */
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
block|}
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Let's reuse the old vtable. */
if|if
condition|(
name|choose
operator|==
name|REUSE_OLD
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge in overrides for virtual bases.    BINFO is the hierarchy we want to modify, and OLD has the potential    overrides.  */
end_comment

begin_function
specifier|static
name|void
name|merge_overrides
parameter_list|(
name|binfo
parameter_list|,
name|old
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|old
decl_stmt|,
name|t
decl_stmt|;
name|int
name|do_self
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|old
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|old_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|old_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|merge_overrides
argument_list|(
name|base_binfo
argument_list|,
name|old_base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|interface_only
decl_stmt|,
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration    (or C++ class declaration).     For C++, we must handle the building of derived classes.    Also, C++ allows static class members.  The way that this is    handled is to keep the field name where it is (as the DECL_NAME    of the field), and place the overloaded decl in the DECL_FIELD_BITPOS    of the field.  layout_record and layout_union will know about this.     More C++ hair: inline functions have text in their    DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into    meaningful tree structure.  After the struct has been laid out, set    things up so that this can happen.     And still more: virtual functions.  In the case of single inheritance,    when a new virtual function is seen which redefines a virtual function    from the base class, the new virtual function is placed into    the virtual function table at exactly the same address that    it had in the base class.  When this is extended to multiple    inheritance, the same thing happens, except that multiple virtual    function tables must be maintained.  The first virtual function    table is treated in exactly the same way as in the case of single    inheritance.  Additional virtual function tables have different    DELTAs, which tell how to adjust `this' to point to the right thing.     LIST_OF_FIELDLISTS is just that.  The elements of the list are    TREE_LIST elements, whose TREE_PURPOSE field tells what access    the list has, and the TREE_VALUE slot gives the actual fields.     If flag_all_virtual == 1, then we lay all functions into    the virtual function table, as though they were declared    virtual.  Constructors do not lay down in the virtual function table.     If flag_all_virtual == 2, then we lay all functions into    the virtual function table, such that virtual functions    occupy a space by themselves, and then all functions    of the class occupy a space by themselves.  This is illustrated    in the following diagram:     class A; class B : A;  	Class A's vtbl:			Class B's vtbl:     --------------------------------------------------------------------    | A's virtual functions|		| B's virtual functions		|    |			  |		| (may inherit some from A).	|     --------------------------------------------------------------------    | All of A's functions |		| All of A's functions		|    | (such as a->A::f).	  |		| (such as b->A::f)		|     -------------------------------------------------------------------- 					| B's new virtual functions	| 					| (not defined in A.)		| 					 ------------------------------- 					| All of B's functions		| 					| (such as b->B::f)		| 					 -------------------------------     this allows the program to make references to any function, virtual    or otherwise in a type-consistent manner.  */
end_comment

begin_function
name|tree
name|finish_struct_1
parameter_list|(
name|t
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
name|int
name|old
decl_stmt|;
name|int
name|round_up_size
init|=
literal|1
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|fn_fields
init|=
name|CLASSTYPE_METHODS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|last_x
decl_stmt|,
name|method_vec
decl_stmt|;
name|int
name|needs_virtual_dtor
decl_stmt|;
name|int
name|all_virtual
decl_stmt|;
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|tree
name|pending_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|cant_have_const_ctor
decl_stmt|;
name|int
name|cant_synth_copy_ctor
decl_stmt|;
name|int
name|cant_synth_asn_ref
decl_stmt|;
name|int
name|no_const_asn_ref
decl_stmt|;
comment|/* The index of the first base class which has virtual      functions.  Only applied to non-virtual baseclasses.  */
name|int
name|first_vfn_base_index
decl_stmt|;
name|int
name|n_baseclasses
decl_stmt|;
name|int
name|any_default_members
init|=
literal|0
decl_stmt|;
name|int
name|const_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|ref_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|nonprivate_method
init|=
literal|0
decl_stmt|;
name|tree
name|t_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|access_decls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|aggregate
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|warn_anon
operator|&&
name|code
operator|!=
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"anonymous class type not used to declare any objects"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|172
argument_list|)
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|dont_allow_type_definitions
condition|)
block|{
name|pedwarn
argument_list|(
literal|"types cannot be defined %s"
argument_list|,
name|dont_allow_type_definitions
argument_list|)
expr_stmt|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is in general too late to do this.  I moved the main case up to      left_curly, what else needs to move?  */
block|if (! IS_SIGNATURE (t))     {       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);       my_friendly_assert (CLASSTYPE_INTERFACE_KNOWN (t) == ! interface_unknown, 999);     }
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (flag_rtti)     build_t_desc (t, 0);
endif|#
directive|endif
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* Install struct as DECL_FIELD_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
if|if
condition|(
name|t_binfo
operator|&&
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|n_baseclasses
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
name|struct
name|base_info
name|base_info
decl_stmt|;
comment|/* If using multiple inheritance, this may cause variants of our 	 basetypes to be used (instead of their canonical forms).  */
name|tree
name|vf
init|=
name|layout_basetypes
argument_list|(
name|t
argument_list|,
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
decl_stmt|;
name|last_x
operator|=
name|tree_last
argument_list|(
name|vf
argument_list|)
expr_stmt|;
name|fields
operator|=
name|chainon
argument_list|(
name|vf
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|first_vfn_base_index
operator|=
name|finish_base_struct
argument_list|(
name|t
argument_list|,
operator|&
name|base_info
argument_list|,
name|t_binfo
argument_list|)
expr_stmt|;
comment|/* Remember where we got our vfield from */
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|t
argument_list|)
operator|=
name|first_vfn_base_index
expr_stmt|;
name|has_virtual
operator|=
name|base_info
operator|.
name|has_virtual
expr_stmt|;
name|max_has_virtual
operator|=
name|base_info
operator|.
name|max_has_virtual
expr_stmt|;
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
name|base_info
operator|.
name|n_ancestors
expr_stmt|;
name|vfield
operator|=
name|base_info
operator|.
name|vfield
expr_stmt|;
name|vfields
operator|=
name|base_info
operator|.
name|vfields
expr_stmt|;
name|cant_have_default_ctor
operator|=
name|base_info
operator|.
name|cant_have_default_ctor
expr_stmt|;
name|cant_have_const_ctor
operator|=
name|base_info
operator|.
name|cant_have_const_ctor
expr_stmt|;
name|cant_synth_copy_ctor
operator|=
name|base_info
operator|.
name|cant_synth_copy_ctor
expr_stmt|;
name|cant_synth_asn_ref
operator|=
name|base_info
operator|.
name|cant_synth_asn_ref
expr_stmt|;
name|no_const_asn_ref
operator|=
name|base_info
operator|.
name|no_const_asn_ref
expr_stmt|;
name|needs_virtual_dtor
operator|=
name|base_info
operator|.
name|needs_virtual_dtor
expr_stmt|;
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
argument_list|)
expr_stmt|;
name|aggregate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|first_vfn_base_index
operator|=
operator|-
literal|1
expr_stmt|;
name|has_virtual
operator|=
literal|0
expr_stmt|;
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
name|vfield
operator|=
name|NULL_TREE
expr_stmt|;
name|vfields
operator|=
name|NULL_TREE
expr_stmt|;
name|last_x
operator|=
name|NULL_TREE
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
name|cant_synth_copy_ctor
operator|=
literal|0
expr_stmt|;
name|cant_synth_asn_ref
operator|=
literal|0
expr_stmt|;
name|no_const_asn_ref
operator|=
literal|0
expr_stmt|;
name|needs_virtual_dtor
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Both of these should be done before now.  */
block|if (write_virtuals == 3&& CLASSTYPE_INTERFACE_KNOWN (t)&& ! IS_SIGNATURE (t))     {       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);       my_friendly_assert (CLASSTYPE_VTABLE_NEEDS_WRITING (t) == ! interface_only, 999);     }
endif|#
directive|endif
comment|/* The three of these are approximations which may later be      modified.  Needed at this point to make add_virtual_function      and modify_vtable_entries work.  */
name|TREE_CHAIN
argument_list|(
name|t_binfo
argument_list|)
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|t_binfo
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|all_virtual
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_all_virtual
operator|==
literal|1
operator|&&
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|t
argument_list|)
condition|)
name|all_virtual
operator|=
literal|1
expr_stmt|;
else|else
name|all_virtual
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|CLASSTYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|nonprivate_method
operator||=
operator|!
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|DECL_CLASS_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Do both of these, even though they're in the same union; 	 if the insn `r' member and the size `i' member are 	 different sizes, as on the alpha, the larger of the two 	 will end up with garbage in it.  */
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The name of the field is the original field name 	 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|all_virtual
operator|==
literal|1
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|pending_virtuals
operator|=
name|add_virtual_function
argument_list|(
name|pending_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
else|else
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Handle access declarations.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|fdecl
init|=
name|TREE_OPERAND
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|access_type
name|access
init|=
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
condition|?
name|access_private
else|:
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
condition|?
name|access_protected
else|:
name|access_public
decl_stmt|;
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|access_decls
operator|=
name|tree_cons
argument_list|(
operator|(
name|tree
operator|)
name|access
argument_list|,
name|fdecl
argument_list|,
name|access_decls
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
continue|continue;
comment|/* If we've gotten this far, it's a data member, possibly static, 	 or an enumerator. */
name|DECL_FIELD_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* ``A local class cannot have static data members.'' ARM 9.4 */
if|if
condition|(
name|current_function_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"field `%D' in local class cannot be static"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Perform error checking that did not get done in 	 grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared function type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared method type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared offset type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (DECL_NAME (x) == constructor_name (t)) 	cant_have_default_ctor = cant_synth_copy_ctor = 1;
endif|#
directive|endif
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Unions cannot have static members.  */
name|cp_error_at
argument_list|(
literal|"field `%D' declared static in union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now it can only be a FIELD_DECL.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
condition|)
name|aggregate
operator|=
literal|0
expr_stmt|;
comment|/* If this is of reference type, check if it needs an init. 	 Also do a little ANSI jig if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|ref_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
name|cant_synth_asn_ref
operator|=
literal|1
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static reference `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"non-static reference in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
name|cant_synth_asn_ref
operator|=
literal|1
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static const member `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"non-static const member in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A field that is pseudo-const makes the structure 	     likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t1
argument_list|)
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We set DECL_BIT_FIELD tentatively in grokbitfield. 	 If the type and width are valid, we'll keep it set. 	 Otherwise, the flag is cleared.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Invalid bit-field size done by grokfield.  */
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%#D' with non-integral type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"negative width in bit-field `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"zero width for bit-field `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
condition|)
block|{
comment|/* The backend will dump if you try to use something 		     too big; avoid that.  */
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sorry
argument_list|(
literal|"bit-fields larger than %d bits"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  in declaration of `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"width of `%D' exceeds its type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
operator|(
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|width
operator|)
operator|||
operator|(
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|width
operator|)
operator|)
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"`%D' is too small to hold all values of `%#T'"
argument_list|,
name|x
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process valid field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
comment|/* field size 0 => mark following field as "aligned" */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* field of size 0 at the end => round up the size.  */
else|else
name|round_up_size
operator|=
name|EMPTY_FIELD_BOUNDARY
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Traditionally a bit field is unsigned 		     even if declared signed.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
block|}
else|else
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|ANON_UNION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Never let anything with uninheritable virtuals 		 make it through without complaint.  */
if|if
condition|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Don't let signatures make it through either.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
name|signature_error
argument_list|(
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|char
modifier|*
name|fie
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"constructor"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"destructor"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_REAL_ASSIGNMENT
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"assignment operator"
expr_stmt|;
if|if
condition|(
name|fie
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with %s not allowed in union"
argument_list|,
name|x
argument_list|,
name|fie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|t
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|cant_synth_copy_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|t
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|cant_synth_asn_ref
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is wrong for aggregates.  */
block|if (! TYPE_HAS_CONSTRUCTOR (t)) 		    { 		      if (DECL_NAME (x)) 			cp_pedwarn_at ("member `%#D' with only non-default constructor", x); 		      else 			cp_pedwarn_at ("member with only non-default constructor", x); 		      cp_pedwarn_at ("in class without a constructor", 				     x); 		    }
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize 		 non-FIELD_DECLs.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|cp_error_at
argument_list|(
literal|"multiple fields in union `%T' initialized"
argument_list|)
expr_stmt|;
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If this type has any constant members which did not come      with their own initialization, mark that fact here.  It is      not an error here, since such types can be saved either by their      constructors, or by fortuitous initialization.  */
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|const_sans_init
expr_stmt|;
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|ref_sans_init
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
comment|/* Synthesize any needed methods.  Note that methods will be synthesized      for anonymous unions; grok_x_components undoes that.  */
if|if
condition|(
operator|!
name|fn_fields
condition|)
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Here we must cons up a destructor on the fly.  */
name|tree
name|dtor
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|needs_virtual_dtor
operator|!=
literal|0
argument_list|)
decl_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|dtor
operator|==
name|void_type_node
condition|)
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Link dtor onto end of fn_fields. */
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|dtor
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|needs_virtual_dtor
operator|||
name|pending_virtuals
operator|!=
name|NULL_TREE
operator|||
name|pending_hard_virtuals
operator|!=
name|NULL_TREE
operator|)
condition|)
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
condition|)
name|pending_virtuals
operator|=
name|add_virtual_function
argument_list|(
name|pending_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|dtor
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rtti
operator|&&
operator|(
name|max_has_virtual
operator|>
literal|0
operator|||
name|needs_virtual_dtor
operator|)
operator|&&
name|has_virtual
operator|==
literal|0
condition|)
name|has_virtual
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|any_default_members
operator|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|has_virtual
operator|||
name|any_default_members
operator|||
name|first_vfn_base_index
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|aggregate
operator|||
name|has_virtual
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* ARM $12.1: A default constructor will be generated for a class X      only if no constructor has been declared for class X.  So we      check TYPE_HAS_CONSTRUCTOR also, to make sure we don't generate      one if they declared a constructor in this class.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_have_default_ctor
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Create default copy constructor, if needed.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_synth_copy_ctor
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* ARM 12.18: You get either X(X&) or X(const X&), but 	 not both.  --Chip  */
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|3
operator|+
name|cant_have_const_ctor
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
block|}
name|TYPE_HAS_REAL_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_REAL_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_synth_asn_ref
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|5
operator|+
name|no_const_asn_ref
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
block|}
if|if
condition|(
name|fn_fields
condition|)
block|{
name|method_vec
operator|=
name|finish_struct_methods
argument_list|(
name|t
argument_list|,
name|fn_fields
argument_list|,
name|nonprivate_method
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
name|tree
name|ctor
decl_stmt|;
for|for
control|(
name|ctor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|ctor
condition|;
name|ctor
operator|=
name|DECL_CHAIN
argument_list|(
name|ctor
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
operator|&&
name|warn_ctor_dtor_privacy
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' only defines private constructors and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|method_vec
operator|=
literal|0
expr_stmt|;
comment|/* Just in case these got accidentally 	 filled in by syntax errors.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|{
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|access_decls
operator|=
name|nreverse
argument_list|(
name|access_decls
argument_list|)
init|;
name|access_decls
condition|;
name|access_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|access_decls
argument_list|)
control|)
block|{
name|tree
name|fdecl
init|=
name|TREE_VALUE
argument_list|(
name|access_decls
argument_list|)
decl_stmt|;
name|tree
name|flist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|enum
name|access_type
name|access
init|=
operator|(
expr|enum
name|access_type
operator|)
name|TREE_PURPOSE
argument_list|(
name|access_decls
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|flist
operator|=
name|fdecl
expr_stmt|;
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|flist
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n_methods
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot adjust access to `%#D' in `%#T'"
argument_list|,
name|fdecl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local method `%#D' with same name"
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fdecl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fdecl
condition|)
continue|continue;
for|for
control|(
name|tmp
operator|=
name|fields
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot adjust access to `%#D' in `%#T'"
argument_list|,
name|fdecl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local field `%#D' with same name"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fdecl
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fdecl
condition|)
continue|continue;
comment|/* Make type T see field decl FDECL with access ACCESS.*/
if|if
condition|(
name|flist
condition|)
block|{
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|flist
argument_list|)
expr_stmt|;
while|while
condition|(
name|fdecl
condition|)
block|{
if|if
condition|(
name|alter_access
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|access
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fdecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|alter_access
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vfield
operator|==
name|NULL_TREE
operator|&&
name|has_virtual
condition|)
block|{
comment|/* We build this decl with ptr_type_node, and 	 change the type when we know what it should be.  */
name|vfield
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* If you change any of the below, take a look at all the 	 other VFIELD_BASEs and VTABLE_BASEs in the code, and change 	 them too. */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|vfield
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VFIELD_BASE
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|vfield
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|vfield
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|vfield
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* vfield is always first entry in structure.  */
name|TREE_CHAIN
argument_list|(
name|vfield
argument_list|)
operator|=
name|fields
expr_stmt|;
name|fields
operator|=
name|vfield
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_x
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|175
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|last_x
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|fields
operator|=
name|vfield
expr_stmt|;
name|vfields
operator|=
name|chainon
argument_list|(
name|vfields
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now DECL_INITIAL is null on all members except for zero-width bit-fields.      And they have already done their work.       C++: maybe we will support default field initialization some day...  */
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fields
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|fields
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Delete all such fields from the rest of the fields.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all duplicate fields from the fields */
name|delete_duplicate_fields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Catch function/field name conflict.  We don't need to do this for a      signature, since it can only contain the fields constructed in      append_signature_fields.  */
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
init|=
comment|/*TREE_VEC_ELT (method_vec, 0) ? 0 : */
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|n_methods
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"data member `%#D' conflicts with"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"function member `%#D'"
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now we have the final fieldlist for the data fields.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
comment|/* If there's a :0 field at the end, round the size to the      EMPTY_FIELD_BOUNDARY.  */
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|round_up_size
expr_stmt|;
comment|/* Pass layout information about base classes to layout_type, if any.  */
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|tree
name|pseudo_basetype
init|=
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|base_layout_decl
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pseudo_basetype
argument_list|)
expr_stmt|;
comment|/* Don't re-use old size. */
name|DECL_SIZE
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* If this field is an anonymous union, 	   give each union-member the same position as the union has.  	   ??? This is a real kludge because it makes the structure 	   of the types look strange.  This feature is only used by 	   C++, which should have build_component_ref build two 	   COMPONENT_REF operations, one for the union and one for 	   the inner field.  We set the offset of this field to zero 	   so that either the old or the correct method will work. 	   Setting DECL_FIELD_CONTEXT is wrong unless the inner fields are 	   moved into the type of this field, but nothing seems to break 	   by doing this.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|uelt
init|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|uelt
condition|;
name|uelt
operator|=
name|TREE_CHAIN
argument_list|(
name|uelt
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|uelt
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|uelt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"private member `%#D' in anonymous union"
argument_list|,
name|uelt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|uelt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"protected member `%#D' in anonymous union"
argument_list|,
name|uelt
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|n_baseclasses
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++: do not let empty structures exist.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we left lying      around.  We must get these done before we try to lay out the      virtual function table.  */
name|doing_hard_virtuals
operator|=
literal|1
expr_stmt|;
name|pending_hard_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
name|max_has_virtual
operator|=
name|layout_vbasetypes
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|=
name|list_length
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
comment|/* The rtti code should do this.  (mrs) */
if|#
directive|if
literal|0
block|while (vbases) 	{
comment|/* Update rtti info with offsets for virtual baseclasses.  */
block|if (flag_rtti&& ! BINFO_NEW_VTABLE_MARKED (vbases)) 	    prepare_fresh_vtable (vbases, t); 	  vbases = TREE_CHAIN (vbases); 	}
endif|#
directive|endif
block|{
comment|/* Now fixup overrides of all functions in vtables from all 	   direct or indirect virtual base classes.  */
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|merge_overrides
argument_list|(
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vbases
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now fixup any virtual function entries from virtual bases 	 that have different deltas.  */
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
comment|/* We might be able to shorten the amount of work we do by 	     only doing this for vtables that come from virtual bases 	     that have differing offsets, but don't want to miss any 	     entries.  */
name|fixup_vtable_deltas
argument_list|(
name|vbases
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we      might need to know it for setting up the offsets in the vtable      (or in thunks) below.  */
if|if
condition|(
name|vfield
operator|!=
name|NULL_TREE
operator|&&
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|!=
name|t
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"Doing hard virtuals for %T..."
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|has_virtual
operator|>
name|max_has_virtual
condition|)
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|max_has_virtual
operator|>
literal|0
condition|)
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_rtti
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|pending_hard_virtuals
condition|)
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
while|while
condition|(
name|pending_hard_virtuals
condition|)
block|{
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
expr_stmt|;
name|pending_hard_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
name|doing_hard_virtuals
operator|=
literal|0
expr_stmt|;
comment|/* Under our model of GC, every C++ class gets its own virtual      function table, at least virtually.  */
if|if
condition|(
name|pending_virtuals
operator|||
operator|(
name|flag_rtti
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|pending_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
comment|/* The first slot is for the rtti offset.  */
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* The second slot is for the tdesc pointer when thunks are used.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|pending_virtuals
argument_list|,
name|integer_zero_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|build_vtable
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|offset
decl_stmt|;
comment|/* Here we know enough to change the type of our virtual 	     function table, but we will wait until later this function.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|offset
operator|=
name|get_derived_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|offset
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this type has basetypes with constructors, then those 	 constructors might clobber the virtual function table.  But 	 they don't if the derived class shares the exact vtable of the base 	 class.  */
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|first_vfn_base_index
argument_list|)
decl_stmt|;
comment|/* This class contributes nothing new to the virtual function 	 table.  However, it may have declared functions which 	 went into the virtual function table "inherited" from the 	 base class.  If so, we grab a copy of those updated functions, 	 and pretend they are ours.  */
comment|/* See if we should steal the virtual info from base class.  */
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|!=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|max_has_virtual
operator|||
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pending_virtuals
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_virtual
condition|)
block|{
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|pending_virtuals
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now lay out the virtual function table.  */
if|if
condition|(
name|has_virtual
condition|)
block|{
name|tree
name|atype
decl_stmt|,
name|itype
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|==
name|ptr_type_node
condition|)
block|{
comment|/* We must create a pointer to this table because 	     the one inherited from base class does not exist. 	     We will fill in the type when we know what it 	     should really be.  Use `size_int' so values are memoized 	     in common cases.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_virtual
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|atype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We must extend (or create) the boundaries on this array, 		 because we picked up virtual functions from multiple 		 base classes.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|atype
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|atype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* At one time the vtable info was grabbed 2 words at a time.  This 	     fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|finish_struct_bits
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Complete the rtl for any static member objects of the type we're      working on.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
block|{
name|DECL_MODE
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add the tags, if any, to the list of TYPE_DECLs      defined for this type.  */
if|if
condition|(
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|x
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|tree_last
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|tree
name|tag
init|=
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check to see if it is already there.  This will be the case if 	     was do enum { red; } color; */
if|if
condition|(
name|chain_member
argument_list|(
name|tag
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
block|{
comment|/* Notify dwarfout.c that this TYPE_DECL node represent a 		 gratuitous typedef.  */
name|DECL_IGNORED_P
argument_list|(
name|tag
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|chainon
argument_list|(
name|last_x
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|last_x
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
comment|/* Mark the fact that constructor for T 	     could affect anybody inheriting from T 	     who wants to initialize vtables for VFIELDS's type.  */
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_default_members
operator|!=
literal|0
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|embrace_waiting_friends
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Write out inline function definitions.  */
name|do_inline_function_hair
argument_list|(
name|t
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is now done above. */
block|if (DECL_FIELD_CONTEXT (vfield) != t) 	{ 	  tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0); 	  tree offset = BINFO_OFFSET (binfo);  	  vfield = copy_node (vfield); 	  copy_lang_decl (vfield);  	  if (! integer_zerop (offset)) 	    offset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT)); 	  DECL_FIELD_CONTEXT (vfield) = t; 	  DECL_CLASS_CONTEXT (vfield) = t; 	  DECL_FIELD_BITPOS (vfield) 	    = size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield)); 	  CLASSTYPE_VFIELD (t) = vfield; 	}
endif|#
directive|endif
comment|/* In addition to this one, all the other vfields should be listed. */
comment|/* Before that can be done, we have to have FIELD_DECLs for them, and 	 a place to find them.  */
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|default_conversion
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' has virtual functions but non-virtual destructor"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|finish_vtbls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|hack_incomplete_structures
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TYPE_NAME (t)&& TYPE_IDENTIFIER (t))     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);
endif|#
directive|endif
if|if
condition|(
name|current_class_type
condition|)
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to finish struct, but kicked out due to previous parse errors."
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_struct
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This has to be done after we have sorted out what to do with      the enclosing type.  */
block|if (write_symbols != DWARF_DEBUG)     {
comment|/* Be smarter about nested classes here.  If a type is nested, 	 only output it if we would output the enclosing type.  */
block|if (DECL_CONTEXT (TYPE_NAME (t))&& TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (TYPE_NAME (t)))) == 't') 	DECL_IGNORED_P (TYPE_NAME (t)) = TREE_ASM_WRITTEN (TYPE_NAME (t));     }
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|!=
name|DWARF_DEBUG
condition|)
block|{
comment|/* If the type has methods, we want to think about cutting down 	 the amount of symbol table stuff we output.  The value stored in 	 the TYPE_DECL's DECL_IGNORED_P slot is a first approximation. 	 For example, if a member function is seen and we decide to 	 write out that member function, then we can change the value 	 of the DECL_IGNORED_P slot, and the type will be output when 	 that member function's debug info is written out.  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
comment|/* Don't output full info about any type 	     which does not have its implementation defined here.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|write_virtuals
operator|==
literal|2
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
operator|(
name|value_member
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Only a first approximation!  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|list_of_fieldlists
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|list_of_fieldlists
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
name|tree
name|fields
init|=
name|NULL_TREE
decl_stmt|,
name|fn_fields
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|tree
modifier|*
name|tail_user_methods
init|=
operator|&
name|CLASSTYPE_METHODS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|last_x
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|access_type
name|access
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|name
argument_list|)
operator|=
name|input_filename
expr_stmt|;
comment|/* For TYPE_DECL that are not typedefs (those marked with a line 	 number of zero, we don't want to mark them as real typedefs. 	 If this fails one needs to make sure real typedefs have a 	 previous line number, even if it is wrong, that way the below 	 will fill in the right line number.  (mrs) */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|CLASSTYPE_SOURCE_LINE
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Append the fields we need for constructing signature tables.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|append_signature_fields
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|&
name|fn_fields
expr_stmt|;
if|if
condition|(
name|last_x
operator|&&
name|list_of_fieldlists
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* For signatures, we made all methods `public' in the parser and      reported an error if a access specifier was used.  */
if|if
condition|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_default
condition|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|access_public
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|access_default
condition|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|access_private
expr_stmt|;
while|while
condition|(
name|list_of_fieldlists
condition|)
block|{
name|access
operator|=
operator|(
expr|enum
name|access_type
operator|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|=
name|access
operator|==
name|access_private
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
operator|=
name|access
operator|==
name|access_protected
expr_stmt|;
comment|/* Check for inconsistent use of this name in the class body.              Enums, types and static vars have already been checked.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|icv
decl_stmt|;
comment|/* Don't get confused by access decls.  */
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|icv
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|icv
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|icv
comment|/* Don't complain about constructors.  */
operator|&&
name|name
operator|!=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
comment|/* Or inherited names.  */
operator|&&
name|id_in_current_class
argument_list|(
name|name
argument_list|)
comment|/* Or shadowed tags.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|icv
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|icv
argument_list|)
operator|==
name|t
operator|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"declaration of identifier `%D' as `%+#D'"
argument_list|,
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"conflicts with other use in class as `%#D'"
argument_list|,
name|icv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Link x onto end of fn_fields and CLASSTYPE_METHODS. */
operator|*
name|tail
operator|=
name|x
expr_stmt|;
name|tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|*
name|tail_user_methods
operator|=
name|x
expr_stmt|;
name|tail_user_methods
operator|=
operator|&
name|DECL_NEXT_METHOD
argument_list|(
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* Handle access declarations.  */
block|if (DECL_NAME (x)&& TREE_CODE (DECL_NAME (x)) == SCOPE_REF) 	    { 	      tree n = DECL_NAME (x); 	      x = build_decl 		(USING_DECL, DECL_NAME (TREE_OPERAND (n, 1)), TREE_TYPE (x)); 	      DECL_RESULT (x) = n; 	    }
endif|#
directive|endif
if|if
condition|(
operator|!
name|fields
condition|)
name|fields
operator|=
name|x
expr_stmt|;
name|last_x
operator|=
name|x
expr_stmt|;
block|}
name|list_of_fieldlists
operator|=
name|TREE_CHAIN
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* link the tail while we have it! */
if|if
condition|(
name|last_x
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|tail
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|tail_user_methods
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|processing_template_defn
condition|)
block|{
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|finish_struct_methods
argument_list|(
name|t
argument_list|,
name|fn_fields
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
else|else
return|return
name|finish_struct_1
argument_list|(
name|t
argument_list|,
name|warn_anon
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if the effective type of INSTANCE is static.    Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
comment|/* Check that we are not going through a cast of some sort.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|instance
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fall through...  */
case|case
name|CALL_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
comment|/* This is a call to `new', hence it's never zero.  */
if|if
condition|(
name|TREE_CALLS_NEW
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Propagate nonnull.  */
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
comment|/* fall through... */
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fall through... */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|nonnull
condition|)
block|{
if|if
condition|(
name|instance
operator|==
name|current_class_decl
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
block|{
comment|/* Some people still use `this = 0' inside destructors.  */
operator|*
name|nonnull
operator|=
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In a constructor, we know our type.  */
if|if
condition|(
name|flag_this_is_variable
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* Reference variables should be references to objects.  */
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_class_processing
parameter_list|()
block|{
name|current_class_depth
operator|=
literal|0
expr_stmt|;
name|current_class_stacksize
operator|=
literal|10
expr_stmt|;
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_class_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
expr_stmt|;
comment|/* Keep these values lying around.  */
name|the_null_vtable_entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|base_layout_decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current scope to NAME. CODE tells us if this is a    STRUCT, UNION, or ENUM environment.     NAME may end up being NULL_TREE if this is an anonymous or    late-bound struct (as in "struct { ... } foo;")  */
end_comment

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to    appropriate values, found by looking up the type definition of    NAME (as a CODE).     If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names    which can be seen locally to the class.  They are shadowed by    any subsequent local declaration (including parameter names).     If MODIFY is 2, we set IDENTIFIER_CLASS_VALUE's of names    which have static meaning (i.e., static members, static    member functions, enum declarations, etc).     If MODIFY is 3, we set IDENTIFIER_CLASS_VALUE of names    which can be seen locally to the class (as in 1), but    know that we are doing this for declaration purposes    (i.e. friend foo::bar (int)).     So that we may avoid calls to lookup_name, we cache the _TYPE    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|push_memoized_context
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
name|current_class_depth
operator|++
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_name
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|current_class_stack
operator|>=
name|current_class_base
operator|+
name|current_class_stacksize
condition|)
block|{
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_class_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_class_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
operator|+
name|current_class_stacksize
expr_stmt|;
name|current_class_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|previous_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|type
operator|!=
name|previous_class_type
operator|||
name|TYPE_SIZE
argument_list|(
name|previous_class_type
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|&&
name|current_class_depth
operator|==
literal|1
condition|)
block|{
comment|/* Forcibly remove any old class remnants.  */
name|popclass
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|pushlevel_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|modify
condition|)
block|{
name|tree
name|tags
decl_stmt|;
name|tree
name|this_fndecl
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|current_function_decl
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
name|declare_uninstantiated_type_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|previous_class_type
operator|||
name|current_class_depth
operator|>
literal|1
condition|)
block|{
name|build_mi_matrix
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free_mi_matrix
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_class_depth
operator|==
literal|1
condition|)
name|previous_class_type
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|tree
name|item
decl_stmt|;
comment|/* Hooray, we successfully cached; let's just install the 	     cached class_shadowed list, and walk through it to get the 	     IDENTIFIER_TYPE_VALUEs correct.  */
name|set_class_shadows
argument_list|(
name|previous_class_values
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|previous_class_values
init|;
name|item
condition|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|overload_template_name
argument_list|(
name|current_class_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|tags
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
init|;
name|tags
condition|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
control|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
condition|)
continue|continue;
name|pushtag
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|this_fndecl
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  The flag MODIFY tells whether    the current scope declarations needs to be modified as a result of    popping to the previous scope.  0 is used for class definitions.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|(
name|modify
parameter_list|)
name|int
name|modify
decl_stmt|;
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|modify
operator|<
literal|0
condition|)
block|{
comment|/* Back this old class out completely.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|previous_class_type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* This code can be seen as a cache miss.  When we've cached a 	 class' scope's bindings and we can't use them, we need to reset 	 them.  This is it!  */
for|for
control|(
name|t
operator|=
name|previous_class_values
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|modify
condition|)
block|{
comment|/* Just remove from this class what didn't make 	 it into IDENTIFIER_CLASS_VALUE.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
condition|)
name|undo_template_name_overload
argument_list|(
name|current_class_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Force clearing of IDENTIFIER_CLASS_VALUEs after a class definition,      since not all class decls make it there currently.  */
name|poplevel_class
argument_list|(
operator|!
name|modify
argument_list|)
expr_stmt|;
comment|/* Since poplevel_class does the popping of class decls nowadays,      this really only frees the obstack used for these decls.      That's why it had to be moved down here.  */
if|if
condition|(
name|modify
condition|)
name|pop_class_decls
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|current_class_depth
operator|--
expr_stmt|;
name|current_class_type
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
name|current_class_name
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
name|pop_memoized_context
argument_list|(
name|modify
argument_list|)
expr_stmt|;
name|ret
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* When entering a class scope, all enclosing class scopes' names with    static meaning (static variables, static functions, types and enumerators)    have to be visible.  This recursive function calls pushclass for all    enclosing class contexts until global or a local scope is reached.    TYPE is the enclosed class and MODIFY is equivalent with the pushclass    formal of the same name.  */
end_comment

begin_function
name|void
name|push_nested_class
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|push_nested_class
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undoes a push_nested_class call.  MODIFY is passed on to popclass.  */
end_comment

begin_function
name|void
name|pop_nested_class
parameter_list|(
name|modify
parameter_list|)
name|int
name|modify
decl_stmt|;
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|popclass
argument_list|(
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|pop_nested_class
argument_list|(
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangling machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
operator|*
name|current_lang_stack
operator|++
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|current_lang_stack
operator|>=
name|current_lang_base
operator|+
name|current_lang_stacksize
condition|)
block|{
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_lang_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_lang_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|+
name|current_lang_stacksize
expr_stmt|;
name|current_lang_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_lang
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|()
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_lang
argument_list|()
expr_stmt|;
name|current_lang_name
operator|=
operator|*
operator|--
name|current_lang_stack
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_lang_context_p
parameter_list|()
block|{
return|return
name|current_lang_stack
operator|==
name|current_lang_base
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_comment
comment|/* This function will instantiate the type of the expression given    in RHS to match the type of LHSTYPE.  If LHSTYPE is NULL_TREE,    or other errors exist, the TREE_TYPE of RHS will be ERROR_MARK_NODE.     This function is used in build_modify_expr, convert_arguments,    build_c_cast, and compute_conversion_costs.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|lhstype
parameter_list|,
name|rhs
parameter_list|,
name|complain
parameter_list|)
name|tree
name|lhstype
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
return|return
name|rhs
return|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmetic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|my_friendly_abort
argument_list|(
literal|177
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|lhstype
operator|=
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|rhs
return|;
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|function
init|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|field
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|185
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|tree
name|base
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|base_ptr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|base_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_vfn_ref
argument_list|(
operator|&
name|base_ptr
argument_list|,
name|base
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
return|return
name|function
return|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|178
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
argument_list|,
literal|179
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
comment|/* First look for an exact match  */
while|while
condition|(
name|field
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|lhstype
condition|)
name|field
operator|=
name|DECL_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|field
expr_stmt|;
return|return
name|rhs
return|;
block|}
comment|/* No exact match found, look for a compatible function.  */
name|field
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|&&
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|field
operator|=
name|DECL_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|DECL_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|&&
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|field
operator|=
name|DECL_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for COMPONENT_REF requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no appropriate overload exists for COMPONENT_REF"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rhs
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|elem
decl_stmt|,
name|baselink
decl_stmt|,
name|name
decl_stmt|;
name|int
name|globals
init|=
name|overloaded_globals_p
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* obsolete */
comment|/* If there's only one function we know about, return that.  */
block|if (globals> 0&& TREE_CHAIN (rhs) == NULL_TREE) 	  return TREE_VALUE (rhs);
endif|#
directive|endif
comment|/* First look for an exact match.  Search either overloaded 	   functions or member functions.  May have to undo what 	   `default_conversion' might do to lhstype.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
condition|)
name|lhstype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid type combination for overload"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|globals
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"cannot resolve overloaded function `%D' based on non-function type"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|globals
operator|>
literal|0
condition|)
block|{
name|elem
operator|=
name|get_first_fn
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
else|else
return|return
name|elem
return|;
comment|/* No exact match found, look for a compatible template.  */
block|{
name|tree
name|save_elem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|elem
operator|=
name|get_first_fn
argument_list|(
name|rhs
argument_list|)
init|;
name|elem
condition|;
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|int
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|elem
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|t
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|n
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|d
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|type_unification
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|elem
argument_list|)
argument_list|,
name|t
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|lhstype
argument_list|)
argument_list|,
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|save_elem
condition|)
block|{
name|cp_error
argument_list|(
literal|"ambiguous template instantiation converting to `%#T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|save_elem
operator|=
name|instantiate_template
argument_list|(
name|elem
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Check the return type.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|save_elem
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|save_elem
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_elem
condition|)
return|return
name|save_elem
return|;
block|}
comment|/* No match found, look for a compatible function.  */
name|elem
operator|=
name|get_first_fn
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|elem
decl_stmt|;
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<=
literal|0
condition|)
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot resolve overload to target type `%#T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  ambiguity between `%#D'"
argument_list|,
name|save_elem
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  and `%#D', at least"
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
return|return
name|save_elem
return|;
block|}
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot resolve overload to target type `%#T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  because no suitable overload of function `%D' exists"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_NONLOCAL_FLAG
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* Got to get it as a baselink.  */
name|rhs
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|181
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|rhs
operator|=
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|182
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|elem
return|;
else|else
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
comment|/* No exact match found, look for a compatible method.  */
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|elem
decl_stmt|;
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<=
literal|0
condition|)
name|elem
operator|=
name|DECL_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for overloaded method requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|save_elem
return|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (lhstype) == FUNCTION_TYPE&& globals< 0) 	      {
comment|/* Try to instantiate from non-member functions.  */
block|rhs = lookup_name_nonclass (name); 		if (rhs&& TREE_CODE (rhs) == TREE_LIST) 		  {
comment|/* This code seems to be missing a `return'.  */
block|my_friendly_abort (4); 		    instantiate_type (lhstype, rhs, complain); 		  } 	      }
endif|#
directive|endif
block|}
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"no compatible member functions named `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|my_friendly_abort
argument_list|(
literal|183
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
condition|)
name|lhstype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"type for resolving address of overloaded function must be pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
block|{
name|tree
name|fn
init|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|mark_addressable
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|fn
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
operator|=
name|staticp
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
name|rhs
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|my_friendly_abort
argument_list|(
literal|184
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|185
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"build_method_call = %d (inner = %d)\n"
argument_list|,
name|n_build_method_call
argument_list|,
name|n_inner_fields_searched
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Push an obstack which is sufficiently long-lived to hold such class    decls that may be cached in the previous_class_values list.  For now, let's    use the permanent obstack, later we may create a dedicated obstack just    for this purpose.  The effect is undone by pop_obstacks.  */
end_comment

begin_function
name|void
name|maybe_push_cache_obstack
parameter_list|()
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_class_depth
operator|==
literal|1
condition|)
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
end_function

end_unit

