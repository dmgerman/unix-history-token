begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building classes and their related objects.    Copyright (C) 1987, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is how we tell when two virtual member functions are really the    same.  */
end_comment

begin_define
define|#
directive|define
name|SAME_FN
parameter_list|(
name|FN1DECL
parameter_list|,
name|FN2DECL
parameter_list|)
value|(DECL_ASSEMBLER_NAME (FN1DECL) == DECL_ASSEMBLER_NAME (FN2DECL))
end_define

begin_decl_stmt
specifier|extern
name|void
name|set_class_shadows
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking class types.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|current_class_base
decl_stmt|,
modifier|*
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_class_stacksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|class_level
block|{
comment|/* The previous class level.  */
name|struct
name|class_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* The class instance variable, as a PARM_DECL.  */
name|tree
name|decl
decl_stmt|;
comment|/* The class instance variable, as an object.  */
name|tree
name|object
decl_stmt|;
comment|/* The virtual function table pointer      for the class instance variable.  */
name|tree
name|vtable_decl
decl_stmt|;
comment|/* Name of the current class.  */
name|tree
name|name
decl_stmt|;
comment|/* Type of the current class.  */
name|tree
name|type
decl_stmt|;
comment|/* Flags for this class level.  */
name|int
name|this_is_variable
decl_stmt|;
name|int
name|memoized_lookups
decl_stmt|;
name|int
name|save_memoized
decl_stmt|;
name|int
name|unused
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The current_class_ptr is the pointer to the current class.    current_class_ref is the actual current class.  */
end_comment

begin_decl_stmt
name|tree
name|current_class_ptr
decl_stmt|,
name|current_class_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following two can be derived from the previous one */
end_comment

begin_decl_stmt
name|tree
name|current_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IDENTIFIER_NODE: name of current class */
end_comment

begin_decl_stmt
name|tree
name|current_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the type of the current class */
end_comment

begin_decl_stmt
name|tree
name|previous_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the previous type that was a class */
end_comment

begin_decl_stmt
name|tree
name|previous_class_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TREE_LIST: copy of the class_shadowed list 				   when leaving an outermost class scope.  */
end_comment

begin_struct_decl
struct_decl|struct
name|base_info
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|tree
name|get_vfield_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_anon
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vbase_pointer
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|complete_type_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vtable_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_derived_offset
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_basefndecls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_rtti_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepare_fresh_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_vtable_deltas1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_vtable_deltas
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grow_method
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_vtbls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_vtable_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vtable_entry_n
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_virtual_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|delete_duplicate_fields_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_duplicate_fields
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_struct_bits
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alter_access
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_using_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|overrides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strictly_overrides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_overrides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|override_one_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_overriders
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_for_override
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_fixup_vptrs
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_offset_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_offset
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_one_vtable
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_all_vtables
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_all_direct_vtables
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_all_indirect_vtables
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_class_init_list
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finish_base_struct
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|base_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking language names.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_lang_stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of languages we recognize.  */
end_comment

begin_decl_stmt
name|tree
name|lang_name_c
decl_stmt|,
name|lang_name_cplusplus
decl_stmt|,
name|lang_name_java
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_lang_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When layout out an aggregate type, the size of the    basetypes (virtual and non-virtual) is passed to layout_record    via this node.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|base_layout_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used for access control.  */
end_comment

begin_decl_stmt
name|tree
name|access_default_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 */
end_comment

begin_decl_stmt
name|tree
name|access_public_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 */
end_comment

begin_decl_stmt
name|tree
name|access_protected_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 */
end_comment

begin_decl_stmt
name|tree
name|access_private_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3 */
end_comment

begin_decl_stmt
name|tree
name|access_default_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 4 */
end_comment

begin_decl_stmt
name|tree
name|access_public_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5 */
end_comment

begin_decl_stmt
name|tree
name|access_protected_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6 */
end_comment

begin_decl_stmt
name|tree
name|access_private_virtual_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 7 */
end_comment

begin_comment
comment|/* Variables shared between class.c and call.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|n_vtables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_searches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vtable_elems
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_convert_harshness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_compute_conversion_costs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_build_method_call
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_inner_fields_searched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Virtual baseclass things.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vbase_pointer
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Is the type of the EXPR, the complete type of the object?    If we are going to be wrong, we must be conservative, and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|complete_type_p
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|expr
argument_list|)
condition|)
break|break;
comment|/* fall through...  */
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|type
condition|)
return|return
literal|1
return|;
comment|/* fall through...  */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|type
condition|)
return|return
literal|1
return|;
comment|/* fall through...  */
case|case
name|PLUS_EXPR
case|:
default|default:
break|break;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build multi-level access to EXPR using hierarchy path PATH.    CODE is PLUS_EXPR if we are going with the grain,    and MINUS_EXPR if we are not (in which case, we cannot traverse    virtual baseclass links).     TYPE is the type we want this path to have on exit.     ALIAS_THIS is non-zero if EXPR in an expression involving `this'.  */
end_comment

begin_function
name|tree
name|build_vbase_path
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|expr
parameter_list|,
name|path
parameter_list|,
name|alias_this
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|,
name|path
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|,
name|last_virtual
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|nonnull
init|=
literal|0
decl_stmt|;
name|int
name|fixed_type_p
decl_stmt|;
name|tree
name|null_expr
init|=
literal|0
decl_stmt|,
name|nonnull_expr
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
operator|(
name|alias_this
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
operator|)
condition|)
name|nonnull
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We need additional logic to convert back to the unconverted type      (the static type of the complete object), and then convert back      to the type we want.  Until that is done, or until we can      recognize when that is, we cannot do the short cut logic. (mrs) */
block|fixed_type_p = resolves_to_fixed_type_p (expr,&nonnull);
else|#
directive|else
comment|/* Do this, until we can undo any previous conversions.  See net35.C      for a testcase.  */
name|fixed_type_p
operator|=
name|complete_type_p
argument_list|(
name|expr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fixed_type_p
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|tree
name|reverse_path
init|=
name|NULL_TREE
decl_stmt|;
name|push_expression_obstack
argument_list|()
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|reverse_path
expr_stmt|;
name|reverse_path
operator|=
name|r
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|reverse_path
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|last_virtual
operator|=
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
name|changed
operator|=
operator|!
name|fixed_type_p
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|ind
decl_stmt|;
comment|/* We already check for ambiguous things in the caller, just 		     find a path.  */
if|if
condition|(
name|last
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|nonnull_expr
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|build_indirect_ref
argument_list|(
name|nonnull_expr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|nonnull_expr
operator|=
name|build_vbase_pointer
argument_list|(
name|ind
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonnull
operator|==
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
operator|!
name|flag_assume_nonnull_objects
operator|)
operator|&&
name|null_expr
operator|==
name|NULL_TREE
condition|)
block|{
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|last_virtual
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else we'll figure out the offset below.  */
comment|/* Happens in the case of parse errors.  */
if|if
condition|(
name|nonnull_expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"cannot cast up from virtual baseclass `%T'"
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|last
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* LAST is now the last basetype assoc on the path.  */
comment|/* A pointer to a virtual base member of a non-null object      is non-null.  Therefore, we only need to test for zeroness once.      Make EXPR the canonical expression to deal with here.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|nonnull_expr
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|nonnull_expr
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|nonnull_expr
expr_stmt|;
comment|/* If we go through any virtual base pointers, make sure that      casts to BASETYPE from the last virtual base class use      the right value for BASETYPE.  */
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_virtual
condition|)
block|{
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo_member
argument_list|(
name|last_virtual
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
condition|)
block|{
comment|/* Bash types to make the backend happy.  */
name|offset
operator|=
name|cp_convert
argument_list|(
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This shouldn't be necessary.  (mrs) */
block|expr = build1 (NOP_EXPR, type, expr);
endif|#
directive|endif
comment|/* For multiple inheritance: if `this' can be set by any 	 function, then it could be 0 on entry to any function. 	 Preserve such zeroness here.  Otherwise, only in the 	 case of constructors need we worry, and in those cases, 	 it will be zero, or initialized to some valid value to 	 which we may add.  */
if|if
condition|(
name|nonnull
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|null_expr
condition|)
name|TREE_TYPE
argument_list|(
name|null_expr
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|null_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|null_expr
argument_list|,
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/* Cannot change the TREE_TYPE of a NOP_EXPR here, since it may      be used multiple times in initialization of multiple inheritance.  */
if|if
condition|(
name|null_expr
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Virtual function things.  */
end_comment

begin_comment
comment|/* Build an entry in the virtual function table.    DELTA is the offset for the `this' pointer.    PFN is an ADDR_EXPR containing a pointer to the virtual function.    Note that the index (DELTA2) in the virtual function table    is always 0.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable_entry
parameter_list|(
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|delta
decl_stmt|,
name|pfn
decl_stmt|;
block|{
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
name|HOST_WIDE_INT
name|idelta
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
name|idelta
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vtable_entry_type
argument_list|,
name|make_thunk
argument_list|(
name|pfn
argument_list|,
name|idelta
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|pfn
return|;
block|}
else|else
block|{
specifier|extern
name|int
name|flag_huge_objects
decl_stmt|;
name|tree
name|elems
init|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|pfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|entry
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
decl_stmt|;
comment|/* DELTA used to be constructed by `size_int' and/or size_binop, 	 which caused overflow problems when it was negative.  That should 	 be fixed now.  */
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|delta
argument_list|,
name|delta_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_huge_objects
condition|)
name|sorry
argument_list|(
literal|"object size exceeds built-in limit for virtual function table implementation"
argument_list|)
expr_stmt|;
else|else
name|sorry
argument_list|(
literal|"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects"
argument_list|)
expr_stmt|;
block|}
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    virtual function vtable element corresponding to INDEX.  There are    many special cases for INSTANCE which we take care of here, mainly    to avoid creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vtbl_ref
parameter_list|(
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|tree
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|current_class_ref
condition|)
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Try to figure out what a reference refers to, and 	     access its virtual function table directly.  */
name|tree
name|ref
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|instance
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|instance
operator|=
name|init
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|vtbl
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|aref
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields the    virtual function corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|ptr_to_instptr
parameter_list|,
name|instance
parameter_list|,
name|idx
parameter_list|)
name|tree
modifier|*
name|ptr_to_instptr
decl_stmt|,
name|instance
decl_stmt|;
name|tree
name|idx
decl_stmt|;
block|{
name|tree
name|aref
init|=
name|build_vtbl_ref
argument_list|(
name|instance
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|/* When using thunks, there is no extra delta, and we get the pfn      directly.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
return|return
name|aref
return|;
if|if
condition|(
name|ptr_to_instptr
condition|)
block|{
comment|/* Save the intermediate result in a SAVE_EXPR so we don't have to 	 compute each component of the virtual function pointer twice.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ptr_to_instptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|ptr_to_instptr
argument_list|)
argument_list|,
operator|*
name|ptr_to_instptr
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type_id
init|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|type_id
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|type_id
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
index|[
name|i
index|]
operator|==
name|OPERATOR_TYPENAME_FORMAT
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|#
directive|if
literal|0
comment|/* We don't take off the numbers; prepare_fresh_vtable uses the      DECL_ASSEMBLER_NAME for the type, which includes the number      in `3foo'.  If we were to pull them off here, we'd end up with      something like `_vt.foo.3bar', instead of a uniform definition.  */
block|while (ptr[i]>= '0'&& ptr[i]<= '9')     i += 1;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|ptr
operator|+
name|i
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the offset to the main vtable for a given base BINFO.  */
end_comment

begin_function
name|tree
name|get_vfield_offset
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|tmp
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the offset to the start of the original binfo that we derived    this binfo from.  If we find TYPE first, return the offset only    that far.  The shortened search is useful because the this pointer    on method calling is expected to point to a DECL_CONTEXT (fndecl)    object, and not a baseclass of it.  */
end_comment

begin_function
specifier|static
name|tree
name|get_derived_offset
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|offset1
init|=
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|offset2
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|type
condition|)
break|break;
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|offset2
operator|=
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset1
argument_list|,
name|offset2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the rtti info for this class.  */
end_comment

begin_function
specifier|static
name|void
name|set_rtti_entry
parameter_list|(
name|virtuals
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|tree
name|virtuals
decl_stmt|,
name|offset
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|vfn
decl_stmt|;
if|if
condition|(
name|flag_rtti
condition|)
name|vfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|get_tinfo_fn
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vfn
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|size_zero_node
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_vtable_thunks
condition|)
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|offset
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|voff
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|voff
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|voff
argument_list|)
expr_stmt|;
comment|/* The second slot is for the tdesc pointer when thunks are used.  */
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a virtual function for type TYPE.    If BINFO is non-NULL, build the vtable starting with the initial    approximation that it is the same as the one which is the head of    the association list.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|binfo
parameter_list|,
name|type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|name
init|=
name|get_vtable_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|virtuals
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|tree
name|offset
decl_stmt|;
name|virtuals
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now do rtti stuff.  */
name|offset
operator|=
name|get_derived_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|virtuals
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|WRITABLE_VTABLES
comment|/* Make them READONLY by default. (mrs) */
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* At one time the vtable info was grabbed 2 words at a time.  This      fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Why is this conditional? (mrs) */
if|if
condition|(
name|binfo
operator|&&
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|tree
name|signed_size_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Give TYPE a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the derived type which caused this table to    be needed.     BINFO is the type association which provided TYPE for FOR_TYPE.     The order in which vtables are built (by calling this function) for    an object must remain the same, otherwise a binary incompatibility    can result.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_fresh_vtable
parameter_list|(
name|binfo
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|for_type
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|orig_decl
init|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|new_decl
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|tree
name|path
init|=
name|binfo
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|char
name|joiner
init|=
literal|'_'
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|JOINER
name|joiner
operator|=
name|JOINER
expr_stmt|;
endif|#
directive|endif
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|i
operator|=
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* We know that the vtable that we are going to create doesn't exist      yet in the global namespace, and when we finish, it will be      pushed into the global namespace.  In complex MI hierarchies, we      have to loop while the name we are thinking of adding is globally      defined, adding more name components to the vtable name as we      loop, until the name is unique.  This is because in complex MI      cases, we might have the same base more than once.  This means      that the order in which this function is called for vtables must      remain the same, otherwise binary compatibility can be      compromised.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|buf1
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|for_type
argument_list|)
operator|+
literal|1
operator|+
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_buf2
decl_stmt|;
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%s%c%s"
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|for_type
argument_list|)
argument_list|,
name|joiner
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* If this name doesn't clash, then we can use it, otherwise 	 we add more to the name until it is unique.  */
if|if
condition|(
operator|!
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
break|break;
comment|/* Set values for next loop through, if the name isn't unique.  */
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* We better not run out of stuff to make it unique.  */
name|my_friendly_assert
argument_list|(
name|path
operator|!=
name|NULL_TREE
argument_list|,
literal|368
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_type
operator|==
name|basetype
condition|)
block|{
comment|/* If we run out of basetypes in the path, we have already 	     found created a vtable with that name before, we now 	     resort to tacking on _%d to distinguish them.  */
name|int
name|j
init|=
literal|2
decl_stmt|;
name|i
operator|=
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
operator|+
name|i
operator|+
literal|1
operator|+
literal|3
expr_stmt|;
name|buf1
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%s%c%s%c%d"
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|joiner
argument_list|,
name|buf2
argument_list|,
name|joiner
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* If this name doesn't clash, then we can use it, 	       otherwise we add something different to the name until 	       it is unique.  */
block|}
do|while
condition|(
operator|++
name|j
operator|<=
literal|999
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
do|;
comment|/* Hey, they really like MI don't they?  Increase the 3              above to 6, and the 999 to 999999.  :-)  */
name|my_friendly_assert
argument_list|(
name|j
operator|<=
literal|999
argument_list|,
literal|369
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|TYPE_ASSEMBLER_NAME_LENGTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
operator|+
name|i
expr_stmt|;
name|new_buf2
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_buf2
argument_list|,
literal|"%s%c%s"
argument_list|,
name|TYPE_ASSEMBLER_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|joiner
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|new_buf2
expr_stmt|;
block|}
name|new_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember which class this vtable is really for.  */
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|for_type
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|pushdecl_top_level
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|WRITABLE_VTABLES
comment|/* Make them READONLY by default. (mrs) */
name|TREE_READONLY
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|DECL_ALIGN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|copy_list
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|binfo1
init|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|for_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* XXX - This should never happen, if it does, the caller should 	 ensure that the binfo is from for_type's binfos, not from any 	 base type's.  We can remove all this code after a while.  */
if|if
condition|(
name|binfo1
operator|!=
name|binfo
condition|)
name|warning
argument_list|(
literal|"internal inconsistency: binfo offset error for rtti"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo1
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|offset
argument_list|)
argument_list|,
name|for_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set TREE_PUBLIC and TREE_EXTERN as appropriate.  */
name|import_export_vtable
argument_list|(
name|new_decl
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|binfo
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
literal|170
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Access the virtual function table entry that logically    contains BASE_FNDECL.  VIRTUALS is the virtual function table's    initializer.  We can run off the end, when dealing with virtual    destructors in MI situations, return NULL_TREE in that case.  */
end_comment

begin_ifdef
unit|static tree get_vtable_entry (virtuals, base_fndecl)      tree virtuals, base_fndecl; {   unsigned HOST_WIDE_INT n = (HOST_BITS_PER_WIDE_INT>= BITS_PER_WORD 	   ? (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))& (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1)) 	   : TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl)));
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_endif
unit|n_vtable_searches += n;
endif|#
directive|endif
end_endif

begin_endif
unit|while (n> 0&& virtuals)     {       --n;       virtuals = TREE_CHAIN (virtuals);     }   return virtuals; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put new entry ENTRY into virtual function table initializer    VIRTUALS.     Also update DECL_VINDEX (FNDECL).  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|old_entry_in_list
parameter_list|,
name|new_entry
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|old_entry_in_list
decl_stmt|,
name|new_entry
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"replaced %D with %D"
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
operator|=
name|new_entry
expr_stmt|;
comment|/* Now assign virtual dispatch information, if unset.  */
comment|/* We can dispatch this, through any overridden base function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Access the virtual function table entry N.  VIRTUALS is the virtual    function table's initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_entry_n
parameter_list|(
name|virtuals
parameter_list|,
name|n
parameter_list|)
name|tree
name|virtuals
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|--
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Add a virtual function to all the appropriate vtables for the class    T.  DECL_VINDEX(X) should be error_mark_node, if we want to    allocate a new slot in our table.  If it is error_mark_node, we    know that no other function from another vtable is overridden by X.    HAS_VIRTUAL keeps track of how many virtuals there are in our main    vtable for the type, and we build upon the PENDING_VIRTUALS list    and return it.  */
end_comment

begin_function
specifier|static
name|void
name|add_virtual_function
parameter_list|(
name|pv
parameter_list|,
name|phv
parameter_list|,
name|has_virtual
parameter_list|,
name|fndecl
parameter_list|,
name|t
parameter_list|)
name|tree
modifier|*
name|pv
decl_stmt|,
decl|*
name|phv
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|has_virtual
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure type.  */
end_comment

begin_block
block|{
name|tree
name|pending_virtuals
init|=
operator|*
name|pv
decl_stmt|;
name|tree
name|pending_hard_virtuals
init|=
operator|*
name|phv
decl_stmt|;
comment|/* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely      convert to void *.  Make such a conversion here.  */
name|tree
name|vfn
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|DUMB_USER
if|if
condition|(
name|current_class_type
operator|==
literal|0
condition|)
name|cp_warning
argument_list|(
literal|"internal problem, current_class_type is zero when adding `%D', please report"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|t
operator|!=
name|current_class_type
condition|)
name|cp_warning
argument_list|(
literal|"internal problem, current_class_type differs when adding `%D', please report"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the virtual function is a redefinition of a prior one,      figure out in which base class the new definition goes,      and if necessary, make a fresh virtual function table      to hold that entry.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|tree
name|entry
decl_stmt|;
comment|/* We remember that this was the base sub-object for rtti.  */
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* If we are using thunks, use two slots at the front, one 	 for the offset pointer, one for the tdesc pointer.  */
if|if
condition|(
operator|*
name|has_virtual
operator|==
literal|0
operator|&&
name|flag_vtable_thunks
condition|)
block|{
operator|*
name|has_virtual
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Build a new INT_CST for this DECL_VINDEX.  */
block|{
specifier|static
name|tree
name|index_table
index|[
literal|256
index|]
decl_stmt|;
name|tree
name|idx
decl_stmt|;
comment|/* We skip a slot for the offset/tdesc entry.  */
name|int
name|i
init|=
operator|++
operator|(
operator|*
name|has_virtual
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
operator|||
name|index_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|idx
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|256
condition|)
name|index_table
index|[
name|i
index|]
operator|=
name|idx
expr_stmt|;
block|}
else|else
name|idx
operator|=
name|index_table
index|[
name|i
index|]
expr_stmt|;
comment|/* Now assign virtual dispatch information.  */
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|=
name|idx
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
name|entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Might already be INTEGER_CST if declared twice in class.  We will      give error later or we've already given it.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* Need an entry in some other virtual function table.          Deal with this after we have laid out our virtual base classes.  */
name|pending_hard_virtuals
operator|=
name|temp_tree_cons
argument_list|(
name|fndecl
argument_list|,
name|vfn
argument_list|,
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
operator|*
name|pv
operator|=
name|pending_virtuals
expr_stmt|;
operator|*
name|phv
operator|=
name|pending_hard_virtuals
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Obstack on which to build the vector of class methods.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add method METHOD to class TYPE.  This is used when a method    has been defined which did not initially appear in the class definition,    and helps cut down on spurious error messages.     FIELDS is the entry in the METHOD_VEC vector entry of the class type where    the method should be added.  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|type
parameter_list|,
name|fields
parameter_list|,
name|method
parameter_list|)
name|tree
name|type
decl_stmt|,
decl|*
name|fields
decl_stmt|,
name|method
decl_stmt|;
end_function

begin_block
block|{
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|&&
operator|*
name|fields
condition|)
operator|*
name|fields
operator|=
name|build_overload
argument_list|(
name|method
argument_list|,
operator|*
name|fields
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|method_vec
init|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|method
argument_list|)
condition|)
block|{
comment|/* ??? Is it possible for there to have been enough room in the 	     current chunk for the tree_vec structure but not a tree_vec 	     plus a tree*?  Will this work in that case?  */
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
operator|=
name|method
expr_stmt|;
else|else
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|method
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Is it possible for there to have been enough room in the 	     current chunk for the tree_vec structure but not a tree_vec 	     plus a tree*?  Will this work in that case?  */
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
operator|=
name|method
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|3
expr_stmt|;
name|obstack_finish
argument_list|(
name|current_obstack
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
block|}
else|else
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
comment|/* Adding a new ctor or dtor.  This is easy because our          METHOD_VEC always has a slot for such entries.  */
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|int
name|idx
init|=
operator|!
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
comment|/* TREE_VEC_ELT (method_vec, idx) = method; */
if|if
condition|(
name|method
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|idx
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|idx
argument_list|)
operator|=
name|build_overload
argument_list|(
name|method
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is trickier.  We try to extend the TREE_VEC in-place, 	     but if that does not work, we copy all its data to a new 	     TREE_VEC that's large enough.  */
name|struct
name|obstack
modifier|*
name|ob
init|=
operator|&
name|class_obstack
decl_stmt|;
name|tree
modifier|*
name|end
init|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|ob
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|)
block|{
name|ob
operator|=
name|current_obstack
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|method_vec
operator|=
name|copy_node
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tmp_vec
init|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
name|ob
argument_list|)
decl_stmt|;
if|if
condition|(
name|obstack_room
argument_list|(
name|ob
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
condition|)
block|{
name|obstack_blank
argument_list|(
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_VEC
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_vec
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|method_vec
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp_vec
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_VEC
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|tmp_vec
expr_stmt|;
block|}
else|else
name|obstack_blank
argument_list|(
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obstack_finish
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|method
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* ??? May be better to know whether these can be extended?  */
name|tree
name|baselink_vec
init|=
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|copy_node
argument_list|(
name|baselink_vec
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|DECL_CONTEXT
argument_list|(
name|method
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|method
argument_list|)
operator|=
name|type
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Look through the list of fields for this struct, deleting    duplicates as we go.  This must be recursive to handle    anonymous unions.     FIELD is the field which may not appear anywhere in FIELDS.    FIELD_PTR, if non-null, is the starting point at which    chained deletions may take place.    The value returned is the first acceptable entry found    in FIELDS.     Note that anonymous fields which are not of UNION_TYPE are    not duplicates, they are just anonymous fields.  This happens    when we have unnamed bitfields, for example.  */
end_comment

begin_function
specifier|static
name|tree
name|delete_duplicate_fields_1
parameter_list|(
name|field
parameter_list|,
name|fields
parameter_list|)
name|tree
name|field
decl_stmt|,
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
return|return
name|fields
return|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|fields
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|fields
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|field
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate enum value `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as enum and non-enum)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_DECLARES_TYPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|cp_error_at
argument_list|(
literal|"duplicate nested type `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|field
argument_list|)
operator|||
name|DECL_DECLARES_TYPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Hide tag decls.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
continue|continue;
name|cp_error_at
argument_list|(
literal|"duplicate field `%D' (as type and non-type)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error_at
argument_list|(
literal|"duplicate member `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|fields
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_duplicate_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the access of FDECL to ACCESS in T.  The access to FDECL is    along the path given by BINFO.  Return 1 if change was legit,    otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_access
parameter_list|(
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fdecl
parameter_list|,
name|access
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|fdecl
decl_stmt|;
name|tree
name|access
decl_stmt|;
block|{
name|tree
name|elem
init|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
name|access
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"conflicting access specifications for method `%D', ignored"
argument_list|,
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"conflicting access specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* They're changing the access to the same thing they changed 	     it to before.  That's OK.  */
empty_stmt|;
block|}
block|}
else|else
block|{
name|enforce_access
argument_list|(
name|binfo
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|access
argument_list|,
name|DECL_ACCESS
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the USING_DECL, which is a member of T.  The METHOD_VEC, if    non-NULL, is the methods of T.  The FIELDS are the fields of T.    Returns 1 if the USING_DECL was valid, 0 otherwise.  */
end_comment

begin_function
name|void
name|handle_using_decl
parameter_list|(
name|using_decl
parameter_list|,
name|t
parameter_list|,
name|method_vec
parameter_list|,
name|fields
parameter_list|)
name|tree
name|using_decl
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|ctype
init|=
name|DECL_INITIAL
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|using_decl
argument_list|)
decl_stmt|;
name|tree
name|access
init|=
name|TREE_PRIVATE
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_private_node
else|:
name|TREE_PROTECTED
argument_list|(
name|using_decl
argument_list|)
condition|?
name|access_protected_node
else|:
name|access_public_node
decl_stmt|;
name|tree
name|fdecl
decl_stmt|,
name|binfo
decl_stmt|;
name|tree
name|flist
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n_methods
decl_stmt|;
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|ctype
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
return|return;
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"using-declaration for constructor"
argument_list|,
name|using_decl
argument_list|)
expr_stmt|;
name|fdecl
operator|=
name|lookup_member
argument_list|(
name|binfo
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"no members matching `%D' in `%#T'"
argument_list|,
name|using_decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Functions are represented as TREE_LIST, with the purpose      being the type and the value the functions. Other members      come as themselves. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Ignore base type this came from. */
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
comment|/* We later iterate over all functions. */
name|flist
operator|=
name|fdecl
expr_stmt|;
name|fdecl
operator|=
name|OVL_FUNCTION
argument_list|(
name|flist
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
name|n_methods
operator|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|n_methods
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot adjust access to `%#D' in `%#T'"
argument_list|,
name|fdecl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local method `%#D' with same name"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|fdecl
argument_list|)
condition|)
comment|/* We don't currently handle DECL_ACCESS for TYPE_DECLs; just return.  */
return|return;
for|for
control|(
name|tmp
operator|=
name|fields
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot adjust access to `%#D' in `%#T'"
argument_list|,
name|fdecl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  because of local field `%#D' with same name"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make type T see field decl FDECL with access ACCESS.*/
if|if
condition|(
name|flist
condition|)
block|{
while|while
condition|(
name|flist
condition|)
block|{
if|if
condition|(
name|alter_access
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|OVL_FUNCTION
argument_list|(
name|flist
argument_list|)
argument_list|,
name|access
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|flist
operator|=
name|OVL_CHAIN
argument_list|(
name|flist
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|alter_access
argument_list|(
name|t
argument_list|,
name|binfo
argument_list|,
name|fdecl
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If FOR_TYPE needs to reinitialize virtual function table pointers    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.    Returns BASE_INIT_LIST appropriately modified.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fixup_vptrs
parameter_list|(
name|for_type
parameter_list|,
name|binfo
parameter_list|,
name|base_init_list
parameter_list|)
name|tree
name|for_type
decl_stmt|,
name|binfo
decl_stmt|,
name|base_init_list
decl_stmt|;
block|{
comment|/* Now reinitialize any slots that don't fall under our virtual      function table pointer.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
name|tree
name|basetype
init|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
condition|?
name|TYPE_MAIN_VARIANT
argument_list|(
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
else|:
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Punt until this is implemented.  */
if|if
condition|(
literal|1
comment|/* BINFO_MODIFIED (base_binfo) */
condition|)
block|{
name|tree
name|base_offset
init|=
name|get_vfield_offset
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|base_offset
argument_list|,
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|for_type
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|base_offset
argument_list|,
name|get_vfield_offset
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
return|return
name|base_init_list
return|;
block|}
end_function

begin_comment
comment|/* If TYPE does not have a constructor, then the compiler must    manually deal with all of the initialization this type requires.     If a base initializer exists only to fill in the virtual function    table pointer, then we mark that fact with the TREE_VIRTUAL bit.    This way, we avoid multiple initializations of the same field by    each virtual function table up the class hierarchy.     Virtual base class pointers are not initialized here.  They are    initialized only at the "top level" of object creation.  If we    initialized them here, we would have to skip a lot of work.  */
end_comment

begin_function
specifier|static
name|void
name|build_class_init_list
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|base_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Since we build member_init_list and base_init_list using      tree_cons, backwards fields the all through work.  */
name|tree
name|x
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|x
argument_list|,
name|type
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|member_init_list
operator|=
name|nreverse
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
comment|/* We will end up doing this last.  Need special marker      to avoid infinite regress.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Each base class which needs to have initialization      of some kind gets to make such requests known here.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|blist
decl_stmt|;
comment|/* Don't initialize virtual baseclasses this way.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* ...and the last shall come first...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|blist
operator|=
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL_TREE
condition|)
comment|/* Nothing to initialize.  */
continue|continue;
comment|/* ...ditto...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* This is normally true for single inheritance. 	 The win is we can shrink the chain of initializations 	 to be done by only converting to the actual type 	 we are interested in.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|base_init_list
condition|)
block|{
comment|/* Does it do more than just fill in a 		 virtual function table pointer?  */
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|blist
argument_list|)
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* Can we get by just with the virtual function table 		 pointer that it fills in?  */
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|blist
expr_stmt|;
comment|/* Maybe, but it is not obvious as the previous case.  */
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|base_init_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|last
operator|=
name|tree_last
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|base_init_list
operator|=
name|blist
expr_stmt|;
block|}
else|else
block|{
comment|/* The function expand_aggr_init knows how to do the 	     initialization of `basetype' without getting 	     an explicit `blist'.  */
if|if
condition|(
name|base_init_list
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
else|else
name|base_init_list
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_init_list
condition|)
block|{
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|base_init_list
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|base_init_list
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|member_init_list
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|base_info
block|{
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|int
name|n_ancestors
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|tree
name|rtti
decl_stmt|;
name|char
name|cant_have_default_ctor
decl_stmt|;
name|char
name|cant_have_const_ctor
decl_stmt|;
name|char
name|no_const_asn_ref
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about type T derived from its base classes.    Store most of that information in T itself, and place the    remaining information in the struct BASE_INFO.     Propagate basetype offsets throughout the lattice.  Note that the    lattice topped by T is really a pair: it's a DAG that gives the    structure of the derivation hierarchy, and it's a list of the    virtual baseclasses that appear anywhere in the DAG.  When a vbase    type appears in the DAG, it's offset is 0, and it's children start    their offsets from that point.  When a vbase type appears in the list,    its offset is the offset it has in the hierarchy, and its children's    offsets include that offset in theirs.     Returns the index of the first base class to have virtual functions,    or -1 if no such base class.  */
end_comment

begin_function
specifier|static
name|int
name|finish_base_struct
parameter_list|(
name|t
parameter_list|,
name|b
parameter_list|)
name|tree
name|t
decl_stmt|;
name|struct
name|base_info
modifier|*
name|b
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|first_vfn_base_index
init|=
operator|-
literal|1
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|base_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P 	 here because the case of virtual functions but non-virtual 	 dtor is handled in finish_struct_1.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|!
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"base class `%#T' has a non-virtual destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* If the type of basetype is incomplete, then 	 we already complained about that fact 	 (and we should have fixed it up as well).  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
operator|-
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|b
operator|->
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"base `%T' with only non-default constructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"in class without a constructor"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|n_ancestors
operator|+=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* Ensure that this is set from at least a virtual base              class.  */
if|if
condition|(
name|b
operator|->
name|rtti
operator|==
name|NULL_TREE
condition|)
name|b
operator|->
name|rtti
operator|=
name|CLASSTYPE_RTTI
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* Don't borrow virtuals from virtual baseclasses.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
name|tree
name|vfields
decl_stmt|;
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
comment|/* Update these two, now that we know what vtable we are 		 going to extend.  This is so that we can add virtual 		 functions, and override them properly.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfields
operator|=
name|copy_list
argument_list|(
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|vfields
operator|=
name|b
operator|->
name|vfields
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
else|else
block|{
comment|/* Only add unique vfields, and flatten them out as we go.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|VF_BINFO_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
name|b
operator|->
name|vfields
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|value
argument_list|,
name|b
operator|->
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
else|else
name|VF_NORMAL_VALUE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|has_virtual
operator|==
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
comment|/* Update these two, now that we know what vtable we are 		     going to extend.  This is so that we can add virtual 		     functions, and override them properly.  */
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
comment|/* When we install the first one, set the VF_NORMAL_VALUE 		     to be the current class, as this it is the most derived 		     class.  Hopefully, this is not set to something else 		     later.  (mrs) */
name|vfields
operator|=
name|b
operator|->
name|vfields
expr_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
name|VF_NORMAL_VALUE
argument_list|(
name|vfields
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* There should only be one of them!  And it should 			     always be found, if we get into here.  (mrs)  */
break|break;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* This comment said "Must come after offsets are fixed for all bases."      Well, now this happens before the offsets are fixed, but it seems to      work fine.  Guess we'll see...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
name|cp_warning
argument_list|(
literal|"direct base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|tree
name|v
init|=
name|get_vbase_types
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
name|cp_warning
argument_list|(
literal|"virtual base `%T' inaccessible in `%T' due to ambiguity"
argument_list|,
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
name|tree
name|vfields
decl_stmt|;
comment|/* Find the base class with the largest number of virtual functions.  */
for|for
control|(
name|vfields
operator|=
name|b
operator|->
name|vfields
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_BASETYPE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|->
name|vfield
operator|==
literal|0
condition|)
comment|/* If all virtual functions come only from virtual baseclasses.  */
return|return
operator|-
literal|1
return|;
comment|/* Update the rtti base if we have a non-virtual base class version      of it.  */
name|b
operator|->
name|rtti
operator|=
name|CLASSTYPE_RTTI
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|first_vfn_base_index
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later use.    MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|t
parameter_list|,
name|max_has_virtual
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
comment|/* These fields are in the _TYPE part of the node, not in 	 the TYPE_LANG_SPECIFIC component, so they are not shared.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_VIRTUAL_P
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Copy whatever these are holding today.  */
name|TYPE_MIN_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|max_has_virtual
condition|)
block|{
comment|/* Done by `finish_struct' for classes without baseclasses.  */
name|int
name|might_have_abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|might_have_abstract_virtuals
operator||=
operator|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|might_have_abstract_virtuals
condition|)
break|break;
block|}
if|if
condition|(
name|might_have_abstract_virtuals
condition|)
block|{
comment|/* We use error_mark_node from override_one_vtable to signal 	     an artificial abstract.  */
if|if
condition|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|get_abstract_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined.  */
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|basetype
argument_list|)
operator|>=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|basetype
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this type has a copy constructor, force its mode to be BLKmode, and      force its TREE_ADDRESSABLE bit to be nonzero.  This will cause it to      be passed by invisible reference and prevent it from being returned in      a register.       Also do this if the class has BLKmode but can still be returned in      registers, since function_cannot_inline_p won't let us inline      functions returning such a type.  This affects the HP-PA.  */
if|if
condition|(
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|aggregate_value_p
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|tree
name|variants
decl_stmt|;
name|DECL_MODE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
for|for
control|(
name|variants
operator|=
name|t
init|;
name|variants
condition|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
control|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add FNDECL to the method_vec growing on the class_obstack.  Used by    finish_struct_methods.  Note, FNDECL cannot be a constructor or    destructor, those cases are handled by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|grow_method
parameter_list|(
name|fndecl
parameter_list|,
name|method_vec_ptr
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|tree
modifier|*
name|method_vec_ptr
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
decl_stmt|;
comment|/* Start off past the constructors and destructor.  */
name|tree
modifier|*
name|testp
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
decl_stmt|;
while|while
condition|(
name|testp
operator|<
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|&&
operator|(
operator|*
name|testp
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|testp
argument_list|)
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|)
name|testp
operator|++
expr_stmt|;
if|if
condition|(
name|testp
operator|<
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
condition|)
operator|*
name|testp
operator|=
name|build_overload
argument_list|(
name|fndecl
argument_list|,
operator|*
name|testp
argument_list|)
expr_stmt|;
else|else
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
operator|*
name|method_vec_ptr
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about duplicate methods in fn_fields.  Also compact method    lists so that lookup can be made faster.     Algorithm: Outer loop builds lists by method name.  Inner loop    checks for redundant method names within a list.     Data Structure: List of method lists.  The outer list is a    TREE_LIST, whose TREE_PURPOSE field is the field name and the    TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN    links the entire list of methods for TYPE_METHODS.  Friends are    chained in the same way as member functions (? TREE_CHAIN or    DECL_CHAIN), but they live in the TREE_TYPE field of the outer    list.  That allows them to be quickly deleted, and requires no    extra storage.     If there are any constructors/destructors, they are moved to the    front of the list.  This makes pushclass more efficient.     We also link each field which has shares a name with its baseclass    to the head of the list of fields for that base class.  This allows    us to reduce search time in places like `build_method_call' to    consider only reasonably likely functions.  */
end_comment

begin_function
name|tree
name|finish_struct_methods
parameter_list|(
name|t
parameter_list|,
name|fn_fields
parameter_list|,
name|nonprivate_method
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fn_fields
decl_stmt|;
name|int
name|nonprivate_method
decl_stmt|;
block|{
name|tree
name|method_vec
decl_stmt|;
name|tree
name|save_fn_fields
init|=
name|fn_fields
decl_stmt|;
name|tree
name|ctor_name
init|=
name|constructor_name
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Now prepare to gather fn_fields into vector.  */
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|method_vec
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
comment|/* Now make this a live vector.  */
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
comment|/* Save room for constructors and destructors.  */
name|obstack_blank
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First fill in entry 0 with the constructors, entry 1 with destructors,      and the next few with type conversion operators (if any).  */
for|for
control|(
init|;
name|fn_fields
condition|;
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
control|)
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
comment|/* Clear out this flag.  	 @@ Doug may figure out how to break 	 @@ this with nested classes and friends.  */
name|DECL_IN_AGGR_P
argument_list|(
name|fn_fields
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Note here that a copy ctor is private, so we don't dare generate  	 a default copy constructor for a class that has a member  	 of this type without making sure they have access to it.  */
if|if
condition|(
name|fn_name
operator|==
name|ctor_name
condition|)
block|{
name|tree
name|parmtypes
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
name|tree
name|parmtype
init|=
name|parmtypes
condition|?
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
else|:
name|void_type_node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|void_list_node
operator|||
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_CTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Destructors go in slot 1.  */
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
operator|=
name|build_overload
argument_list|(
name|fn_fields
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Constructors go in slot 0.  */
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|build_overload
argument_list|(
name|fn_fields
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|fn_name
argument_list|)
condition|)
name|grow_method
argument_list|(
name|fn_fields
argument_list|,
operator|&
name|method_vec
argument_list|)
expr_stmt|;
block|}
name|fn_fields
operator|=
name|save_fn_fields
expr_stmt|;
for|for
control|(
init|;
name|fn_fields
condition|;
name|fn_fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
control|)
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|ctor_name
operator|||
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|fn_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fn_name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy_assignment_arg_p
argument_list|(
name|parmtype
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|TYPE_HAS_NONPUBLIC_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|grow_method
argument_list|(
name|fn_fields
argument_list|,
operator|&
name|method_vec
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|-
operator|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_PROTECTED
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
operator|&&
name|warn_ctor_dtor_privacy
condition|)
name|cp_warning
argument_list|(
literal|"all member functions in class `%T' are private"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Warn if all destructors are private (in which case this class is      effectively unusable.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|dtor
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Wild parse errors can cause this to happen.  */
if|if
condition|(
name|dtor
operator|==
name|NULL_TREE
condition|)
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|dtor
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|warn_ctor_dtor_privacy
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' only defines a private destructor and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Now for each member function (except for constructors and      destructors), compute where member functions of the same      name reside in base classes.  */
if|if
condition|(
name|n_baseclasses
operator|!=
literal|0
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>
literal|2
condition|)
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|tree
name|baselink_vec
init|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|int
name|any_links
init|=
literal|0
decl_stmt|;
name|tree
name|baselink_binfo
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|=
name|get_baselinks
argument_list|(
name|baselink_binfo
argument_list|,
name|t
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|any_links
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|any_links
operator|!=
literal|0
condition|)
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|baselink_vec
expr_stmt|;
else|else
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|baselink_vec
argument_list|)
expr_stmt|;
block|}
return|return
name|method_vec
return|;
block|}
end_function

begin_comment
comment|/* Emit error when a duplicate definition of a type is seen.  Patch up.  */
end_comment

begin_function
name|void
name|duplicate_tag_error
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|cp_error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous definition here"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Pretend we haven't defined this type.  */
comment|/* All of the component_decl's were TREE_CHAINed together in the parser.      finish_struct_methods walks these chains and assembles all methods with      the same base name into DECL_CHAINs. Now we don't need the parser chains      anymore, so we unravel them.  */
comment|/* This used to be in finish_struct, but it turns out that the      TREE_CHAIN is used by dbxout_type_methods and perhaps some other      things...  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|unchain
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|unchain
operator|!=
name|NULL_TREE
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|OVL_CURRENT
argument_list|(
name|unchain
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|unchain
operator|=
name|OVL_NEXT
argument_list|(
name|unchain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|as_list
init|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfo_as_list
init|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_only
init|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|interface_unknown
init|=
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|as_list
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|binfo_as_list
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|TYPE_REDEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* finish up all new vtables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_vtbls
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|context
decl_stmt|;
name|decl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_vtbls
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True if we should override the given BASE_FNDECL with the given    FNDECL.  */
end_comment

begin_function
specifier|static
name|int
name|overrides
parameter_list|(
name|fndecl
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
comment|/* Destructors have special names.  */
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&&
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|base_fndecl
argument_list|)
condition|)
block|{
name|tree
name|types
decl_stmt|,
name|base_types
decl_stmt|;
if|#
directive|if
literal|0
block|retypes = TREE_TYPE (TREE_TYPE (fndecl));       base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));
endif|#
directive|endif
name|types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|base_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_types
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|base_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_class_offset_1
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|context
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|,
name|context
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|parent
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|nrval
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|nrval
operator|=
name|get_class_offset_1
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|,
name|context
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* See if we have a new value */
if|if
condition|(
name|nrval
operator|&&
operator|(
name|nrval
operator|!=
name|error_mark_node
operator|||
name|rval
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Only compare if we have two offsets */
if|if
condition|(
name|rval
operator|&&
name|rval
operator|!=
name|error_mark_node
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|nrval
argument_list|,
name|rval
argument_list|)
condition|)
block|{
comment|/* Only give error if the two offsets are different */
name|error
argument_list|(
literal|"every virtual function must have a unique final overrider"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  found two (or more) `%T' class subobjects in `%T'"
argument_list|,
name|context
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  with virtual `%D' from virtual base class"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
name|rval
operator|=
name|nrval
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|rval
operator|==
name|error_mark_node
operator|||
name|tree_int_cst_equal
argument_list|(
name|rval
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|rval
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Get the offset to the CONTEXT subobject that is related to the    given BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_offset
parameter_list|(
name|context
parameter_list|,
name|t
parameter_list|,
name|binfo
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|context
decl_stmt|,
name|t
decl_stmt|,
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|first_binfo
init|=
name|binfo
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|context
operator|==
name|t
condition|)
return|return
name|integer_zero_node
return|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
comment|/* Check less derived binfos first.  */
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|context
condition|)
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
block|}
comment|/* Ok, not found in the less derived binfos, now check the more      derived binfos.  */
name|offset
operator|=
name|get_class_offset_1
argument_list|(
name|first_binfo
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|context
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|my_friendly_abort
argument_list|(
literal|999
argument_list|)
expr_stmt|;
comment|/* we have to find it.  */
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Skip RTTI information at the front of the virtual list.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|skip_rtti_stuff
parameter_list|(
name|virtuals
parameter_list|)
name|tree
modifier|*
name|virtuals
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|virtuals
condition|)
block|{
comment|/* We always reserve a slot for the offset/tdesc entry.  */
operator|++
name|n
expr_stmt|;
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_vtable_thunks
operator|&&
operator|*
name|virtuals
condition|)
block|{
comment|/* The second slot is reserved for the tdesc pointer when thunks          are used.  */
operator|++
name|n
expr_stmt|;
operator|*
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|virtuals
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|modify_one_vtable
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
comment|/* update rtti entry */
if|if
condition|(
name|flag_rtti
condition|)
block|{
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fndecl
operator|==
name|NULL_TREE
condition|)
return|return;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|current_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|current_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|current_fndecl
argument_list|)
expr_stmt|;
name|current_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|current_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_fndecl
operator|&&
name|overrides
argument_list|(
name|fndecl
argument_list|,
name|current_fndecl
argument_list|)
condition|)
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|this_offset
decl_stmt|;
name|offset
operator|=
name|get_class_offset
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Find the right offset for the this pointer based on the 	     base class we just found.  We have to take into 	     consideration the virtual base class pointers that we 	     stick in before the virtual function table pointer.  	     Also, we want just the delta between the most base class 	     that we derived this vfield from and us.  */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|get_derived_offset
argument_list|(
name|binfo
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|current_fndecl
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 		 We start with the approximation that it's vtable is that 		 of the immediate base class.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 		 Later, we will fill in all the virtual functions 		 that override the virtual functions in these base classes 		 which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"in %D"
argument_list|,
name|DECL_NAME
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry_n
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the ones that are not through virtual base classes.  */
end_comment

begin_function
specifier|static
name|void
name|modify_all_direct_vtables
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|modify_one_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|modify_all_direct_vtables
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup all the delta entries in this one vtable that need updating.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_vtable_deltas1
parameter_list|(
name|binfo
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|tree
name|pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|delta
init|=
name|DELTA_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|this_offset
decl_stmt|;
name|offset
operator|=
name|get_class_offset
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Find the right offset for the this pointer based on the 	     base class we just found.  We have to take into 	     consideration the virtual base class pointers that we 	     stick in before the virtual function table pointer.  	     Also, we want just the delta between the most base class 	     that we derived this vfield from and us.  */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|get_derived_offset
argument_list|(
name|binfo
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|this_offset
operator|=
name|ssize_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|this_offset
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|binfo
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying. 		     We start with the approximation that it's vtable is that 		     of the immediate base class.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with. 		     Later, we will fill in all the virtual functions 		     that override the virtual functions in these base classes 		     which are not defined by the current type.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry_n
argument_list|(
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|n
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fixup all the delta entries in all the direct vtables that need updating.    This happens when we have non-overridden virtual functions from a    virtual base class, that are at a different offset, in the new    hierarchy, because the layout of the virtual bases has changed.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_vtable_deltas
parameter_list|(
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|init_self
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|fixup_vtable_deltas
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|fixup_vtable_deltas1
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the ones that are through virtual base classes.  */
end_comment

begin_function
specifier|static
name|void
name|modify_all_indirect_vtables
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|via_virtual
parameter_list|,
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|,
name|via_virtual
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|via_virtual
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|modify_one_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
name|via_virtual
operator|=
literal|1
expr_stmt|;
name|base_binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|modify_all_indirect_vtables
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|via_virtual
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|modify_all_vtables
parameter_list|(
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|vfn
parameter_list|)
name|tree
name|t
decl_stmt|,
name|fndecl
decl_stmt|,
name|vfn
decl_stmt|;
block|{
comment|/* Do these first, so that we will make use of any non-virtual class's      vtable, over a virtual classes vtable.  */
name|modify_all_direct_vtables
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|modify_all_indirect_vtables
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
name|fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here, we already know that they match in every respect.    All we have to check is where they had their declarations.  */
end_comment

begin_function
specifier|static
name|int
name|strictly_overrides
parameter_list|(
name|fndecl1
parameter_list|,
name|fndecl2
parameter_list|)
name|tree
name|fndecl1
decl_stmt|,
name|fndecl2
decl_stmt|;
block|{
name|int
name|distance
init|=
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl2
argument_list|)
argument_list|,
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|2
operator|||
name|distance
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Merge overrides for one vtable.    If we want to merge in same function, we are fine.    else      if one has a DECL_CLASS_CONTEXT that is a parent of the        other, than choose the more derived one      else        potentially ill-formed (see 10.3 [class.virtual])        we have to check later to see if there was an        override in this class.  If there was ok, if not        then it is ill-formed.  (mrs)     We take special care to reuse a vtable, if we can.  */
end_comment

begin_function
specifier|static
name|void
name|override_one_vtable
parameter_list|(
name|binfo
parameter_list|,
name|old
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|old
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|old
argument_list|)
decl_stmt|;
enum|enum
block|{
name|REUSE_NEW
block|,
name|REUSE_OLD
block|,
name|UNDECIDED
block|,
name|NEITHER
block|}
name|choose
init|=
name|UNDECIDED
enum|;
comment|/* If we have already committed to modifying it, then don't try and      reuse another vtable.  */
if|if
condition|(
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
name|choose
operator|=
name|NEITHER
expr_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|old_virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|tree
name|old_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
decl_stmt|;
name|fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|old_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|old_fndecl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|old_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First check to see if they are the same.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|old_fndecl
argument_list|)
condition|)
block|{
comment|/* No need to do anything.  */
block|}
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|fndecl
argument_list|,
name|old_fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|choose
operator|==
name|UNDECIDED
condition|)
name|choose
operator|=
name|REUSE_NEW
expr_stmt|;
elseif|else
if|if
condition|(
name|choose
operator|==
name|REUSE_OLD
condition|)
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strictly_overrides
argument_list|(
name|old_fndecl
argument_list|,
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|choose
operator|==
name|UNDECIDED
condition|)
name|choose
operator|=
name|REUSE_OLD
expr_stmt|;
elseif|else
if|if
condition|(
name|choose
operator|==
name|REUSE_NEW
condition|)
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|choose
operator|==
name|NEITHER
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|choose
operator|=
name|NEITHER
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|prepare_fresh_vtable
argument_list|(
name|binfo
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
comment|/* This MUST be overridden, or the class is ill-formed.  */
comment|/* For now, we just make it abstract.  */
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|vfn
decl_stmt|;
name|fndecl
operator|=
name|copy_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make sure we search for it later.  */
if|if
condition|(
operator|!
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|vfn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can use integer_zero_node, as we will core dump 	       if this is used anyway.  */
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
block|}
block|}
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|old_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|old_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Let's reuse the old vtable.  */
if|if
condition|(
name|choose
operator|==
name|REUSE_OLD
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge in overrides for virtual bases.    BINFO is the hierarchy we want to modify, and OLD has the potential    overrides.  */
end_comment

begin_function
specifier|static
name|void
name|merge_overrides
parameter_list|(
name|binfo
parameter_list|,
name|old
parameter_list|,
name|do_self
parameter_list|,
name|t
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|old
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|old_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|old
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|override_one_vtable
argument_list|(
name|binfo
argument_list|,
name|old
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|old_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|old_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|merge_overrides
argument_list|(
name|base_binfo
argument_list|,
name|old_base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the base virtual function declarations in T that are either    overridden or hidden by FNDECL as a list.  We set TREE_PURPOSE with    the overrider/hider.  */
end_comment

begin_function
specifier|static
name|tree
name|get_basefndecls
parameter_list|(
name|fndecl
parameter_list|,
name|t
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|t
decl_stmt|;
block|{
name|tree
name|methods
init|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|base_fndecls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|methods
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|methods
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|methods
argument_list|)
condition|)
name|base_fndecls
operator|=
name|temp_tree_cons
argument_list|(
name|fndecl
argument_list|,
name|methods
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base_fndecls
condition|)
return|return
name|base_fndecls
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|fndecl
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
return|return
name|base_fndecls
return|;
block|}
end_function

begin_comment
comment|/* Mark the functions that have been hidden with their overriders.    Since we start out with all functions already marked with a hider,    no need to mark functions that are just hidden.  */
end_comment

begin_function
specifier|static
name|void
name|mark_overriders
parameter_list|(
name|fndecl
parameter_list|,
name|base_fndecls
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|base_fndecls
decl_stmt|;
block|{
while|while
condition|(
name|base_fndecls
condition|)
block|{
if|if
condition|(
name|overrides
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|fndecl
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|base_fndecls
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If this declaration supersedes the declaration of    a method declared virtual in the base class, then    mark this field as being virtual as well.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_override
parameter_list|(
name|decl
parameter_list|,
name|ctype
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|ctype
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|virtualp
init|=
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|flag_all_virtual
operator|==
literal|1
condition|)
block|{
name|tree
name|tmp
init|=
name|get_matching_virtual
argument_list|(
name|base_binfo
argument_list|,
name|decl
argument_list|,
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* If this function overrides some virtual in some base 		 class, then the function itself is also necessarily 		 virtual, even if the user didn't explicitly say so.  */
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The TMP we really want is the one from the deepest 		 baseclass on this path, taking care not to 		 duplicate if we have already found it (via another 		 path to its virtual baseclass.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"method `%D' may not be declared static"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"(since `%D' declared virtual in base class.)"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|virtualp
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The signature of an overriding function is not changed.  */
block|{
comment|/* The argument types may have changed...  */
block|tree type = TREE_TYPE (decl); 		tree argtypes = TYPE_ARG_TYPES (type); 		tree base_variant = TREE_TYPE (TREE_VALUE (argtypes)); 		tree raises = TYPE_RAISES_EXCEPTIONS (type);  		argtypes = commonparms (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (tmp))), 					TREE_CHAIN (argtypes));
comment|/* But the return type has not.  */
block|type = build_cplus_method_type (base_variant, TREE_TYPE (type), argtypes); 		if (raises) 		  type = build_exception_variant (type, raises); 		TREE_TYPE (decl) = type; 	      }
endif|#
directive|endif
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmp
argument_list|,
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|virtualp
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Warn about hidden virtual functions that are not overridden in t.    We know that constructors and destructors don't apply.  */
end_comment

begin_function
name|void
name|warn_hidden
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We go through each separately named virtual function.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|n_methods
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|base_fndecls
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* First we get a list of all possible functions that might be 	 hidden from each base class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|base_fndecls
operator|=
name|chainon
argument_list|(
name|get_basefndecls
argument_list|(
name|fndecl
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
condition|)
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
else|else
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* ...then mark up all the base functions with overriders, preferring 	 overriders to hiders.  */
if|if
condition|(
name|base_fndecls
condition|)
while|while
condition|(
name|fndecl
condition|)
block|{
name|mark_overriders
argument_list|(
name|fndecl
argument_list|,
name|base_fndecls
argument_list|)
expr_stmt|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
condition|)
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
else|else
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Now give a warning for all base functions without overriders, 	 as they are hidden.  */
while|while
condition|(
name|base_fndecls
condition|)
block|{
if|if
condition|(
operator|!
name|overrides
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Here we know it is a hider, and no overrider exists.  */
name|cp_warning_at
argument_list|(
literal|"`%D' was hidden"
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  by `%D'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check for things that are invalid.  There are probably plenty of other    things we should check for also.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_anon
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
modifier|*
name|uelt
init|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|*
name|uelt
condition|;
name|uelt
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|uelt
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|uelt
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
operator|*
name|uelt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"private member `%#D' in anonymous union"
argument_list|,
operator|*
name|uelt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
operator|*
name|uelt
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"protected member `%#D' in anonymous union"
argument_list|,
operator|*
name|uelt
argument_list|)
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
operator|*
name|uelt
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
operator|*
name|uelt
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|interface_only
decl_stmt|,
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration    (or C++ class declaration).     For C++, we must handle the building of derived classes.    Also, C++ allows static class members.  The way that this is    handled is to keep the field name where it is (as the DECL_NAME    of the field), and place the overloaded decl in the DECL_FIELD_BITPOS    of the field.  layout_record and layout_union will know about this.     More C++ hair: inline functions have text in their    DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into    meaningful tree structure.  After the struct has been laid out, set    things up so that this can happen.     And still more: virtual functions.  In the case of single inheritance,    when a new virtual function is seen which redefines a virtual function    from the base class, the new virtual function is placed into    the virtual function table at exactly the same address that    it had in the base class.  When this is extended to multiple    inheritance, the same thing happens, except that multiple virtual    function tables must be maintained.  The first virtual function    table is treated in exactly the same way as in the case of single    inheritance.  Additional virtual function tables have different    DELTAs, which tell how to adjust `this' to point to the right thing.     LIST_OF_FIELDLISTS is just that.  The elements of the list are    TREE_LIST elements, whose TREE_PURPOSE field tells what access    the list has, and the TREE_VALUE slot gives the actual fields.     ATTRIBUTES is the set of decl attributes to be applied, if any.     If flag_all_virtual == 1, then we lay all functions into    the virtual function table, as though they were declared    virtual.  Constructors do not lay down in the virtual function table.     If flag_all_virtual == 2, then we lay all functions into    the virtual function table, such that virtual functions    occupy a space by themselves, and then all functions    of the class occupy a space by themselves.  This is illustrated    in the following diagram:     class A; class B : A;  	Class A's vtbl:			Class B's vtbl:     --------------------------------------------------------------------    | A's virtual functions|		| B's virtual functions		|    |			  |		| (may inherit some from A).	|     --------------------------------------------------------------------    | All of A's functions |		| All of A's functions		|    | (such as a->A::f).	  |		| (such as b->A::f)		|     -------------------------------------------------------------------- 					| B's new virtual functions	| 					| (not defined in A.)		| 					 ------------------------------- 					| All of B's functions		| 					| (such as b->B::f)		| 					 -------------------------------     this allows the program to make references to any function, virtual    or otherwise in a type-consistent manner.  */
end_comment

begin_function
name|tree
name|finish_struct_1
parameter_list|(
name|t
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
name|int
name|old
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|fn_fields
init|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|last_x
decl_stmt|,
name|method_vec
decl_stmt|;
name|int
name|all_virtual
decl_stmt|;
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|tree
name|pending_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|pending_hard_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|cant_have_const_ctor
decl_stmt|;
name|int
name|no_const_asn_ref
decl_stmt|;
comment|/* The index of the first base class which has virtual      functions.  Only applied to non-virtual baseclasses.  */
name|int
name|first_vfn_base_index
decl_stmt|;
name|int
name|n_baseclasses
decl_stmt|;
name|int
name|any_default_members
init|=
literal|0
decl_stmt|;
name|int
name|const_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|ref_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|nonprivate_method
init|=
literal|0
decl_stmt|;
name|tree
name|access_decls
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|aggregate
init|=
literal|1
decl_stmt|;
name|int
name|empty
init|=
literal|1
decl_stmt|;
name|int
name|has_pointers
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|warn_anon
operator|&&
name|code
operator|!=
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"anonymous class type not used to declare any objects"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|172
argument_list|)
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|GNU_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is in general too late to do this.  I moved the main case up to      left_curly, what else needs to move?  */
block|if (! IS_SIGNATURE (t))     {       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);       my_friendly_assert (CLASSTYPE_INTERFACE_KNOWN (t) == ! interface_unknown, 999);     }
endif|#
directive|endif
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* Install struct as DECL_FIELD_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|n_baseclasses
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
name|struct
name|base_info
name|base_info
decl_stmt|;
name|first_vfn_base_index
operator|=
name|finish_base_struct
argument_list|(
name|t
argument_list|,
operator|&
name|base_info
argument_list|)
expr_stmt|;
comment|/* Remember where we got our vfield from.  */
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|t
argument_list|)
operator|=
name|first_vfn_base_index
expr_stmt|;
name|has_virtual
operator|=
name|base_info
operator|.
name|has_virtual
expr_stmt|;
name|max_has_virtual
operator|=
name|base_info
operator|.
name|max_has_virtual
expr_stmt|;
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
name|base_info
operator|.
name|n_ancestors
expr_stmt|;
name|vfield
operator|=
name|base_info
operator|.
name|vfield
expr_stmt|;
name|vfields
operator|=
name|base_info
operator|.
name|vfields
expr_stmt|;
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|base_info
operator|.
name|rtti
expr_stmt|;
name|cant_have_default_ctor
operator|=
name|base_info
operator|.
name|cant_have_default_ctor
expr_stmt|;
name|cant_have_const_ctor
operator|=
name|base_info
operator|.
name|cant_have_const_ctor
expr_stmt|;
name|no_const_asn_ref
operator|=
name|base_info
operator|.
name|no_const_asn_ref
expr_stmt|;
name|aggregate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|first_vfn_base_index
operator|=
operator|-
literal|1
expr_stmt|;
name|has_virtual
operator|=
literal|0
expr_stmt|;
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
name|vfield
operator|=
name|NULL_TREE
expr_stmt|;
name|vfields
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_RTTI
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
name|no_const_asn_ref
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Both of these should be done before now.  */
block|if (write_virtuals == 3&& CLASSTYPE_INTERFACE_KNOWN (t)&& ! IS_SIGNATURE (t))     {       my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);       my_friendly_assert (CLASSTYPE_VTABLE_NEEDS_WRITING (t) == ! interface_only, 999);     }
endif|#
directive|endif
comment|/* The three of these are approximations which may later be      modified.  Needed at this point to make add_virtual_function      and modify_vtable_entries work.  */
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|all_virtual
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_all_virtual
operator|==
literal|1
condition|)
name|all_virtual
operator|=
literal|1
expr_stmt|;
else|else
name|all_virtual
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|nonprivate_method
operator||=
operator|!
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|DECL_CLASS_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Do both of these, even though they're in the same union; 	 if the insn `r' member and the size `i' member are 	 different sizes, as on the alpha, the larger of the two 	 will end up with garbage in it.  */
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|check_for_override
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"initializer specified for non-virtual method `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* The name of the field is the original field name 	 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|all_virtual
operator|==
literal|1
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|add_virtual_function
argument_list|(
operator|&
name|pending_virtuals
argument_list|,
operator|&
name|pending_hard_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Why did I comment this out?  (jason) */
block|else 	    TREE_USED (x) = 1;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|n_baseclasses
condition|)
name|fields
operator|=
name|chainon
argument_list|(
name|build_vbase_pointer_fields
argument_list|(
name|t
argument_list|)
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator||=
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|empty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
comment|/* Save access declarations for later.  */
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|access_decls
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|access_decls
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
continue|continue;
comment|/* If we've gotten this far, it's a data member, possibly static, 	 or an enumerator.  */
name|DECL_FIELD_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* ``A local class cannot have static data members.'' ARM 9.4 */
if|if
condition|(
name|current_function_decl
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"field `%D' in local class cannot be static"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Perform error checking that did not get done in 	 grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared function type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared method type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"field `%D' invalidly declared offset type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (DECL_NAME (x) == constructor_name (t)) 	cant_have_default_ctor = 1;
endif|#
directive|endif
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Unions cannot have static members.  */
name|cp_error_at
argument_list|(
literal|"field `%D' declared static in union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now it can only be a FIELD_DECL.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
condition|)
name|aggregate
operator|=
literal|0
expr_stmt|;
comment|/* If this is of reference type, check if it needs an init. 	 Also do a little ANSI jig if necessary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|ref_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static reference `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"non-static reference in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|has_pointers
operator|=
literal|1
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* ARM $12.6.2: [A member initializer list] (or, for an 	     aggregate, initialization by a brace-enclosed list) is the 	     only way to initialize nonstatic const and reference 	     members.  */
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|cp_warning_at
argument_list|(
literal|"non-static const member `%#D' in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"non-static const member in class without a constructor"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A field that is pseudo-const makes the structure 	     likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t1
argument_list|)
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We set DECL_BIT_FIELD tentatively in grokbitfield. 	 If the type and width are valid, we'll keep it set. 	 Otherwise, the flag is cleared.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Invalid bit-field size done by grokfield.  */
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%#D' with non-integral type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|w
init|=
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|width
init|=
literal|0
decl_stmt|;
comment|/* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */
name|STRIP_NOPS
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* detect invalid field size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|w
operator|=
name|DECL_INITIAL
argument_list|(
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|w
argument_list|)
condition|)
name|w
operator|=
name|decl_constant_value
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|w
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"bit-field `%D' width not an integer constant"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|w
argument_list|)
operator|,
name|width
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"negative width in bit-field `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"zero width for bit-field `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
condition|)
block|{
comment|/* The backend will dump if you try to use something 		     too big; avoid that.  */
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sorry
argument_list|(
literal|"bit-fields larger than %d bits"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  in declaration of `%D'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"width of `%D' exceeds its type"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
operator|(
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|width
operator|)
operator|||
operator|(
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|width
operator|)
operator|)
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"`%D' is too small to hold all values of `%#T'"
argument_list|,
name|x
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|ANON_UNION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Never let anything with uninheritable virtuals 		 make it through without complaint.  */
if|if
condition|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Don't let signatures make it through either.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
name|signature_error
argument_list|(
name|x
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|char
modifier|*
name|fie
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"constructor"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"destructor"
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|fie
operator|=
literal|"copy assignment operator"
expr_stmt|;
if|if
condition|(
name|fie
condition|)
name|cp_error_at
argument_list|(
literal|"member `%#D' with %s not allowed in union"
argument_list|,
name|x
argument_list|,
name|fie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|no_const_asn_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is wrong for aggregates.  */
block|if (! TYPE_HAS_CONSTRUCTOR (t)) 		    { 		      if (DECL_NAME (x)) 			cp_pedwarn_at ("member `%#D' with only non-default constructor", x); 		      else 			cp_pedwarn_at ("member with only non-default constructor", x); 		      cp_pedwarn_at ("in class without a constructor", 				     x); 		    }
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize 		 non-FIELD_DECLs.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|cp_error_at
argument_list|(
literal|"multiple fields in union `%T' initialized"
argument_list|)
expr_stmt|;
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If this type has any constant members which did not come      with their own initialization, mark that fact here.  It is      not an error here, since such types can be saved either by their      constructors, or by fortuitous initialization.  */
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|const_sans_init
expr_stmt|;
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|ref_sans_init
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
comment|/* Synthesize any needed methods.  Note that methods will be synthesized      for anonymous unions; grok_x_components undoes that.  */
if|if
condition|(
operator|!
name|fn_fields
condition|)
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Here we must cons up a destructor on the fly.  */
name|tree
name|dtor
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|check_for_override
argument_list|(
name|dtor
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|dtor
operator|==
name|void_type_node
condition|)
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Link dtor onto end of fn_fields.  */
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|dtor
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
condition|)
name|add_virtual_function
argument_list|(
operator|&
name|pending_virtuals
argument_list|,
operator|&
name|pending_hard_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|dtor
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Effective C++ rule 11.  */
if|if
condition|(
name|has_pointers
operator|&&
name|warn_ecpp
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%#T' has pointer data members"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"  but does not override `%T(const %T&)'"
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"  or `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"  but does not override `operator=(const %T&)'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|has_virtual
operator|||
name|any_default_members
operator|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|has_virtual
operator|||
name|any_default_members
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_NON_AGGREGATE
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|aggregate
operator|||
name|has_virtual
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* ARM $12.1: A default constructor will be generated for a class X      only if no constructor has been declared for class X.  So we      check TYPE_HAS_CONSTRUCTOR also, to make sure we don't generate      one if they declared a constructor in this class.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|cant_have_default_ctor
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
block|}
comment|/* Create default copy constructor, if needed.  */
if|if
condition|(
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* ARM 12.18: You get either X(X&) or X(const X&), but 	 not both.  --Chip  */
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|3
operator|+
name|cant_have_const_ctor
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
block|}
name|TYPE_HAS_REAL_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_REAL_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|5
operator|+
name|no_const_asn_ref
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
block|}
if|if
condition|(
name|fn_fields
condition|)
block|{
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|method_vec
operator|=
name|finish_struct_methods
argument_list|(
name|t
argument_list|,
name|fn_fields
argument_list|,
name|nonprivate_method
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
name|tree
name|ctor
decl_stmt|;
for|for
control|(
name|ctor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|ctor
condition|;
name|ctor
operator|=
name|OVL_NEXT
argument_list|(
name|ctor
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ctor
argument_list|)
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
operator|&&
name|warn_ctor_dtor_privacy
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' only defines private constructors and has no friends"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|method_vec
operator|=
literal|0
expr_stmt|;
comment|/* Just in case these got accidentally 	 filled in by syntax errors.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|access_decls
operator|=
name|nreverse
argument_list|(
name|access_decls
argument_list|)
init|;
name|access_decls
condition|;
name|access_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|access_decls
argument_list|)
control|)
name|handle_using_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|access_decls
argument_list|)
argument_list|,
name|t
argument_list|,
name|method_vec
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfield
operator|==
name|NULL_TREE
operator|&&
name|has_virtual
condition|)
block|{
comment|/* We build this decl with ptr_type_node, and 	 change the type when we know what it should be.  */
name|vfield
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* If you change any of the below, take a look at all the 	 other VFIELD_BASEs and VTABLE_BASEs in the code, and change 	 them too.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|vfield
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|VFIELD_BASE
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|vfield
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|vfield
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|vfield
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is more efficient, but breaks binary compatibility, turn 	 it on sometime when we don't care.  If we turn it on, we also 	 have to enable the code in dfs_init_vbase_pointers.  */
comment|/* vfield is always first entry in structure.  */
block|TREE_CHAIN (vfield) = fields;       fields = vfield;
else|#
directive|else
if|if
condition|(
name|last_x
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|175
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|last_x
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|fields
operator|=
name|vfield
expr_stmt|;
endif|#
directive|endif
name|empty
operator|=
literal|0
expr_stmt|;
name|vfields
operator|=
name|chainon
argument_list|(
name|vfields
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now DECL_INITIAL is null on all members except for zero-width bit-fields.      And they have already done their work.       C++: maybe we will support default field initialization some day...  */
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fields
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|fields
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Delete all such fields from the rest of the fields.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all duplicate fields from the fields */
name|delete_duplicate_fields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Catch function/field name conflict.  We don't need to do this for a      signature, since it can only contain the fields constructed in      append_signature_fields.  */
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|n_methods
init|=
name|method_vec
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
condition|)
continue|continue;
for|for
control|(
init|;
name|i
operator|<
name|n_methods
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|name
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"data member `%#D' conflicts with"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"function member `%#D'"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now we have the final fieldlist for the data fields.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|last_x
operator|=
name|build_base_fields
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If all our bases are empty, we can be empty too.  */
for|for
control|(
name|x
operator|=
name|last_x
init|;
name|empty
operator|&&
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
operator|!=
name|integer_zero_node
condition|)
name|empty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|empty
condition|)
block|{
comment|/* C++: do not let empty structures exist.  */
name|tree
name|decl
init|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|char_type_node
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|fields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|last_x
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Remember the size and alignment of the class before adding      the virtual bases.  */
if|if
condition|(
name|empty
operator|&&
name|flag_new_abi
condition|)
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_new_abi
operator|&&
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|t
argument_list|)
condition|)
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_struct_anon
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
name|layout_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we left lying      around.  We must get these done before we try to lay out the      virtual function table.  */
name|pending_hard_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
comment|/* layout_basetypes will remove the base subobject fields.  */
name|max_has_virtual
operator|=
name|layout_basetypes
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|empty
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|=
name|list_length
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|{
comment|/* Now fixup overrides of all functions in vtables from all 	   direct or indirect virtual base classes.  */
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|merge_overrides
argument_list|(
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vbases
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we      might need to know it for setting up the offsets in the vtable      (or in thunks) below.  */
if|if
condition|(
name|vfield
operator|!=
name|NULL_TREE
operator|&&
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|!=
name|t
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTQUITE
name|cp_warning
argument_list|(
literal|"Doing hard virtuals for %T..."
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|has_virtual
operator|>
name|max_has_virtual
condition|)
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|max_has_virtual
operator|>
literal|0
condition|)
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_rtti
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|pending_hard_virtuals
condition|)
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
while|while
condition|(
name|pending_hard_virtuals
condition|)
block|{
name|modify_all_vtables
argument_list|(
name|t
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
expr_stmt|;
name|pending_hard_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
comment|/* Now fixup any virtual function entries from virtual bases 	 that have different deltas.  This has to come after we do the 	 pending hard virtuals, as we might have a function that comes 	 from multiple virtual base instances that is only overridden 	 by a hard virtual above.  */
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
comment|/* We might be able to shorten the amount of work we do by 	     only doing this for vtables that come from virtual bases 	     that have differing offsets, but don't want to miss any 	     entries.  */
name|fixup_vtable_deltas
argument_list|(
name|vbases
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Under our model of GC, every C++ class gets its own virtual      function table, at least virtually.  */
if|if
condition|(
name|pending_virtuals
condition|)
block|{
name|pending_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
name|first_vfn_base_index
operator|<
literal|0
condition|)
block|{
comment|/* The second slot is for the tdesc pointer when thunks are used.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* The first slot is for the rtti offset.  */
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
name|set_rtti_entry
argument_list|(
name|pending_virtuals
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|build_vtable
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we know enough to change the type of our virtual 	     function table, but we will wait until later this function.  */
if|if
condition|(
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this type has basetypes with constructors, then those 	 constructors might clobber the virtual function table.  But 	 they don't if the derived class shares the exact vtable of the base 	 class.  */
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|first_vfn_base_index
argument_list|)
decl_stmt|;
comment|/* This class contributes nothing new to the virtual function 	 table.  However, it may have declared functions which 	 went into the virtual function table "inherited" from the 	 base class.  If so, we grab a copy of those updated functions, 	 and pretend they are ours.  */
comment|/* See if we should steal the virtual info from base class.  */
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|!=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
condition|)
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|max_has_virtual
operator|||
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pending_virtuals
condition|)
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_virtual
condition|)
block|{
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|pending_virtuals
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now lay out the virtual function table.  */
if|if
condition|(
name|has_virtual
condition|)
block|{
name|tree
name|atype
decl_stmt|,
name|itype
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|==
name|ptr_type_node
condition|)
block|{
comment|/* We must create a pointer to this table because 	     the one inherited from base class does not exist. 	     We will fill in the type when we know what it 	     should really be.  Use `size_int' so values are memoized 	     in common cases.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_virtual
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|atype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We must extend (or create) the boundaries on this array, 		 because we picked up virtual functions from multiple 		 base classes.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|has_virtual
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|atype
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|atype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* At one time the vtable info was grabbed 2 words at a time.  This 	     fails on sparc unless you have 8-byte alignment.  (tiemann) */
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
operator|>=
literal|0
condition|)
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|finish_struct_bits
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Complete the rtl for any static member objects of the type we're      working on.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
block|{
name|DECL_MODE
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
comment|/* Mark the fact that constructor for T 	     could affect anybody inheriting from T 	     who wants to initialize vtables for VFIELDS's type.  */
if|if
condition|(
name|VF_DERIVED_VALUE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_default_members
operator|!=
literal|0
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Write out inline function definitions.  */
name|do_inline_function_hair
argument_list|(
name|t
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This is now done above.  */
block|if (DECL_FIELD_CONTEXT (vfield) != t) 	{ 	  tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0); 	  tree offset = BINFO_OFFSET (binfo);  	  vfield = copy_node (vfield); 	  copy_lang_decl (vfield);  	  if (! integer_zerop (offset)) 	    offset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT)); 	  DECL_FIELD_CONTEXT (vfield) = t; 	  DECL_CLASS_CONTEXT (vfield) = t; 	  DECL_FIELD_BITPOS (vfield) 	    = size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield)); 	  CLASSTYPE_VFIELD (t) = vfield; 	}
endif|#
directive|endif
comment|/* In addition to this one, all the other vfields should be listed.  */
comment|/* Before that can be done, we have to have FIELD_DECLs for them, and 	 a place to find them.  */
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|default_conversion
argument_list|(
name|TYPE_BINFO_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_nonvdtor
operator|&&
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|cp_warning
argument_list|(
literal|"`%#T' has virtual functions but non-virtual destructor"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|finish_vtbls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|hack_incomplete_structures
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TYPE_NAME (t)&& TYPE_IDENTIFIER (t))     undo_template_name_overload (TYPE_IDENTIFIER (t), 1);
endif|#
directive|endif
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_overloaded_virtual
condition|)
name|warn_hidden
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This has to be done after we have sorted out what to do with      the enclosing type.  */
block|if (write_symbols != DWARF_DEBUG)     {
comment|/* Be smarter about nested classes here.  If a type is nested, 	 only output it if we would output the enclosing type.  */
block|if (DECL_CLASS_SCOPE_P (TYPE_MAIN_DECL (t))) 	DECL_IGNORED_P (TYPE_MAIN_DECL (t)) = TREE_ASM_WRITTEN (TYPE_MAIN_DECL (t));     }
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|!=
name|DWARF_DEBUG
operator|&&
name|write_symbols
operator|!=
name|DWARF2_DEBUG
condition|)
block|{
comment|/* If the type has methods, we want to think about cutting down 	 the amount of symbol table stuff we output.  The value stored in 	 the TYPE_DECL's DECL_IGNORED_P slot is a first approximation. 	 For example, if a member function is seen and we decide to 	 write out that member function, then we can change the value 	 of the DECL_IGNORED_P slot, and the type will be output when 	 that member function's debug info is written out.  	 We can't do this with DWARF, which does not support name 	 references between translation units.  */
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
comment|/* Don't output full info about any type 	     which does not have its implementation defined here.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|write_virtuals
operator|==
literal|2
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
operator|(
name|value_member
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX do something about this.  */
block|else if (CLASSTYPE_INTERFACE_UNKNOWN (t))
comment|/* Only a first approximation!  */
block|TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|list_of_fieldlists
parameter_list|,
name|attributes
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|,
name|list_of_fieldlists
decl_stmt|,
name|attributes
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
name|tree
name|fields
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|tail
init|=
operator|&
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|specializations
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|specialization_tail
init|=
operator|&
name|specializations
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|,
name|last_x
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|access
decl_stmt|;
name|tree
name|dummy
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|next_x
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|name
argument_list|)
operator|=
name|input_filename
expr_stmt|;
comment|/* For TYPE_DECL that are not typedefs (those marked with a line 	 number of zero, we don't want to mark them as real typedefs. 	 If this fails one needs to make sure real typedefs have a 	 previous line number, even if it is wrong, that way the below 	 will fill in the right line number.  (mrs) */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
condition|)
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|CLASSTYPE_SOURCE_LINE
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Append the fields we need for constructing signature tables.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
name|append_signature_fields
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* Move our self-reference declaration to the end of the field list so      any real field with the same name takes precedence.  */
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
argument_list|)
condition|)
block|{
name|dummy
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
name|list_of_fieldlists
operator|=
name|TREE_CHAIN
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_x
operator|&&
name|list_of_fieldlists
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_of_fieldlists
condition|)
block|{
name|access
operator|=
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* For signatures, we made all methods `public' in the parser and 	 reported an error if a access specifier was used.  */
if|if
condition|(
name|access
operator|==
name|access_default_node
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|access
operator|=
name|access_public_node
expr_stmt|;
else|else
name|access
operator|=
name|access_private_node
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|next_x
control|)
block|{
name|next_x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|=
name|access
operator|==
name|access_private_node
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
operator|=
name|access
operator|==
name|access_protected_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|TREE_PRIVATE
argument_list|(
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* A name N used in a class S shall refer to the same declaration 	     in its context and when re-evaluated in the completed scope of S.               Enums, types and static vars have already been checked.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|USING_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|icv
decl_stmt|;
comment|/* Don't get confused by access decls.  */
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|icv
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|icv
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|icv
operator|&&
name|flag_optional_diags
comment|/* Don't complain about constructors.  */
operator|&&
name|name
operator|!=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
comment|/* Or inherited names.  */
operator|&&
name|id_in_current_class
argument_list|(
name|name
argument_list|)
comment|/* Or shadowed tags.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|icv
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|icv
argument_list|)
operator|==
name|t
operator|)
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"declaration of identifier `%D' as `%+#D'"
argument_list|,
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"conflicts with other use in class as `%#D'"
argument_list|,
name|icv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|DECL_CLASS_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|last_x
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|next_x
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|x
argument_list|)
condition|)
comment|/* We don't enter the specialization into the class 		   method vector since specializations don't affect 		   overloading.  Instead we keep track of the 		   specializations, and process them after the method 		   vector is complete.  */
block|{
operator|*
name|specialization_tail
operator|=
name|x
expr_stmt|;
name|specialization_tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
comment|/* Link x onto end of TYPE_METHODS.  */
operator|*
name|tail
operator|=
name|x
expr_stmt|;
name|tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|DECL_FIELD_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
name|fields
operator|=
name|x
expr_stmt|;
name|last_x
operator|=
name|x
expr_stmt|;
block|}
name|list_of_fieldlists
operator|=
name|TREE_CHAIN
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* link the tail while we have it! */
if|if
condition|(
name|last_x
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|TREE_CHAIN
argument_list|(
name|last_x
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add the tags, if any, to the list of TYPE_DECLs      defined for this type.  */
if|if
condition|(
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
operator|||
name|dummy
condition|)
block|{
comment|/* The list of tags was built up in pushtag in reverse order; we need 	 to fix that so that enumerators will be processed in forward order 	 in template instantiation.  */
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
operator|=
name|x
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|tree
name|tag_type
init|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|tag
init|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|tag_type
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|tag_type
argument_list|)
condition|)
name|tag
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|tag_type
argument_list|)
expr_stmt|;
name|TREE_NONLOCAL_FLAG
argument_list|(
name|tag_type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|last_x
operator|=
name|chainon
argument_list|(
name|last_x
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dummy
condition|)
name|last_x
operator|=
name|chainon
argument_list|(
name|last_x
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL_TREE
condition|)
name|fields
operator|=
name|last_x
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|tail
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|d
init|=
name|getdecls
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|d
condition|;
name|d
operator|=
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
control|)
block|{
comment|/* If this is the decl for the class or one of the template              parms, we've seen all the injected decls.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
operator|==
name|t
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|CONST_DECL
condition|)
break|break;
comment|/* Don't inject cache decls.  */
elseif|else
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
condition|)
continue|continue;
name|DECL_TEMPLATE_INJECT
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|d
argument_list|,
name|DECL_TEMPLATE_INJECT
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|finish_struct_methods
argument_list|(
name|t
argument_list|,
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
name|t
operator|=
name|finish_struct_1
argument_list|(
name|t
argument_list|,
name|warn_anon
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now, figure out which member templates we're specializing.  */
for|for
control|(
name|x
operator|=
name|specializations
init|;
name|x
operator|!=
name|NULL_TREE
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|spec_args
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|int
name|pending_specialization
decl_stmt|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|t
argument_list|)
condition|)
comment|/* If t is a template class, and x is a specialization, then x 	   is itself really a template.  Due to the vagaries of the 	   parser, however, we will have a handle to a function 	   declaration, rather than the template declaration, at this 	   point.  */
block|{
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|fn
operator|=
name|x
expr_stmt|;
comment|/* We want the specialization arguments, which will be the 	 innermost ones.  */
if|if
condition|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|spec_args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|spec_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pending_specialization
operator|=
name|TI_PENDING_SPECIALIZATION_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|check_explicit_specialization
argument_list|(
name|lookup_template_function
argument_list|(
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
argument_list|,
name|spec_args
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|,
literal|1
operator||
operator|(
literal|8
operator|*
name|pending_specialization
operator|)
argument_list|)
expr_stmt|;
name|TI_PENDING_SPECIALIZATION_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now, the assembler name will be correct for fn, so we 	 make its RTL.  */
name|DECL_RTL
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|fn
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|fn
condition|)
block|{
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|x
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_class_type
condition|)
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"trying to finish struct, but kicked out due to previous parse errors."
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if the effective type of INSTANCE is static.    Used to determine whether the virtual function table is needed    or not.     *NONNULL is set iff INSTANCE can be known to be nonnull, regardless    of our knowledge of its type.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|instance
parameter_list|,
name|nonnull
parameter_list|)
name|tree
name|instance
decl_stmt|;
name|int
modifier|*
name|nonnull
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
comment|/* Check that we are not going through a cast of some sort.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|instance
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fall through...  */
case|case
name|CALL_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|SAVE_EXPR
case|:
comment|/* This is a call to a constructor, hence it's never zero.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|instance
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|RTL_EXPR
case|:
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Propagate nonnull.  */
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|,
name|nonnull
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fall through...  */
case|case
name|TARGET_EXPR
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|nonnull
condition|)
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|nonnull
condition|)
block|{
if|if
condition|(
name|instance
operator|==
name|current_class_ptr
operator|&&
name|flag_this_is_variable
operator|<=
literal|0
condition|)
block|{
comment|/* Some people still use `this = 0' inside destructors.  */
operator|*
name|nonnull
operator|=
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In a constructor, we know our type.  */
if|if
condition|(
name|flag_this_is_variable
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* Reference variables should be references to objects.  */
operator|*
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_class_processing
parameter_list|()
block|{
name|current_class_depth
operator|=
literal|0
expr_stmt|;
name|current_class_stacksize
operator|=
literal|10
expr_stmt|;
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_class_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
expr_stmt|;
name|access_default_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_public_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_protected_node
operator|=
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_private_node
operator|=
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_default_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_public_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_protected_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|access_private_virtual_node
operator|=
name|build_int_2
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep these values lying around.  */
name|base_layout_decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current scope to NAME. CODE tells us if this is a    STRUCT, UNION, or ENUM environment.     NAME may end up being NULL_TREE if this is an anonymous or    late-bound struct (as in "struct { ... } foo;")  */
end_comment

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to    appropriate values, found by looking up the type definition of    NAME (as a CODE).     If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names    which can be seen locally to the class.  They are shadowed by    any subsequent local declaration (including parameter names).     If MODIFY is 2, we set IDENTIFIER_CLASS_VALUE's of names    which have static meaning (i.e., static members, static    member functions, enum declarations, etc).     If MODIFY is 3, we set IDENTIFIER_CLASS_VALUE of names    which can be seen locally to the class (as in 1), but    know that we are doing this for declaration purposes    (i.e. friend foo::bar (int)).     So that we may avoid calls to lookup_name, we cache the _TYPE    nodes of local TYPE_DECLs in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|push_memoized_context
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
name|current_class_depth
operator|++
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_name
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|current_class_stack
operator|>=
name|current_class_base
operator|+
name|current_class_stacksize
condition|)
block|{
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_class_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_class_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
operator|+
name|current_class_stacksize
expr_stmt|;
name|current_class_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|previous_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|type
operator|!=
name|previous_class_type
operator|||
name|TYPE_SIZE
argument_list|(
name|previous_class_type
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|&&
name|current_class_depth
operator|==
literal|1
condition|)
block|{
comment|/* Forcibly remove any old class remnants.  */
name|popclass
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|previous_class_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|pushlevel_class
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if (CLASSTYPE_TEMPLATE_INFO (type))     overload_template_name (type);
endif|#
directive|endif
if|if
condition|(
name|modify
condition|)
block|{
name|tree
name|tags
decl_stmt|;
name|tree
name|this_fndecl
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|current_function_decl
operator|=
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|previous_class_type
operator|||
name|current_class_depth
operator|>
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MI_MATRIX
name|build_mi_matrix
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free_mi_matrix
argument_list|()
expr_stmt|;
else|#
directive|else
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tree
name|item
decl_stmt|;
comment|/* Hooray, we successfully cached; let's just install the 	     cached class_shadowed list, and walk through it to get the 	     IDENTIFIER_TYPE_VALUEs correct.  */
name|set_class_shadows
argument_list|(
name|previous_class_values
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|previous_class_values
init|;
name|item
condition|;
name|item
operator|=
name|TREE_CHAIN
argument_list|(
name|item
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_PURPOSE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|id
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tags
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
init|;
name|tags
condition|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
control|)
block|{
name|tree
name|tag_type
init|=
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
decl_stmt|;
name|TREE_NONLOCAL_FLAG
argument_list|(
name|tag_type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|tag_type
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|tag_type
argument_list|)
operator|)
condition|)
name|pushtag
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|tag_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|tag_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|this_fndecl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  The flag MODIFY tells whether    the current scope declarations needs to be modified as a result of    popping to the previous scope.  0 is used for class definitions.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|(
name|modify
parameter_list|)
name|int
name|modify
decl_stmt|;
block|{
if|if
condition|(
name|modify
operator|<
literal|0
condition|)
block|{
comment|/* Back this old class out completely.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|previous_class_type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* This code can be seen as a cache miss.  When we've cached a 	 class' scope's bindings and we can't use them, we need to reset 	 them.  This is it!  */
for|for
control|(
name|t
operator|=
name|previous_class_values
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|modify
condition|)
block|{
comment|/* Just remove from this class what didn't make 	 it into IDENTIFIER_CLASS_VALUE.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Force clearing of IDENTIFIER_CLASS_VALUEs after a class definition,      since not all class decls make it there currently.  */
name|poplevel_class
argument_list|(
operator|!
name|modify
argument_list|)
expr_stmt|;
comment|/* Since poplevel_class does the popping of class decls nowadays,      this really only frees the obstack used for these decls.      That's why it had to be moved down here.  */
if|if
condition|(
name|modify
condition|)
name|pop_class_decls
argument_list|()
expr_stmt|;
name|current_class_depth
operator|--
expr_stmt|;
name|current_class_type
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
name|current_class_name
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
name|pop_memoized_context
argument_list|(
name|modify
argument_list|)
expr_stmt|;
name|ret
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if current_class_type is either T or a nested type of T.  */
end_comment

begin_function
name|int
name|currently_open_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|current_class_type
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_class_depth
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|current_class_stack
index|[
operator|-
name|i
operator|*
literal|2
operator|-
literal|1
index|]
operator|==
name|t
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When entering a class scope, all enclosing class scopes' names with    static meaning (static variables, static functions, types and enumerators)    have to be visible.  This recursive function calls pushclass for all    enclosing class contexts until global or a local scope is reached.    TYPE is the enclosed class and MODIFY is equivalent with the pushclass    formal of the same name.  */
end_comment

begin_function
name|void
name|push_nested_class
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|NAMESPACE_DECL
argument_list|,
literal|980711
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
return|return;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|push_nested_class
argument_list|(
name|context
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undoes a push_nested_class call.  MODIFY is passed on to popclass.  */
end_comment

begin_function
name|void
name|pop_nested_class
parameter_list|(
name|modify
parameter_list|)
name|int
name|modify
decl_stmt|;
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|popclass
argument_list|(
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|pop_nested_class
argument_list|(
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangling machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
operator|*
name|current_lang_stack
operator|++
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|current_lang_stack
operator|>=
name|current_lang_base
operator|+
name|current_lang_stacksize
condition|)
block|{
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_lang_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_lang_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|+
name|current_lang_stacksize
expr_stmt|;
name|current_lang_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
operator|||
name|name
operator|==
name|lang_name_java
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|()
block|{
name|current_lang_name
operator|=
operator|*
operator|--
name|current_lang_stack
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|||
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_function
specifier|static
name|tree
name|validate_lhs
parameter_list|(
name|lhstype
parameter_list|,
name|complain
parameter_list|)
name|tree
name|lhstype
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
condition|)
name|lhstype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid type combination for overload"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|lhstype
return|;
block|}
end_function

begin_comment
comment|/* This function will instantiate the type of the expression given in    RHS to match the type of LHSTYPE.  If errors exist, then return    error_mark_node.  If only complain is COMPLAIN is set.  If we are    not complaining, never modify rhs, as overload resolution wants to    try many possible instantiations, in hopes that at least one will    work.     This function is used in build_modify_expr, convert_arguments,    build_c_cast, and compute_conversion_costs.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|lhstype
parameter_list|,
name|rhs
parameter_list|,
name|complain
parameter_list|)
name|tree
name|lhstype
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"argument of type `%T' does not match `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We don't overwrite rhs if it is an overloaded function.      Copying it would destroy the tree link.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|rhs
operator|=
name|copy_node
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmetic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|my_friendly_abort
argument_list|(
literal|177
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|new_rhs
decl_stmt|;
name|new_rhs
operator|=
name|instantiate_type
argument_list|(
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|new_rhs
expr_stmt|;
return|return
name|rhs
return|;
block|}
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|function
init|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|field
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|185
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|tree
name|base
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|base_ptr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|base_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_vfn_ref
argument_list|(
operator|&
name|base_ptr
argument_list|,
name|base
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
comment|/* I could not trigger this code. MvL */
name|my_friendly_abort
argument_list|(
literal|980326
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|my_friendly_assert (TREE_CODE (field) == FIELD_DECL, 178); 	my_friendly_assert (!(TREE_CODE (TREE_TYPE (field)) == FUNCTION_TYPE 			      || TREE_CODE (TREE_TYPE (field)) == METHOD_TYPE), 			    179);  	TREE_TYPE (rhs) = lhstype;
comment|/* First look for an exact match  */
block|while (field&& TREE_TYPE (field) != lhstype) 	  field = DECL_CHAIN (field); 	if (field) 	  { 	    TREE_OPERAND (rhs, 1) = field; 	    mark_used (field); 	    return rhs; 	  }
comment|/* No exact match found, look for a compatible function.  */
block|field = TREE_OPERAND (rhs, 1); 	while (field&& ! comptypes (lhstype, TREE_TYPE (field), 0)) 	  field = DECL_CHAIN (field); 	if (field) 	  { 	    TREE_OPERAND (rhs, 1) = field; 	    field = DECL_CHAIN (field); 	    while (field&& ! comptypes (lhstype, TREE_TYPE (field), 0)) 	      field = DECL_CHAIN (field); 	    if (field) 	      { 		if (complain) 		  error ("ambiguous overload for COMPONENT_REF requested"); 		return error_mark_node; 	      } 	  } 	else 	  { 	    if (complain) 	      error ("no appropriate overload exists for COMPONENT_REF"); 	    return error_mark_node; 	  }
endif|#
directive|endif
return|return
name|rhs
return|;
block|}
case|case
name|OFFSET_REF
case|:
comment|/* This can happen if we are forming a pointer-to-member for a 	 member template.  */
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|template_only
operator|=
literal|1
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* fall through */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OVERLOAD
argument_list|,
literal|980401
argument_list|)
expr_stmt|;
case|case
name|OVERLOAD
case|:
block|{
name|tree
name|elem
decl_stmt|,
name|elems
decl_stmt|;
comment|/* Check that the LHSTYPE and the RHS are reasonable.  */
name|lhstype
operator|=
name|validate_lhs
argument_list|(
name|lhstype
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhstype
operator|==
name|error_mark_node
condition|)
return|return
name|lhstype
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"cannot resolve overloaded function `%D' "
literal|"based on non-function type"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look for an exact match, by searching through the 	   overloaded functions.  */
if|if
condition|(
name|template_only
condition|)
comment|/* If we're processing a template-id, only a template 	     function can match, so we don't look through the 	     overloaded functions.  */
empty_stmt|;
else|else
for|for
control|(
name|elems
operator|=
name|rhs
init|;
name|elems
condition|;
name|elems
operator|=
name|OVL_CHAIN
argument_list|(
name|elems
argument_list|)
control|)
block|{
name|elem
operator|=
name|OVL_FUNCTION
argument_list|(
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mark_used
argument_list|(
name|elem
argument_list|)
expr_stmt|;
return|return
name|elem
return|;
block|}
block|}
comment|/* No overloaded function was an exact match.  See if we can 	   instantiate some template to match.  */
block|{
name|tree
name|save_elem
init|=
literal|0
decl_stmt|;
name|elems
operator|=
name|rhs
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elems
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|elems
operator|=
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elems
condition|;
name|elems
operator|=
name|OVL_NEXT
argument_list|(
name|elems
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elem
operator|=
name|OVL_CURRENT
argument_list|(
name|elems
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|int
name|n
init|=
name|DECL_NTPARMS
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|make_scratch_vec
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|type_unification
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|elem
argument_list|)
argument_list|,
name|t
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|explicit_targs
argument_list|,
name|DEDUCE_EXACT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|save_elem
condition|)
block|{
name|cp_error
argument_list|(
literal|"ambiguous template instantiation converting to `%#T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|save_elem
operator|=
name|instantiate_template
argument_list|(
name|elem
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Check the return type.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|save_elem
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|save_elem
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_elem
condition|)
block|{
name|mark_used
argument_list|(
name|save_elem
argument_list|)
expr_stmt|;
return|return
name|save_elem
return|;
block|}
block|}
comment|/* There's no exact match, and no templates can be 	   instantiated to match.  The last thing we try is to see if 	   some ordinary overloaded function is close enough.  If 	   we're only looking for template functions, we don't do 	   this.  */
if|if
condition|(
operator|!
name|template_only
condition|)
block|{
for|for
control|(
name|elems
operator|=
name|rhs
init|;
name|elems
condition|;
name|elems
operator|=
name|OVL_NEXT
argument_list|(
name|elems
argument_list|)
control|)
block|{
name|elem
operator|=
name|OVL_CURRENT
argument_list|(
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|elems
condition|)
block|{
name|tree
name|save_elem
init|=
name|elem
decl_stmt|;
for|for
control|(
name|elems
operator|=
name|OVL_CHAIN
argument_list|(
name|elems
argument_list|)
init|;
name|elems
condition|;
name|elems
operator|=
name|OVL_CHAIN
argument_list|(
name|elems
argument_list|)
control|)
block|{
name|elem
operator|=
name|OVL_FUNCTION
argument_list|(
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|elems
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot resolve overload to target type `%#T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  ambiguity between `%#D'"
argument_list|,
name|save_elem
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  and `%#D', at least"
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|mark_used
argument_list|(
name|save_elem
argument_list|)
expr_stmt|;
return|return
name|save_elem
return|;
block|}
block|}
comment|/* We failed to find a match.  */
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot resolve overload to target type `%#T'"
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  because no suitable overload of function `%D' exists"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|elem
decl_stmt|,
name|baselink
decl_stmt|,
name|name
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Make sure we don't drop the non-local flag, as the old code 	       would rely on it. */
name|int
name|nl
init|=
name|TREE_NONLOCAL_FLAG
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
comment|/* We don't need the type of this node. */
name|rhs
operator|=
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_NONLOCAL_FLAG
argument_list|(
name|rhs
argument_list|)
operator|==
name|nl
argument_list|,
literal|980331
argument_list|)
expr_stmt|;
block|}
comment|/* Now we should have a baselink. */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|980331
argument_list|)
expr_stmt|;
comment|/* First look for an exact match.  Search member functions. 	   May have to undo what `default_conversion' might do to 	   lhstype.  */
name|lhstype
operator|=
name|validate_lhs
argument_list|(
name|lhstype
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhstype
operator|==
name|error_mark_node
condition|)
return|return
name|lhstype
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|181
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|OVERLOAD
argument_list|,
literal|182
argument_list|)
expr_stmt|;
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mark_used
argument_list|(
name|OVL_CURRENT
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|OVL_CURRENT
argument_list|(
name|elem
argument_list|)
return|;
block|}
else|else
name|elem
operator|=
name|OVL_NEXT
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
comment|/* No exact match found, look for a compatible method.  */
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elem
condition|;
name|elem
operator|=
name|OVL_NEXT
argument_list|(
name|elem
argument_list|)
control|)
if|if
condition|(
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|OVL_CURRENT
argument_list|(
name|elem
argument_list|)
decl_stmt|;
for|for
control|(
name|elem
operator|=
name|OVL_NEXT
argument_list|(
name|elem
argument_list|)
init|;
name|elem
condition|;
name|elem
operator|=
name|OVL_NEXT
argument_list|(
name|elem
argument_list|)
control|)
if|if
condition|(
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for overloaded method requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|mark_used
argument_list|(
name|save_elem
argument_list|)
expr_stmt|;
return|return
name|save_elem
return|;
block|}
name|name
operator|=
name|rhs
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|name
operator|=
name|TREE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (lhstype) == FUNCTION_TYPE&& globals< 0) 	      {
comment|/* Try to instantiate from non-member functions.  */
block|rhs = lookup_name_nonclass (name); 		if (rhs&& TREE_CODE (rhs) == TREE_LIST) 		  {
comment|/* This code seems to be missing a `return'.  */
block|my_friendly_abort (4); 		    instantiate_type (lhstype, rhs, complain); 		  } 	      }
endif|#
directive|endif
block|}
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"no compatible member functions named `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|my_friendly_abort
argument_list|(
literal|183
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|lhstype
argument_list|)
condition|)
name|lhstype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"type for resolving address of overloaded function must be pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|{
name|tree
name|fn
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|mark_addressable
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|fn
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
operator|=
name|staticp
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|build_ptrmemfunc_type
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build_ptrmemfunc
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rhs
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|my_friendly_abort
argument_list|(
literal|184
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|185
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"build_method_call = %d (inner = %d)\n"
argument_list|,
name|n_build_method_call
argument_list|,
name|n_inner_fields_searched
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Push an obstack which is sufficiently long-lived to hold such class    decls that may be cached in the previous_class_values list.  For now, let's    use the permanent obstack, later we may create a dedicated obstack just    for this purpose.  The effect is undone by pop_obstacks.  */
end_comment

begin_function
name|void
name|maybe_push_cache_obstack
parameter_list|()
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_class_depth
operator|==
literal|1
condition|)
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a dummy reference to ourselves so Derived::Base (and A::A) works,    according to [class]:                                           The class-name is also inserted    into  the scope of the class itself.  For purposes of access checking,    the inserted class name is treated as if it were a public member name.  */
end_comment

begin_function
name|tree
name|build_self_reference
parameter_list|()
block|{
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|build_lang_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
decl_stmt|;
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE contains only padding bytes.  */
end_comment

begin_function
name|int
name|is_empty_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_new_abi
condition|)
return|return
name|CLASSTYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|integer_zero_node
return|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|==
name|NULL_TREE
operator|)
return|;
block|}
end_function

end_unit

