begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|obstack
parameter_list|,
name|tp
parameter_list|,
name|size
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Sony NewsOS 5.0 compiler doesn't like void * here.  */
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
operator|-
name|size
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_abstract_virtuals_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|next_baselink
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vbase_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_pointer_to_vbase
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_pointer_to_single_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_fnfields_here
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_subobject_of_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|virtual_context
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_check_overlap
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_no_overlap_yet
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_base_distance_recursive
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_upcast_fixups
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_virtual_upcast_offsets
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unmarkedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|marked_vtable_pathp
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unmarked_vtable_pathp
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|marked_new_vtablep
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unmarked_new_vtablep
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|marked_pushdecls_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unmarked_pushdecls_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_debug_unmarkedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_debug_mark
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_find_vbases
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_clear_vbase_slots
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_init_vbase_pointers
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_get_vbase_types
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_push_type_decls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_push_decls
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_unuse_fields
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_conversions
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_virtuals_named_this
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_virtual_destructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tree_has_any_destructor_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|covariant_return_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|bfs_walk
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_queue_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_r
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_walk_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_bfv_queue_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_bfv_helper
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_virtuals_named_this_r
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|context_for_name_lookup
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|canonical_binfo
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|shared_marked_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|shared_unmarked_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dependent_base_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_accessible_queue_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_accessible_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_access_in_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|access_in_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_canonical_queue
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_assert_unmarked_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assert_canonical_unmarked
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|protected_accessible_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|friend_accessible_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_class_bindings
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_self_reference_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
parameter_list|(
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|obstack
decl_stmt|;
block|{
specifier|register
name|struct
name|search_level
modifier|*
name|stack
init|=
name|pop_stack_level
argument_list|(
name|obstack
argument_list|)
decl_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|tree
name|_vptr_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GATHER_STATISTICS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get a virtual binfo that is found inside BINFO's hierarchy that is    the same type as the type given in PARENT.  To be optimal, we want    the first one that is found by going through the least number of    virtual bases.     This uses a clever algorithm that updates *depth when we find the vbase,    and cuts off other paths of search when they reach that depth.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vbase_1
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|depth
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|unsigned
name|int
modifier|*
name|depth
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
operator|*
name|depth
operator|=
literal|0
expr_stmt|;
return|return
name|binfo
return|;
block|}
operator|*
name|depth
operator|=
operator|*
name|depth
operator|-
literal|1
expr_stmt|;
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|nrval
decl_stmt|;
if|if
condition|(
operator|*
name|depth
operator|==
literal|0
condition|)
break|break;
name|nrval
operator|=
name|get_vbase_1
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrval
condition|)
name|rval
operator|=
name|nrval
expr_stmt|;
block|}
operator|*
name|depth
operator|=
operator|*
name|depth
operator|+
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Return the shortest path to vbase PARENT within BINFO, ignoring    access and ambiguity.  */
end_comment

begin_function
name|tree
name|get_vbase
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|parent
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|unsigned
name|int
name|d
init|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
decl_stmt|;
return|return
name|get_vbase_1
argument_list|(
name|parent
argument_list|,
name|binfo
argument_list|,
operator|&
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to a virtual base class of type TYPE.  We know that    EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that    the type of what expr points to has a virtual base of type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_pointer_to_vbase
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|vb
init|=
name|get_vbase
argument_list|(
name|type
argument_list|,
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|convert_pointer_to_real
argument_list|(
name|vb
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether the type given in BINFO is derived from PARENT.  If    it isn't, return 0.  If it is, but the derivation is MI-ambiguous    AND protect != 0, emit an error message and return error_mark_node.     Otherwise, if TYPE is derived from PARENT, return the actual base    information, unless a one of the protection violations below    occurs, in which case emit an error message and return error_mark_node.     If PROTECT is 1, then check if access to a public field of PARENT    would be private.  Also check for ambiguity.  */
end_comment

begin_function
name|tree
name|get_binfo
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|dist
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|parent
operator|=
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|89
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|binfo
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|90
argument_list|)
expr_stmt|;
name|dist
operator|=
name|get_base_distance
argument_list|(
name|parent
argument_list|,
name|binfo
argument_list|,
name|protect
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|==
operator|-
literal|3
condition|)
block|{
name|cp_error
argument_list|(
literal|"fields of `%T' are inaccessible in `%T' due to private inheritance"
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|dist
operator|==
operator|-
literal|2
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' is ambiguous base class for type `%T'"
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* This is the newer depth first get_base_distance routine.  */
end_comment

begin_function
specifier|static
name|int
name|get_base_distance_recursive
parameter_list|(
name|binfo
parameter_list|,
name|depth
parameter_list|,
name|is_private
parameter_list|,
name|rval
parameter_list|,
name|rval_private_ptr
parameter_list|,
name|new_binfo_ptr
parameter_list|,
name|parent
parameter_list|,
name|protect
parameter_list|,
name|via_virtual_ptr
parameter_list|,
name|via_virtual
parameter_list|,
name|current_scope_in_chain
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|is_private
decl_stmt|,
name|rval
decl_stmt|;
name|int
modifier|*
name|rval_private_ptr
decl_stmt|;
name|tree
modifier|*
name|new_binfo_ptr
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|protect
decl_stmt|,
decl|*
name|via_virtual_ptr
decl_stmt|,
name|via_virtual
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|current_scope_in_chain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
if|if
condition|(
name|protect
operator|&&
operator|!
name|current_scope_in_chain
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
name|current_scope_in_chain
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
operator|||
name|binfo
operator|==
name|parent
condition|)
block|{
name|int
name|better
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
comment|/* This is the first time we've found parent.  */
name|better
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
operator|*
name|new_binfo_ptr
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|*
name|via_virtual_ptr
operator|&&
name|via_virtual
condition|)
block|{
comment|/* A new path to the same vbase.  If this one has better 	     access or is shorter, take it.  */
if|if
condition|(
name|protect
condition|)
name|better
operator|=
operator|*
name|rval_private_ptr
operator|-
name|is_private
expr_stmt|;
if|if
condition|(
name|better
operator|==
literal|0
condition|)
name|better
operator|=
name|rval
operator|-
name|depth
expr_stmt|;
block|}
else|else
block|{
comment|/* Ambiguous base class.  */
name|rval
operator|=
name|depth
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* If we get an ambiguity between virtual and non-virtual base 	     class, return the non-virtual in case we are ignoring 	     ambiguity.  */
name|better
operator|=
operator|*
name|via_virtual_ptr
operator|-
name|via_virtual
expr_stmt|;
block|}
if|if
condition|(
name|better
operator|>
literal|0
condition|)
block|{
name|rval
operator|=
name|depth
expr_stmt|;
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
name|depth
operator|+=
literal|1
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|via_private
init|=
operator|(
name|protect
operator|&&
operator|(
name|is_private
operator|||
operator|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|current_scope_in_chain
operator|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|this_virtual
init|=
name|via_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|rval
operator|=
name|get_base_distance_recursive
argument_list|(
name|base_binfo
argument_list|,
name|depth
argument_list|,
name|via_private
argument_list|,
name|rval
argument_list|,
name|rval_private_ptr
argument_list|,
name|new_binfo_ptr
argument_list|,
name|parent
argument_list|,
name|protect
argument_list|,
name|via_virtual_ptr
argument_list|,
name|this_virtual
argument_list|,
name|current_scope_in_chain
argument_list|)
expr_stmt|;
comment|/* If we've found a non-virtual, ambiguous base class, we don't need 	 to keep searching.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
operator|&&
operator|*
name|via_virtual_ptr
operator|==
literal|0
condition|)
return|return
name|rval
return|;
block|}
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Return the number of levels between type PARENT and the type given    in BINFO, following the leftmost path to PARENT not found along a    virtual path, if there are no real PARENTs (all come from virtual    base classes), then follow the shortest public path to PARENT.     Return -1 if TYPE is not derived from PARENT.    Return -2 if PARENT is an ambiguous base class of TYPE, and PROTECT is     non-negative.    Return -3 if PARENT is private to TYPE, and PROTECT is non-zero.     If PATH_PTR is non-NULL, then also build the list of types    from PARENT to TYPE, with TREE_VIA_VIRTUAL and TREE_VIA_PUBLIC    set.     PARENT can also be a binfo, in which case that exact parent is found    and no other.  convert_pointer_to_real uses this functionality.     If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.  */
end_comment

begin_function
name|int
name|get_base_distance
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|,
name|path_ptr
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
name|tree
modifier|*
name|path_ptr
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|new_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|via_virtual
decl_stmt|;
name|int
name|watch_access
init|=
name|protect
decl_stmt|;
comment|/* Should we be completing types here?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|parent
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|complete_type
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|type
operator|||
name|parent
operator|==
name|binfo
condition|)
block|{
comment|/* If the distance is 0, then we don't really need 	 a path pointer, but we shouldn't let garbage go back.  */
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|binfo
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|path_ptr
condition|)
name|watch_access
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|get_base_distance_recursive
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|rval_private
argument_list|,
operator|&
name|new_binfo
argument_list|,
name|parent
argument_list|,
name|watch_access
argument_list|,
operator|&
name|via_virtual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Access restrictions don't count if we found an ambiguous basetype.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
operator|&&
name|protect
operator|>=
literal|0
condition|)
name|rval_private
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
return|return
operator|-
literal|3
return|;
comment|/* If they gave us the real vbase binfo, which isn't in the main binfo      tree, deal with it.  This happens when we are called from      expand_upcast_fixups.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|parent
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|parent
argument_list|)
operator|==
name|binfo
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
name|new_binfo
operator|=
name|parent
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|new_binfo
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance lattice    specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return the FIELD_DECL.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller must    figure out whether it can access this field.  (Since it is only one    level, this is reasonable.)  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
comment|/* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM are not fields at all;        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,        the code often worked even when we treated the index as a list        of fields!)  */
return|return
name|NULL_TREE
return|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
while|while
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|USING_DECL
condition|)
comment|/* For now, we're just treating member using declarations as 	   old ARM-style access declarations.  Thus, there's no reason 	   to return a USING_DECL, and the rest of the compiler can't 	   handle it.  Once the class is defined, these are purged 	   from TYPE_FIELDS anyhow; see handle_using_decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|field
return|;
block|}
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|_vptr_name
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* There are a number of cases we need to be aware of here: 			 current_class_type	current_function_decl      global			NULL			NULL      fn-local			NULL			SET      class-local		SET			NULL      class->fn			SET			SET      fn->class			SET			SET     Those last two make life interesting.  If we're in a function which is    itself inside a class, we need decls to go into the fn's decls (our    second case below).  But if we're in a class and the class itself is    inside a function, we need decls to go into the decls for the class.  To    achieve this last goal, we must see if, when both current_class_ptr and    current_function_decl are set, the class was declared inside that    function.  If so, we know to put the decls into the class's scope.  */
end_comment

begin_function
name|tree
name|current_scope
parameter_list|()
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|current_class_type
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
name|current_function_decl
return|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|current_function_decl
return|;
return|return
name|current_class_type
return|;
block|}
end_function

begin_comment
comment|/* Return the scope of DECL, as appropriate when doing name-lookup.  */
end_comment

begin_function
specifier|static
name|tree
name|context_for_name_lookup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* [class.union]            For the purposes of name lookup, after the anonymous union      definition, the members of the anonymous union are considered to      have been defined in the scope in which teh anonymous union is      declared.  */
name|tree
name|context
init|=
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Return a canonical BINFO if BINFO is a virtual base, or just BINFO    otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|canonical_binfo
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
operator|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|?
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
else|:
name|binfo
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A queue function that simply ensures that we walk into the    canonical versions of virtual bases.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_canonical_queue
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from assert_canonical_unmarked.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_assert_unmarked_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Asserts that all the nodes below BINFO (using the canonical    versions of virtual bases) are unmarked.  */
end_comment

begin_function
specifier|static
name|void
name|assert_canonical_unmarked
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_assert_unmarked_p
argument_list|,
name|dfs_canonical_queue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If BINFO is marked, return a canonical version of BINFO.    Otherwise, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|shared_marked_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|binfo
operator|=
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|markedp
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If BINFO is not marked, return a canonical version of BINFO.    Otherwise, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|shared_unmarked_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|binfo
operator|=
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|unmarkedp
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called from access_in_type via dfs_walk.  Calculate the access to    DATA (which is really a DECL) in BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_access_in_type
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|access
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
operator|==
name|type
condition|)
block|{
comment|/* If we have desceneded to the scope of DECL, just note the 	 appropriate access.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|access_private_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|access
operator|=
name|access_public_node
expr_stmt|;
block|}
else|else
block|{
comment|/* First, check for an access-declaration that gives us more 	 access to the DECL.  The CONST_DECL for an enumeration 	 constant will not have DECL_LANG_SPECIFIC, and thus no 	 DECL_ACCESS.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|access
operator|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_ACCESS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
condition|)
name|access
operator|=
name|TREE_VALUE
argument_list|(
name|access
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|access
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
comment|/* Otherwise, scan our baseclasses, and pick the most favorable 	     access.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_access
init|=
name|TREE_CHAIN
argument_list|(
name|canonical_binfo
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|base_access
operator|||
name|base_access
operator|==
name|access_private_node
condition|)
comment|/* If it was not accessible in the base, or only 		   accessible as a private member, we can't access it 		   all.  */
name|base_access
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* Public and protected members in the base are 		   protected here.  */
name|base_access
operator|=
name|access_protected_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* Public and protected members in the base are 		   private here.  */
name|base_access
operator|=
name|access_private_node
expr_stmt|;
comment|/* See if the new access, via this base, gives more 		 access than our previous best access.  */
if|if
condition|(
name|base_access
operator|&&
operator|(
name|base_access
operator|==
name|access_public_node
operator|||
operator|(
name|base_access
operator|==
name|access_protected_node
operator|&&
name|access
operator|!=
name|access_public_node
operator|)
operator|||
operator|(
name|base_access
operator|==
name|access_private_node
operator|&&
operator|!
name|access
operator|)
operator|)
condition|)
block|{
name|access
operator|=
name|base_access
expr_stmt|;
comment|/* If the new access is public, we can't do better.  */
if|if
condition|(
name|access
operator|==
name|access_public_node
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/* Note the access to DECL in TYPE.  */
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|=
name|access
expr_stmt|;
comment|/* Mark TYPE as visited so that if we reach it again we do not      duplicate our efforts here.  */
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the access to DECL in TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|access_in_type
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We must take into account         [class.paths]         If a name can be reached by several paths through a multiple        inheritance graph, the access is that of the path that gives        most access.        The algorithm we use is to make a post-order depth-first traversal     of the base-class hierarchy.  As we come up the tree, we annotate     each node with the most lenient access.  */
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
name|dfs_access_in_type
argument_list|,
name|shared_unmarked_p
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|shared_marked_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert_canonical_unmarked
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from dfs_accessible_p via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this class is inherited via private or protected inheritance,      then we can't see it, unless we are a friend of the subclass.  */
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from dfs_accessible_p via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|protected_ok
init|=
name|data
operator|!=
literal|0
decl_stmt|;
name|tree
name|access
decl_stmt|;
comment|/* We marked the binfos while computing the access in each type.      So, we unmark as we go now.  */
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|access
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_public_node
operator|||
operator|(
name|access
operator|==
name|access_protected_node
operator|&&
name|protected_ok
operator|)
condition|)
return|return
name|binfo
return|;
elseif|else
if|if
condition|(
name|access
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
return|return
name|binfo
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if it is OK to access DECL when named in TYPE    through an object indiated by BINFO in the context of DERIVED.  */
end_comment

begin_function
specifier|static
name|int
name|protected_accessible_p
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|,
name|derived
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|derived
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|access
decl_stmt|;
comment|/* We're checking this clause from [class.access.base]         m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected.        If DERIVED isn't derived from TYPE, then it certainly does not     apply.  */
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|type
argument_list|,
name|derived
argument_list|)
condition|)
return|return
literal|0
return|;
name|access
operator|=
name|access_in_type
argument_list|(
name|derived
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|derived
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
operator|!=
name|access_private_node
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|access
operator|!=
name|access_private_node
operator|&&
name|access
operator|!=
name|access_protected_node
condition|)
return|return
literal|0
return|;
comment|/* [class.protected]       When a friend or a member function of a derived class references      a protected nonstatic member of a base class, an access check      applies in addition to those described earlier in clause      _class.access_.4) Except when forming a pointer to member      (_expr.unary.op_), the access must be through a pointer to,      reference to, or object of the derived class itself (or any class      derived from that class) (_expr.ref_).  If the access is to form      a pointer to member, the nested-name-specifier shall name the      derived class (or any class derived from that class).  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We can tell through what the reference is occurring by 	 chasing BINFO up to the root.  */
name|tree
name|t
init|=
name|binfo
decl_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|derived
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if SCOPE is a friend of a type which would be able    to acces DECL, named in TYPE, through the object indicated by    BINFO.  */
end_comment

begin_function
specifier|static
name|int
name|friend_accessible_p
parameter_list|(
name|scope
parameter_list|,
name|type
parameter_list|,
name|decl
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|befriending_classes
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|scope
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|befriending_classes
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* Perhaps this SCOPE is a member of a class which is a  	 friend.  */
if|if
condition|(
name|friend_accessible_p
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|scope
argument_list|)
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Or an instantiation of something which is a friend.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|friend_accessible_p
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|friend_accessible_p
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DECL is a declaration from a base class of TYPE, which was the    classs used to name DECL.  Return non-zero if, in the current    context, DECL is accessible.  If TYPE is actually a BINFO node,    then we can tell in what context the access is occurring by looking    at the most derived class along the path indicated by BINFO.  */
end_comment

begin_function
name|int
name|accessible_p
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Non-zero if it's OK to access DECL if it has protected      accessibility in TYPE.  */
name|int
name|protected_ok
init|=
literal|0
decl_stmt|;
comment|/* If we're not checking access, everything is accessible.  */
if|if
condition|(
operator|!
name|flag_access_control
condition|)
return|return
literal|1
return|;
comment|/* If this declaration is in a block or namespace scope, there's no      access control.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We don't do access control for types yet.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* [class.access.base]       A member m is accessible when named in class N if       --m as a member of N is public, or       --m as a member of N is private, and the reference occurs in a        member or friend of class N, or       --m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected, or       --there exists a base class B of N that is accessible at the point        of reference, and m is accessible when named in class B.        We walk the base class hierarchy, checking these conditions.  */
comment|/* Figure out where the reference is occurring.  Check to see if      DECL is private or protected in this scope, since that will      determine whether protected access in TYPE allowed.  */
if|if
condition|(
name|current_class_type
condition|)
name|protected_ok
operator|=
name|protected_accessible_p
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
name|current_class_type
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Now, loop through the classes of which we are a friend.  */
if|if
condition|(
operator|!
name|protected_ok
condition|)
name|protected_ok
operator|=
name|friend_accessible_p
argument_list|(
name|current_scope
argument_list|()
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Standardize on the same that will access_in_type will use.  We      don't need to know what path was chosen from this point onwards.  */
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the accessibility of DECL in the class hierarchy      dominated by type.  */
name|access_in_type
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Walk the hierarchy again, looking for a base class that allows      access.  */
name|t
operator|=
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_accessible_p
argument_list|,
name|dfs_accessible_queue_p
argument_list|,
name|protected_ok
condition|?
operator|&
name|protected_ok
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear any mark bits.  Note that we have to walk the whole tree      here, since we have aborted the previous walk from some point      deep in the tree.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_canonical_queue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert_canonical_unmarked
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|t
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Routine to see if the sub-object denoted by the binfo PARENT can be    found as a base class and sub-object of the object denoted by    BINFO.  This routine relies upon binfos not being shared, except    for binfos for virtual bases.  */
end_comment

begin_function
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
comment|/* We want to canonicalize for comparison purposes.  But, when we      iterate through basetypes later, we want the binfos from the      original hierarchy.  That's why we have to calculate BINFOS      first, and then canonicalize.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|parent
operator|=
name|canonical_binfo
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|binfo
condition|)
return|return
literal|1
return|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
comment|/* If we see a TEMPLATE_TYPE_PARM, or some such, as a base 	   class there's no way to descend into it.  */
continue|continue;
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See if a one FIELD_DECL hides another.  This routine is meant to    correspond to ANSI working paper Sept 17, 1992 10p4.  The two    binfos given are the binfos corresponding to the particular places    the FIELD_DECLs are found.  This routine relies upon binfos not    being shared, except for virtual bases.  */
end_comment

begin_function
specifier|static
name|int
name|hides
parameter_list|(
name|hider_binfo
parameter_list|,
name|hidee_binfo
parameter_list|)
name|tree
name|hider_binfo
decl_stmt|,
name|hidee_binfo
decl_stmt|;
block|{
comment|/* hider hides hidee, if hider has hidee as a base class and      the instance of hidee is a sub-object of hider.  The first      part is always true is the second part is true.       When hider and hidee are the same (two ways to get to the exact      same member) we consider either one as hiding the other.  */
return|return
name|is_subobject_of_p
argument_list|(
name|hidee_binfo
argument_list|,
name|hider_binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Very similar to lookup_fnfields_1 but it ensures that at least one    function was declared inside the class given by TYPE.  It really should    only return functions that match the given TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_here
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|int
name|idx
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|tree
name|fndecls
decl_stmt|;
comment|/* ctors and dtors are always only in the right class.  */
if|if
condition|(
name|idx
operator|<=
literal|1
condition|)
return|return
name|idx
return|;
name|fndecls
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecls
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|idx
return|;
name|fndecls
operator|=
name|OVL_CHAIN
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|lookup_field_info
block|{
comment|/* The type in which we're looking.  */
name|tree
name|type
decl_stmt|;
comment|/* The name of the field for which we're looking.  */
name|tree
name|name
decl_stmt|;
comment|/* If non-NULL, the current result of the lookup.  */
name|tree
name|rval
decl_stmt|;
comment|/* The path to RVAL.  */
name|tree
name|rval_binfo
decl_stmt|;
comment|/* If non-NULL, the lookup was ambiguous, and this is a list of the      candidates.  */
name|tree
name|ambiguous
decl_stmt|;
comment|/* If non-zero, we are looking for types, not data members.  */
name|int
name|want_type
decl_stmt|;
comment|/* If non-zero, RVAL was found by looking through a dependent base.  */
name|int
name|from_dep_base_p
decl_stmt|;
comment|/* If something went wrong, a message indicating what.  */
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Returns non-zero if BINFO is not hidden by the value found by the    lookup so far.  If BINFO is hidden, then there's no need to look in    it.  DATA is really a struct lookup_field_info.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Don't look for constructors or destructors in base classes.  */
if|if
condition|(
name|lfi
operator|->
name|name
operator|==
name|ctor_identifier
operator|||
name|lfi
operator|->
name|name
operator|==
name|dtor_identifier
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this base class is hidden by the best-known value so far, we      don't need to look.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|from_dep_base_p
operator|&&
name|lfi
operator|->
name|rval_binfo
operator|&&
name|hides
argument_list|(
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|lfi
operator|->
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class, you can refer to the    particular to the current specialization with the name of the    template itself.  For example:          template<typename T> struct S { S* sp; }     Returns non-zero if DECL is such a declaration in a class TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|template_self_reference_p
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* DATA is really a struct lookup_field_info.  Look for a field with    the name indicated there in BINFO.  If this function returns a    non-NULL value it is the result of the lookup.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_r
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|nval
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|from_dep_base_p
decl_stmt|;
comment|/* First, look for a function.  There can't be a function and a data      member with the same name, and if there's a function and a type      with the same name, the type is hidden by the function.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|want_type
condition|)
block|{
name|int
name|idx
init|=
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nval
condition|)
comment|/* Look for a data member or type.  */
name|nval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If there is no declaration with the indicated name in this type,      then there's nothing to do.  */
if|if
condition|(
operator|!
name|nval
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we're looking up a type (as with an elaborated type specifier)      we ignore all non-types we find.  */
if|if
condition|(
name|lfi
operator|->
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|nval
operator|=
name|purpose_member
argument_list|(
name|lfi
operator|->
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
condition|)
name|nval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|nval
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
block|}
comment|/* You must name a template base class with a template-id.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|nval
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|from_dep_base_p
operator|=
name|dependent_base_p
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfi
operator|->
name|from_dep_base_p
operator|&&
operator|!
name|from_dep_base_p
condition|)
block|{
comment|/* If the new declaration is not found via a dependent base, and 	 the old one was, then we must prefer the new one.  We weren't 	 really supposed to be able to find the old one, so we don't 	 want to be affected by a specialization.  Consider:  	   struct B { typedef int I; }; 	   template<typename T> struct D1 : virtual public B {};  	   template<typename T> struct D : 	   public D1, virtual pubic B { I i; };  	 The `I' in `D<T>' is unambigousuly `B::I', regardless of how 	 D1 is specialized.  */
name|lfi
operator|->
name|from_dep_base_p
operator|=
literal|0
expr_stmt|;
name|lfi
operator|->
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|lfi
operator|->
name|rval_binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|lfi
operator|->
name|ambiguous
operator|=
name|NULL_TREE
expr_stmt|;
name|lfi
operator|->
name|errstr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|lfi
operator|->
name|from_dep_base_p
operator|&&
name|from_dep_base_p
condition|)
comment|/* Similarly, if the old declaration was not found via a dependent        base, and the new one is, ignore the new one.  */
return|return
name|NULL_TREE
return|;
comment|/* If the lookup already found a match, and the new value doesn't      hide the old one, we might have an ambiguity.  */
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|hides
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|rval_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|nval
operator|==
name|lfi
operator|->
name|rval
operator|&&
name|SHARED_MEMBER_P
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* The two things are really the same.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|hides
argument_list|(
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|binfo
argument_list|)
condition|)
comment|/* The previous value hides the new one.  */
empty_stmt|;
else|else
block|{
comment|/* We have a real ambiguity.  We keep a chain of all the 	     candidates.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|ambiguous
operator|&&
name|lfi
operator|->
name|rval
condition|)
block|{
comment|/* This is the first time we noticed an ambiguity.  Add 		 what we previously thought was a reasonable candidate 		 to the list.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lfi
operator|->
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add the new value.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|nval
argument_list|,
name|lfi
operator|->
name|ambiguous
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|lfi
operator|->
name|errstr
operator|=
literal|"request for member `%D' is ambiguous"
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the thing we're looking for is a virtual base class, then 	 we know we've got what we want at this point; there's no way 	 to get an ambiguity.  */
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|lfi
operator|->
name|name
argument_list|)
condition|)
block|{
name|lfi
operator|->
name|rval
operator|=
name|nval
expr_stmt|;
return|return
name|nval
return|;
block|}
if|if
condition|(
name|from_dep_base_p
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
comment|/* We need to return a member template class so we can 	     define partial specializations.  Is there a better 	     way?  */
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* The thing we're looking for isn't a type, so the implicit 	   typename extension doesn't apply, so we just pretend we 	   didn't find anything.  */
return|return
name|NULL_TREE
return|;
name|lfi
operator|->
name|rval
operator|=
name|nval
expr_stmt|;
name|lfi
operator|->
name|from_dep_base_p
operator|=
name|from_dep_base_p
expr_stmt|;
name|lfi
operator|->
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look for a memer named NAME in an inheritance lattice dominated by    XBASETYPE.  PROTECT is 0 or two, we do not check access.  If it is    1, we enforce accessibility.  If PROTECT is zero, then, for an    ambiguous lookup, we return NULL.  If PROTECT is 1, we issue an    error message.  If PROTECT is 2, we return a TREE_LIST whose    TREEE_TYPE is error_mark_node and whose TREE_VALUEs are the list of    ambiguous candidates.     WANT_TYPE is 1 when we should only return TYPE_DECLs, if no    TYPE_DECL can be found return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_member
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|basetype_path
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|lookup_field_info
name|lfi
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just non-function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      non-function member is found.  */
specifier|const
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|xbasetype
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|xbasetype
argument_list|)
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|field
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
condition|)
comment|/* We're in the scope of this class, and the value has already 	   been looked up.  Just return the cached value.  */
return|return
name|field
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|xbasetype
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|97
argument_list|)
expr_stmt|;
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|bzero
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lfi
argument_list|,
sizeof|sizeof
argument_list|(
name|lfi
argument_list|)
argument_list|)
expr_stmt|;
name|lfi
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|lfi
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|lfi
operator|.
name|want_type
operator|=
name|want_type
expr_stmt|;
name|bfs_walk
argument_list|(
name|basetype_path
argument_list|,
operator|&
name|lookup_field_r
argument_list|,
operator|&
name|lookup_field_queue_p
argument_list|,
operator|&
name|lfi
argument_list|)
expr_stmt|;
name|rval
operator|=
name|lfi
operator|.
name|rval
expr_stmt|;
name|rval_binfo
operator|=
name|lfi
operator|.
name|rval_binfo
expr_stmt|;
if|if
condition|(
name|rval_binfo
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|rval_binfo
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|lfi
operator|.
name|errstr
expr_stmt|;
comment|/* If we are not interested in ambiguities, don't report them;      just return NULL_TREE.  */
if|if
condition|(
operator|!
name|protect
operator|&&
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|protect
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|lfi
operator|.
name|ambiguous
return|;
else|else
name|protect
operator|=
literal|0
expr_stmt|;
block|}
comment|/* [class.access]       In the case of overloaded function names, access control is      applied to the function selected by overloaded resolution.  */
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE_POINTER
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|rval
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|rval
argument_list|)
argument_list|)
operator|&&
operator|!
name|enforce_access
argument_list|(
name|xbasetype
argument_list|,
name|rval
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
name|print_candidates
argument_list|(
name|lfi
operator|.
name|ambiguous
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If the thing we found was found via the implicit typename      extension, build the typename type.  */
if|if
condition|(
name|rval
operator|&&
name|lfi
operator|.
name|from_dep_base_p
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|rval
argument_list|)
condition|)
name|rval
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|build_typename_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
condition|)
block|{
name|rval
operator|=
name|scratch_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_BASELINK_P
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
name|want_type
argument_list|)
decl_stmt|;
comment|/* Ignore functions.  */
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a non-function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
comment|/*want_type=*/
literal|0
argument_list|)
decl_stmt|;
comment|/* Ignore non-functions.  */
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
name|int
name|lookup_fnfields_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|method_vec
init|=
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
comment|/* Constructors are first...  */
if|if
condition|(
operator|*
name|methods
operator|&&
name|name
operator|==
name|ctor_identifier
condition|)
return|return
literal|0
return|;
comment|/* and destructors are second.  */
if|if
condition|(
operator|*
operator|++
name|methods
operator|&&
name|name
operator|==
name|dtor_identifier
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
operator|&&
operator|*
name|methods
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|==
name|name
condition|)
break|break;
block|}
comment|/* If we didn't find it, it might have been a template 	 conversion operator.  (Note that we don't look for this case 	 above so that we will always find specializations first.)  */
if|if
condition|(
operator|(
name|methods
operator|==
name|end
operator|||
operator|!
operator|*
name|methods
operator|)
operator|&&
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
operator|&&
operator|*
name|methods
condition|)
block|{
name|tree
name|method_name
init|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|method_name
argument_list|)
condition|)
block|{
comment|/* Since all conversion operators come first, we know 		     there is no such operator.  */
name|methods
operator|=
name|end
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|methods
operator|!=
name|end
operator|&&
operator|*
name|methods
condition|)
return|return
name|methods
operator|-
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the class hierarchy dominated by TYPE.  FN is called for each    type in the hierarchy, in a breadth-first preorder traversal.  .    If it ever returns a non-NULL value, that value is immediately    returned and the walk is terminated.  At each node FN, is passed a    BINFO indicating the path from the curently visited base-class to    TYPE.  The TREE_CHAINs of the BINFOs may be used for scratch space;    they are otherwise unused.  Before each base-class is walked QFN is    called.  If the value returned is non-zero, the base-class is    walked; otherwise it is not.  If QFN is NULL, it is treated as a    function which always returns 1.  Both FN and QFN are passed the    DATA whenever they are called.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|bfs_walk
parameter_list|(
name|binfo
parameter_list|,
name|fn
parameter_list|,
name|qfn
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|size_t
name|head
decl_stmt|;
name|size_t
name|tail
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* An array of the base classes of BINFO.  These will be built up in      breadth-first order, except where QFN prunes the search.  */
name|varray_type
name|bfs_bases
decl_stmt|;
comment|/* Start with enough room for ten base classes.  That will be enough      for most hierarchies.  */
name|VARRAY_TREE_INIT
argument_list|(
name|bfs_bases
argument_list|,
literal|10
argument_list|,
literal|"search_stack"
argument_list|)
expr_stmt|;
comment|/* Put the first type into the stack.  */
name|VARRAY_TREE
argument_list|(
name|bfs_bases
argument_list|,
literal|0
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|tail
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|head
operator|=
literal|0
init|;
name|head
operator|<
name|tail
condition|;
operator|++
name|head
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
comment|/* Pull the next type out of the queue.  */
name|binfo
operator|=
name|VARRAY_TREE
argument_list|(
name|bfs_bases
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* If this is the one we're looking for, we're done.  */
name|rval
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
break|break;
comment|/* Queue up the base types.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfn
condition|)
name|base_binfo
operator|=
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
block|{
if|if
condition|(
name|tail
operator|==
name|VARRAY_SIZE
argument_list|(
name|bfs_bases
argument_list|)
condition|)
name|VARRAY_GROW
argument_list|(
name|bfs_bases
argument_list|,
literal|2
operator|*
name|VARRAY_SIZE
argument_list|(
name|bfs_bases
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_TREE
argument_list|(
name|bfs_bases
argument_list|,
name|tail
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
operator|++
name|tail
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean up.  */
name|VARRAY_FREE
argument_list|(
name|bfs_bases
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Exactly like bfs_walk, except that a depth-first traversal is    performed, and PREFN is called in preorder, while POSTFN is called    in postorder.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|dfs_walk_real
parameter_list|(
name|binfo
parameter_list|,
name|prefn
parameter_list|,
name|postfn
parameter_list|,
name|qfn
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*prefn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*postfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Call the pre-order walking function.  */
if|if
condition|(
name|prefn
condition|)
block|{
name|rval
operator|=
call|(
modifier|*
name|prefn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
comment|/* Process the basetypes.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfn
condition|)
name|base_binfo
operator|=
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
block|{
name|rval
operator|=
name|dfs_walk_real
argument_list|(
name|base_binfo
argument_list|,
name|prefn
argument_list|,
name|postfn
argument_list|,
name|qfn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
block|}
comment|/* Call the post-order walking function.  */
if|if
condition|(
name|postfn
condition|)
name|rval
operator|=
call|(
modifier|*
name|postfn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Exactly like bfs_walk, except that a depth-first post-order traversal is    performed.  */
end_comment

begin_function_decl
name|tree
name|dfs_walk
parameter_list|(
name|binfo
parameter_list|,
name|fn
parameter_list|,
name|qfn
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|,
name|data
argument_list|)
return|;
block|}
end_block

begin_struct
struct|struct
name|gvnt_info
block|{
comment|/* The name of the function we are looking for.  */
name|tree
name|name
decl_stmt|;
comment|/* The overloaded functions we have found.  */
name|tree
name|fields
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called from get_virtuals_named_this via bfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|get_virtuals_named_this_r
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|gvnt_info
modifier|*
name|gvnti
init|=
operator|(
expr|struct
name|gvnt_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|lookup_fnfields_here
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|gvnti
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|gvnti
operator|->
name|fields
operator|=
name|scratch_tree_cons
argument_list|(
name|binfo
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
argument_list|,
name|gvnti
operator|->
name|fields
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the virtual functions with the indicated NAME in the type    indicated by BINFO.  The result is a TREE_LIST whose TREE_PURPOSE    indicates the base class from which the TREE_VALUE (an OVERLOAD or    just a FUNCTION_DECL) originated.  */
end_comment

begin_function
specifier|static
name|tree
name|get_virtuals_named_this
parameter_list|(
name|binfo
parameter_list|,
name|name
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|struct
name|gvnt_info
name|gvnti
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|gvnti
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|gvnti
operator|.
name|fields
operator|=
name|NULL_TREE
expr_stmt|;
name|bfs_walk
argument_list|(
name|binfo
argument_list|,
name|get_virtuals_named_this_r
argument_list|,
literal|0
argument_list|,
operator|&
name|gvnti
argument_list|)
expr_stmt|;
comment|/* Get to the function decls, and return the first virtual function      with this name, if there is one.  */
for|for
control|(
name|fields
operator|=
name|gvnti
operator|.
name|fields
init|;
name|fields
condition|;
name|fields
operator|=
name|next_baselink
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|fndecl
decl_stmt|;
for|for
control|(
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|OVL_NEXT
argument_list|(
name|fndecl
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
name|fields
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_virtual_destructor
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|tree_has_any_destructor_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
return|return
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns> 0 if a function with type DRETTYPE overriding a function    with type BRETTYPE is covariant, as defined in [class.virtual].     Returns 1 if trivial covariance, 2 if non-trivial (requiring runtime    adjustment), or -1 if pedantically invalid covariance.  */
end_comment

begin_function
specifier|static
name|int
name|covariant_return_p
parameter_list|(
name|brettype
parameter_list|,
name|drettype
parameter_list|)
name|tree
name|brettype
decl_stmt|,
name|drettype
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|THUNK_DECL
condition|)
block|{
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|drettype
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TYPE_QUALS
argument_list|(
name|brettype
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|drettype
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|can_convert
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
return|return
literal|0
return|;
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
expr_stmt|;
comment|/* If not pedantic, allow any standard pointer conversion.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|drettype
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|brettype
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|binfo
operator|=
name|get_binfo
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we get an error_mark_node from get_binfo, it already complained,      so let's just succeed.  */
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a class type TYPE, and a function decl FNDECL, look for a    virtual function in TYPE's hierarchy which FNDECL could match as a    virtual function.  It doesn't matter which one we find.     DTORP is nonzero if we are looking for a destructor.  Destructors    need special treatment because they do not match by name.  */
end_comment

begin_function
name|tree
name|get_matching_virtual
parameter_list|(
name|binfo
parameter_list|,
name|fndecl
parameter_list|,
name|dtorp
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|dtorp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* In [temp.mem] we have:           A specialization of a member function template does not          override a virtual function from a base class.  */
return|return
name|NULL_TREE
return|;
comment|/* Breadth first search routines start searching basetypes      of TYPE, so we must perform first ply of search here.  */
if|if
condition|(
name|dtorp
condition|)
return|return
name|bfs_walk
argument_list|(
name|binfo
argument_list|,
name|get_virtual_destructor
argument_list|,
name|tree_has_any_destructor_p
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|drettype
decl_stmt|,
name|dtypes
decl_stmt|,
name|btypes
decl_stmt|,
name|instptr_type
decl_stmt|;
name|tree
name|basetype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|baselink
decl_stmt|,
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|declarator
init|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|baselink
operator|=
name|get_virtuals_named_this
argument_list|(
name|binfo
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
if|if
condition|(
name|baselink
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|dtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|instptr_type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|instptr_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|dtypes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|tree
name|tmps
decl_stmt|;
for|for
control|(
name|tmps
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
init|;
name|tmps
condition|;
name|tmps
operator|=
name|OVL_NEXT
argument_list|(
name|tmps
argument_list|)
control|)
block|{
name|tmp
operator|=
name|OVL_CURRENT
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_VINDEX
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
name|btypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instptr_type
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|)
condition|)
comment|/* Caller knows to give error in this case.  */
return|return
name|tmp
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
comment|/* The first parameter is the `this' parameter, 		     which has POINTER_TYPE, and we can therefore 		     safely use TYPE_QUALS, rather than 		     CP_TYPE_QUALS.  */
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|btypes
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|instptr_type
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|dtypes
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|brettype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|covariant_return_p
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|sorry
argument_list|(
literal|"adjusting pointers for covariant returns"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"invalid covariant return type for `%#D' (must be pointer or reference to class)"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_2
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
operator|&&
name|same_or_base_type_p
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid covariant return type (must use pointer or reference)"
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  with `%#D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"conflicting return type specified for virtual function `%#D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding definition as `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* FNDECL overrides this function.  We continue to 		     check all the other functions in order to catch 		     errors; it might be that in some other baseclass 		     a virtual function was declared with the same 		     parameter types, but a different return type.  */
name|best
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
return|return
name|best
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type    TYPE that come from non virtual base classes.  See    expand_direct_vtbls_init for the style of search we do.  */
end_comment

begin_function
specifier|static
name|tree
name|get_abstract_virtuals_1
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|abstract_virtuals
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|abstract_virtuals
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|get_abstract_virtuals_1
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|abstract_virtuals
return|;
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type TYPE.    This information is cached, and so must be built on a    non-temporary obstack.  */
end_comment

begin_function
name|tree
name|get_abstract_virtuals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|NULL
decl_stmt|;
comment|/* First get all from non-virtual bases.  */
name|abstract_virtuals
operator|=
name|get_abstract_virtuals_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|,
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%#D' needs a final overrider"
argument_list|,
name|base_fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|abstract_virtuals
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|next_baselink
parameter_list|(
name|baselink
parameter_list|)
name|tree
name|baselink
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|baselink
operator|=
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
comment|/* @@ does not yet add previous base types.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|baselink
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|baselink
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* This routine converts a pointer to be a pointer of an immediate    base class.  The normal convert_pointer_to routine would diagnose    the conversion as ambiguous, under MI code that has the base class    as an ambiguous base class.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_pointer_to_single_level
parameter_list|(
name|to_type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|to_type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|derived
decl_stmt|;
name|tree
name|binfo_of_derived
decl_stmt|;
name|int
name|i
decl_stmt|;
name|derived
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|binfo_of_derived
operator|=
name|TYPE_BINFO
argument_list|(
name|derived
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo_of_derived
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|derived
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|binfo_of_derived
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|==
name|binfo_of_derived
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|to_type
argument_list|)
condition|)
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|expr
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|19990607
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|markedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|!
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|marked_new_vtablep
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmarked_new_vtablep
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|!
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|marked_pushdecls_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmarked_pushdecls_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|!
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int dfs_search_slot_nonempty_p (binfo) tree binfo; { return CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) != 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|tree
name|dfs_debug_unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dfs_mark (binfo) tree binfo; { SET_BINFO_MARKED (binfo); }
endif|#
directive|endif
end_endif

begin_function
name|tree
name|dfs_unmark
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dfs_mark_vtable_path (binfo) tree binfo; { SET_BINFO_VTABLE_PATH_MARKED (binfo); }  static void dfs_unmark_vtable_path (binfo) tree binfo; { CLEAR_BINFO_VTABLE_PATH_MARKED (binfo); }  static void dfs_mark_new_vtable (binfo) tree binfo; { SET_BINFO_NEW_VTABLE_MARKED (binfo); }  static void dfs_unmark_new_vtable (binfo) tree binfo; { CLEAR_BINFO_NEW_VTABLE_MARKED (binfo); }  static void dfs_clear_search_slot (binfo) tree binfo; { CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|tree
name|dfs_debug_mark
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* Use heuristic that if there are virtual functions,      ignore until we see a non-inline virtual function.  */
name|tree
name|methods
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|methods
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If interface info is known, either we've already emitted the debug      info or we don't need to.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If debug info is requested from this context for this type, supply it.      If debug info is requested from another context for this type,      see if some third context can supply it.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|t
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
condition|)
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
condition|)
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|methods
operator|=
name|OVL_CURRENT
argument_list|(
name|methods
argument_list|)
expr_stmt|;
while|while
condition|(
name|methods
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|&&
name|DECL_THIS_INLINE
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Somebody, somewhere is going to have to define this 		 virtual function.  When they do, they will provide 		 the debugging info.  */
return|return
name|NULL_TREE
return|;
block|}
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We cannot rely on some alien method to solve our problems,      so we must write out the debug info ourselves.  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|vbase_info
block|{
name|tree
name|decl_ptr
decl_stmt|;
name|tree
name|inits
decl_stmt|;
name|tree
name|vbase_types
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  Attach to the type of the virtual base class, the pointer to the     virtual base class.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_find_vbases
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|vbase_info
modifier|*
name|vi
init|=
operator|(
expr|struct
name|vbase_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vbase
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_member
argument_list|(
name|vbase
argument_list|,
name|vi
operator|->
name|vbase_types
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|vbase
argument_list|)
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|vi
operator|->
name|decl_ptr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|dfs_init_vbase_pointers
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|vbase_info
modifier|*
name|vi
init|=
operator|(
expr|struct
name|vbase_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|this_vbase_ptr
decl_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See finish_struct_1 for when we can enable this.  */
comment|/* If we have a vtable pointer first, skip it.  */
block|if (VFIELD_NAME_P (DECL_NAME (fields)))     fields = TREE_CHAIN (fields);
endif|#
directive|endif
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|this_vbase_ptr
operator|=
name|TREE_CHAIN
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|this_vbase_ptr
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|this_vbase_ptr
operator|=
name|convert_pointer_to_single_level
argument_list|(
name|type
argument_list|,
name|this_vbase_ptr
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|=
name|this_vbase_ptr
expr_stmt|;
block|}
else|else
name|this_vbase_ptr
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_vbase_ptr
argument_list|)
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|125
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
operator|&&
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ref
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|this_vbase_ptr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|vi
operator|->
name|inits
operator|=
name|tree_cons
argument_list|(
name|binfo_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|vi
operator|->
name|vbase_types
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vi
operator|->
name|inits
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other    times, just NEW_VTABLE, but optimizer should make both with equal    efficiency (though it does not currently).  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_clear_vbase_slots
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|init_vbase_pointers
parameter_list|(
name|type
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl_ptr
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|vbase_info
name|vi
decl_stmt|;
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|flag_this_is_variable
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Find all the virtual base classes, marking them for later 	 initialization.  */
name|vi
operator|.
name|decl_ptr
operator|=
name|decl_ptr
expr_stmt|;
name|vi
operator|.
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vi
operator|.
name|inits
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_vtable_pathp
argument_list|,
operator|&
name|vi
argument_list|)
expr_stmt|;
comment|/* Build up a list of the initializers.  */
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|=
name|decl_ptr
expr_stmt|;
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
name|dfs_init_vbase_pointers
argument_list|,
literal|0
argument_list|,
name|marked_vtable_pathp
argument_list|,
operator|&
name|vi
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
return|return
name|vi
operator|.
name|inits
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get the virtual context (the vbase that directly contains the    DECL_CLASS_CONTEXT of the FNDECL) that the given FNDECL is declared in,    or NULL_TREE if there is none.     FNDECL must come from a virtual table from a virtual base to ensure that    there is only one possible DECL_CLASS_CONTEXT.     We know that if there is more than one place (binfo) the fndecl that the    declared, they all refer to the same binfo.  See get_class_offset_1 for    the check that ensures this.  */
end_comment

begin_function
specifier|static
name|tree
name|virtual_context
parameter_list|(
name|fndecl
parameter_list|,
name|t
parameter_list|,
name|vbase
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|t
decl_stmt|,
name|vbase
decl_stmt|;
block|{
name|tree
name|path
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* DECL_CLASS_CONTEXT can be ambiguous in t.  */
if|if
condition|(
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|vbase
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|path
condition|)
block|{
comment|/* Not sure if checking path == vbase is necessary here, but just in 		 case it is.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
operator|||
name|path
operator|==
name|vbase
condition|)
return|return
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This shouldn't happen, I don't want errors! */
name|warning
argument_list|(
literal|"recoverable compiler error, fixups for virtual function"
argument_list|)
expr_stmt|;
return|return
name|vbase
return|;
block|}
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fixups upcast offsets for one vtable.    Entries may stay within the VBASE given, or    they may upcast into a direct base, or    they may upcast into a different vbase.     We only need to do fixups in case 2 and 3.  In case 2, we add in    the virtual base offset to effect an upcast, in case 3, we add in    the virtual base offset to effect an upcast, then subtract out the    offset for the other virtual base, to effect a downcast into it.     This routine mirrors fixup_vtable_deltas in functionality, though    this one is runtime based, and the other is compile time based.    Conceivably that routine could be removed entirely, and all fixups    done at runtime.     VBASE_OFFSETS is an association list of virtual bases that contains    offset information for the virtual bases, so the offsets are only    calculated once.  The offsets are computed by where we think the    vbase should be (as noted by the CLASSTYPE_SEARCH_SLOT) minus where    the vbase really is.  */
end_comment

begin_function
specifier|static
name|void
name|expand_upcast_fixups
parameter_list|(
name|binfo
parameter_list|,
name|addr
parameter_list|,
name|orig_addr
parameter_list|,
name|vbase
parameter_list|,
name|vbase_addr
parameter_list|,
name|t
parameter_list|,
name|vbase_offsets
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|addr
decl_stmt|,
name|orig_addr
decl_stmt|,
name|vbase
decl_stmt|,
name|vbase_addr
decl_stmt|,
name|t
decl_stmt|,
decl|*
name|vbase_offsets
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|vc
decl_stmt|;
name|tree
name|delta
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|delta
operator|=
name|purpose_member
argument_list|(
name|vbase
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
block|{
name|delta
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|,
name|vbase_addr
argument_list|)
expr_stmt|;
name|delta
operator|=
name|save_expr
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|=
name|tree_cons
argument_list|(
name|vbase
argument_list|,
name|delta
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
expr_stmt|;
operator|*
name|vbase_offsets
operator|=
name|delta
expr_stmt|;
block|}
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|current_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|current_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|current_fndecl
argument_list|)
expr_stmt|;
name|current_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|current_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_fndecl
operator|&&
name|current_fndecl
operator|!=
name|abort_fndecl
operator|&&
operator|(
name|vc
operator|=
name|virtual_context
argument_list|(
name|current_fndecl
argument_list|,
name|t
argument_list|,
name|vbase
argument_list|)
operator|)
operator|!=
name|vbase
condition|)
block|{
comment|/* This may in fact need a runtime fixup.  */
name|tree
name|idx
init|=
name|build_int_2
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|vtbl
init|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|nvtbl
init|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|vtbl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|aref
decl_stmt|,
name|ref
decl_stmt|,
name|naref
decl_stmt|;
name|tree
name|old_delta
decl_stmt|,
name|new_delta
decl_stmt|;
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|nvtbl
operator|==
name|NULL_TREE
operator|||
name|nvtbl
operator|==
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|vtbl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Dup it if it isn't in local scope yet.  */
name|nvtbl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|nvtbl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|nvtbl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|nvtbl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|nvtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nvtbl
operator|=
name|pushdecl
argument_list|(
name|nvtbl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|nvtbl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
comment|/* We don't set DECL_VIRTUAL_P and DECL_CONTEXT on nvtbl 		 because they wouldn't be useful; everything that wants to 		 look at the vtable will look at the decl for the normal 		 vtable.  Setting DECL_CONTEXT also screws up 		 decl_function_context.  */
name|init
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|nvtbl
argument_list|)
argument_list|,
name|nvtbl
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Update the vtable pointers as necessary.  */
name|ref
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|nvtbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|naref
operator|=
name|build_array_ref
argument_list|(
name|nvtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|old_delta
operator|=
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_delta
operator|=
name|build_component_ref
argument_list|(
name|naref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a upcast, so we have to add the offset for the 	     virtual base.  */
name|old_delta
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|old_delta
argument_list|,
name|TREE_VALUE
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
condition|)
block|{
comment|/* If this is set, we need to subtract out the delta 		 adjustments for the other virtual base that we 		 downcast into.  */
name|tree
name|vc_delta
init|=
name|purpose_member
argument_list|(
name|vc
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vc_delta
condition|)
block|{
name|tree
name|vc_addr
init|=
name|convert_pointer_to_real
argument_list|(
name|vc
argument_list|,
name|orig_addr
argument_list|)
decl_stmt|;
name|vc_delta
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vc
argument_list|)
argument_list|)
expr_stmt|;
name|vc_delta
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|vc_delta
argument_list|,
name|vc_addr
argument_list|)
expr_stmt|;
name|vc_delta
operator|=
name|save_expr
argument_list|(
name|vc_delta
argument_list|)
expr_stmt|;
operator|*
name|vbase_offsets
operator|=
name|tree_cons
argument_list|(
name|vc
argument_list|,
name|vc_delta
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
expr_stmt|;
block|}
else|else
name|vc_delta
operator|=
name|TREE_VALUE
argument_list|(
name|vc_delta
argument_list|)
expr_stmt|;
comment|/* This is a downcast, so we have to subtract the offset 		 for the virtual base.  */
name|old_delta
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|old_delta
argument_list|,
name|vc_delta
argument_list|)
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|new_delta
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_delta
argument_list|)
operator|=
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_delta
argument_list|)
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_delta
argument_list|)
argument_list|)
operator|&
operator|~
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|new_delta
argument_list|,
name|NOP_EXPR
argument_list|,
name|old_delta
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Fixup upcast offsets for all direct vtables.  Patterned after    expand_direct_vtbls_init.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_virtual_upcast_offsets
parameter_list|(
name|real_binfo
parameter_list|,
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|can_elide
parameter_list|,
name|addr
parameter_list|,
name|orig_addr
parameter_list|,
name|type
parameter_list|,
name|vbase
parameter_list|,
name|vbase_offsets
parameter_list|)
name|tree
name|real_binfo
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|init_self
decl_stmt|,
name|can_elide
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|orig_addr
decl_stmt|,
name|type
decl_stmt|,
name|vbase
decl_stmt|,
decl|*
name|vbase_offsets
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|real_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|real_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|real_binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|real_binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|real_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|real_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|real_base_binfo
argument_list|)
condition|)
name|fixup_virtual_upcast_offsets
argument_list|(
name|real_base_binfo
argument_list|,
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|can_elide
argument_list|,
name|addr
argument_list|,
name|orig_addr
argument_list|,
name|type
argument_list|,
name|vbase
argument_list|,
name|vbase_offsets
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Before turning this on, make sure it is correct.  */
block|if (can_elide&& ! BINFO_MODIFIED (binfo))     return;
endif|#
directive|endif
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|new_addr
init|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|expand_upcast_fixups
argument_list|(
name|real_binfo
argument_list|,
name|new_addr
argument_list|,
name|orig_addr
argument_list|,
name|vbase
argument_list|,
name|addr
argument_list|,
name|type
argument_list|,
name|vbase_offsets
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Build a COMPOUND_EXPR which when expanded will generate the code    needed to initialize all the virtual function table slots of all    the virtual baseclasses.  MAIN_BINFO is the binfo which determines    the virtual baseclasses to use; TYPE is the type of the object to    which the initialization applies.  TRUE_EXP is the true object we    are initializing, and DECL_PTR is the pointer to the sub-object we    are initializing.     When USE_COMPUTED_OFFSETS is non-zero, we can assume that the    object was laid out by a top-level constructor and the computed    offsets are valid to store vtables.  When zero, we must store new    vtables through virtual baseclass pointers.  */
end_comment

begin_function
name|void
name|expand_indirect_vtbls_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|decl_ptr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* This function executes during the finish_function() segment,      AFTER the auto variables and temporary stack space has been marked      unused...If space is needed for the virtual function tables,      some of them might fit within what the compiler now thinks      are available stack slots... These values are actually initialized at      the beginnning of the function, so when the automatics use their space,      they will overwrite the values that are placed here. Marking all      temporary space as unavailable prevents this from happening. */
name|mark_all_temps_used
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|rtx
name|fixup_insns
init|=
name|NULL_RTX
decl_stmt|;
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|vbase_info
name|vi
decl_stmt|;
name|vi
operator|.
name|decl_ptr
operator|=
operator|(
name|true_exp
condition|?
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|true_exp
argument_list|,
literal|0
argument_list|)
else|:
name|decl_ptr
operator|)
expr_stmt|;
name|vi
operator|.
name|vbase_types
operator|=
name|vbases
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_new_vtablep
argument_list|,
operator|&
name|vi
argument_list|)
expr_stmt|;
comment|/* Initialized with vtables of type TYPE.  */
for|for
control|(
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|addr
decl_stmt|;
name|addr
operator|=
name|convert_pointer_to_vbase
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|vi
operator|.
name|decl_ptr
argument_list|)
expr_stmt|;
comment|/* Do all vtables from this virtual base.  */
comment|/* This assumes that virtual bases can never serve as parent 	     binfos.  (in the CLASSTYPE_VFIELD_PARENT sense)  */
name|expand_direct_vtbls_init
argument_list|(
name|vbases
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Now we adjust the offsets for virtual functions that 	     cross virtual boundaries on an implicit upcast on vf call 	     so that the layout of the most complete type is used, 	     instead of assuming the layout of the virtual bases from 	     our current type.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
comment|/* We don't have dynamic thunks yet! 		 So for now, just fail silently.  */
block|}
else|else
block|{
name|tree
name|vbase_offsets
init|=
name|NULL_TREE
decl_stmt|;
name|push_to_sequence
argument_list|(
name|fixup_insns
argument_list|)
expr_stmt|;
name|fixup_virtual_upcast_offsets
argument_list|(
name|vbases
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|vi
operator|.
name|decl_ptr
argument_list|,
name|type
argument_list|,
name|vbases
argument_list|,
operator|&
name|vbase_offsets
argument_list|)
expr_stmt|;
name|fixup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixup_insns
condition|)
block|{
specifier|extern
name|tree
name|in_charge_identifier
decl_stmt|;
name|tree
name|in_charge_node
init|=
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|in_charge_node
condition|)
block|{
name|warning
argument_list|(
literal|"recoverable internal compiler error, nobody's in charge!"
argument_list|)
expr_stmt|;
name|in_charge_node
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|in_charge_node
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|in_charge_node
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|in_charge_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|fixup_insns
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get virtual base class types.    This adds type to the vbase_types list in reverse dfs order.    Ordering is very important, so don't change it.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_get_vbase_types
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
modifier|*
name|vbase_types
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_VBASE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|new_vbase
init|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|new_vbase
argument_list|)
operator|=
operator|*
name|vbase_types
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|new_vbase
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|vbase_types
operator|=
name|new_vbase
expr_stmt|;
name|SET_BINFO_VBASE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a list of binfos for the virtual base classes for TYPE, in    depth-first search order.  The list is freshly allocated, so    no modification is made to  the current binfo hierarchy.  */
end_comment

begin_function
name|tree
name|get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbase_types
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_types
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_get_vbase_types
argument_list|,
name|unmarkedp
argument_list|,
operator|&
name|vbase_types
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now      reverse it so that we get normal dfs ordering.  */
name|vbase_types
operator|=
name|nreverse
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
comment|/* unmark marked vbases */
for|for
control|(
name|vbases
operator|=
name|vbase_types
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
name|CLEAR_BINFO_VBASE_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
return|return
name|vbase_types
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we want debug info for a type TYPE, make sure all its base types    are also marked as being potentially interesting.  This avoids    the problem of not writing any debug info for intermediate basetypes    that have abstract virtual functions.  Also mark member types.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|current_template_parms
condition|)
return|return;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
comment|/* We can't go looking for the base types and fields just yet.  */
return|return;
comment|/* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which      does not support name references between translation units.  Well, we      could, but that would mean putting global labels in the debug output      before each exported type and each of its functions and static data      members.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
return|return;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|dfs_debug_unmarkedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|ttype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
operator|=
name|target_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|dfs_debug_unmarkedp
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ttype
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_comment
comment|/* Returns 1 iff BINFO is a base we shouldn't really be able to see into,    because it (or one of the intermediate bases) depends on template parms.  */
end_comment

begin_function
specifier|static
name|int
name|dependent_base_p
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
for|for
control|(
init|;
name|binfo
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|currently_open_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_class_bindings
parameter_list|(
name|name
parameter_list|,
name|type_binding_p
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|type_binding_p
decl_stmt|;
block|{
name|tree
name|type_binding
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|value_binding
decl_stmt|;
comment|/* If we've already done the lookup for this declaration, we're      done.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
comment|/* First, deal with the type binding.  */
if|if
condition|(
name|type_binding_p
condition|)
block|{
name|type_binding
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|type_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|type_binding
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|type_binding
argument_list|)
expr_stmt|;
block|}
comment|/* Now, do the value binding.  */
name|value_binding
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_binding_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|value_binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
comment|/* We found a type-binding, even when looking for a non-type        binding.  This means that we already processed this binding        above.  */
name|my_friendly_assert
argument_list|(
name|type_binding_p
argument_list|,
literal|19990401
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|value_binding
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|BASELINK_P
argument_list|(
name|value_binding
argument_list|)
condition|)
comment|/* NAME is some overloaded functions.  */
name|value_binding
operator|=
name|TREE_VALUE
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Push class-level declarations for any names appearing in BINFO that    are TYPE_DECLS.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_push_type_decls
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
operator|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|fields
argument_list|)
operator|)
condition|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't just use BINFO_MARKED because envelope_add_decl uses      DERIVED_FROM_P, which calls get_base_distance.  */
name|SET_BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Push class-level declarations for any names appearing in BINFO that    are not TYPE_DECLS.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_push_decls
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|int
name|dep_base_p
decl_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|dep_base_p
operator|=
operator|(
name|processing_template_decl
operator|&&
name|type
operator|!=
name|current_class_type
operator|&&
name|dependent_base_p
argument_list|(
name|binfo
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dep_base_p
condition|)
block|{
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|USING_DECL
condition|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|dfs_push_decls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|method_vec
operator|=
operator|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|method_vec
condition|)
block|{
name|tree
modifier|*
name|methods
decl_stmt|;
name|tree
modifier|*
name|end
decl_stmt|;
comment|/* Farm out constructors and destructors.  */
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
for|for
control|(
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
init|;
operator|*
name|methods
operator|&&
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|CLEAR_BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
comment|/* Build up all the relevant bindings and such on the cache      obstack.  That way no memory is wasted when we throw away the      cache later.  */
name|push_cache_obstack
argument_list|()
expr_stmt|;
comment|/* Enter type declarations and mark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_push_type_decls
argument_list|,
name|unmarked_pushdecls_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enter non-type declarations and unmark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_push_decls
argument_list|,
name|marked_pushdecls_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Undo the call to push_cache_obstack above.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_unuse_fields
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|unuse_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unuse_fields
argument_list|,
name|unmarkedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|()
block|{
comment|/* We haven't pushed a search level when dealing with cached classes,      so we'd better not try to pop it.  */
if|if
condition|(
name|search_stack
condition|)
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* GATHER_STATISTICS */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|_vptr_name
operator|=
name|get_identifier
argument_list|(
literal|"_vptr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_define
define|#
directive|define
name|scratch_tree_cons
value|expr_tree_cons
end_define

begin_function
specifier|static
name|tree
name|add_conversions
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|conversions
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmp
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|||
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
break|break;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we don't already have this conversion.  */
if|if
condition|(
operator|!
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
condition|)
block|{
operator|*
name|conversions
operator|=
name|scratch_tree_cons
argument_list|(
name|binfo
argument_list|,
name|tmp
argument_list|,
operator|*
name|conversions
argument_list|)
expr_stmt|;
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|lookup_conversions
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|conversions
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
name|bfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|add_conversions
argument_list|,
literal|0
argument_list|,
operator|&
name|conversions
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|conversions
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_MARKED
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|conversions
return|;
block|}
end_function

begin_struct
struct|struct
name|overlap_info
block|{
name|tree
name|compare_type
decl_stmt|;
name|int
name|found_overlap
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Check whether the empty class indicated by EMPTY_BINFO is also present    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_check_overlap
parameter_list|(
name|empty_binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|empty_binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|overlap_info
modifier|*
name|oi
init|=
operator|(
expr|struct
name|overlap_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|oi
operator|->
name|compare_type
argument_list|)
init|;
condition|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|empty_binfo
argument_list|)
condition|)
block|{
name|oi
operator|->
name|found_overlap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Trivial function to stop base traversal when we find something.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_no_overlap_yet
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|overlap_info
modifier|*
name|oi
init|=
operator|(
expr|struct
name|overlap_info
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|!
name|oi
operator|->
name|found_overlap
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at    offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */
end_comment

begin_function
name|int
name|types_overlap_p
parameter_list|(
name|empty_type
parameter_list|,
name|next_type
parameter_list|)
name|tree
name|empty_type
decl_stmt|,
name|next_type
decl_stmt|;
block|{
name|struct
name|overlap_info
name|oi
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|next_type
argument_list|)
condition|)
return|return
literal|0
return|;
name|oi
operator|.
name|compare_type
operator|=
name|next_type
expr_stmt|;
name|oi
operator|.
name|found_overlap
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|empty_type
argument_list|)
argument_list|,
name|dfs_check_overlap
argument_list|,
name|dfs_no_overlap_yet
argument_list|,
operator|&
name|oi
argument_list|)
expr_stmt|;
return|return
name|oi
operator|.
name|found_overlap
return|;
block|}
end_function

begin_struct
struct|struct
name|bfv_info
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|var
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|tree
name|dfs_bfv_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|bfv_info
modifier|*
name|bfvi
init|=
operator|(
expr|struct
name|bfv_info
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Use the real virtual base class objects, not the placeholders in      the usual hierarchy.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|bfvi
operator|->
name|vbases
argument_list|)
return|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Passed to dfs_walk_real by binfo_for_vtable; determine if bvtable    comes from BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_bfv_helper
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|bfv_info
modifier|*
name|bfvi
init|=
operator|(
expr|struct
name|bfv_info
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
operator|==
name|bfvi
operator|->
name|var
condition|)
return|return
name|binfo
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a vtable VAR, determine which binfo it comes from.  */
end_comment

begin_function
name|tree
name|binfo_for_vtable
parameter_list|(
name|var
parameter_list|)
name|tree
name|var
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|struct
name|bfv_info
name|bfvi
decl_stmt|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|bfvi
operator|.
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bfvi
operator|.
name|var
operator|=
name|var
expr_stmt|;
return|return
name|dfs_walk_real
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dfs_bfv_helper
argument_list|,
name|dfs_bfv_queue_p
argument_list|,
operator|&
name|bfvi
argument_list|)
return|;
block|}
end_function

end_unit

