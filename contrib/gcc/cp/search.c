begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002, 2003 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
name|char
modifier|*
name|tp
parameter_list|,
comment|/* Sony NewsOS 5.0 compiler doesn't like void * here.  */
name|int
name|size
parameter_list|)
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
operator|-
name|size
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|struct
name|stack_level
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vbase_info
block|{
comment|/* The class dominating the hierarchy.  */
name|tree
name|type
decl_stmt|;
comment|/* A pointer to a complete object of the indicated TYPE.  */
name|tree
name|decl_ptr
decl_stmt|;
name|tree
name|inits
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_check_overlap
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_no_overlap_yet
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|base_kind
name|lookup_base_r
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|base_access
parameter_list|,
name|bool
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dynamic_cast_base_recurse
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|marked_pushdecls_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|unmarked_pushdecls_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_debug_unmarkedp
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_debug_mark
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_push_type_decls
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_push_decls
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_unuse_fields
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_conversions
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|look_for_overrides_r
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|struct
name|stack_level
modifier|*
parameter_list|,
name|struct
name|obstack
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
parameter_list|(
name|struct
name|stack_level
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|bfs_walk
parameter_list|(
name|tree
parameter_list|,
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_field_queue_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_field_r
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_accessible_queue_p
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_accessible_p
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_access_in_type
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|access_kind
name|access_in_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|protected_accessible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|friend_accessible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_class_bindings
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|template_self_reference_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_get_pure_virtuals
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|struct
name|stack_level
modifier|*
name|stack
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
parameter_list|(
name|struct
name|stack_level
modifier|*
name|obstack
parameter_list|)
block|{
name|struct
name|search_level
modifier|*
name|stack
init|=
name|pop_stack_level
argument_list|(
name|obstack
argument_list|)
decl_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GATHER_STATISTICS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Worker for lookup_base.  BINFO is the binfo we are searching at,    BASE is the RECORD_TYPE we are searching for.  ACCESS is the    required access checks.  IS_VIRTUAL indicates if BINFO is morally    virtual.     If BINFO is of the required type, then *BINFO_PTR is examined to    compare with any other instance of BASE we might have already    discovered. *BINFO_PTR is initialized and a base_kind return value    indicates what kind of base was located.     Otherwise BINFO's bases are searched.  */
end_comment

begin_function
specifier|static
name|base_kind
name|lookup_base_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|base
parameter_list|,
name|base_access
name|access
parameter_list|,
name|bool
name|is_virtual
parameter_list|,
comment|/* inside a virtual part */
name|tree
modifier|*
name|binfo_ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|bases
decl_stmt|,
name|accesses
decl_stmt|;
name|base_kind
name|found
init|=
name|bk_not_base
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
block|{
comment|/* We have found a base. Check against what we have found          already.  */
name|found
operator|=
name|bk_same_type
expr_stmt|;
if|if
condition|(
name|is_virtual
condition|)
name|found
operator|=
name|bk_via_virtual
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|binfo_ptr
condition|)
operator|*
name|binfo_ptr
operator|=
name|binfo
expr_stmt|;
elseif|else
if|if
condition|(
name|binfo
operator|!=
operator|*
name|binfo_ptr
condition|)
block|{
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
operator|*
name|binfo_ptr
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_virtual
condition|)
comment|/* Prefer a non-virtual base.  */
operator|*
name|binfo_ptr
operator|=
name|binfo
expr_stmt|;
name|found
operator|=
name|bk_ambig
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
name|bases
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|accesses
operator|=
name|BINFO_BASEACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bases
condition|)
return|return
name|bk_not_base
return|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|base_kind
name|bk
decl_stmt|;
name|bk
operator|=
name|lookup_base_r
argument_list|(
name|base_binfo
argument_list|,
name|base
argument_list|,
name|access
argument_list|,
name|is_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|binfo_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bk
condition|)
block|{
case|case
name|bk_ambig
case|:
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
return|return
name|bk
return|;
name|found
operator|=
name|bk
expr_stmt|;
break|break;
case|case
name|bk_same_type
case|:
name|bk
operator|=
name|bk_proper_base
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|bk_proper_base
case|:
name|my_friendly_assert
argument_list|(
name|found
operator|==
name|bk_not_base
argument_list|,
literal|20010723
argument_list|)
expr_stmt|;
name|found
operator|=
name|bk
expr_stmt|;
break|break;
case|case
name|bk_via_virtual
case|:
if|if
condition|(
name|found
operator|!=
name|bk_ambig
condition|)
name|found
operator|=
name|bk
expr_stmt|;
break|break;
case|case
name|bk_not_base
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Returns true if type BASE is accessible in T.  (BASE is known to be    a (possibly non-proper) base class of T.)  */
end_comment

begin_function
name|bool
name|accessible_base_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|base
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* [class.access.base]       A base class is said to be accessible if an invented public      member of the base class is accessible.         If BASE is a non-proper base, this condition is trivially      true.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|t
argument_list|,
name|base
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Rather than inventing a public member, we use the implicit      public typedef created in the scope of every class.  */
name|decl
operator|=
name|TYPE_FIELDS
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|accessible_p
argument_list|(
name|t
argument_list|,
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup BASE in the hierarchy dominated by T.  Do access checking as    ACCESS specifies.  Return the binfo we discover.  If KIND_PTR is    non-NULL, fill with information about what kind of base we    discovered.     If the base is inaccessible, or ambiguous, and the ba_quiet bit is    not set in ACCESS, then an error is issued and error_mark_node is    returned.  If the ba_quiet bit is set, then no error is issued and    NULL_TREE is returned.  */
end_comment

begin_function
name|tree
name|lookup_base
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|base
parameter_list|,
name|base_access
name|access
parameter_list|,
name|base_kind
modifier|*
name|kind_ptr
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|NULL
decl_stmt|;
comment|/* The binfo we've found so far.  */
name|tree
name|t_binfo
init|=
name|NULL
decl_stmt|;
name|base_kind
name|bk
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
name|base
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|kind_ptr
condition|)
operator|*
name|kind_ptr
operator|=
name|bk_not_base
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_assert
argument_list|(
name|TYPE_P
argument_list|(
name|base
argument_list|)
argument_list|,
literal|20011127
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t_binfo
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|t_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Ensure that the types are instantiated.  */
name|t
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|bk
operator|=
name|lookup_base_r
argument_list|(
name|t_binfo
argument_list|,
name|base
argument_list|,
name|access
argument_list|,
literal|0
argument_list|,
operator|&
name|binfo
argument_list|)
expr_stmt|;
comment|/* Check that the base is unambiguous and accessible.  */
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
switch|switch
condition|(
name|bk
condition|)
block|{
case|case
name|bk_not_base
case|:
break|break;
case|case
name|bk_ambig
case|:
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|access
operator|&
name|ba_quiet
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%T' is an ambiguous base of `%T'"
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|error_mark_node
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|access
operator|&
operator|~
name|ba_quiet
operator|)
operator|!=
name|ba_ignore
comment|/* If BASE is incomplete, then BASE and TYPE are probably 	       the same, in which case BASE is accessible.  If they 	       are not the same, then TYPE is invalid.  In that case, 	       there's no need to issue another error here, and 	       there's no implicit typedef to use in the code that 	       follows, so we skip the check.  */
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
name|accessible_base_p
argument_list|(
name|t
argument_list|,
name|base
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|access
operator|&
name|ba_quiet
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%T' is an inaccessible base of `%T'"
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|bk
operator|=
name|bk_inaccessible
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|kind_ptr
condition|)
operator|*
name|kind_ptr
operator|=
name|bk
expr_stmt|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Worker function for get_dynamic_cast_base_type.  */
end_comment

begin_function
specifier|static
name|int
name|dynamic_cast_base_recurse
parameter_list|(
name|tree
name|subtype
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|bool
name|is_via_virtual
parameter_list|,
name|tree
modifier|*
name|offset_ptr
parameter_list|)
block|{
name|tree
name|binfos
decl_stmt|,
name|accesses
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|int
name|worst
init|=
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|subtype
condition|)
block|{
if|if
condition|(
name|is_via_virtual
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
operator|*
name|offset_ptr
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|accesses
operator|=
name|BINFO_BASEACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_access
init|=
name|TREE_VEC_ELT
argument_list|(
name|accesses
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|base_access
operator|!=
name|access_public_node
condition|)
continue|continue;
name|rval
operator|=
name|dynamic_cast_base_recurse
argument_list|(
name|subtype
argument_list|,
name|base_binfo
argument_list|,
name|is_via_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|offset_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|worst
operator|==
operator|-
literal|2
condition|)
name|worst
operator|=
name|rval
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|>=
literal|0
condition|)
name|worst
operator|=
name|worst
operator|>=
literal|0
condition|?
operator|-
literal|3
else|:
name|worst
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
name|worst
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
operator|-
literal|3
operator|&&
name|worst
operator|!=
operator|-
literal|1
condition|)
name|worst
operator|=
operator|-
literal|3
expr_stmt|;
block|}
return|return
name|worst
return|;
block|}
end_function

begin_comment
comment|/* The dynamic cast runtime needs a hint about how the static SUBTYPE type    started from is related to the required TARGET type, in order to optimize    the inheritance graph search. This information is independent of the    current context, and ignores private paths, hence get_base_distance is    inappropriate. Return a TREE specifying the base offset, BOFF.    BOFF>= 0, there is only one public non-virtual SUBTYPE base at offset BOFF,       and there are no public virtual SUBTYPE bases.    BOFF == -1, SUBTYPE occurs as multiple public virtual or non-virtual bases.    BOFF == -2, SUBTYPE is not a public base.    BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.  */
end_comment

begin_function
name|tree
name|get_dynamic_cast_base_type
parameter_list|(
name|tree
name|subtype
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|tree
name|offset
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|boff
init|=
name|dynamic_cast_base_recurse
argument_list|(
name|subtype
argument_list|,
name|TYPE_BINFO
argument_list|(
name|target
argument_list|)
argument_list|,
name|false
argument_list|,
operator|&
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|boff
condition|)
return|return
name|offset
return|;
name|offset
operator|=
name|build_int_2
argument_list|(
name|boff
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
operator|=
name|ssizetype
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance    lattice specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return a DECL with the indicated name.  If WANT_TYPE is    true, type declarations are preferred.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller must    figure out whether it can access this field.  (Since it is only one    level, this is reasonable.)  */
end_comment

begin_function
name|tree
name|lookup_field_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|,
name|bool
name|want_type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
comment|/* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and         BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,        the code often worked even when we treated the index as a list        of fields!)        The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|fields
init|=
operator|&
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|->
name|elts
index|[
literal|0
index|]
decl_stmt|;
name|int
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|->
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|>
name|name
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|<
name|name
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|field
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We might have a nested class and a field with the 		 same name; we sorted them appropriately via 		 field_decl_cmp, so just look for the first or last 		 field with this name.  */
if|if
condition|(
name|want_type
condition|)
block|{
do|do
name|field
operator|=
name|fields
index|[
name|i
operator|--
index|]
expr_stmt|;
do|while
condition|(
name|i
operator|>=
name|lo
operator|&&
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|==
name|name
condition|)
do|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|field
argument_list|)
condition|)
name|field
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
do|do
name|field
operator|=
name|fields
index|[
name|i
operator|++
index|]
expr_stmt|;
do|while
condition|(
name|i
operator|<
name|hi
operator|&&
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|==
name|name
condition|)
do|;
block|}
return|return
name|field
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|,
name|want_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|USING_DECL
condition|)
comment|/* For now, we're just treating member using declarations as 	   old ARM-style access declarations.  Thus, there's no reason 	   to return a USING_DECL, and the rest of the compiler can't 	   handle it.  Once the class is defined, these are purged 	   from TYPE_FIELDS anyhow; see handle_using_decl.  */
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
operator|&&
operator|(
operator|!
name|want_type
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|field
argument_list|)
operator|)
condition|)
return|return
name|field
return|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|vptr_identifier
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* There are a number of cases we need to be aware of here: 			 current_class_type	current_function_decl      global			NULL			NULL      fn-local			NULL			SET      class-local		SET			NULL      class->fn			SET			SET      fn->class			SET			SET     Those last two make life interesting.  If we're in a function which is    itself inside a class, we need decls to go into the fn's decls (our    second case below).  But if we're in a class and the class itself is    inside a function, we need decls to go into the decls for the class.  To    achieve this last goal, we must see if, when both current_class_ptr and    current_function_decl are set, the class was declared inside that    function.  If so, we know to put the decls into the class's scope.  */
end_comment

begin_function
name|tree
name|current_scope
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|current_class_type
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
name|current_function_decl
return|;
if|if
condition|(
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|||
operator|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
condition|)
return|return
name|current_function_decl
return|;
return|return
name|current_class_type
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if we are currently in a function scope.  Note    that this function returns zero if we are within a local class, but    not within a member function body of the local class.  */
end_comment

begin_function
name|int
name|at_function_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
return|return
name|cs
operator|&&
name|TREE_CODE
argument_list|(
name|cs
argument_list|)
operator|==
name|FUNCTION_DECL
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the innermost active scope is a class scope.  */
end_comment

begin_function
name|bool
name|at_class_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
return|return
name|cs
operator|&&
name|TYPE_P
argument_list|(
name|cs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the innermost active scope is a namespace scope.  */
end_comment

begin_function
name|bool
name|at_namespace_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We are in a namespace scope if we are not it a class scope or a      function scope.  */
return|return
operator|!
name|current_scope
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return the scope of DECL, as appropriate when doing name-lookup.  */
end_comment

begin_function
name|tree
name|context_for_name_lookup
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* [class.union]            For the purposes of name lookup, after the anonymous union      definition, the members of the anonymous union are considered to      have been defined in the scope in which the anonymous union is      declared.  */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|context
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* The accessibility routines use BINFO_ACCESS for scratch space    during the computation of the accessibility of some declaration.  */
end_comment

begin_define
define|#
directive|define
name|BINFO_ACCESS
parameter_list|(
name|NODE
parameter_list|)
define|\
value|((access_kind) ((TREE_PUBLIC (NODE)<< 1) | TREE_PRIVATE (NODE)))
end_define

begin_comment
comment|/* Set the access associated with NODE to ACCESS.  */
end_comment

begin_define
define|#
directive|define
name|SET_BINFO_ACCESS
parameter_list|(
name|NODE
parameter_list|,
name|ACCESS
parameter_list|)
define|\
value|((TREE_PUBLIC (NODE) = ((ACCESS)& 2) != 0),	\    (TREE_PRIVATE (NODE) = ((ACCESS)& 1) != 0))
end_define

begin_comment
comment|/* Called from access_in_type via dfs_walk.  Calculate the access to    DATA (which is really a DECL) in BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_access_in_type
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|access_kind
name|access
init|=
name|ak_none
decl_stmt|;
if|if
condition|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
operator|==
name|type
condition|)
block|{
comment|/* If we have descended to the scope of DECL, just note the 	 appropriate access.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|ak_private
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|ak_protected
expr_stmt|;
else|else
name|access
operator|=
name|ak_public
expr_stmt|;
block|}
else|else
block|{
comment|/* First, check for an access-declaration that gives us more 	 access to the DECL.  The CONST_DECL for an enumeration 	 constant will not have DECL_LANG_SPECIFIC, and thus no 	 DECL_ACCESS.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_DISCRIMINATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|decl_access
init|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_ACCESS
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_access
condition|)
block|{
name|decl_access
operator|=
name|TREE_VALUE
argument_list|(
name|decl_access
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_access
operator|==
name|access_public_node
condition|)
name|access
operator|=
name|ak_public
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_access
operator|==
name|access_protected_node
condition|)
name|access
operator|=
name|ak_protected
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_access
operator|==
name|access_private_node
condition|)
name|access
operator|=
name|ak_private
expr_stmt|;
else|else
name|my_friendly_assert
argument_list|(
name|false
argument_list|,
literal|20030217
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|access
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|,
name|accesses
decl_stmt|;
comment|/* Otherwise, scan our baseclasses, and pick the most favorable 	     access.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|accesses
operator|=
name|BINFO_BASEACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_access
init|=
name|TREE_VEC_ELT
argument_list|(
name|accesses
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|access_kind
name|base_access_now
init|=
name|BINFO_ACCESS
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_access_now
operator|==
name|ak_none
operator|||
name|base_access_now
operator|==
name|ak_private
condition|)
comment|/* If it was not accessible in the base, or only 		   accessible as a private member, we can't access it 		   all.  */
name|base_access_now
operator|=
name|ak_none
expr_stmt|;
elseif|else
if|if
condition|(
name|base_access
operator|==
name|access_protected_node
condition|)
comment|/* Public and protected members in the base become 		   protected here.  */
name|base_access_now
operator|=
name|ak_protected
expr_stmt|;
elseif|else
if|if
condition|(
name|base_access
operator|==
name|access_private_node
condition|)
comment|/* Public and protected members in the base become 		   private here.  */
name|base_access_now
operator|=
name|ak_private
expr_stmt|;
comment|/* See if the new access, via this base, gives more 		 access than our previous best access.  */
if|if
condition|(
name|base_access_now
operator|!=
name|ak_none
operator|&&
operator|(
name|access
operator|==
name|ak_none
operator|||
name|base_access_now
operator|<
name|access
operator|)
condition|)
block|{
name|access
operator|=
name|base_access_now
expr_stmt|;
comment|/* If the new access is public, we can't do better.  */
if|if
condition|(
name|access
operator|==
name|ak_public
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/* Note the access to DECL in TYPE.  */
name|SET_BINFO_ACCESS
argument_list|(
name|binfo
argument_list|,
name|access
argument_list|)
expr_stmt|;
comment|/* Mark TYPE as visited so that if we reach it again we do not      duplicate our efforts here.  */
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the access to DECL in TYPE.  */
end_comment

begin_function
specifier|static
name|access_kind
name|access_in_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We must take into account         [class.paths]         If a name can be reached by several paths through a multiple        inheritance graph, the access is that of the path that gives        most access.        The algorithm we use is to make a post-order depth-first traversal     of the base-class hierarchy.  As we come up the tree, we annotate     each node with the most lenient access.  */
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
name|dfs_access_in_type
argument_list|,
name|unmarkedp
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|BINFO_ACCESS
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from accessible_p via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_queue_p
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this class is inherited via private or protected inheritance,      then we can't see it, unless we are a friend of the derived class.  */
if|if
condition|(
name|BINFO_BASEACCESS
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
operator|!=
name|access_public_node
operator|&&
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|derived
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Called from accessible_p via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_p
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|access_kind
name|access
decl_stmt|;
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|access
operator|=
name|BINFO_ACCESS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|!=
name|ak_none
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
return|return
name|binfo
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it is OK to access DECL through an object    indicated by BINFO in the context of DERIVED.  */
end_comment

begin_function
specifier|static
name|int
name|protected_accessible_p
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|derived
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|access_kind
name|access
decl_stmt|;
comment|/* We're checking this clause from [class.access.base]         m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected.        Here DERIVED is a possible P and DECL is m.  accessible_p will     iterate over various values of N, but the access to m in DERIVED     does not change.      Note that I believe that the passage above is wrong, and should read     "...is private or protected or public"; otherwise you get bizarre results     whereby a public using-decl can prevent you from accessing a protected     member of a base.  (jason 2000/02/28)  */
comment|/* If DERIVED isn't derived from m's class, then it can't be a P.  */
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|,
name|derived
argument_list|)
condition|)
return|return
literal|0
return|;
name|access
operator|=
name|access_in_type
argument_list|(
name|derived
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If m is inaccessible in DERIVED, then it's not a P.  */
if|if
condition|(
name|access
operator|==
name|ak_none
condition|)
return|return
literal|0
return|;
comment|/* [class.protected]       When a friend or a member function of a derived class references      a protected nonstatic member of a base class, an access check      applies in addition to those described earlier in clause      _class.access_) Except when forming a pointer to member      (_expr.unary.op_), the access must be through a pointer to,      reference to, or object of the derived class itself (or any class      derived from that class) (_expr.ref_).  If the access is to form      a pointer to member, the nested-name-specifier shall name the      derived class (or any class derived from that class).  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We can tell through what the reference is occurring by 	 chasing BINFO up to the root.  */
name|tree
name|t
init|=
name|binfo
decl_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|derived
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if SCOPE is a friend of a type which would be able    to access DECL through the object indicated by BINFO.  */
end_comment

begin_function
specifier|static
name|int
name|friend_accessible_p
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|befriending_classes
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|scope
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|befriending_classes
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Nested classes are implicitly friends of their enclosing types, as      per core issue 45 (this is a change from the standard).  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
for|for
control|(
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
init|;
name|t
operator|&&
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* Perhaps this SCOPE is a member of a class which is a  	 friend.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|friend_accessible_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Or an instantiation of something which is a friend.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Increment processing_template_decl to make sure that 	     dependent_type_p works correctly.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|ret
operator|=
name|friend_accessible_p
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Increment processing_template_decl to make sure that 	 dependent_type_p works correctly.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|ret
operator|=
name|friend_accessible_p
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DECL is a declaration from a base class of TYPE, which was the    class used to name DECL.  Return nonzero if, in the current    context, DECL is accessible.  If TYPE is actually a BINFO node,    then we can tell in what context the access is occurring by looking    at the most derived class along the path indicated by BINFO.  */
end_comment

begin_function
name|int
name|accessible_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|access_kind
name|access
decl_stmt|;
comment|/* Nonzero if it's OK to access DECL if it has protected      accessibility in TYPE.  */
name|int
name|protected_ok
init|=
literal|0
decl_stmt|;
comment|/* If this declaration is in a block or namespace scope, there's no      access control.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* There is no need to perform access checks inside a thunk.  */
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|scope
operator|&&
name|DECL_THUNK_P
argument_list|(
name|scope
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* In a template declaration, we cannot be sure whether the      particular specialization that is instantiated will be a friend      or not.  Therefore, all access checks are deferred until      instantiation.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* [class.access.base]       A member m is accessible when named in class N if       --m as a member of N is public, or       --m as a member of N is private, and the reference occurs in a        member or friend of class N, or       --m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected, or       --there exists a base class B of N that is accessible at the point        of reference, and m is accessible when named in class B.        We walk the base class hierarchy, checking these conditions.  */
comment|/* Figure out where the reference is occurring.  Check to see if      DECL is private or protected in this scope, since that will      determine whether protected access is allowed.  */
if|if
condition|(
name|current_class_type
condition|)
name|protected_ok
operator|=
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|current_class_type
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Now, loop through the classes of which we are a friend.  */
if|if
condition|(
operator|!
name|protected_ok
condition|)
name|protected_ok
operator|=
name|friend_accessible_p
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Standardize the binfo that access_in_type will use.  We don't      need to know what path was chosen from this point onwards.  */
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the accessibility of DECL in the class hierarchy      dominated by type.  */
name|access
operator|=
name|access_in_type
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|ak_public
operator|||
operator|(
name|access
operator|==
name|ak_protected
operator|&&
name|protected_ok
operator|)
condition|)
return|return
literal|1
return|;
else|else
block|{
comment|/* Walk the hierarchy again, looking for a base class that allows 	 access.  */
name|t
operator|=
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_accessible_p
argument_list|,
name|dfs_accessible_queue_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear any mark bits.  Note that we have to walk the whole tree 	 here, since we have aborted the previous walk from some point 	 deep in the tree.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
operator|!=
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|lookup_field_info
block|{
comment|/* The type in which we're looking.  */
name|tree
name|type
decl_stmt|;
comment|/* The name of the field for which we're looking.  */
name|tree
name|name
decl_stmt|;
comment|/* If non-NULL, the current result of the lookup.  */
name|tree
name|rval
decl_stmt|;
comment|/* The path to RVAL.  */
name|tree
name|rval_binfo
decl_stmt|;
comment|/* If non-NULL, the lookup was ambiguous, and this is a list of the      candidates.  */
name|tree
name|ambiguous
decl_stmt|;
comment|/* If nonzero, we are looking for types, not data members.  */
name|int
name|want_type
decl_stmt|;
comment|/* If something went wrong, a message indicating what.  */
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Returns nonzero if BINFO is not hidden by the value found by the    lookup so far.  If BINFO is hidden, then there's no need to look in    it.  DATA is really a struct lookup_field_info.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_queue_p
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Don't look for constructors or destructors in base classes.  */
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|lfi
operator|->
name|name
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this base class is hidden by the best-known value so far, we      don't need to look.  */
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
name|original_binfo
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|rval_binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this is a dependent base, don't look in it.  */
if|if
condition|(
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class, you can refer to the to the    current specialization with the name of the template itself.  For    example:          template<typename T> struct S { S* sp; }     Returns nonzero if DECL is such a declaration in a class TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|template_self_reference_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero for a class member means that it is shared between all objects    of that class.     [class.member.lookup]:If the resulting set of declarations are not all    from sub-objects of the same type, or the set has a  nonstatic  member    and  includes members from distinct sub-objects, there is an ambiguity    and the program is ill-formed.     This function checks that T contains no nonstatic members.  */
end_comment

begin_function
name|int
name|shared_member_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
expr|\
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|OVL_NEXT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Routine to see if the sub-object denoted by the binfo PARENT can be    found as a base class and sub-object of the object denoted by    BINFO.  */
end_comment

begin_function
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|tree
name|parent
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|parent
init|;
name|probe
condition|;
name|probe
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
if|if
condition|(
name|probe
operator|==
name|binfo
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|probe
argument_list|)
condition|)
return|return
operator|(
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DATA is really a struct lookup_field_info.  Look for a field with    the name indicated there in BINFO.  If this function returns a    non-NULL value it is the result of the lookup.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|nval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* First, look for a function.  There can't be a function and a data      member with the same name, and if there's a function and a type      with the same name, the type is hidden by the function.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|want_type
condition|)
block|{
name|int
name|idx
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nval
condition|)
comment|/* Look for a data member or type.  */
name|nval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|,
name|lfi
operator|->
name|want_type
argument_list|)
expr_stmt|;
comment|/* If there is no declaration with the indicated name in this type,      then there's nothing to do.  */
if|if
condition|(
operator|!
name|nval
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we're looking up a type (as with an elaborated type specifier)      we ignore all non-types we find.  */
if|if
condition|(
name|lfi
operator|->
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|nval
argument_list|)
condition|)
block|{
if|if
condition|(
name|lfi
operator|->
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If the aggregate has no user defined constructors, we allow 	     it to have fields with the same name as the enclosing type. 	     If we are looking for that name, find the corresponding 	     TYPE_DECL.  */
for|for
control|(
name|nval
operator|=
name|TREE_CHAIN
argument_list|(
name|nval
argument_list|)
init|;
name|nval
condition|;
name|nval
operator|=
name|TREE_CHAIN
argument_list|(
name|nval
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|nval
argument_list|)
operator|==
name|lfi
operator|->
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|==
name|TYPE_DECL
condition|)
break|break;
block|}
else|else
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|nval
operator|&&
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|binding_entry
name|e
init|=
name|binding_table_find
argument_list|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|type
argument_list|)
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|nval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|e
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
block|}
block|}
comment|/* You must name a template base class with a template-id.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|nval
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If the lookup already found a match, and the new value doesn't      hide the old one, we might have an ambiguity.  */
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|is_subobject_of_p
argument_list|(
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|nval
operator|==
name|lfi
operator|->
name|rval
operator|&&
name|shared_member_p
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* The two things are really the same.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|rval_binfo
argument_list|)
condition|)
comment|/* The previous value hides the new one.  */
empty_stmt|;
else|else
block|{
comment|/* We have a real ambiguity.  We keep a chain of all the 	     candidates.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|ambiguous
operator|&&
name|lfi
operator|->
name|rval
condition|)
block|{
comment|/* This is the first time we noticed an ambiguity.  Add 		 what we previously thought was a reasonable candidate 		 to the list.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lfi
operator|->
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add the new value.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|nval
argument_list|,
name|lfi
operator|->
name|ambiguous
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|lfi
operator|->
name|errstr
operator|=
literal|"request for member `%D' is ambiguous"
expr_stmt|;
block|}
block|}
else|else
block|{
name|lfi
operator|->
name|rval
operator|=
name|nval
expr_stmt|;
name|lfi
operator|->
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a "baselink" which BASELINK_BINFO, BASELINK_ACCESS_BINFO,    BASELINK_FUNCTIONS, and BASELINK_OPTYPE set to BINFO, ACCESS_BINFO,    FUNCTIONS, and OPTYPE respectively.  */
end_comment

begin_function
name|tree
name|build_baselink
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|access_binfo
parameter_list|,
name|tree
name|functions
parameter_list|,
name|tree
name|optype
parameter_list|)
block|{
name|tree
name|baselink
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|OVERLOAD
argument_list|,
literal|20020730
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|optype
operator|||
name|TYPE_P
argument_list|(
name|optype
argument_list|)
argument_list|,
literal|20020730
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|functions
argument_list|)
argument_list|,
literal|20020805
argument_list|)
expr_stmt|;
name|baselink
operator|=
name|make_node
argument_list|(
name|BASELINK
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
name|BASELINK_BINFO
argument_list|(
name|baselink
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BASELINK_ACCESS_BINFO
argument_list|(
name|baselink
argument_list|)
operator|=
name|access_binfo
expr_stmt|;
name|BASELINK_FUNCTIONS
argument_list|(
name|baselink
argument_list|)
operator|=
name|functions
expr_stmt|;
name|BASELINK_OPTYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|optype
expr_stmt|;
return|return
name|baselink
return|;
block|}
end_function

begin_comment
comment|/* Look for a member named NAME in an inheritance lattice dominated by    XBASETYPE.  If PROTECT is 0 or two, we do not check access.  If it    is 1, we enforce accessibility.  If PROTECT is zero, then, for an    ambiguous lookup, we return NULL.  If PROTECT is 1, we issue error    messages about inaccessible or ambiguous lookup.  If PROTECT is 2,    we return a TREE_LIST whose TREE_TYPE is error_mark_node and whose    TREE_VALUEs are the list of ambiguous candidates.     WANT_TYPE is 1 when we should only return TYPE_DECLs.     If nothing can be found return NULL_TREE and do not issue an error.  */
end_comment

begin_function
name|tree
name|lookup_member
parameter_list|(
name|tree
name|xbasetype
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|protect
parameter_list|,
name|bool
name|want_type
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|basetype_path
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|lookup_field_info
name|lfi
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just non-function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      non-function member is found.  */
specifier|const
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|20030624
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
argument_list|,
literal|20030624
argument_list|)
expr_stmt|;
name|type
operator|=
name|xbasetype
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|field
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
operator|(
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
condition|)
comment|/* We're in the scope of this class, and the value has already 	   been looked up.  Just return the cached value.  */
return|return
name|field
return|;
block|}
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|memset
argument_list|(
operator|&
name|lfi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lfi
argument_list|)
argument_list|)
expr_stmt|;
name|lfi
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|lfi
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|lfi
operator|.
name|want_type
operator|=
name|want_type
expr_stmt|;
name|bfs_walk
argument_list|(
name|basetype_path
argument_list|,
operator|&
name|lookup_field_r
argument_list|,
operator|&
name|lookup_field_queue_p
argument_list|,
operator|&
name|lfi
argument_list|)
expr_stmt|;
name|rval
operator|=
name|lfi
operator|.
name|rval
expr_stmt|;
name|rval_binfo
operator|=
name|lfi
operator|.
name|rval_binfo
expr_stmt|;
if|if
condition|(
name|rval_binfo
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|rval_binfo
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|lfi
operator|.
name|errstr
expr_stmt|;
comment|/* If we are not interested in ambiguities, don't report them;      just return NULL_TREE.  */
if|if
condition|(
operator|!
name|protect
operator|&&
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|protect
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|lfi
operator|.
name|ambiguous
return|;
else|else
name|protect
operator|=
literal|0
expr_stmt|;
block|}
comment|/* [class.access]       In the case of overloaded function names, access control is      applied to the function selected by overloaded resolution.  */
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
name|print_candidates
argument_list|(
name|lfi
operator|.
name|ambiguous
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
condition|)
name|rval
operator|=
name|build_baselink
argument_list|(
name|rval_binfo
argument_list|,
name|basetype_path
argument_list|,
name|rval
argument_list|,
operator|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
else|:
name|NULL_TREE
operator|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|tree
name|xbasetype
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|protect
parameter_list|,
name|bool
name|want_type
parameter_list|)
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
name|want_type
argument_list|)
decl_stmt|;
comment|/* Ignore functions.  */
if|if
condition|(
name|rval
operator|&&
name|BASELINK_P
argument_list|(
name|rval
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a non-function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|tree
name|xbasetype
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|protect
parameter_list|)
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
decl_stmt|;
comment|/* Ignore non-functions.  */
if|if
condition|(
name|rval
operator|&&
operator|!
name|BASELINK_P
argument_list|(
name|rval
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Return the index in the CLASSTYPE_METHOD_VEC for CLASS_TYPE    corresponding to "operator TYPE ()", or -1 if there is no such    operator.  Only CLASS_TYPE itself is searched; this routine does    not scan the base classes of CLASS_TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_conversion_operator
parameter_list|(
name|tree
name|class_type
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|pass
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|methods
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|class_type
argument_list|)
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
operator|++
name|pass
control|)
for|for
control|(
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|methods
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* The size of the vector may have some unused slots at the 	   end.  */
if|if
condition|(
operator|!
name|fn
condition|)
break|break;
comment|/* All the conversion operators come near the beginning of the 	   class.  Therefore, if FN is not a conversion operator, there 	   is no matching conversion operator in CLASS_TYPE.  */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* On the first pass we only consider exact matches.  If 	       the types match, this slot is the one where the right 	       conversion operators can be found.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|same_type_p
argument_list|(
name|DECL_CONV_FN_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|i
return|;
block|}
else|else
block|{
comment|/* On the second pass we look for template conversion 	       operators.  It may be possible to instantiate the 	       template to get the type desired.  All of the template 	       conversion operators share a slot.  By looking for 	       templates second we ensure that specializations are 	       preferred over templates.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
name|int
name|lookup_fnfields_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|method_vec
decl_stmt|;
name|tree
modifier|*
name|methods
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_vec
condition|)
return|return
operator|-
literal|1
return|;
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
comment|/* Constructors are first...  */
if|if
condition|(
name|name
operator|==
name|ctor_identifier
condition|)
return|return
operator|(
name|methods
index|[
name|CLASSTYPE_CONSTRUCTOR_SLOT
index|]
condition|?
name|CLASSTYPE_CONSTRUCTOR_SLOT
else|:
operator|-
literal|1
operator|)
return|;
comment|/* and destructors are second.  */
if|if
condition|(
name|name
operator|==
name|dtor_identifier
condition|)
return|return
operator|(
name|methods
index|[
name|CLASSTYPE_DESTRUCTOR_SLOT
index|]
condition|?
name|CLASSTYPE_DESTRUCTOR_SLOT
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|lookup_conversion_operator
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
comment|/* Skip the conversion operators.  */
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|methods
index|[
name|i
index|]
operator|&&
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|methods
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* If the type is complete, use binary search.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|lo
init|=
name|i
decl_stmt|;
name|int
name|hi
init|=
name|len
decl_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|tmp
operator|=
name|methods
index|[
name|i
index|]
expr_stmt|;
comment|/* This slot may be empty; we allocate more slots than we 	     need.  In that case, the entry we're looking for is 	     closer to the beginning of the list.  */
if|if
condition|(
name|tmp
condition|)
name|tmp
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|||
name|tmp
operator|>
name|name
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|<
name|name
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|i
return|;
block|}
block|}
else|else
for|for
control|(
init|;
name|i
operator|<
name|len
operator|&&
name|methods
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|tmp
operator|=
name|OVL_CURRENT
argument_list|(
name|methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
operator|==
name|name
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* DECL is the result of a qualified name lookup.  QUALIFYING_SCOPE is    the class or namespace used to qualify the name.  CONTEXT_CLASS is    the class corresponding to the object in which DECL will be used.    Return a possibly modified version of DECL that takes into account    the CONTEXT_CLASS.     In particular, consider an expression like `B::m' in the context of    a derived class `D'.  If `B::m' has been resolved to a BASELINK,    then the most derived class indicated by the BASELINK_BINFO will be    `B', not `D'.  This function makes that adjustment.  */
end_comment

begin_function
name|tree
name|adjust_result_of_qualified_name_lookup
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|qualifying_scope
parameter_list|,
name|tree
name|context_class
parameter_list|)
block|{
if|if
condition|(
name|context_class
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|qualifying_scope
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|qualifying_scope
argument_list|,
name|context_class
argument_list|)
operator|&&
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|base
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|context_class
argument_list|)
argument_list|,
literal|20020808
argument_list|)
expr_stmt|;
comment|/* Look for the QUALIFYING_SCOPE as a base of the CONTEXT_CLASS. 	 Because we do not yet know which function will be chosen by 	 overload resolution, we cannot yet check either accessibility 	 or ambiguity -- in either case, the choice of a static member 	 function might make the usage valid.  */
name|base
operator|=
name|lookup_base
argument_list|(
name|context_class
argument_list|,
name|qualifying_scope
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|BASELINK_ACCESS_BINFO
argument_list|(
name|decl
argument_list|)
operator|=
name|base
expr_stmt|;
name|BASELINK_BINFO
argument_list|(
name|decl
argument_list|)
operator|=
name|lookup_base
argument_list|(
name|base
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BASELINK_BINFO
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the class hierarchy dominated by TYPE.  FN is called for each    type in the hierarchy, in a breadth-first preorder traversal.    If it ever returns a non-NULL value, that value is immediately    returned and the walk is terminated.  At each node, FN is passed a    BINFO indicating the path from the currently visited base-class to    TYPE.  Before each base-class is walked QFN is called.  If the    value returned is nonzero, the base-class is walked; otherwise it    is not.  If QFN is NULL, it is treated as a function which always    returns 1.  Both FN and QFN are passed the DATA whenever they are    called.     Implementation notes: Uses a circular queue, which starts off on    the stack but gets moved to the malloc arena if it needs to be    enlarged.  The underflow and overflow conditions are    indistinguishable except by context: if head == tail and we just    moved the head pointer, the queue is empty, but if we just moved    the tail pointer, the queue is full.      Start with enough room for ten concurrent base classes.  That    will be enough for most hierarchies.  */
end_comment

begin_define
define|#
directive|define
name|BFS_WALK_INITIAL_QUEUE_SIZE
value|10
end_define

begin_function
specifier|static
name|tree
name|bfs_walk
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|bases_initial
index|[
name|BFS_WALK_INITIAL_QUEUE_SIZE
index|]
decl_stmt|;
comment|/* A circular queue of the base classes of BINFO.  These will be      built up in breadth-first order, except where QFN prunes the      search.  */
name|size_t
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|size_t
name|base_buffer_size
init|=
name|BFS_WALK_INITIAL_QUEUE_SIZE
decl_stmt|;
name|tree
modifier|*
name|base_buffer
init|=
name|bases_initial
decl_stmt|;
name|head
operator|=
name|tail
operator|=
literal|0
expr_stmt|;
name|base_buffer
index|[
name|tail
operator|++
index|]
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
name|int
name|n_bases
decl_stmt|,
name|ix
decl_stmt|;
name|tree
name|binfo
init|=
name|base_buffer
index|[
name|head
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|base_buffer_size
condition|)
name|head
operator|=
literal|0
expr_stmt|;
comment|/* Is this the one we're looking for?  If so, we're done.  */
name|rval
operator|=
name|fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
goto|goto
name|done
goto|;
name|n_bases
operator|=
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|n_bases
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
if|if
condition|(
name|qfn
condition|)
name|base_binfo
operator|=
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
block|{
name|base_buffer
index|[
name|tail
operator|++
index|]
operator|=
name|base_binfo
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|base_buffer_size
condition|)
name|tail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|head
condition|)
block|{
name|tree
modifier|*
name|new_buffer
init|=
name|xmalloc
argument_list|(
literal|2
operator|*
name|base_buffer_size
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_buffer
index|[
literal|0
index|]
argument_list|,
operator|&
name|base_buffer
index|[
literal|0
index|]
argument_list|,
name|tail
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|new_buffer
index|[
name|head
operator|+
name|base_buffer_size
index|]
argument_list|,
operator|&
name|base_buffer
index|[
name|head
index|]
argument_list|,
operator|(
name|base_buffer_size
operator|-
name|head
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_buffer_size
operator|!=
name|BFS_WALK_INITIAL_QUEUE_SIZE
condition|)
name|free
argument_list|(
name|base_buffer
argument_list|)
expr_stmt|;
name|base_buffer
operator|=
name|new_buffer
expr_stmt|;
name|head
operator|+=
name|base_buffer_size
expr_stmt|;
name|base_buffer_size
operator|*=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|base_buffer_size
operator|!=
name|BFS_WALK_INITIAL_QUEUE_SIZE
condition|)
name|free
argument_list|(
name|base_buffer
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Exactly like bfs_walk, except that a depth-first traversal is    performed, and PREFN is called in preorder, while POSTFN is called    in postorder.  */
end_comment

begin_function
name|tree
name|dfs_walk_real
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
function_decl|(
modifier|*
name|prefn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|postfn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Call the pre-order walking function.  */
if|if
condition|(
name|prefn
condition|)
block|{
name|rval
operator|=
call|(
modifier|*
name|prefn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
comment|/* Process the basetypes.  */
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
decl_stmt|;
if|if
condition|(
name|qfn
condition|)
name|base_binfo
operator|=
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|base_binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
block|{
name|rval
operator|=
name|dfs_walk_real
argument_list|(
name|base_binfo
argument_list|,
name|prefn
argument_list|,
name|postfn
argument_list|,
name|qfn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
block|}
block|}
comment|/* Call the post-order walking function.  */
if|if
condition|(
name|postfn
condition|)
name|rval
operator|=
call|(
modifier|*
name|postfn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Exactly like bfs_walk, except that a depth-first post-order traversal is    performed.  */
end_comment

begin_function
name|tree
name|dfs_walk
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|qfn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check that virtual overrider OVERRIDER is acceptable for base function    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */
end_comment

begin_function
name|int
name|check_final_overrider
parameter_list|(
name|tree
name|overrider
parameter_list|,
name|tree
name|basefn
parameter_list|)
block|{
name|tree
name|over_type
init|=
name|TREE_TYPE
argument_list|(
name|overrider
argument_list|)
decl_stmt|;
name|tree
name|base_type
init|=
name|TREE_TYPE
argument_list|(
name|basefn
argument_list|)
decl_stmt|;
name|tree
name|over_return
init|=
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
decl_stmt|;
name|tree
name|base_return
init|=
name|TREE_TYPE
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|tree
name|over_throw
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|over_type
argument_list|)
decl_stmt|;
name|tree
name|base_throw
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|base_return
argument_list|,
name|over_return
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|CLASS_TYPE_P
argument_list|(
name|over_return
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|base_return
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base_return
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|over_return
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|base_return
argument_list|)
operator|)
condition|)
block|{
comment|/* Potentially covariant.  */
name|unsigned
name|base_quals
decl_stmt|,
name|over_quals
decl_stmt|;
name|fail
operator|=
operator|!
name|POINTER_TYPE_P
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|fail
operator|=
name|cp_type_quals
argument_list|(
name|base_return
argument_list|)
operator|!=
name|cp_type_quals
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
name|base_return
operator|=
name|TREE_TYPE
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
name|over_return
operator|=
name|TREE_TYPE
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
block|}
name|base_quals
operator|=
name|cp_type_quals
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
name|over_quals
operator|=
name|cp_type_quals
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|base_quals
operator|&
name|over_quals
operator|)
operator|!=
name|over_quals
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|base_return
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|over_return
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|over_return
argument_list|,
name|base_return
argument_list|,
name|ba_check
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|can_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
argument_list|)
condition|)
comment|/* GNU extension, allow trivial pointer conversions such as 	   converting to void *, or qualification conversion.  */
block|{
comment|/* can_convert will permit user defined conversion from a 	     (reference to) class type. We must reject them.  */
name|over_return
operator|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|over_return
argument_list|)
condition|)
name|fail
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|fail
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|fail
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|overrider
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
if|if
condition|(
name|fail
operator|==
literal|1
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"invalid covariant return type for `%#D'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error_at
argument_list|(
literal|"conflicting return type specified for `%#D'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
block|}
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|overrider
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|overrider
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check throw specifier is at least as strict.  */
if|if
condition|(
operator|!
name|comp_except_specs
argument_list|(
name|base_throw
argument_list|,
name|over_throw
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|overrider
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"looser throw specifier for `%#F'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#F'"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|overrider
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|overrider
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a class TYPE, and a function decl FNDECL, look for    virtual functions in TYPE's hierarchy which FNDECL overrides.    We do not look in TYPE itself, only its bases.        Returns nonzero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we    find that it overrides anything.        We check that every function which is overridden, is correctly    overridden.  */
end_comment

begin_function
name|int
name|look_for_overrides
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|basebinfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|nbasebinfos
init|=
name|basebinfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|basebinfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|nbasebinfos
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|basebinfos
argument_list|,
name|ix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|found
operator|+=
name|look_for_overrides_r
argument_list|(
name|basetype
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Look in TYPE for virtual functions with the same signature as    FNDECL.  */
end_comment

begin_function
name|tree
name|look_for_overrides_here
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|ix
operator|=
name|CLASSTYPE_DESTRUCTOR_SLOT
expr_stmt|;
else|else
name|ix
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
name|tree
name|fns
init|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Not a virtual.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|!=
name|type
condition|)
comment|/* Introduced with a using declaration.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|btypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|dtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
elseif|else
if|if
condition|(
name|same_signature_p
argument_list|(
name|fndecl
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look in TYPE for virtual functions overridden by FNDECL. Check both    TYPE itself and its bases.  */
end_comment

begin_function
specifier|static
name|int
name|look_for_overrides_r
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|fn
init|=
name|look_for_overrides_here
argument_list|(
name|type
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* A static member function cannot match an inherited 	     virtual member function.  */
name|cp_error_at
argument_list|(
literal|"`%#D' cannot be declared"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  since `%#D' declared in base class"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's definitely virtual, even if not explicitly set.  */
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|check_final_overrider
argument_list|(
name|fndecl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* We failed to find one declared in this class. Look in its bases.  */
return|return
name|look_for_overrides
argument_list|(
name|type
argument_list|,
name|fndecl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from dfs_get_pure_virtuals.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_get_pure_virtuals
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
comment|/* We're not interested in primary base classes; the derived class      of which they are a primary base will contain the information we      need.  */
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|virtuals
decl_stmt|;
for|for
control|(
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
control|)
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
condition|)
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set CLASSTYPE_PURE_VIRTUALS for TYPE.  */
end_comment

begin_function
name|void
name|get_pure_virtuals
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|vbases
decl_stmt|;
comment|/* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there      is going to be overridden.  */
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now, run through all the bases which are not primary bases, and      collect the pure virtual functions.  We look at the vtable in      each class to determine what pure virtual functions are present.      (A primary base is not interesting because the derived class of      which it is a primary base will contain vtable entries for the      pure virtuals in the base class.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_get_pure_virtuals
argument_list|,
name|unmarkedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Put the pure virtuals in dfs order.  */
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|virtuals
decl_stmt|;
for|for
control|(
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
control|)
block|{
name|tree
name|base_fndecl
init|=
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%#D' needs a final overrider"
argument_list|,
name|base_fndecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_function
name|tree
name|markedp
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|unmarkedp
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
return|return
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|marked_pushdecls_p
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmarked_pushdecls_p
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_function
name|tree
name|dfs_unmark
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug info for C++ classes can get very large; try to avoid    emitting it everywhere.     Note that this optimization wins even when the target supports    BINCL (if only slightly), and reduces the amount of work for the    linker.  */
end_comment

begin_function
name|void
name|maybe_suppress_debug_info
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* We can't do the usual TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which      does not support name references between translation units.  It supports      symbolic references between translation units, but only within a single      executable or shared library.       For DWARF 2, we handle TYPE_DECL_SUPPRESS_DEBUG by pretending      that the type was never defined, so we only get the members we      actually define.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
return|return;
comment|/* We might have set this earlier in cp_finish_decl.  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If we already know how we're handling this class, handle debug info      the same way.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* else don't set it.  */
block|}
comment|/* If the class has a vtable, write out the debug info along with      the vtable.  */
elseif|else
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, just emit the debug info normally.  */
block|}
end_function

begin_comment
comment|/* Note that we want debugging information for a base class of a class    whose vtable is being emitted.  Normally, this would happen because    calling the constructor for a derived class implies calling the    constructors for all bases, which involve initializing the    appropriate vptr with the vtable for the base class; but in the    presence of optimization, this initialization may be optimized    away, so we tell finish_vtable_vardecl that we want the debugging    information anyway.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_debug_mark
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns BINFO if we haven't already noted that we want debugging    info for this base class.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_debug_unmarkedp
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the debugging information for TYPE, whose vtable is being    emitted.  Also walk through our bases and note that we want to    write out information for them.  This avoids the problem of not    writing any debug info for intermediate basetypes whose    constructors, and thus the references to their vtables, and thus    the vtables themselves, were optimized away.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|type
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|dfs_debug_unmarkedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_function
specifier|static
name|void
name|setup_class_bindings
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|type_binding_p
parameter_list|)
block|{
name|tree
name|type_binding
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|value_binding
decl_stmt|;
comment|/* If we've already done the lookup for this declaration, we're      done.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
comment|/* First, deal with the type binding.  */
if|if
condition|(
name|type_binding_p
condition|)
block|{
name|type_binding
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|type_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|type_binding
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|type_binding
argument_list|)
expr_stmt|;
block|}
comment|/* Now, do the value binding.  */
name|value_binding
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_binding_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|value_binding
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|value_binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
comment|/* We found a type-binding, even when looking for a non-type        binding.  This means that we already processed this binding        above.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|value_binding
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|value_binding
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|BASELINK_P
argument_list|(
name|value_binding
argument_list|)
condition|)
comment|/* NAME is some overloaded functions.  */
name|value_binding
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
comment|/* Two conversion operators that convert to the same type 	     may have different names.  (See 	     mangle_conv_op_name_for_type.)  To avoid recording the 	     same conversion operator declaration more than once we 	     must check to see that the same operator was not already 	     found under another name.  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|value_binding
argument_list|)
condition|)
block|{
name|tree
name|fns
decl_stmt|;
for|for
control|(
name|fns
operator|=
name|value_binding
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return;
block|}
name|pushdecl_class_level
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Push class-level declarations for any names appearing in BINFO that    are TYPE_DECLS.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_push_type_decls
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
operator|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|fields
argument_list|)
operator|)
condition|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't just use BINFO_MARKED because envelope_add_decl uses      DERIVED_FROM_P, which calls get_base_distance.  */
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Push class-level declarations for any names appearing in BINFO that    are not TYPE_DECLS.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_push_decls
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|USING_DECL
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fields
argument_list|)
condition|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|dfs_push_decls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|method_vec
operator|=
operator|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|method_vec
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|tree
modifier|*
name|methods
decl_stmt|;
name|tree
modifier|*
name|end
decl_stmt|;
comment|/* Farm out constructors and destructors.  */
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
for|for
control|(
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
init|;
name|methods
operator|<
name|end
operator|&&
operator|*
name|methods
condition|;
name|methods
operator|++
control|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
comment|/* Enter type declarations and mark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_push_type_decls
argument_list|,
name|unmarked_pushdecls_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enter non-type declarations and unmark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_push_decls
argument_list|,
name|marked_pushdecls_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_unuse_fields
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|fields
argument_list|)
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|unuse_fields
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unuse_fields
argument_list|,
name|unmarkedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We haven't pushed a search level when dealing with cached classes,      so we'd better not try to pop it.  */
if|if
condition|(
name|search_stack
condition|)
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* GATHER_STATISTICS */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
specifier|static
name|tree
name|add_conversions
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|conversions
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Some builtin types have no method vector, not even an empty one.  */
if|if
condition|(
operator|!
name|method_vec
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmp
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|||
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
break|break;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we don't already have this conversion.  */
if|if
condition|(
operator|!
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Make sure that we do not already have a conversion 	     operator for this type.  Merely checking the NAME is not 	     enough because two conversion operators to the same type 	     may not have the same NAME.  */
for|for
control|(
name|t
operator|=
operator|*
name|conversions
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|fn
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|DECL_CONV_FN_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|fn
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|t
condition|)
block|{
operator|*
name|conversions
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|tmp
argument_list|,
operator|*
name|conversions
argument_list|)
expr_stmt|;
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a TREE_LIST containing all the non-hidden user-defined    conversion functions for TYPE (and its base-classes).  The    TREE_VALUE of each node is a FUNCTION_DECL or an OVERLOAD    containing the conversion functions.  The TREE_PURPOSE is the BINFO    from which the conversion functions in this node were selected.  */
end_comment

begin_function
name|tree
name|lookup_conversions
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|conversions
init|=
name|NULL_TREE
decl_stmt|;
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|add_conversions
argument_list|,
literal|0
argument_list|,
operator|&
name|conversions
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|conversions
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_MARKED
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|conversions
return|;
block|}
end_function

begin_struct
struct|struct
name|overlap_info
block|{
name|tree
name|compare_type
decl_stmt|;
name|int
name|found_overlap
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Check whether the empty class indicated by EMPTY_BINFO is also present    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_check_overlap
parameter_list|(
name|tree
name|empty_binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|overlap_info
modifier|*
name|oi
init|=
operator|(
expr|struct
name|overlap_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|oi
operator|->
name|compare_type
argument_list|)
init|;
condition|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|empty_binfo
argument_list|)
condition|)
block|{
name|oi
operator|->
name|found_overlap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Trivial function to stop base traversal when we find something.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_no_overlap_yet
parameter_list|(
name|tree
name|derived
parameter_list|,
name|int
name|ix
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|BINFO_BASETYPE
argument_list|(
name|derived
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|struct
name|overlap_info
modifier|*
name|oi
init|=
operator|(
expr|struct
name|overlap_info
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|!
name|oi
operator|->
name|found_overlap
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at    offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */
end_comment

begin_function
name|int
name|types_overlap_p
parameter_list|(
name|tree
name|empty_type
parameter_list|,
name|tree
name|next_type
parameter_list|)
block|{
name|struct
name|overlap_info
name|oi
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|next_type
argument_list|)
condition|)
return|return
literal|0
return|;
name|oi
operator|.
name|compare_type
operator|=
name|next_type
expr_stmt|;
name|oi
operator|.
name|found_overlap
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|empty_type
argument_list|)
argument_list|,
name|dfs_check_overlap
argument_list|,
name|dfs_no_overlap_yet
argument_list|,
operator|&
name|oi
argument_list|)
expr_stmt|;
return|return
name|oi
operator|.
name|found_overlap
return|;
block|}
end_function

begin_comment
comment|/* Given a vtable VAR, determine which of the inherited classes the vtable    inherits (in a loose sense) functions from.     FIXME: This does not work with the new ABI.  */
end_comment

begin_function
name|tree
name|binfo_for_vtable
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|main_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_binfo
operator|!=
name|NULL_TREE
operator|&&
name|BINFO_VTABLE
argument_list|(
name|base_binfo
argument_list|)
operator|==
name|var
condition|)
return|return
name|base_binfo
return|;
block|}
comment|/* If no secondary base classes matched, return the primary base, if      there is one.  */
if|if
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
condition|)
return|return
name|get_primary_binfo
argument_list|(
name|main_binfo
argument_list|)
return|;
return|return
name|main_binfo
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo of the first direct or indirect virtual base derived    from BINFO, or NULL if binfo is not via virtual.  */
end_comment

begin_function
name|tree
name|binfo_from_vbase
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
for|for
control|(
init|;
name|binfo
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo of the first direct or indirect virtual base derived    from BINFO up to the TREE_TYPE, LIMIT, or NULL if binfo is not    via virtual.  */
end_comment

begin_function
name|tree
name|binfo_via_virtual
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|limit
parameter_list|)
block|{
for|for
control|(
init|;
name|binfo
operator|&&
operator|(
operator|!
name|limit
operator|||
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|limit
argument_list|)
operator|)
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* BINFO is a base binfo in the complete type BINFO_TYPE (HERE).    Find the equivalent binfo within whatever graph HERE is located.    This is the inverse of original_binfo.  */
end_comment

begin_function
name|tree
name|copied_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|here
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|here
init|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
continue|continue;
name|result
operator|=
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|base_binfos
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|n
decl_stmt|;
name|base_binfos
operator|=
name|copied_binfo
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|here
argument_list|)
expr_stmt|;
name|base_binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|base_binfos
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|n
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|base
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|base
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|20030202
argument_list|)
expr_stmt|;
name|result
operator|=
name|here
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|result
argument_list|,
literal|20030202
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* BINFO is some base binfo of HERE, within some other    hierarchy. Return the equivalent binfo, but in the hierarchy    dominated by HERE.  This is the inverse of copied_binfo.  If BINFO    is not a base binfo of HERE, returns NULL_TREE.  */
end_comment

begin_function
name|tree
name|original_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|here
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
condition|)
name|result
operator|=
name|here
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|purpose_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|result
operator|=
name|TREE_VALUE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|base_binfos
decl_stmt|;
name|base_binfos
operator|=
name|original_binfo
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|here
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfos
condition|)
block|{
name|int
name|ix
decl_stmt|,
name|n
decl_stmt|;
name|base_binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|base_binfos
argument_list|)
expr_stmt|;
name|n
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|base_binfos
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|n
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|base
init|=
name|TREE_VEC_ELT
argument_list|(
name|base_binfos
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|result
operator|=
name|base
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

