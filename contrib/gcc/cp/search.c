begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 89, 92-96, 1997 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|obstack
parameter_list|,
name|tp
parameter_list|,
name|size
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Sony NewsOS 5.0 compiler doesn't like void * here.  */
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
operator|-
name|size
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_memoized_cache
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|make_memoized_table_entry
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_abstract_virtuals_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_vbase_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_pointer_to_vbase
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_pointer_to_single_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_fnfields_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_fnfields_here
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_subobject_of_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hides
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|virtual_context
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_template_base_recursive
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_walk
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_check_overlap
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dfs_no_overlap_yet
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|envelope_add_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_base_distance_recursive
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_upcast_fixups
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_virtual_upcast_offsets
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|markedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unmarkedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MI_MATRIX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|numberedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unnumberedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|marked_vtable_pathp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unmarked_vtable_pathp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|marked_new_vtablep
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unmarked_new_vtablep
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dfs_debug_unmarkedp
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MI_MATRIX
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|dfs_number
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_unnumber
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_record_inheritance
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dfs_debug_mark
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_find_vbases
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_clear_vbase_slots
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_unmark
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_init_vbase_pointers
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_get_vbase_types
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_pushdecls
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_compress_decls
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dfs_unuse_fields
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_conversions
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_virtuals_named_this
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_virtual_destructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tree_has_any_destructor_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|covariant_return_p
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|push_type_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|pop_type_level
name|PROTO
argument_list|(
operator|(
expr|struct
name|type_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|my_tree_cons
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|my_build_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|memoized_entry
modifier|*
name|my_new_memoized_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|breadth_first_search
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|int
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|int
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_decl_ptr_intermediate
decl_stmt|,
name|vbase_decl_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|vbase_init_result
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
parameter_list|(
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|obstack
decl_stmt|;
block|{
specifier|register
name|struct
name|search_level
modifier|*
name|stack
init|=
name|pop_stack_level
argument_list|(
name|obstack
argument_list|)
decl_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search memoization.  */
end_comment

begin_struct
struct|struct
name|type_level
block|{
name|struct
name|stack_level
name|base
decl_stmt|;
comment|/* First object allocated in obstack of entries.  */
name|char
modifier|*
name|entries
decl_stmt|;
comment|/* Number of types memoized in this context.  */
name|int
name|len
decl_stmt|;
comment|/* Type being memoized; save this if we are saving      memoized contexts.  */
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack used for memoizing member and member function lookup.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|type_obstack
decl_stmt|,
name|type_obstack_entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|type_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_vptr_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make things that look like tree nodes, but allocate them    on type_obstack_entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_tree_node_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_memoize_lookups
decl_stmt|,
name|flag_save_memoized_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|my_memoized_entry_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fast_finds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_adds
index|[
literal|2
index|]
decl_stmt|,
name|memoized_fast_rejects
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memoized_fields_searched
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GATHER_STATISTICS */
end_comment

begin_comment
comment|/* Local variables to help save memoization contexts.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|prev_type_memoized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type_level
modifier|*
name|prev_type_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This list is used by push_class_decls to know what decls need to    be pushed into class scope.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|closed_envelopes
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of type memoization context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|push_type_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|type_level
name|tem
decl_stmt|;
name|tem
operator|.
name|base
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|entries
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
name|tem
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|tem
operator|.
name|type
operator|=
name|NULL_TREE
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of type memoization context.  */
end_comment

begin_function
specifier|static
name|struct
name|type_level
modifier|*
name|pop_type_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|type_level
modifier|*
name|stack
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
name|stack
operator|->
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|pop_stack_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|stack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make something that looks like a TREE_LIST, but    do it on the type_obstack_entries obstack.  */
end_comment

begin_function
specifier|static
name|tree
name|my_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
name|tree
name|p
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|type_obstack_entries
expr_stmt|;
name|p
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
operator|++
name|my_tree_node_counter
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|tree
name|p
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_string
argument_list|)
argument_list|)
decl_stmt|;
operator|++
name|my_tree_node_counter
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|p
argument_list|,
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|p
argument_list|)
operator|=
name|str
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|p
argument_list|)
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memoizing machinery to make searches for multiple inheritance    reasonably efficient.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZE_HASHSIZE
value|8
end_define

begin_typedef
typedef|typedef
struct|struct
name|memoized_entry
block|{
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|tree
name|data_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
name|tree
name|function_members
index|[
name|MEMOIZE_HASHSIZE
index|]
decl_stmt|;
block|}
typedef|*
name|ME
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MEMOIZED_CHAIN
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->chain)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_UID
parameter_list|(
name|ENTRY
parameter_list|)
value|(((ME)ENTRY)->uid)
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->data_members[INDEX])
end_define

begin_define
define|#
directive|define
name|MEMOIZED_FNFIELDS
parameter_list|(
name|ENTRY
parameter_list|,
name|INDEX
parameter_list|)
value|(((ME)ENTRY)->function_members[INDEX])
end_define

begin_comment
comment|/* The following is probably a lousy hash function.  */
end_comment

begin_define
define|#
directive|define
name|MEMOIZED_HASH_FN
parameter_list|(
name|NODE
parameter_list|)
value|(((long)(NODE)>>4)&(MEMOIZE_HASHSIZE - 1))
end_define

begin_function
specifier|static
name|struct
name|memoized_entry
modifier|*
name|my_new_memoized_entry
parameter_list|(
name|chain
parameter_list|)
name|struct
name|memoized_entry
modifier|*
name|chain
decl_stmt|;
block|{
name|struct
name|memoized_entry
modifier|*
name|p
init|=
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|type_obstack_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
argument_list|)
argument_list|)
expr_stmt|;
name|MEMOIZED_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|chain
expr_stmt|;
name|MEMOIZED_UID
argument_list|(
name|p
argument_list|)
operator|=
operator|++
name|my_memoized_entry_counter
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Clears the deferred pop from pop_memoized_context, if any.  */
end_comment

begin_function
specifier|static
name|void
name|clear_memoized_cache
parameter_list|()
block|{
if|if
condition|(
name|prev_type_stack
condition|)
block|{
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|prev_type_stack
argument_list|)
expr_stmt|;
name|prev_type_memoized
operator|=
literal|0
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make an entry in the memoized table for type TYPE    that the entry for NAME is FIELD.  */
end_comment

begin_function
specifier|static
name|tree
name|make_memoized_table_entry
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|function_p
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
name|int
name|function_p
decl_stmt|;
block|{
name|int
name|idx
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|entry
decl_stmt|,
modifier|*
name|prev_entry
decl_stmt|;
comment|/* Since we allocate from the type_obstack, we must pop any deferred      levels.  */
name|clear_memoized_cache
argument_list|()
expr_stmt|;
name|memoized_adds
index|[
name|function_p
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|type_obstack
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memoized_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|my_new_memoized_entry
argument_list|(
operator|(
expr|struct
name|memoized_entry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|type_stack
operator|->
name|len
operator|*
literal|2
operator|>=
name|type_stack
operator|->
name|base
operator|.
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|88
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|function_p
condition|)
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|prev_entry
operator|=
operator|&
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|entry
operator|=
name|my_tree_cons
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|,
operator|*
name|prev_entry
argument_list|)
expr_stmt|;
operator|*
name|prev_entry
operator|=
name|entry
expr_stmt|;
comment|/* Don't know the error message to give yet.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* When a new function or class context is entered, we build    a table of types which have been searched for members.    The table is an array (obstack) of types.  When a type is    entered into the obstack, its CLASSTYPE_MTABLE_ENTRY    field is set to point to a new record, of type struct memoized_entry.     A non-NULL TREE_TYPE of the entry contains an access control error message.     The slots for the data members are arrays of tree nodes.    These tree nodes are lists, with the TREE_PURPOSE    of this list the known member name, and the TREE_VALUE    as the FIELD_DECL for the member.     For member functions, the TREE_PURPOSE is again the    name of the member functions for that class,    and the TREE_VALUE of the list is a pairs    whose TREE_PURPOSE is a member functions of this name,    and whose TREE_VALUE is a list of known argument lists this    member function has been called with.  The TREE_TYPE of the pair,    if non-NULL, is an error message to print.  */
end_comment

begin_comment
comment|/* Tell search machinery that we are entering a new context, and    to update tables appropriately.     TYPE is the type of the context we are entering, which can    be NULL_TREE if we are not in a class's scope.     USE_OLD, if nonzero tries to use previous context.  */
end_comment

begin_function
name|void
name|push_memoized_context
parameter_list|(
name|type
parameter_list|,
name|use_old
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|prev_type_stack
condition|)
block|{
if|if
condition|(
name|use_old
operator|&&
name|prev_type_memoized
operator|==
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_contexts_saved
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|type_stack
operator|=
name|prev_type_stack
expr_stmt|;
name|prev_type_stack
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, need to pop old stack here.  */
name|clear_memoized_cache
argument_list|()
expr_stmt|;
block|}
name|type_stack
operator|=
name|push_type_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
name|type_stack
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|type_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell search machinery that we have left a context.    We do not currently save these contexts for later use.    If we wanted to, we could not use pop_search_level, since    poping that level allows the data we have collected to    be clobbered; a stack of obstacks would be needed.  */
end_comment

begin_function
name|void
name|pop_memoized_context
parameter_list|(
name|use_old
parameter_list|)
name|int
name|use_old
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|tree
modifier|*
name|tem
init|=
operator|&
name|type_stack
operator|->
name|base
operator|.
name|first
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flag_save_memoized_contexts
condition|)
name|use_old
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|use_old
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|tem
index|[
name|len
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|tree
operator|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* If there was a deferred pop, we need to pop it now.  */
name|clear_memoized_cache
argument_list|()
expr_stmt|;
name|prev_type_stack
operator|=
name|type_stack
expr_stmt|;
name|prev_type_memoized
operator|=
name|type_stack
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|len
operator|=
name|type_stack
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|MEMOIZED_CHAIN
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|tem
index|[
name|len
operator|*
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_old
condition|)
name|type_stack
operator|=
name|pop_type_level
argument_list|(
name|type_stack
argument_list|)
expr_stmt|;
else|else
name|type_stack
operator|=
operator|(
expr|struct
name|type_level
operator|*
operator|)
name|type_stack
operator|->
name|base
operator|.
name|prev
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get a virtual binfo that is found inside BINFO's hierarchy that is    the same type as the type given in PARENT.  To be optimal, we want    the first one that is found by going through the least number of    virtual bases.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vbase_1
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|depth
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|unsigned
name|int
modifier|*
name|depth
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
operator|*
name|depth
operator|=
literal|0
expr_stmt|;
return|return
name|binfo
return|;
block|}
operator|*
name|depth
operator|=
operator|*
name|depth
operator|-
literal|1
expr_stmt|;
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|nrval
decl_stmt|;
if|if
condition|(
operator|*
name|depth
operator|==
literal|0
condition|)
break|break;
name|nrval
operator|=
name|get_vbase_1
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrval
condition|)
name|rval
operator|=
name|nrval
expr_stmt|;
block|}
operator|*
name|depth
operator|=
operator|*
name|depth
operator|+
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|get_vbase
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|parent
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|unsigned
name|int
name|d
init|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
decl_stmt|;
return|return
name|get_vbase_1
argument_list|(
name|parent
argument_list|,
name|binfo
argument_list|,
operator|&
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to a virtual base class of type TYPE.  We know that    EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that    the type of what expr points to has a virtual base of type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_pointer_to_vbase
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|vb
init|=
name|get_vbase
argument_list|(
name|type
argument_list|,
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|convert_pointer_to_real
argument_list|(
name|vb
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether the type given in BINFO is derived from PARENT.  If    it isn't, return 0.  If it is, but the derivation is MI-ambiguous    AND protect != 0, emit an error message and return error_mark_node.     Otherwise, if TYPE is derived from PARENT, return the actual base    information, unless a one of the protection violations below    occurs, in which case emit an error message and return error_mark_node.     If PROTECT is 1, then check if access to a public field of PARENT    would be private.  Also check for ambiguity.  */
end_comment

begin_function
name|tree
name|get_binfo
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|dist
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|parent
operator|=
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|89
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|binfo
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|90
argument_list|)
expr_stmt|;
name|dist
operator|=
name|get_base_distance
argument_list|(
name|parent
argument_list|,
name|binfo
argument_list|,
name|protect
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|==
operator|-
literal|3
condition|)
block|{
name|cp_error
argument_list|(
literal|"fields of `%T' are inaccessible in `%T' due to private inheritance"
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|dist
operator|==
operator|-
literal|2
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' is ambiguous base class for type `%T'"
argument_list|,
name|parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* This is the newer depth first get_base_distance routine.  */
end_comment

begin_function
specifier|static
name|int
name|get_base_distance_recursive
parameter_list|(
name|binfo
parameter_list|,
name|depth
parameter_list|,
name|is_private
parameter_list|,
name|rval
parameter_list|,
name|rval_private_ptr
parameter_list|,
name|new_binfo_ptr
parameter_list|,
name|parent
parameter_list|,
name|path_ptr
parameter_list|,
name|protect
parameter_list|,
name|via_virtual_ptr
parameter_list|,
name|via_virtual
parameter_list|,
name|current_scope_in_chain
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|is_private
decl_stmt|,
name|rval
decl_stmt|;
name|int
modifier|*
name|rval_private_ptr
decl_stmt|;
name|tree
modifier|*
name|new_binfo_ptr
decl_stmt|,
name|parent
decl_stmt|,
decl|*
name|path_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|protect
decl_stmt|,
modifier|*
name|via_virtual_ptr
decl_stmt|,
name|via_virtual
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_scope_in_chain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
if|if
condition|(
name|protect
operator|&&
operator|!
name|current_scope_in_chain
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
name|current_scope_in_chain
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|parent
operator|||
name|binfo
operator|==
name|parent
condition|)
block|{
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|depth
expr_stmt|;
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
else|else
block|{
name|int
name|same_object
init|=
operator|(
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
operator|*
name|new_binfo_ptr
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|*
name|via_virtual_ptr
operator|&&
name|via_virtual
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|via_virtual_ptr
operator|&&
name|via_virtual
operator|==
literal|0
condition|)
block|{
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|same_object
condition|)
block|{
if|if
condition|(
operator|*
name|rval_private_ptr
operator|&&
operator|!
name|is_private
condition|)
block|{
operator|*
name|rval_private_ptr
operator|=
name|is_private
expr_stmt|;
operator|*
name|new_binfo_ptr
operator|=
name|binfo
expr_stmt|;
operator|*
name|via_virtual_ptr
operator|=
name|via_virtual
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
name|rval
operator|=
operator|-
literal|2
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
name|depth
operator|+=
literal|1
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Find any specific instance of a virtual base, when searching with 	 a binfo...  */
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|int
name|via_private
init|=
operator|(
name|protect
operator|&&
operator|(
name|is_private
operator|||
operator|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|current_scope_in_chain
operator|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|this_virtual
init|=
name|via_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|int
name|was
decl_stmt|;
comment|/* When searching for a non-virtual, we cannot mark 	     virtually found binfos.  */
if|if
condition|(
operator|!
name|this_virtual
condition|)
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
define|#
directive|define
name|WATCH_VALUES
parameter_list|(
name|rval
parameter_list|,
name|via_private
parameter_list|)
value|(rval == -1 ? 3 : via_private)
name|was
operator|=
name|WATCH_VALUES
argument_list|(
name|rval
argument_list|,
operator|*
name|via_virtual_ptr
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_base_distance_recursive
argument_list|(
name|base_binfo
argument_list|,
name|depth
argument_list|,
name|via_private
argument_list|,
name|rval
argument_list|,
name|rval_private_ptr
argument_list|,
name|new_binfo_ptr
argument_list|,
name|parent
argument_list|,
name|path_ptr
argument_list|,
name|protect
argument_list|,
name|via_virtual_ptr
argument_list|,
name|this_virtual
argument_list|,
name|current_scope_in_chain
argument_list|)
expr_stmt|;
comment|/* watch for updates; only update if path is good.  */
if|if
condition|(
name|path_ptr
operator|&&
name|WATCH_VALUES
argument_list|(
name|rval
argument_list|,
operator|*
name|via_virtual_ptr
argument_list|)
operator|!=
name|was
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
operator|&&
operator|*
name|via_virtual_ptr
operator|==
literal|0
condition|)
return|return
name|rval
return|;
undef|#
directive|undef
name|WATCH_VALUES
block|}
block|}
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Return the number of levels between type PARENT and the type given    in BINFO, following the leftmost path to PARENT not found along a    virtual path, if there are no real PARENTs (all come from virtual    base classes), then follow the leftmost path to PARENT.     Return -1 if TYPE is not derived from PARENT.    Return -2 if PARENT is an ambiguous base class of TYPE, and PROTECT is     non-negative.    Return -3 if PARENT is private to TYPE, and PROTECT is non-zero.     If PATH_PTR is non-NULL, then also build the list of types    from PARENT to TYPE, with TREE_VIA_VIRTUAL and TREE_VIA_PUBLIC    set.     PARENT can also be a binfo, in which case that exact parent is found    and no other.  convert_pointer_to_real uses this functionality.     If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.  */
end_comment

begin_function
name|int
name|get_base_distance
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|protect
parameter_list|,
name|path_ptr
parameter_list|)
specifier|register
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|protect
decl_stmt|;
name|tree
modifier|*
name|path_ptr
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|int
name|rval_private
init|=
literal|0
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|new_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|via_virtual
decl_stmt|;
name|int
name|watch_access
init|=
name|protect
decl_stmt|;
comment|/* Should we be completing types here?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|parent
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|complete_type
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_ptr
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|type
operator|||
name|parent
operator|==
name|binfo
condition|)
block|{
comment|/* If the distance is 0, then we don't really need 	 a path pointer, but we shouldn't let garbage go back.  */
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|binfo
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|path_ptr
condition|)
name|watch_access
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|get_base_distance_recursive
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|rval_private
argument_list|,
operator|&
name|new_binfo
argument_list|,
name|parent
argument_list|,
name|path_ptr
argument_list|,
name|watch_access
argument_list|,
operator|&
name|via_virtual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
comment|/* Access restrictions don't count if we found an ambiguous basetype.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|2
operator|&&
name|protect
operator|>=
literal|0
condition|)
name|rval_private
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
name|rval_private
condition|)
return|return
operator|-
literal|3
return|;
comment|/* find real virtual base classes.  */
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
operator|&&
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|parent
operator|==
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|parent
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|new_binfo
operator|=
name|parent
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|path_ptr
condition|)
operator|*
name|path_ptr
operator|=
name|new_binfo
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance lattice    specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return the FIELD_DECL.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller must    figure out whether it can access this field.  (Since it is only one    level, this is reasonable.)  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
comment|/* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM are not fields at all;        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,        the code often worked even when we treated the index as a list        of fields!)  */
return|return
name|NULL_TREE
return|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
while|while
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|NULL
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|field
return|;
block|}
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|_vptr_name
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* There are a number of cases we need to be aware of here: 			 current_class_type	current_function_decl      global			NULL			NULL      fn-local			NULL			SET      class-local		SET			NULL      class->fn			SET			SET      fn->class			SET			SET     Those last two make life interesting.  If we're in a function which is    itself inside a class, we need decls to go into the fn's decls (our    second case below).  But if we're in a class and the class itself is    inside a function, we need decls to go into the decls for the class.  To    achieve this last goal, we must see if, when both current_class_ptr and    current_function_decl are set, the class was declared inside that    function.  If so, we know to put the decls into the class's scope.  */
end_comment

begin_function
name|tree
name|current_scope
parameter_list|()
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|current_class_type
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
name|current_function_decl
return|;
if|if
condition|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|current_function_decl
return|;
return|return
name|current_class_type
return|;
block|}
end_function

begin_comment
comment|/* Compute the access of FIELD.  This is done by computing    the access available to each type in BASETYPES (which comes    as a list of [via_public/basetype] in reverse order, namely base    class before derived class).  The first one which defines a    access defines the access for the field.  Otherwise, the    access of the field is that which occurs normally.     Uses global variables CURRENT_CLASS_TYPE and    CURRENT_FUNCTION_DECL to use friend relationships    if necessary.     This will be static when lookup_fnfield comes into this file.     access_public_node means that the field can be accessed by the current lexical    scope.     access_protected_node means that the field cannot be accessed by the current    lexical scope because it is protected.     access_private_node means that the field cannot be accessed by the current    lexical scope because it is private.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|PUBLIC_RETURN
value|return (DECL_PUBLIC (field) = 1), access_public_node
end_define

begin_define
define|#
directive|define
name|PROTECTED_RETURN
value|return (DECL_PROTECTED (field) = 1), access_protected_node
end_define

begin_define
define|#
directive|define
name|PRIVATE_RETURN
value|return (DECL_PRIVATE (field) = 1), access_private_node
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PUBLIC_RETURN
value|return access_public_node
end_define

begin_define
define|#
directive|define
name|PROTECTED_RETURN
value|return access_protected_node
end_define

begin_define
define|#
directive|define
name|PRIVATE_RETURN
value|return access_private_node
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Disabled with DECL_PUBLIC&c.  */
end_comment

begin_endif
unit|static tree previous_scope = NULL_TREE;
endif|#
directive|endif
end_endif

begin_function
name|tree
name|compute_access
parameter_list|(
name|basetype_path
parameter_list|,
name|field
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|field
decl_stmt|;
block|{
name|tree
name|access
decl_stmt|;
name|tree
name|types
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|protected_ok
decl_stmt|,
name|via_protected
decl_stmt|;
specifier|extern
name|int
name|flag_access_control
decl_stmt|;
if|#
directive|if
literal|1
comment|/* Replaces static decl above.  */
name|tree
name|previous_scope
decl_stmt|;
endif|#
directive|endif
name|int
name|static_mem
init|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|field
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_access_control
condition|)
return|return
name|access_public_node
return|;
comment|/* The field lives in the current class.  */
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|access_public_node
return|;
if|#
directive|if
literal|0
comment|/* Disabled until pushing function scope clears these out.  If ever.  */
comment|/* Make these special cases fast.  */
block|if (current_scope () == previous_scope)     {       if (DECL_PUBLIC (field)) 	return access_public_node;       if (DECL_PROTECTED (field)) 	return access_protected_node;       if (DECL_PRIVATE (field)) 	return access_private_node;     }
endif|#
directive|endif
comment|/* We don't currently support access control on nested types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|access_public_node
return|;
name|previous_scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
name|context
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Fields coming from nested anonymous unions have their DECL_CLASS_CONTEXT      slot set to the union type rather than the record type containing      the anonymous union.  */
if|if
condition|(
name|context
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Virtual function tables are never private.  But we should know that      we are looking for this, and not even try to hide it.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|&&
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* Member found immediately within object.  */
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Are we (or an enclosing scope) friends with the class that has          FIELD? */
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|previous_scope
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
comment|/* If it's private, it's private, you letch.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|PRIVATE_RETURN
expr_stmt|;
comment|/* ARM $11.5.  Member functions of a derived class can access the 	 non-static protected members of a base class only through a 	 pointer to the derived class, a reference to it, or an object 	 of it. Also any subsequently derived classes also have 	 access.  */
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|&&
operator|(
name|static_mem
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|field
argument_list|)
operator|)
operator|&&
name|ACCESSIBLY_DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|PUBLIC_RETURN
expr_stmt|;
else|else
name|PROTECTED_RETURN
expr_stmt|;
block|}
else|else
name|PUBLIC_RETURN
expr_stmt|;
block|}
comment|/* must reverse more than one element */
name|basetype_path
operator|=
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|types
operator|=
name|basetype_path
expr_stmt|;
name|via_protected
operator|=
literal|0
expr_stmt|;
name|access
operator|=
name|access_default_node
expr_stmt|;
name|protected_ok
operator|=
name|static_mem
operator|&&
name|current_class_type
operator|&&
name|ACCESSIBLY_DERIVED_FROM_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|types
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|binfo
init|=
name|types
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|private_ok
init|=
literal|0
decl_stmt|;
comment|/* Friends of a class can see protected members of its bases.          Note that classes are their own friends.  */
if|if
condition|(
name|is_friend
argument_list|(
name|type
argument_list|,
name|previous_scope
argument_list|)
condition|)
block|{
name|protected_ok
operator|=
literal|1
expr_stmt|;
name|private_ok
operator|=
literal|1
expr_stmt|;
block|}
name|member
operator|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_ACCESS
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
name|access
operator|=
name|TREE_VALUE
argument_list|(
name|member
argument_list|)
expr_stmt|;
break|break;
block|}
name|types
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* If the next type was VIA_PROTECTED, then fields of all remaining 	 classes past that one are *at least* protected.  */
if|if
condition|(
name|types
condition|)
block|{
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|types
argument_list|)
condition|)
name|via_protected
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|types
argument_list|)
operator|&&
operator|!
name|private_ok
condition|)
block|{
name|access
operator|=
name|access_private_node
expr_stmt|;
break|break;
block|}
block|}
else|else
break|break;
block|}
name|reverse_path
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* No special visibilities apply.  Use normal rules.  */
if|if
condition|(
name|access
operator|==
name|access_default_node
condition|)
block|{
if|if
condition|(
name|is_friend
argument_list|(
name|context
argument_list|,
name|previous_scope
argument_list|)
condition|)
name|access
operator|=
name|access_public_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|access
operator|=
name|access_private_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
name|access
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|access
operator|=
name|access_public_node
expr_stmt|;
block|}
if|if
condition|(
name|access
operator|==
name|access_public_node
operator|&&
name|via_protected
condition|)
name|access
operator|=
name|access_protected_node
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_protected_node
operator|&&
name|protected_ok
condition|)
name|access
operator|=
name|access_public_node
expr_stmt|;
if|#
directive|if
literal|0
block|if (access == access_public_node)     DECL_PUBLIC (field) = 1;   else if (access == access_protected_node)     DECL_PROTECTED (field) = 1;   else if (access == access_private_node)     DECL_PRIVATE (field) = 1;   else my_friendly_abort (96);
endif|#
directive|endif
return|return
name|access
return|;
block|}
end_function

begin_comment
comment|/* Routine to see if the sub-object denoted by the binfo PARENT can be    found as a base class and sub-object of the object denoted by    BINFO.  This routine relies upon binfos not being shared, except    for binfos for virtual bases.  */
end_comment

begin_function
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|binfo
condition|)
return|return
literal|1
return|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|base_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|parent
argument_list|,
name|base_binfo
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See if a one FIELD_DECL hides another.  This routine is meant to    correspond to ANSI working paper Sept 17, 1992 10p4.  The two    binfos given are the binfos corresponding to the particular places    the FIELD_DECLs are found.  This routine relies upon binfos not    being shared, except for virtual bases.  */
end_comment

begin_function
specifier|static
name|int
name|hides
parameter_list|(
name|hider_binfo
parameter_list|,
name|hidee_binfo
parameter_list|)
name|tree
name|hider_binfo
decl_stmt|,
name|hidee_binfo
decl_stmt|;
block|{
comment|/* hider hides hidee, if hider has hidee as a base class and      the instance of hidee is a sub-object of hider.  The first      part is always true is the second part is true.       When hider and hidee are the same (two ways to get to the exact      same member) we consider either one as hiding the other.  */
return|return
name|is_subobject_of_p
argument_list|(
name|hidee_binfo
argument_list|,
name|hider_binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Very similar to lookup_fnfields_1 but it ensures that at least one    function was declared inside the class given by TYPE.  It really should    only return functions that match the given TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_here
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|int
name|idx
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|tree
name|fndecls
decl_stmt|;
comment|/* ctors and dtors are always only in the right class.  */
if|if
condition|(
name|idx
operator|<=
literal|1
condition|)
return|return
name|idx
return|;
name|fndecls
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecls
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|idx
return|;
name|fndecls
operator|=
name|OVL_CHAIN
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look for a field named NAME in an inheritance lattice dominated by    XBASETYPE.  PROTECT is zero if we can avoid computing access    information, otherwise it is 1.  WANT_TYPE is 1 when we should only    return TYPE_DECLs, if no TYPE_DECL can be found return NULL_TREE.     It was not clear what should happen if WANT_TYPE is set, and an    ambiguity is found.  At least one use (lookup_name) to not see    the error.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|,
name|rval_binfo_h
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|basetype_chain
decl_stmt|,
name|basetype_path
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|this_v
init|=
name|access_default_node
decl_stmt|;
name|tree
name|entry
decl_stmt|,
name|binfo
decl_stmt|,
name|binfo_h
decl_stmt|;
name|tree
name|own_access
init|=
name|access_default_node
decl_stmt|;
name|int
name|vbase_name_p
init|=
name|VBASE_NAME_P
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just non-function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      non-function member is found.  */
comment|/* rval_binfo_h and binfo_h are binfo values used when we perform the      hiding checks, as virtual base classes may not be shared.  The strategy      is we always go into the binfo hierarchy owned by TYPE_BINFO of      virtual base classes, as we cross virtual base class lines.  This way      we know that binfo of a virtual base class will always == itself when      found along any line.  (mrs)  */
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for access control.  */
name|int
name|idx
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* We cannot search for constructor/destructor names like this.  */
comment|/* This can't go here, but where should it go?  */
comment|/* If we are looking for a constructor in a templated type, use the      unspecialized name, as that is how we store it.  */
block|if (IDENTIFIER_TEMPLATE (name))     name = constructor_name (name);
endif|#
directive|endif
if|if
condition|(
name|xbasetype
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|xbasetype
argument_list|)
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|field
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
condition|)
return|return
name|field
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|xbasetype
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|97
argument_list|)
expr_stmt|;
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
else|else
name|memoized_fast_finds
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|protect
operator|&&
name|flag_memoize_lookups
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|||
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|want_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|rval
operator|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
name|rval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|protect
operator|&&
name|rval
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
operator||
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|)
name|this_v
operator|=
name|compute_access
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|this_v
operator|==
name|access_private_node
condition|)
name|errstr
operator|=
literal|"enum `%D' is a private value of class `%T'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_protected_node
condition|)
name|errstr
operator|=
literal|"enum `%D' is a protected value of class `%T'"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this_v
operator|==
name|access_private_node
condition|)
name|errstr
operator|=
literal|"member `%D' is a private member of class `%T'"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_protected_node
condition|)
name|errstr
operator|=
literal|"member `%D' is a protected member of class `%T'"
expr_stmt|;
block|}
block|}
name|rval_binfo
operator|=
name|basetype_path
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|basetype_chain
operator|=
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* The ambiguity check relies upon breadth first searching.  */
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|binfo_h
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|nval
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|SET_BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetype_chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
else|else
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|98
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetype_chain
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo_h
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact valid.  */
name|nval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|||
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|nval
operator|&&
name|nval
operator|==
name|rval
operator|&&
name|SHARED_MEMBER_P
argument_list|(
name|nval
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is the same [class.ambig] */
block|}
elseif|else
if|if
condition|(
name|rval_binfo
operator|&&
name|hides
argument_list|(
name|rval_binfo_h
argument_list|,
name|binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is in rval_binfo, not 		 here (binfo).  */
block|}
elseif|else
if|if
condition|(
name|rval_binfo
operator|==
name|NULL_TREE
operator|||
name|hides
argument_list|(
name|binfo_h
argument_list|,
name|rval_binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is here (binfo), not in 		 rval_binfo.  */
if|if
condition|(
name|nval
condition|)
block|{
name|rval
operator|=
name|nval
expr_stmt|;
if|if
condition|(
name|entry
operator|||
name|protect
condition|)
name|this_v
operator|=
name|compute_access
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* These may look ambiguous, but they really are not.  */
if|if
condition|(
name|vbase_name_p
condition|)
break|break;
block|}
else|else
block|{
comment|/* Undo finding it before, as something else hides it.  */
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
name|rval_binfo_h
operator|=
name|binfo_h
expr_stmt|;
block|}
else|else
block|{
comment|/* This is ambiguous.  */
name|errstr
operator|=
literal|"request for member `%D' is ambiguous"
expr_stmt|;
name|protect
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|rval_binfo
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|rval_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|want_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|rval
operator|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
name|rval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rval
operator|==
name|NULL_TREE
condition|)
name|errstr
operator|=
literal|0
expr_stmt|;
comment|/* If this FIELD_DECL defines its own access level, deal with that.  */
if|if
condition|(
name|rval
operator|&&
name|errstr
operator|==
literal|0
operator|&&
operator|(
operator|(
name|protect
operator|&
literal|1
operator|)
operator|||
name|entry
operator|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|rval
argument_list|)
operator|&&
name|DECL_ACCESS
argument_list|(
name|rval
argument_list|)
condition|)
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
comment|/* If is possible for one of the derived types on the path to 	       have defined special access for this field.  Look for such 	       declarations and report an error if a conflict is found.  */
name|tree
name|new_v
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|access_default_node
condition|)
name|new_v
operator|=
name|compute_access
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|access_default_node
operator|&&
name|new_v
operator|!=
name|this_v
condition|)
block|{
name|errstr
operator|=
literal|"conflicting access to member `%D'"
expr_stmt|;
name|this_v
operator|=
name|access_default_node
expr_stmt|;
block|}
name|own_access
operator|=
name|new_v
expr_stmt|;
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|own_access
operator|==
name|access_private_node
condition|)
name|errstr
operator|=
literal|"member `%D' declared private"
expr_stmt|;
elseif|else
if|if
condition|(
name|own_access
operator|==
name|access_protected_node
condition|)
name|errstr
operator|=
literal|"member `%D' declared protected"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_private_node
condition|)
name|errstr
operator|=
name|TREE_PRIVATE
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%D' is private"
else|:
literal|"member `%D' is from private base class"
expr_stmt|;
elseif|else
if|if
condition|(
name|this_v
operator|==
name|access_protected_node
condition|)
name|errstr
operator|=
name|TREE_PROTECTED
argument_list|(
name|rval
argument_list|)
condition|?
literal|"member `%D' is protected"
else|:
literal|"member `%D' is from protected base class"
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|protect
operator|==
literal|2
condition|)
block|{
comment|/* If we are not interested in ambiguities, don't report them, 	 just return NULL_TREE.  */
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|protect
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Do implicit typename stuff.  */
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|rval
argument_list|)
operator|&&
name|processing_template_decl
operator|&&
operator|!
name|currently_open_class
argument_list|(
name|BINFO_TYPE
argument_list|(
name|rval_binfo
argument_list|)
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|rval_binfo
expr_stmt|;
for|for
control|(
init|;
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
name|current_class_type
operator|)
condition|)
break|break;
name|entry
operator|=
name|make_typename_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Try to find NAME inside a nested class.  */
end_comment

begin_function
name|tree
name|lookup_nested_field
parameter_list|(
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|tree
name|id
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Climb our way up the nested ladder, seeing if we're trying to 	 modify a field in an enclosing class.  If so, we should only 	 be able to modify if it's static.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
break|break;
comment|/* N.B.: lookup_field will do the access checking for us */
name|id
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|name
argument_list|,
name|complain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
block|{
name|id
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
comment|/* At parse time, we don't want to give this error, since 			 we won't have enough state to make this kind of 			 decision properly.  But there are times (e.g., with 			 enums in nested classes) when we do need to call 			 this fn at parse time.  So, in those cases, we pass 			 complain as a 0 and just return a NULL_TREE.  */
name|cp_error
argument_list|(
literal|"assignment to non-static member `%D' of enclosing class `%T'"
argument_list|,
name|id
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark this for do_identifier().  It would otherwise 			 claim that the variable was undeclared.  */
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_fnfields_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
comment|/* Constructors are first...  */
if|if
condition|(
operator|*
name|methods
operator|&&
name|name
operator|==
name|ctor_identifier
condition|)
return|return
literal|0
return|;
comment|/* and destructors are second.  */
if|if
condition|(
operator|*
operator|++
name|methods
operator|&&
name|name
operator|==
name|dtor_identifier
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|==
name|name
condition|)
break|break;
block|}
comment|/* If we didn't find it, it might have been a template 	 conversion operator.  (Note that we don't look for this case 	 above so that we will always find specializations first.)  */
if|if
condition|(
name|methods
operator|==
name|end
operator|&&
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|methods
operator|!=
name|end
condition|)
return|return
name|methods
operator|-
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Starting from BASETYPE, return a TREE_BASELINK-like object    which gives the following information (in a list):     TREE_TYPE: list of basetypes needed to get to...    TREE_VALUE: list of all functions in a given type    which have name NAME.     No access information is computed by this function,    other then to adorn the list of basetypes with    TREE_VIA_PUBLIC.     If there are two ways to find a name (two members), if COMPLAIN is    non-zero, then error_mark_node is returned, and an error message is    printed, otherwise, just an error_mark_node is returned.     As a special case, is COMPLAIN is -1, we don't complain, and we    don't return error_mark_node, but rather the complete list of    virtuals.  This is used by get_virtuals_named_this.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|basetype_path
parameter_list|,
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|,
name|rvals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rval_binfo_h
init|=
name|NULL_TREE
decl_stmt|,
name|entry
decl_stmt|,
name|binfo
decl_stmt|,
name|basetype_chain
decl_stmt|,
name|binfo_h
decl_stmt|;
name|int
name|find_all
init|=
literal|0
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      function member is found.  */
comment|/* rval_binfo_h and binfo_h are binfo values used when we perform the      hiding checks, as virtual base classes may not be shared.  The strategy      is we always go into the binfo hierarchy owned by TYPE_BINFO of      virtual base classes, as we cross virtual base class lines.  This way      we know that binfo of a virtual base class will always == itself when      found along any line.  (mrs)  */
comment|/* For now, don't try this.  */
name|int
name|protect
init|=
name|complain
decl_stmt|;
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
comment|/* Set this to nonzero if we don't know how to compute      accurate error messages for access control.  */
name|int
name|idx
init|=
name|MEMOIZED_HASH_FN
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|complain
operator|==
operator|-
literal|1
condition|)
block|{
name|find_all
operator|=
literal|1
expr_stmt|;
name|protect
operator|=
name|complain
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* We cannot search for constructor/destructor names like this.  */
comment|/* This can't go here, but where should it go?  */
comment|/* If we are looking for a constructor in a templated type, use the      unspecialized name, as that is how we store it.  */
block|if (IDENTIFIER_TEMPLATE (name))     name = constructor_name (name);
endif|#
directive|endif
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|binfo_h
operator|=
name|binfo
expr_stmt|;
name|type
operator|=
name|complete_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The memoization code is in need of maintenance.  */
if|if
condition|(
operator|!
name|find_all
operator|&&
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|MEMOIZED_FNFIELDS
argument_list|(
name|CLASSTYPE_MTABLE_ENTRY
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
decl_stmt|;
while|while
condition|(
name|tem
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
operator|!=
name|name
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|protect
operator|&&
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
comment|/* Want to return this, but we must make sure 		 that access information is consistent.  */
name|tree
name|baselink
init|=
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|tree
name|memoized_basetypes
init|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|tree
name|these_basetypes
init|=
name|basetype_path
decl_stmt|;
while|while
condition|(
name|memoized_basetypes
operator|&&
name|these_basetypes
condition|)
block|{
name|memoized_fields_searched
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|memoized_basetypes
argument_list|)
operator|!=
name|these_basetypes
condition|)
break|break;
name|memoized_basetypes
operator|=
name|TREE_CHAIN
argument_list|(
name|memoized_basetypes
argument_list|)
expr_stmt|;
name|these_basetypes
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|these_basetypes
argument_list|)
expr_stmt|;
block|}
comment|/* The following statement is true only when both are NULL.  */
if|if
condition|(
name|memoized_basetypes
operator|==
name|these_basetypes
condition|)
block|{
name|memoized_fast_finds
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
return|;
block|}
comment|/* else, we must re-find this field by hand.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|baselink
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|protect
operator|&&
name|flag_memoize_lookups
operator|&&
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|entry
operator|=
name|make_memoized_table_entry
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|||
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|rval_binfo
operator|=
name|basetype_path
expr_stmt|;
name|rval_binfo_h
operator|=
name|rval_binfo
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|rvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|rvals
return|;
block|}
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|ctor_identifier
operator|||
name|name
operator|==
name|dtor_identifier
condition|)
block|{
comment|/* Don't allow lookups of constructors and destructors to go  	 deeper than the first place we look.  */
if|if
condition|(
name|entry
condition|)
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|basetype_path
operator|==
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|basetype_chain
operator|=
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|basetype_chain
operator|=
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_chain
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
block|}
comment|/* The ambiguity check relies upon breadth first searching.  */
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|binfo_h
operator|=
name|binfo
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|btypes
decl_stmt|;
name|SET_BINFO_FIELDS_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetype_chain
argument_list|)
expr_stmt|;
name|TREE_VIA_PUBLIC
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_PROTECTED
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|btypes
argument_list|)
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
else|else
name|btypes
operator|=
name|my_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo_h
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetype_chain
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo_h
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
condition|)
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|basetype_chain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|binfo
operator|=
name|basetype_path
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* See if we can find NAME in TYPE.  If RVAL is nonzero, 	 and we do find NAME in TYPE, verify that such a second 	 sighting is in fact valid.  */
name|idx
operator|=
name|lookup_fnfields_here
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|||
operator|(
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|find_all
operator|)
condition|)
block|{
if|if
condition|(
name|rval_binfo
operator|&&
operator|!
name|find_all
operator|&&
name|hides
argument_list|(
name|rval_binfo_h
argument_list|,
name|binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is in rval_binfo, not 		 here (binfo).  */
block|}
elseif|else
if|if
condition|(
name|rval_binfo
operator|==
name|NULL_TREE
operator|||
name|find_all
operator|||
name|hides
argument_list|(
name|binfo_h
argument_list|,
name|rval_binfo_h
argument_list|)
condition|)
block|{
comment|/* This is ok, the member found is here (binfo), not in 		 rval_binfo.  */
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|rval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Note, rvals can only be previously set if find_all is 		     true.  */
name|rvals
operator|=
name|my_tree_cons
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|rvals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rvals
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Undo finding it before, as something else hides it.  */
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|rvals
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
name|rval_binfo_h
operator|=
name|binfo_h
expr_stmt|;
block|}
else|else
block|{
comment|/* This is ambiguous.  */
name|errstr
operator|=
literal|"request for method `%D' is ambiguous"
expr_stmt|;
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
block|}
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|CLEAR_BINFO_FIELDS_MARKED
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|errstr
condition|)
block|{
name|tree
name|error_string
init|=
name|my_build_string
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Save error message with entry.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|error_string
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark entry as having no error string.  */
name|TREE_TYPE
argument_list|(
name|entry
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|entry
argument_list|)
operator|=
name|rvals
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|cp_error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rvals
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|rvals
return|;
block|}
end_function

begin_comment
comment|/* Look for a field or function named NAME in an inheritance lattice    dominated by XBASETYPE.  PROTECT is zero if we can avoid computing    access information, otherwise it is 1.  WANT_TYPE is 1 when we should    only return TYPE_DECLs, if no TYPE_DECL can be found return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_member
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|tree
name|ret
decl_stmt|,
name|basetype_path
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
block|{
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|BINFO_VIA_PUBLIC
argument_list|(
name|basetype_path
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|97
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
name|want_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|!
name|want_type
condition|)
name|ret
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
name|protect
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BREADTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_comment
comment|/* Search a multiple inheritance hierarchy by breadth-first search.     BINFO is an aggregate type, possibly in a multiple-inheritance hierarchy.    TESTFN is a function, which, if true, means that our condition has been met,    and its return value should be returned.    QFN, if non-NULL, is a predicate dictating whether the type should    even be queued.  */
end_comment

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|breadth_first_search
parameter_list|(
name|binfo
parameter_list|,
name|testfn
parameter_list|,
name|qfn
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*testfn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|qfn
operator|==
literal|0
operator|||
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
operator|)
condition|)
block|{
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|i
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|search_stack
operator|->
name|limit
condition|)
name|my_friendly_abort
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|binfo
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
call|(
modifier|*
name|testfn
call|)
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
operator|)
condition|)
break|break;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
modifier|*
name|tp
init|=
name|search_stack
operator|->
name|first
decl_stmt|;
name|tree
modifier|*
name|search_tail
init|=
name|tp
operator|+
name|tail
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|search_tail
condition|)
block|{
name|tree
name|binfo
init|=
operator|*
name|tp
operator|++
decl_stmt|;
name|int
name|i
init|=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
decl_stmt|;
name|CLEAR_BINFO_MARKED
argument_list|(
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Functions to use in breadth first searches.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*pfi
argument_list|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|static
name|tree
name|declarator
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_virtuals_named_this
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|;
name|fields
operator|=
name|lookup_fnfields
argument_list|(
name|binfo
argument_list|,
name|declarator
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* fields cannot be error_mark_node */
if|if
condition|(
name|fields
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Get to the function decls, and return the first virtual function      with this name, if there is one.  */
while|while
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
for|for
control|(
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
init|;
name|fndecl
condition|;
name|fndecl
operator|=
name|OVL_NEXT
argument_list|(
name|fndecl
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
return|return
name|fields
return|;
name|fields
operator|=
name|next_baselink
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_virtual_destructor
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tree_has_any_destructor_p
parameter_list|(
name|binfo
parameter_list|,
name|i
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns> 0 if a function with type DRETTYPE overriding a function    with type BRETTYPE is covariant, as defined in [class.virtual].     Returns 1 if trivial covariance, 2 if non-trivial (requiring runtime    adjustment), or -1 if pedantically invalid covariance.  */
end_comment

begin_function
specifier|static
name|int
name|covariant_return_p
parameter_list|(
name|brettype
parameter_list|,
name|drettype
parameter_list|)
name|tree
name|brettype
decl_stmt|,
name|drettype
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|THUNK_DECL
condition|)
block|{
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comptypes
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|drettype
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TYPE_READONLY
argument_list|(
name|brettype
argument_list|)
operator|==
name|TYPE_READONLY
argument_list|(
name|drettype
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|brettype
argument_list|)
operator|==
name|TYPE_VOLATILE
argument_list|(
name|drettype
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|can_convert
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
return|return
literal|0
return|;
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
expr_stmt|;
comment|/* If not pedantic, allow any standard pointer conversion.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|drettype
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|brettype
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|binfo
operator|=
name|get_binfo
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we get an error_mark_node from get_binfo, it already complained,      so let's just succeed.  */
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a class type TYPE, and a function decl FNDECL, look for a    virtual function in TYPE's hierarchy which FNDECL could match as a    virtual function.  It doesn't matter which one we find.     DTORP is nonzero if we are looking for a destructor.  Destructors    need special treatment because they do not match by name.  */
end_comment

begin_function
name|tree
name|get_matching_virtual
parameter_list|(
name|binfo
parameter_list|,
name|fndecl
parameter_list|,
name|dtorp
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|dtorp
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* In [temp.mem] we have:           A specialization of a member function template does not          override a virtual function from a base class.  */
return|return
name|NULL_TREE
return|;
comment|/* Breadth first search routines start searching basetypes      of TYPE, so we must perform first ply of search here.  */
if|if
condition|(
name|dtorp
condition|)
block|{
if|if
condition|(
name|tree_has_any_destructor_p
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|tmp
operator|=
name|get_virtual_destructor
argument_list|(
name|binfo
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
name|tmp
operator|=
operator|(
name|tree
operator|)
name|breadth_first_search
argument_list|(
name|binfo
argument_list|,
operator|(
name|pfi
operator|)
name|get_virtual_destructor
argument_list|,
name|tree_has_any_destructor_p
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|tree
name|drettype
decl_stmt|,
name|dtypes
decl_stmt|,
name|btypes
decl_stmt|,
name|instptr_type
decl_stmt|;
name|tree
name|basetype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|baselink
decl_stmt|,
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_VIRTUAL_P
argument_list|(
name|declarator
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|baselink
operator|=
name|get_virtuals_named_this
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|baselink
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|dtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|instptr_type
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|instptr_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|dtypes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|tree
name|tmps
decl_stmt|;
for|for
control|(
name|tmps
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
init|;
name|tmps
condition|;
name|tmps
operator|=
name|OVL_NEXT
argument_list|(
name|tmps
argument_list|)
control|)
block|{
name|tmp
operator|=
name|OVL_CURRENT
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_VINDEX
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
name|btypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instptr_type
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|,
literal|3
argument_list|)
condition|)
comment|/* Caller knows to give error in this case.  */
return|return
name|tmp
return|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|btypes
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_READONLY
argument_list|(
name|instptr_type
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|dtypes
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|tree
name|brettype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|covariant_return_p
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|sorry
argument_list|(
literal|"adjusting pointers for covariant returns"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"invalid covariant return type for `%#D' (must be pointer or reference to class)"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_2
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid covariant return type (must use pointer or reference)"
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  with `%#D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"conflicting return type specified for virtual function `%#D'"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding definition as `%#D'"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* If not at the end */
if|if
condition|(
name|tmps
condition|)
block|{
name|best
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
return|return
name|best
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type    TYPE that come from non virtual base classes.  See    expand_direct_vtbls_init for the style of search we do.  */
end_comment

begin_function
specifier|static
name|tree
name|get_abstract_virtuals_1
parameter_list|(
name|binfo
parameter_list|,
name|do_self
parameter_list|,
name|abstract_virtuals
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|int
name|do_self
decl_stmt|;
name|tree
name|abstract_virtuals
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|get_abstract_virtuals_1
argument_list|(
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|do_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|abstract_virtuals
return|;
block|}
end_function

begin_comment
comment|/* Return the list of virtual functions which are abstract in type TYPE.    This information is cached, and so must be built on a    non-temporary obstack.  */
end_comment

begin_function
name|tree
name|get_abstract_virtuals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* First get all from non-virtual bases.  */
name|abstract_virtuals
operator|=
name|get_abstract_virtuals_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_fndecl
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|abstract_virtuals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For the type TYPE, return a list of member functions available from    base classes with name NAME.  The TREE_VALUE of the list is a chain of    member functions with name NAME.  The TREE_PURPOSE of the list is a    basetype, or a list of base types (in reverse order) which were    traversed to reach the chain of member functions.  If we reach a base    type which provides a member function of name NAME, and which has at    most one base type itself, then we can terminate the search.  */
end_comment

begin_function
name|tree
name|get_baselinks
parameter_list|(
name|type_as_binfo_list
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type_as_binfo_list
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|int
name|head
init|=
literal|0
decl_stmt|,
name|tail
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
name|tree
name|rval
init|=
literal|0
decl_stmt|,
name|nval
init|=
literal|0
decl_stmt|;
name|tree
name|basetypes
init|=
name|type_as_binfo_list
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Process and/or queue base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|btypes
decl_stmt|;
name|btypes
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|basetypes
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|search_obstack
argument_list|,
name|btypes
argument_list|)
expr_stmt|;
name|search_stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|tail
operator|+=
literal|1
expr_stmt|;
block|}
name|dont_queue
label|:
comment|/* Process head of queue, if one exists.  */
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
break|break;
name|basetypes
operator|=
name|search_stack
operator|->
name|first
index|[
name|head
operator|++
index|]
expr_stmt|;
name|binfo
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|idx
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|rval
operator|=
name|hash_tree_cons
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|basetypes
argument_list|,
name|nval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|dont_queue
goto|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
goto|goto
name|dont_queue
goto|;
block|}
block|}
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|next_baselink
parameter_list|(
name|baselink
parameter_list|)
name|tree
name|baselink
decl_stmt|;
block|{
name|tree
name|tmp
init|=
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|baselink
operator|=
name|TREE_CHAIN
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
comment|/* @@ does not yet add previous base types.  */
name|baselink
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|baselink
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|baselink
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MI_MATRIX
end_ifdef

begin_comment
comment|/* Assign unique numbers to _CLASSTYPE members of the lattice    specified by TYPE.  The root nodes are marked first; the nodes    are marked depth-fisrt, left-right.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Matrix implementing a relation from CLASSTYPE X CLASSTYPE => INT.    Relation yields 1 if C1<= C2, 0 otherwise.  */
end_comment

begin_typedef
typedef|typedef
name|char
name|mi_boolean
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|mi_boolean
modifier|*
name|mi_matrix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type for which this matrix is defined.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|mi_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the matrix for indexing purposes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mi_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return nonzero if class C2 derives from class C1.  */
end_comment

begin_define
define|#
directive|define
name|BINFO_DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(BINFO_CID (C1)-1))[BINFO_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|TYPE_DERIVES_FROM
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|((mi_matrix+mi_size*(CLASSTYPE_CID (C1)-1))[CLASSTYPE_CID (C2)-1])
end_define

begin_define
define|#
directive|define
name|BINFO_DERIVES_FROM_STAR
parameter_list|(
name|C
parameter_list|)
define|\
value|(mi_matrix+(BINFO_CID (C)-1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This routine converts a pointer to be a pointer of an immediate    base class.  The normal convert_pointer_to routine would diagnose    the conversion as ambiguous, under MI code that has the base class    as an ambiguous base class.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_pointer_to_single_level
parameter_list|(
name|to_type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|to_type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|binfo_of_derived
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|binfo_of_derived
operator|=
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_binfo
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|binfo_of_derived
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo_of_derived
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|expr
argument_list|,
name|last
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main function which implements depth first search.     This routine has to remember the path it walked up, when    dfs_init_vbase_pointers is the work function, as otherwise there    would be no record.  */
end_comment

begin_function_decl
specifier|static
name|void
name|dfs_walk
parameter_list|(
name|binfo
parameter_list|,
name|fn
parameter_list|,
name|qfn
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfn
operator|==
literal|0
operator|||
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
comment|/* Pass */
empty_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|==
name|dfs_init_vbase_pointers
condition|)
block|{
comment|/* When traversing an arbitrary MI hierarchy, we need to keep 		 a record of the path we took to get down to the final base 		 type, as otherwise there would be no record of it, and just 		 trying to blindly convert at the bottom would be ambiguous.  		 The easiest way is to do the conversions one step at a time, 		 as we know we want the immediate base class at each step.  		 The only special trick to converting one step at a time, 		 is that when we hit the last virtual base class, we must 		 use the SLOT value for it, and not use the normal convert 		 routine.  We use the last virtual base class, as in our 		 implementation, we have pointers to all virtual base 		 classes in the base object.  */
name|tree
name|saved_vbase_decl_ptr_intermediate
init|=
name|vbase_decl_ptr_intermediate
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
comment|/* No need for the conversion here, as we know it is the 		     right type.  */
name|vbase_decl_ptr_intermediate
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vbase_decl_ptr_intermediate
operator|=
name|convert_pointer_to_single_level
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|vbase_decl_ptr_intermediate
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|base_binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
name|vbase_decl_ptr_intermediate
operator|=
name|saved_vbase_decl_ptr_intermediate
expr_stmt|;
block|}
else|else
name|dfs_walk
argument_list|(
name|base_binfo
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|)
expr_stmt|;
block|}
block|}
name|fn
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MI_MATRIX
end_ifdef

begin_comment
comment|/* Predicate functions which serve for dfs_walk.  */
end_comment

begin_function
specifier|static
name|int
name|numberedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unnumberedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|markedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarkedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int bfs_markedp (binfo, i) tree binfo; int i; { return BINFO_MARKED (BINFO_BASETYPE (binfo, i)); } static int bfs_unmarkedp (binfo, i) tree binfo; int i; { return BINFO_MARKED (BINFO_BASETYPE (binfo, i)) == 0; } static int bfs_marked_vtable_pathp (binfo, i) tree binfo; int i; { return BINFO_VTABLE_PATH_MARKED (BINFO_BASETYPE (binfo, i)); } static int bfs_unmarked_vtable_pathp (binfo, i) tree binfo; int i; { return BINFO_VTABLE_PATH_MARKED (BINFO_BASETYPE (binfo, i)) == 0; } static int bfs_marked_new_vtablep (binfo, i) tree binfo; int i; { return BINFO_NEW_VTABLE_MARKED (BINFO_BASETYPE (binfo, i)); } static int bfs_unmarked_new_vtablep (binfo, i) tree binfo; int i; { return BINFO_NEW_VTABLE_MARKED (BINFO_BASETYPE (binfo, i)) == 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|marked_new_vtablep
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmarked_new_vtablep
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int dfs_search_slot_nonempty_p (binfo) tree binfo; { return CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) != 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dfs_debug_unmarkedp
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MI_MATRIX
end_ifdef

begin_comment
comment|/* Assign each type within the lattice a number which is unique    in the lattice.  The first number assigned is 1.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_number
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|=
operator|++
name|cid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_unnumber
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|BINFO_CID
argument_list|(
name|binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dfs_mark (binfo) tree binfo; { SET_BINFO_MARKED (binfo); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dfs_unmark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dfs_mark_vtable_path (binfo) tree binfo; { SET_BINFO_VTABLE_PATH_MARKED (binfo); }  static void dfs_unmark_vtable_path (binfo) tree binfo; { CLEAR_BINFO_VTABLE_PATH_MARKED (binfo); }  static void dfs_mark_new_vtable (binfo) tree binfo; { SET_BINFO_NEW_VTABLE_MARKED (binfo); }  static void dfs_unmark_new_vtable (binfo) tree binfo; { CLEAR_BINFO_NEW_VTABLE_MARKED (binfo); }  static void dfs_clear_search_slot (binfo) tree binfo; { CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dfs_debug_mark
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* Use heuristic that if there are virtual functions,      ignore until we see a non-inline virtual function.  */
name|tree
name|methods
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|methods
operator|==
literal|0
condition|)
return|return;
comment|/* If interface info is known, either we've already emitted the debug      info or we don't need to.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|write_virtuals
operator|==
literal|2
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return;
comment|/* If debug info is requested from this context for this type, supply it.      If debug info is requested from another context for this type,      see if some third context can supply it.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|t
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
condition|)
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
condition|)
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|methods
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|methods
operator|=
name|OVL_CURRENT
argument_list|(
name|methods
argument_list|)
expr_stmt|;
while|while
condition|(
name|methods
condition|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|methods
argument_list|)
operator|&&
name|DECL_THIS_INLINE
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|methods
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Somebody, somewhere is going to have to define this 		 virtual function.  When they do, they will provide 		 the debugging info.  */
return|return;
block|}
name|methods
operator|=
name|TREE_CHAIN
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We cannot rely on some alien method to solve our problems,      so we must write out the debug info ourselves.  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Attach to the type of the virtual base class, the pointer to the     virtual base class, given the global pointer vbase_decl_ptr.      We use the global vbase_types.  ICK!  */
end_comment

begin_function
specifier|static
name|void
name|dfs_find_vbases
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vbase
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_member
argument_list|(
name|vbase
argument_list|,
name|vbase_types
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|vbase
argument_list|)
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|vbase
argument_list|)
argument_list|,
name|vbase_decl_ptr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|SET_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_init_vbase_pointers
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|this_vbase_ptr
decl_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See finish_struct_1 for when we can enable this.  */
comment|/* If we have a vtable pointer first, skip it.  */
block|if (VFIELD_NAME_P (DECL_NAME (fields)))     fields = TREE_CHAIN (fields);
endif|#
directive|endif
if|if
condition|(
name|fields
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
return|return;
name|this_vbase_ptr
operator|=
name|vbase_decl_ptr_intermediate
expr_stmt|;
if|if
condition|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_vbase_ptr
argument_list|)
argument_list|)
condition|)
name|my_friendly_abort
argument_list|(
literal|125
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
operator|&&
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|ref
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|this_vbase_ptr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|fields
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|vbase_init_result
operator|=
name|tree_cons
argument_list|(
name|binfo_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|vbase_init_result
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other    times, just NEW_VTABLE, but optimizer should make both with equal    efficiency (though it does not currently).  */
end_comment

begin_function
specifier|static
name|void
name|dfs_clear_vbase_slots
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLEAR_BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|CLEAR_BINFO_NEW_VTABLE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|init_vbase_pointers
parameter_list|(
name|type
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl_ptr
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_flag
init|=
name|flag_this_is_variable
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|flag_this_is_variable
operator|=
operator|-
literal|2
expr_stmt|;
name|vbase_types
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|vbase_decl_ptr_intermediate
operator|=
name|decl_ptr
expr_stmt|;
name|vbase_init_result
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_vtable_pathp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_init_vbase_pointers
argument_list|,
name|marked_vtable_pathp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|)
expr_stmt|;
name|flag_this_is_variable
operator|=
name|old_flag
expr_stmt|;
return|return
name|vbase_init_result
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get the virtual context (the vbase that directly contains the    DECL_CLASS_CONTEXT of the FNDECL) that the given FNDECL is declared in,    or NULL_TREE if there is none.     FNDECL must come from a virtual table from a virtual base to ensure that    there is only one possible DECL_CLASS_CONTEXT.     We know that if there is more than one place (binfo) the fndecl that the    declared, they all refer to the same binfo.  See get_class_offset_1 for    the check that ensures this.  */
end_comment

begin_function
specifier|static
name|tree
name|virtual_context
parameter_list|(
name|fndecl
parameter_list|,
name|t
parameter_list|,
name|vbase
parameter_list|)
name|tree
name|fndecl
decl_stmt|,
name|t
decl_stmt|,
name|vbase
decl_stmt|;
block|{
name|tree
name|path
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* DECL_CLASS_CONTEXT can be ambiguous in t.  */
if|if
condition|(
name|get_base_distance
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|vbase
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|path
condition|)
block|{
comment|/* Not sure if checking path == vbase is necessary here, but just in 		 case it is.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
operator|||
name|path
operator|==
name|vbase
condition|)
return|return
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This shouldn't happen, I don't want errors! */
name|warning
argument_list|(
literal|"recoverable compiler error, fixups for virtual function"
argument_list|)
expr_stmt|;
return|return
name|vbase
return|;
block|}
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|path
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|path
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fixups upcast offsets for one vtable.    Entries may stay within the VBASE given, or    they may upcast into a direct base, or    they may upcast into a different vbase.     We only need to do fixups in case 2 and 3.  In case 2, we add in    the virtual base offset to effect an upcast, in case 3, we add in    the virtual base offset to effect an upcast, then subtract out the    offset for the other virtual base, to effect a downcast into it.     This routine mirrors fixup_vtable_deltas in functionality, though    this one is runtime based, and the other is compile time based.    Conceivably that routine could be removed entirely, and all fixups    done at runtime.     VBASE_OFFSETS is an association list of virtual bases that contains    offset information for the virtual bases, so the offsets are only    calculated once.  The offsets are computed by where we think the    vbase should be (as noted by the CLASSTYPE_SEARCH_SLOT) minus where    the vbase really is.  */
end_comment

begin_function
specifier|static
name|void
name|expand_upcast_fixups
parameter_list|(
name|binfo
parameter_list|,
name|addr
parameter_list|,
name|orig_addr
parameter_list|,
name|vbase
parameter_list|,
name|vbase_addr
parameter_list|,
name|t
parameter_list|,
name|vbase_offsets
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|addr
decl_stmt|,
name|orig_addr
decl_stmt|,
name|vbase
decl_stmt|,
name|vbase_addr
decl_stmt|,
name|t
decl_stmt|,
decl|*
name|vbase_offsets
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|virtuals
init|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|vc
decl_stmt|;
name|tree
name|delta
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n
decl_stmt|;
name|delta
operator|=
name|purpose_member
argument_list|(
name|vbase
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
block|{
name|delta
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|,
name|vbase_addr
argument_list|)
expr_stmt|;
name|delta
operator|=
name|save_expr
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|=
name|tree_cons
argument_list|(
name|vbase
argument_list|,
name|delta
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
expr_stmt|;
operator|*
name|vbase_offsets
operator|=
name|delta
expr_stmt|;
block|}
name|n
operator|=
name|skip_rtti_stuff
argument_list|(
operator|&
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
condition|)
block|{
name|tree
name|current_fndecl
init|=
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
name|current_fndecl
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|current_fndecl
argument_list|)
expr_stmt|;
name|current_fndecl
operator|=
name|TREE_OPERAND
argument_list|(
name|current_fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_fndecl
operator|&&
name|current_fndecl
operator|!=
name|abort_fndecl
operator|&&
operator|(
name|vc
operator|=
name|virtual_context
argument_list|(
name|current_fndecl
argument_list|,
name|t
argument_list|,
name|vbase
argument_list|)
operator|)
operator|!=
name|vbase
condition|)
block|{
comment|/* This may in fact need a runtime fixup.  */
name|tree
name|idx
init|=
name|build_int_2
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|vtbl
init|=
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|nvtbl
init|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|vtbl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|aref
decl_stmt|,
name|ref
decl_stmt|,
name|naref
decl_stmt|;
name|tree
name|old_delta
decl_stmt|,
name|new_delta
decl_stmt|;
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|nvtbl
operator|==
name|NULL_TREE
operator|||
name|nvtbl
operator|==
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|vtbl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Dup it if it isn't in local scope yet.  */
name|nvtbl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|nvtbl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|nvtbl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|nvtbl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|nvtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nvtbl
operator|=
name|pushdecl
argument_list|(
name|nvtbl
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|nvtbl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
comment|/* We don't set DECL_VIRTUAL_P and DECL_CONTEXT on nvtbl 		 because they wouldn't be useful; everything that wants to 		 look at the vtable will look at the decl for the normal 		 vtable.  Setting DECL_CONTEXT also screws up 		 decl_function_context.  */
name|init
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|nvtbl
argument_list|)
argument_list|,
name|nvtbl
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Update the vtable pointers as necessary.  */
name|ref
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|ref
argument_list|,
name|NOP_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|nvtbl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|naref
operator|=
name|build_array_ref
argument_list|(
name|nvtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|old_delta
operator|=
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_delta
operator|=
name|build_component_ref
argument_list|(
name|naref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a upcast, so we have to add the offset for the 	     virtual base.  */
name|old_delta
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|old_delta
argument_list|,
name|TREE_VALUE
argument_list|(
name|delta
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
condition|)
block|{
comment|/* If this is set, we need to subtract out the delta 		 adjustments for the other virtual base that we 		 downcast into.  */
name|tree
name|vc_delta
init|=
name|purpose_member
argument_list|(
name|vc
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vc_delta
condition|)
block|{
name|tree
name|vc_addr
init|=
name|convert_pointer_to_real
argument_list|(
name|vc
argument_list|,
name|orig_addr
argument_list|)
decl_stmt|;
name|vc_delta
operator|=
name|CLASSTYPE_SEARCH_SLOT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vc
argument_list|)
argument_list|)
expr_stmt|;
name|vc_delta
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|vc_delta
argument_list|,
name|vc_addr
argument_list|)
expr_stmt|;
name|vc_delta
operator|=
name|save_expr
argument_list|(
name|vc_delta
argument_list|)
expr_stmt|;
operator|*
name|vbase_offsets
operator|=
name|tree_cons
argument_list|(
name|vc
argument_list|,
name|vc_delta
argument_list|,
operator|*
name|vbase_offsets
argument_list|)
expr_stmt|;
block|}
else|else
name|vc_delta
operator|=
name|TREE_VALUE
argument_list|(
name|vc_delta
argument_list|)
expr_stmt|;
comment|/* This is a downcast, so we have to subtract the offset 		 for the virtual base.  */
name|old_delta
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|old_delta
argument_list|,
name|vc_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_READONLY
argument_list|(
name|new_delta
argument_list|)
operator|=
literal|0
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|new_delta
argument_list|,
name|NOP_EXPR
argument_list|,
name|old_delta
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Fixup upcast offsets for all direct vtables.  Patterned after    expand_direct_vtbls_init.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_virtual_upcast_offsets
parameter_list|(
name|real_binfo
parameter_list|,
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|can_elide
parameter_list|,
name|addr
parameter_list|,
name|orig_addr
parameter_list|,
name|type
parameter_list|,
name|vbase
parameter_list|,
name|vbase_offsets
parameter_list|)
name|tree
name|real_binfo
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|init_self
decl_stmt|,
name|can_elide
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|orig_addr
decl_stmt|,
name|type
decl_stmt|,
name|vbase
decl_stmt|,
decl|*
name|vbase_offsets
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|real_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|real_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|real_binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|real_binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|real_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|real_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|real_base_binfo
argument_list|)
condition|)
name|fixup_virtual_upcast_offsets
argument_list|(
name|real_base_binfo
argument_list|,
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|can_elide
argument_list|,
name|addr
argument_list|,
name|orig_addr
argument_list|,
name|type
argument_list|,
name|vbase
argument_list|,
name|vbase_offsets
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Before turning this on, make sure it is correct.  */
block|if (can_elide&& ! BINFO_MODIFIED (binfo))     return;
endif|#
directive|endif
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|new_addr
init|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|expand_upcast_fixups
argument_list|(
name|real_binfo
argument_list|,
name|new_addr
argument_list|,
name|orig_addr
argument_list|,
name|vbase
argument_list|,
name|addr
argument_list|,
name|type
argument_list|,
name|vbase_offsets
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Build a COMPOUND_EXPR which when expanded will generate the code    needed to initialize all the virtual function table slots of all    the virtual baseclasses.  MAIN_BINFO is the binfo which determines    the virtual baseclasses to use; TYPE is the type of the object to    which the initialization applies.  TRUE_EXP is the true object we    are initializing, and DECL_PTR is the pointer to the sub-object we    are initializing.     When USE_COMPUTED_OFFSETS is non-zero, we can assume that the    object was laid out by a top-level constructor and the computed    offsets are valid to store vtables.  When zero, we must store new    vtables through virtual baseclass pointers.     We setup and use the globals: vbase_decl_ptr, vbase_types    ICK!  */
end_comment

begin_function
name|void
name|expand_indirect_vtbls_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|decl_ptr
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|decl_ptr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|rtx
name|fixup_insns
init|=
name|NULL_RTX
decl_stmt|;
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|vbase_types
operator|=
name|vbases
expr_stmt|;
name|vbase_decl_ptr
operator|=
name|true_exp
condition|?
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|true_exp
argument_list|,
literal|0
argument_list|)
else|:
name|decl_ptr
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_find_vbases
argument_list|,
name|unmarked_new_vtablep
argument_list|)
expr_stmt|;
comment|/* Initialized with vtables of type TYPE.  */
for|for
control|(
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|addr
decl_stmt|;
name|addr
operator|=
name|convert_pointer_to_vbase
argument_list|(
name|TREE_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|vbase_decl_ptr
argument_list|)
expr_stmt|;
comment|/* Do all vtables from this virtual base.  */
comment|/* This assumes that virtual bases can never serve as parent 	     binfos.  (in the CLASSTYPE_VFIELD_PARENT sense)  */
name|expand_direct_vtbls_init
argument_list|(
name|vbases
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Now we adjust the offsets for virtual functions that 	     cross virtual boundaries on an implicit upcast on vf call 	     so that the layout of the most complete type is used, 	     instead of assuming the layout of the virtual bases from 	     our current type.  */
if|if
condition|(
name|flag_vtable_thunks
condition|)
block|{
comment|/* We don't have dynamic thunks yet! 		 So for now, just fail silently.  */
block|}
else|else
block|{
name|tree
name|vbase_offsets
init|=
name|NULL_TREE
decl_stmt|;
name|push_to_sequence
argument_list|(
name|fixup_insns
argument_list|)
expr_stmt|;
name|fixup_virtual_upcast_offsets
argument_list|(
name|vbases
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|vbase_decl_ptr
argument_list|,
name|type
argument_list|,
name|vbases
argument_list|,
operator|&
name|vbase_offsets
argument_list|)
expr_stmt|;
name|fixup_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixup_insns
condition|)
block|{
specifier|extern
name|tree
name|in_charge_identifier
decl_stmt|;
name|tree
name|in_charge_node
init|=
name|lookup_name
argument_list|(
name|in_charge_identifier
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|in_charge_node
condition|)
block|{
name|warning
argument_list|(
literal|"recoverable internal compiler error, nobody's in charge!"
argument_list|)
expr_stmt|;
name|in_charge_node
operator|=
name|integer_zero_node
expr_stmt|;
block|}
name|in_charge_node
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|in_charge_node
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|in_charge_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|fixup_insns
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_clear_vbase_slots
argument_list|,
name|marked_new_vtablep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get virtual base class types.    This adds type to the vbase_types list in reverse dfs order.    Ordering is very important, so don't change it.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_get_vbase_types
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_VBASE_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|vbase_types
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|binfo
argument_list|,
name|BINFO_VTABLE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|vbase_types
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|vbase_types
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_BINFO_VBASE_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get a list of virtual base classes in dfs order.  */
end_comment

begin_function
name|tree
name|get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|binfo
operator|=
name|type
expr_stmt|;
else|else
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vbase_types
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_get_vbase_types
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
comment|/* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now      reverse it so that we get normal dfs ordering.  */
name|vbase_types
operator|=
name|nreverse
argument_list|(
name|vbase_types
argument_list|)
expr_stmt|;
comment|/* unmark marked vbases */
for|for
control|(
name|vbases
operator|=
name|vbase_types
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
name|CLEAR_BINFO_VBASE_MARKED
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
return|return
name|vbase_types
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|MI_MATRIX
end_ifdef

begin_function
specifier|static
name|void
name|dfs_record_inheritance
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|mi_boolean
modifier|*
name|derived_row
init|=
name|BINFO_DERIVES_FROM_STAR
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baselinks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|baseclass
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|mi_boolean
modifier|*
name|base_row
init|=
name|BINFO_DERIVES_FROM_STAR
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|baseclass
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|baseclass
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
continue|continue;
name|my_friendly_assert
argument_list|(
name|CLASSTYPE_CID
argument_list|(
name|baseclass
argument_list|)
operator|!=
literal|0
argument_list|,
literal|2365
argument_list|)
expr_stmt|;
comment|/* Don't search if there's nothing there!  MI_SIZE can be 	 zero as a result of parse errors.  */
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|baseclass
argument_list|)
operator|&&
name|mi_size
operator|>
literal|0
condition|)
for|for
control|(
name|j
operator|=
name|mi_size
operator|*
operator|(
name|CLASSTYPE_CID
argument_list|(
name|baseclass
argument_list|)
operator|-
literal|1
operator|)
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
name|mi_size
control|)
name|derived_row
index|[
name|j
index|]
operator||=
name|base_row
index|[
name|j
index|]
expr_stmt|;
name|TYPE_DERIVES_FROM
argument_list|(
name|baseclass
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a _CLASSTYPE node in a multiple inheritance lattice,    convert the lattice into a simple relation such that,    given to CIDs, C1 and C2, one can determine if C1<= C2    or C2<= C1 or C1<> C2.     Once constructed, we walk the lattice depth fisrt,    applying various functions to elements as they are encountered.     We use xmalloc here, in case we want to randomly free these tables.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_MI_MATRIX
end_define

begin_function
name|void
name|build_mi_matrix
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
if|if
condition|(
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_matrix
operator|=
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_number
argument_list|,
name|unnumberedp
argument_list|)
expr_stmt|;
name|mi_size
operator|=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|type
argument_list|)
operator|+
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi_size
operator|<
operator|(
name|cid
operator|-
literal|1
operator|)
condition|)
name|mi_size
operator|=
name|cid
operator|-
literal|1
expr_stmt|;
name|mi_matrix
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|mi_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|mi_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|mi_type
operator|=
name|type
expr_stmt|;
name|bzero
argument_list|(
name|mi_matrix
argument_list|,
operator|(
name|mi_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|mi_size
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_record_inheritance
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_mi_matrix
parameter_list|()
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|mi_type
argument_list|)
argument_list|,
name|dfs_unnumber
argument_list|,
name|numberedp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAVE_MI_MATRIX
name|CLASSTYPE_MI_MATRIX
argument_list|(
name|mi_type
argument_list|)
operator|=
name|mi_matrix
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|mi_matrix
argument_list|)
expr_stmt|;
name|mi_size
operator|=
literal|0
expr_stmt|;
name|cid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* If we want debug info for a type TYPE, make sure all its base types    are also marked as being potentially interesting.  This avoids    the problem of not writing any debug info for intermediate basetypes    that have abstract virtual functions.  Also mark member types.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|current_template_parms
condition|)
return|return;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
comment|/* We can't go looking for the base types and fields just yet.  */
return|return;
comment|/* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which      does not support name references between translation units.  Well, we      could, but that would mean putting global labels in the debug output      before each exported type and each of its functions and static data      members.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
return|return;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|dfs_debug_unmarkedp
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|ttype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
operator|=
name|target_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|dfs_debug_unmarkedp
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ttype
argument_list|)
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_comment
comment|/* Add in a decl to the envelope.  */
end_comment

begin_function
specifier|static
name|void
name|envelope_add_decl
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|,
name|values
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|,
decl|*
name|values
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|context
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|dont_add
init|=
literal|0
decl_stmt|;
comment|/* Yet Another Implicit Typename Kludge:  Since we don't tsubst      the members for partial instantiations, DECL_CONTEXT (decl) is wrong.      But pretend it's right for this function.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|type
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* virtual base names are always unique.  */
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
operator|*
name|values
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Possible ambiguity.  If its defining type(s)      is (are all) derived from us, no problem.  */
elseif|else
if|if
condition|(
operator|*
name|values
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|values
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|tree
name|value
init|=
operator|*
name|values
decl_stmt|;
comment|/* Only complain if we shadow something we can access.  */
if|if
condition|(
name|warn_shadow
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
operator|*
name|values
argument_list|)
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|==
name|current_class_type
operator|)
operator|||
operator|!
name|TREE_PRIVATE
argument_list|(
name|value
argument_list|)
operator|)
condition|)
comment|/* Should figure out access control more accurately.  */
block|{
name|cp_warning_at
argument_list|(
literal|"member `%#D' is shadowed"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"by member function `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|value
argument_list|)
condition|)
operator|*
name|values
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|dont_add
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|current_class_type
ifdef|#
directive|ifdef
name|MI_MATRIX
comment|/* If we don't check CLASSTYPE_CID on CONTEXT right now, 		  we'll end up subtracting from the address of MI_MATRIX, 		  putting us off in la la land.  */
operator|||
operator|(
name|CLASSTYPE_CID
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
operator|)
else|#
directive|else
operator|||
name|DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* Don't add in *values to list */
operator|*
name|values
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
operator|*
name|values
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|tmp
operator|=
name|values
init|;
operator|*
name|tmp
condition|;
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|tmp
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|TREE_LIST
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|value
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|current_class_type
ifdef|#
directive|ifdef
name|MI_MATRIX
comment|/* If we don't check CLASSTYPE_CID on CONTEXT right now, 	       we'll end up subtracting from the address of MI_MATRIX, 	       putting us off in la la land.  */
operator|||
operator|(
name|CLASSTYPE_CID
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_DERIVES_FROM
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
operator|)
else|#
directive|else
operator|||
name|DERIVED_FROM_P
argument_list|(
name|context
argument_list|,
name|type
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* remove *tmp from list */
operator|*
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dont_add
condition|)
block|{
comment|/* Put the new contents in our envelope.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
operator|*
name|values
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
operator|*
name|values
argument_list|)
expr_stmt|;
name|TREE_NONLOCAL_FLAG
argument_list|(
operator|*
name|values
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|values
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|values
condition|)
block|{
operator|*
name|values
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
operator|*
name|values
argument_list|)
expr_stmt|;
comment|/* Mark this as a potentially ambiguous member.  */
comment|/* Leaving TREE_TYPE blank is intentional. 		 We cannot use `error_mark_node' (lookup_name) 		 or `unknown_type_node' (all member functions use this).  */
name|TREE_NONLOCAL_FLAG
argument_list|(
operator|*
name|values
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|values
operator|=
name|decl
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Add the instance variables which this class contributed to the    current class binding contour.  When a redefinition occurs, if the    redefinition is strictly within a single inheritance path, we just    overwrite the old declaration with the new.  If the fields are not    within a single inheritance path, we must cons them.     In order to know what decls are new (stemming from the current    invocation of push_class_decls) we enclose them in an "envelope",    which is a TREE_LIST node where the TREE_PURPOSE slot contains the    new decl (or possibly a list of competing ones), the TREE_VALUE slot    points to the old value and the TREE_CHAIN slot chains together all    envelopes which needs to be "opened" in push_class_decls.  Opening an    envelope means: push the old value onto the class_shadowed list,    install the new one and if it's a TYPE_DECL do the same to the    IDENTIFIER_TYPE_VALUE.  Such an envelope is recognized by seeing that    the TREE_PURPOSE slot is non-null, and that it is not an identifier.    Because if it is, it could be a set of overloaded methods from an    outer scope.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_pushdecls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|,
modifier|*
name|methods
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
comment|/* Unmark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Recurse into anonymous unions.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|dfs_pushdecls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|tree
name|class_value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* If the class value is not an envelope of the kind described in 	     the comment above, we create a new envelope.  */
if|if
condition|(
name|class_value
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|class_value
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* See comment above for a description of envelopes.  */
name|closed_envelopes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_value
argument_list|,
name|closed_envelopes
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|closed_envelopes
expr_stmt|;
name|class_value
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|envelope_add_decl
argument_list|(
name|type
argument_list|,
name|fields
argument_list|,
operator|&
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_vec
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
while|while
condition|(
name|methods
operator|!=
name|end
condition|)
block|{
comment|/* This will cause lookup_name to return a pointer 	     to the tree_list of possible methods of this name.  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|class_value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* If the class value is not an envelope of the kind described in 	     the comment above, we create a new envelope.  */
if|if
condition|(
name|class_value
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|class_value
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* See comment above for a description of envelopes.  */
name|closed_envelopes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_value
argument_list|,
name|closed_envelopes
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|closed_envelopes
expr_stmt|;
name|class_value
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Here we try to rule out possible ambiguities. 	     If we can't do that, keep a TREE_LIST with possibly ambiguous 	     decls in there.  */
name|maybe_push_cache_obstack
argument_list|()
expr_stmt|;
comment|/* Arbitrarily choose the first function in the list.  This is OK 	     because this is only used for initial lookup; anything that 	     actually uses the function will look it up again.  */
name|envelope_add_decl
argument_list|(
name|type
argument_list|,
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|,
operator|&
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|methods
operator|++
expr_stmt|;
block|}
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consolidate unique (by name) member functions.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_compress_decls
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
comment|/* Farm out constructors and destructors.  */
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
block|{
comment|/* This is known to be an envelope of the kind described before 	     dfs_pushdecls.  */
name|tree
name|class_value
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmp
init|=
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
decl_stmt|;
comment|/* This was replaced in scope by somebody else.  Just leave it 	     alone.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|TREE_LIST
condition|)
continue|continue;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|&&
name|OVL_NEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|class_value
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
comment|/* Push class fields into CLASS_VALUE scope, and mark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_pushdecls
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
comment|/* Compress fields which have only a single entry      by a given name, and unmark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_compress_decls
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
comment|/* Open up all the closed envelopes and push the contained decls into      class scope.  */
while|while
condition|(
name|closed_envelopes
condition|)
block|{
name|tree
name|new
init|=
name|TREE_PURPOSE
argument_list|(
name|closed_envelopes
argument_list|)
decl_stmt|;
name|tree
name|id
decl_stmt|;
comment|/* This is messy because the class value may be a *_DECL, or a 	 TREE_LIST of overloaded *_DECLs or even a TREE_LIST of ambiguous 	 *_DECLs.  The name is stored at different places in these three 	 cases.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|new
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|id
operator|=
name|TREE_PURPOSE
argument_list|(
name|new
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|node
init|=
name|TREE_VALUE
argument_list|(
name|new
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|node
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|n
init|=
name|new
decl_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
control|)
block|{
name|tree
name|d
init|=
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|node
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
name|t
condition|)
comment|/* OK */
empty_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NULL_TREE
condition|)
name|new
operator|=
name|t
expr_stmt|;
block|}
else|else
while|while
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|node
operator|=
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|id
operator|=
name|DECL_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|id
operator|=
name|DECL_NAME
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Install the original class value in order to make 	 pushdecl_class_level work correctly.  */
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|closed_envelopes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|push_class_level_binding
argument_list|(
name|id
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|closed_envelopes
operator|=
name|TREE_CHAIN
argument_list|(
name|closed_envelopes
argument_list|)
expr_stmt|;
block|}
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_unuse_fields
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|unuse_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unuse_fields
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|()
block|{
comment|/* We haven't pushed a search level when dealing with cached classes,      so we'd better not try to pop it.  */
if|if
condition|(
name|search_stack
condition|)
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|flag_memoize_lookups
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d memoized contexts saved\n"
argument_list|,
name|n_contexts_saved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local tree nodes made\n"
argument_list|,
name|my_tree_node_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d local hash nodes made\n"
argument_list|,
name|my_memoized_entry_counter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|0
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|0
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fnfields statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized finds = %d; rejects = %d; (searches = %d)\n"
argument_list|,
name|memoized_fast_finds
index|[
literal|1
index|]
argument_list|,
name|memoized_fast_rejects
index|[
literal|1
index|]
argument_list|,
name|memoized_fields_searched
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  memoized_adds = %d\n"
argument_list|,
name|memoized_adds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* GATHER_STATISTICS */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|type_obstack_entries
argument_list|)
expr_stmt|;
comment|/* This gives us room to build our chains of basetypes,      whether or not we decide to memoize them.  */
name|type_stack
operator|=
name|push_type_level
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|type_obstack
argument_list|)
expr_stmt|;
name|_vptr_name
operator|=
name|get_identifier
argument_list|(
literal|"_vptr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|()
block|{
name|my_memoized_entry_counter
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_finds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_adds
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fast_rejects
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|memoized_fields_searched
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_define
define|#
directive|define
name|scratch_tree_cons
value|expr_tree_cons
end_define

begin_decl_stmt
specifier|static
name|tree
name|conversions
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_conversions
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmp
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
name|conversions
operator|=
name|scratch_tree_cons
argument_list|(
name|binfo
argument_list|,
name|tmp
argument_list|,
name|conversions
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|lookup_conversions
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|conversions
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|add_conversions
argument_list|,
name|unmarkedp
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
block|}
return|return
name|conversions
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of get_template_base.  */
end_comment

begin_function
specifier|static
name|tree
name|get_template_base_recursive
parameter_list|(
name|binfo
parameter_list|,
name|rval
parameter_list|,
name|template
parameter_list|,
name|via_virtual
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|template
decl_stmt|,
name|rval
decl_stmt|;
name|int
name|via_virtual
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|==
name|template
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|NULL_TREE
operator|||
name|rval
operator|==
name|type
condition|)
return|return
name|type
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Find any specific instance of a virtual base, when searching with 	 a binfo...  */
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|this_virtual
init|=
name|via_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
comment|/* When searching for a non-virtual, we cannot mark 	     virtually found binfos.  */
if|if
condition|(
operator|!
name|this_virtual
condition|)
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_template_base_recursive
argument_list|(
name|base_binfo
argument_list|,
name|rval
argument_list|,
name|template
argument_list|,
name|this_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|rval
return|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Given a class template TEMPLATE and a class type or binfo node BINFO,    find the unique base type in BINFO that is an instance of TEMPLATE.    If there are more than one, return error_mark_node.  Used by unify.  */
end_comment

begin_function
name|tree
name|get_template_base
parameter_list|(
name|template
parameter_list|,
name|binfo
parameter_list|)
specifier|register
name|tree
name|template
decl_stmt|,
name|binfo
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|complete_type
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|==
name|template
condition|)
return|return
name|type
return|;
name|rval
operator|=
name|get_template_base_recursive
argument_list|(
name|binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|template
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Check whether the empty class indicated by EMPTY_BINFO is also present    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|compare_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|found_overlap
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dfs_check_overlap
parameter_list|(
name|empty_binfo
parameter_list|)
name|tree
name|empty_binfo
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|compare_type
argument_list|)
init|;
condition|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|empty_binfo
argument_list|)
condition|)
block|{
name|found_overlap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Trivial function to stop base traversal when we find something.  */
end_comment

begin_function
specifier|static
name|int
name|dfs_no_overlap_yet
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|found_overlap
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at    offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */
end_comment

begin_function
name|int
name|types_overlap_p
parameter_list|(
name|empty_type
parameter_list|,
name|next_type
parameter_list|)
name|tree
name|empty_type
decl_stmt|,
name|next_type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|next_type
argument_list|)
condition|)
return|return
literal|0
return|;
name|compare_type
operator|=
name|next_type
expr_stmt|;
name|found_overlap
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|empty_type
argument_list|)
argument_list|,
name|dfs_check_overlap
argument_list|,
name|dfs_no_overlap_yet
argument_list|)
expr_stmt|;
return|return
name|found_overlap
return|;
block|}
end_function

end_unit

