begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_comment
comment|/* Obstack used for remembering decision points of breadth-first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|search_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Methods for pushing and popping objects to and from obstacks.  */
end_comment

begin_function
name|struct
name|stack_level
modifier|*
name|push_stack_level
parameter_list|(
name|obstack
parameter_list|,
name|tp
parameter_list|,
name|size
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Sony NewsOS 5.0 compiler doesn't like void * here.  */
name|int
name|size
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|obstack_grow
argument_list|(
name|obstack
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
expr|struct
name|stack_level
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|obstack
argument_list|)
operator|-
name|size
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|stack
operator|->
name|first
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_base
argument_list|(
name|obstack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|limit
operator|=
name|obstack_room
argument_list|(
name|obstack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|struct
name|stack_level
modifier|*
name|pop_stack_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|stack_level
modifier|*
name|tem
init|=
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|tem
operator|->
name|obstack
decl_stmt|;
name|stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
name|obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_define
define|#
directive|define
name|search_level
value|stack_level
end_define

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|search_stack
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|vbase_info
block|{
comment|/* The class dominating the hierarchy.  */
name|tree
name|type
decl_stmt|;
comment|/* A pointer to a complete object of the indicated TYPE.  */
name|tree
name|decl_ptr
decl_stmt|;
name|tree
name|inits
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_subobject_of_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_check_overlap
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_no_overlap_yet
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|base_kind
name|lookup_base_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|base_access
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamic_cast_base_recurse
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|marked_pushdecls_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|unmarked_pushdecls_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_debug_unmarkedp
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_debug_mark
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_get_vbase_types
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_push_type_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_push_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_unuse_fields
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_conversions
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|covariant_return_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_final_overrider
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|look_for_overrides_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stack_level
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|bfs_walk
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_queue_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shared_member_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_field_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|canonical_binfo
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|shared_marked_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|shared_unmarked_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dependent_base_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_accessible_queue_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_accessible_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_access_in_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|access_kind
name|access_in_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_canonical_queue
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_assert_unmarked_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assert_canonical_unmarked
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|protected_accessible_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|friend_accessible_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_class_bindings
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_self_reference_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_shared_vbase_if_not_primary
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_find_vbase_instance
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_get_pure_virtuals
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_build_inheritance_graph_order
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a level of searching.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|push_search_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|search_level
name|tem
decl_stmt|;
name|tem
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|search_level
modifier|*
name|pop_search_level
parameter_list|(
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|obstack
decl_stmt|;
block|{
specifier|register
name|struct
name|search_level
modifier|*
name|stack
init|=
name|pop_stack_level
argument_list|(
name|obstack
argument_list|)
decl_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GATHER_STATISTICS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Worker for lookup_base.  BINFO is the binfo we are searching at,    BASE is the RECORD_TYPE we are searching for.  ACCESS is the    required access checks.  WITHIN_CURRENT_SCOPE, IS_NON_PUBLIC and    IS_VIRTUAL indicate how BINFO was reached from the start of the    search.  WITHIN_CURRENT_SCOPE is true if we met the current scope,    or friend thereof (this allows us to determine whether a protected    base is accessible or not).  IS_NON_PUBLIC indicates whether BINFO    is accessible and IS_VIRTUAL indicates if it is morally virtual.     If BINFO is of the required type, then *BINFO_PTR is examined to    compare with any other instance of BASE we might have already    discovered. *BINFO_PTR is initialized and a base_kind return value    indicates what kind of base was located.     Otherwise BINFO's bases are searched.  */
end_comment

begin_function
specifier|static
name|base_kind
name|lookup_base_r
parameter_list|(
name|binfo
parameter_list|,
name|base
parameter_list|,
name|access
parameter_list|,
name|within_current_scope
parameter_list|,
name|is_non_public
parameter_list|,
name|is_virtual
parameter_list|,
name|binfo_ptr
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|base
decl_stmt|;
name|base_access
name|access
decl_stmt|;
name|int
name|within_current_scope
decl_stmt|;
name|int
name|is_non_public
decl_stmt|;
comment|/* inside a non-public part */
name|int
name|is_virtual
decl_stmt|;
comment|/* inside a virtual part */
name|tree
modifier|*
name|binfo_ptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|bases
decl_stmt|;
name|base_kind
name|found
init|=
name|bk_not_base
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|ba_check
operator|&&
operator|!
name|within_current_scope
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
block|{
name|within_current_scope
operator|=
literal|1
expr_stmt|;
name|is_non_public
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
block|{
comment|/* We have found a base. Check against what we have found          already. */
name|found
operator|=
name|bk_same_type
expr_stmt|;
if|if
condition|(
name|is_virtual
condition|)
name|found
operator|=
name|bk_via_virtual
expr_stmt|;
if|if
condition|(
name|is_non_public
condition|)
name|found
operator|=
name|bk_inaccessible
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|binfo_ptr
condition|)
operator|*
name|binfo_ptr
operator|=
name|binfo
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_virtual
operator|||
operator|!
name|tree_int_cst_equal
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
operator|*
name|binfo_ptr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
operator|*
name|binfo_ptr
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_virtual
condition|)
comment|/* Prefer a non-virtual base.  */
operator|*
name|binfo_ptr
operator|=
name|binfo
expr_stmt|;
name|found
operator|=
name|bk_ambig
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
name|bases
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bases
condition|)
return|return
name|bk_not_base
return|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|this_non_public
init|=
name|is_non_public
decl_stmt|;
name|int
name|this_virtual
init|=
name|is_virtual
decl_stmt|;
name|base_kind
name|bk
decl_stmt|;
if|if
condition|(
name|access
operator|<=
name|ba_ignore
condition|)
empty_stmt|;
comment|/* no change */
elseif|else
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
condition|)
empty_stmt|;
comment|/* no change */
elseif|else
if|if
condition|(
name|access
operator|==
name|ba_not_special
condition|)
name|this_non_public
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|within_current_scope
condition|)
empty_stmt|;
comment|/* no change */
elseif|else
if|if
condition|(
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
empty_stmt|;
comment|/* no change */
else|else
name|this_non_public
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|this_virtual
operator|=
literal|1
expr_stmt|;
name|bk
operator|=
name|lookup_base_r
argument_list|(
name|base_binfo
argument_list|,
name|base
argument_list|,
name|access
argument_list|,
name|within_current_scope
argument_list|,
name|this_non_public
argument_list|,
name|this_virtual
argument_list|,
name|binfo_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bk
condition|)
block|{
case|case
name|bk_ambig
case|:
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
return|return
name|bk
return|;
name|found
operator|=
name|bk
expr_stmt|;
break|break;
case|case
name|bk_inaccessible
case|:
if|if
condition|(
name|found
operator|==
name|bk_not_base
condition|)
name|found
operator|=
name|bk
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|found
operator|==
name|bk_via_virtual
operator|||
name|found
operator|==
name|bk_inaccessible
argument_list|,
literal|20010723
argument_list|)
expr_stmt|;
break|break;
case|case
name|bk_same_type
case|:
name|bk
operator|=
name|bk_proper_base
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|bk_proper_base
case|:
name|my_friendly_assert
argument_list|(
name|found
operator|==
name|bk_not_base
argument_list|,
literal|20010723
argument_list|)
expr_stmt|;
name|found
operator|=
name|bk
expr_stmt|;
break|break;
case|case
name|bk_via_virtual
case|:
if|if
condition|(
name|found
operator|!=
name|bk_ambig
condition|)
name|found
operator|=
name|bk
expr_stmt|;
break|break;
case|case
name|bk_not_base
case|:
break|break;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Lookup BASE in the hierarchy dominated by T.  Do access checking as    ACCESS specifies.  Return the binfo we discover (which might not be    canonical).  If KIND_PTR is non-NULL, fill with information about    what kind of base we discovered.     If ba_quiet bit is set in ACCESS, then do not issue an error, and    return NULL_TREE for failure.  */
end_comment

begin_function
name|tree
name|lookup_base
parameter_list|(
name|t
parameter_list|,
name|base
parameter_list|,
name|access
parameter_list|,
name|kind_ptr
parameter_list|)
name|tree
name|t
decl_stmt|,
name|base
decl_stmt|;
name|base_access
name|access
decl_stmt|;
name|base_kind
modifier|*
name|kind_ptr
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|NULL
decl_stmt|;
comment|/* The binfo we've found so far. */
name|base_kind
name|bk
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
name|base
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|kind_ptr
condition|)
operator|*
name|kind_ptr
operator|=
name|bk_not_base
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_assert
argument_list|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|base
argument_list|)
argument_list|,
literal|20011127
argument_list|)
expr_stmt|;
comment|/* Ensure that the types are instantiated.  */
name|t
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|bk
operator|=
name|lookup_base_r
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|,
name|base
argument_list|,
name|access
operator|&
operator|~
name|ba_quiet
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|binfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bk
condition|)
block|{
case|case
name|bk_inaccessible
case|:
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|access
operator|&
name|ba_quiet
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%T' is an inaccessible base of `%T'"
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|error_mark_node
expr_stmt|;
block|}
break|break;
case|case
name|bk_ambig
case|:
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
block|{
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|access
operator|&
name|ba_quiet
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%T' is an ambiguous base of `%T'"
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|kind_ptr
condition|)
operator|*
name|kind_ptr
operator|=
name|bk
expr_stmt|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Worker function for get_dynamic_cast_base_type.  */
end_comment

begin_function
specifier|static
name|int
name|dynamic_cast_base_recurse
parameter_list|(
name|subtype
parameter_list|,
name|binfo
parameter_list|,
name|via_virtual
parameter_list|,
name|offset_ptr
parameter_list|)
name|tree
name|subtype
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|int
name|via_virtual
decl_stmt|;
name|tree
modifier|*
name|offset_ptr
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|int
name|worst
init|=
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|subtype
condition|)
block|{
if|if
condition|(
name|via_virtual
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
operator|*
name|offset_ptr
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|rval
operator|=
name|dynamic_cast_base_recurse
argument_list|(
name|subtype
argument_list|,
name|base_binfo
argument_list|,
name|via_virtual
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|offset_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|worst
operator|==
operator|-
literal|2
condition|)
name|worst
operator|=
name|rval
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|>=
literal|0
condition|)
name|worst
operator|=
name|worst
operator|>=
literal|0
condition|?
operator|-
literal|3
else|:
name|worst
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
name|worst
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
operator|-
literal|3
operator|&&
name|worst
operator|!=
operator|-
literal|1
condition|)
name|worst
operator|=
operator|-
literal|3
expr_stmt|;
block|}
return|return
name|worst
return|;
block|}
end_function

begin_comment
comment|/* The dynamic cast runtime needs a hint about how the static SUBTYPE type    started from is related to the required TARGET type, in order to optimize    the inheritance graph search. This information is independent of the    current context, and ignores private paths, hence get_base_distance is    inappropriate. Return a TREE specifying the base offset, BOFF.    BOFF>= 0, there is only one public non-virtual SUBTYPE base at offset BOFF,       and there are no public virtual SUBTYPE bases.    BOFF == -1, SUBTYPE occurs as multiple public virtual or non-virtual bases.    BOFF == -2, SUBTYPE is not a public base.    BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.  */
end_comment

begin_function
name|tree
name|get_dynamic_cast_base_type
parameter_list|(
name|subtype
parameter_list|,
name|target
parameter_list|)
name|tree
name|subtype
decl_stmt|;
name|tree
name|target
decl_stmt|;
block|{
name|tree
name|offset
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|boff
init|=
name|dynamic_cast_base_recurse
argument_list|(
name|subtype
argument_list|,
name|TYPE_BINFO
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|boff
condition|)
return|return
name|offset
return|;
name|offset
operator|=
name|build_int_2
argument_list|(
name|boff
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
operator|=
name|ssizetype
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance lattice    specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return the FIELD_DECL.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller must    figure out whether it can access this field.  (Since it is only one    level, this is reasonable.)  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
comment|/* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and         BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,        the code often worked even when we treated the index as a list        of fields!)        The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|fields
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|>
name|name
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|<
name|name
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
block|{
comment|/* We might have a nested class and a field with the 		 same name; we sorted them appropriately via 		 field_decl_cmp, so just look for the last field with 		 this name.  */
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|hi
operator|&&
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
name|name
condition|)
operator|++
name|i
expr_stmt|;
return|return
name|fields
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
while|while
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|USING_DECL
condition|)
comment|/* For now, we're just treating member using declarations as 	   old ARM-style access declarations.  Thus, there's no reason 	   to return a USING_DECL, and the rest of the compiler can't 	   handle it.  Once the class is defined, these are purged 	   from TYPE_FIELDS anyhow; see handle_using_decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
return|return
name|field
return|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|vptr_identifier
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* There are a number of cases we need to be aware of here: 			 current_class_type	current_function_decl      global			NULL			NULL      fn-local			NULL			SET      class-local		SET			NULL      class->fn			SET			SET      fn->class			SET			SET     Those last two make life interesting.  If we're in a function which is    itself inside a class, we need decls to go into the fn's decls (our    second case below).  But if we're in a class and the class itself is    inside a function, we need decls to go into the decls for the class.  To    achieve this last goal, we must see if, when both current_class_ptr and    current_function_decl are set, the class was declared inside that    function.  If so, we know to put the decls into the class's scope.  */
end_comment

begin_function
name|tree
name|current_scope
parameter_list|()
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
return|return
name|current_class_type
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
name|current_function_decl
return|;
if|if
condition|(
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|||
operator|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
condition|)
return|return
name|current_function_decl
return|;
return|return
name|current_class_type
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if we are currently in a function scope.  Note    that this function returns zero if we are within a local class, but    not within a member function body of the local class.  */
end_comment

begin_function
name|int
name|at_function_scope_p
parameter_list|()
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
return|return
name|cs
operator|&&
name|TREE_CODE
argument_list|(
name|cs
argument_list|)
operator|==
name|FUNCTION_DECL
return|;
block|}
end_function

begin_comment
comment|/* Return the scope of DECL, as appropriate when doing name-lookup.  */
end_comment

begin_function
name|tree
name|context_for_name_lookup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* [class.union]            For the purposes of name lookup, after the anonymous union      definition, the members of the anonymous union are considered to      have been defined in the scope in which the anonymous union is      declared.  */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|context
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Return a canonical BINFO if BINFO is a virtual base, or just BINFO    otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|canonical_binfo
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
return|return
operator|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|?
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
else|:
name|binfo
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A queue function that simply ensures that we walk into the    canonical versions of virtual bases.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_canonical_queue
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from assert_canonical_unmarked.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_assert_unmarked_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Asserts that all the nodes below BINFO (using the canonical    versions of virtual bases) are unmarked.  */
end_comment

begin_function
specifier|static
name|void
name|assert_canonical_unmarked
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_assert_unmarked_p
argument_list|,
name|dfs_canonical_queue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If BINFO is marked, return a canonical version of BINFO.    Otherwise, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|shared_marked_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|binfo
operator|=
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|markedp
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If BINFO is not marked, return a canonical version of BINFO.    Otherwise, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|shared_unmarked_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|binfo
operator|=
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|unmarkedp
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The accessibility routines use BINFO_ACCESS for scratch space    during the computation of the accssibility of some declaration.  */
end_comment

begin_define
define|#
directive|define
name|BINFO_ACCESS
parameter_list|(
name|NODE
parameter_list|)
define|\
value|((access_kind) ((TREE_LANG_FLAG_1 (NODE)<< 1) | TREE_LANG_FLAG_6 (NODE)))
end_define

begin_comment
comment|/* Set the access associated with NODE to ACCESS.  */
end_comment

begin_define
define|#
directive|define
name|SET_BINFO_ACCESS
parameter_list|(
name|NODE
parameter_list|,
name|ACCESS
parameter_list|)
define|\
value|((TREE_LANG_FLAG_1 (NODE) = ((ACCESS)& 2) != 0),	\    (TREE_LANG_FLAG_6 (NODE) = ((ACCESS)& 1) != 0))
end_define

begin_comment
comment|/* Called from access_in_type via dfs_walk.  Calculate the access to    DATA (which is really a DECL) in BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_access_in_type
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|access_kind
name|access
init|=
name|ak_none
decl_stmt|;
if|if
condition|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
operator|==
name|type
condition|)
block|{
comment|/* If we have desceneded to the scope of DECL, just note the 	 appropriate access.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|ak_private
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|ak_protected
expr_stmt|;
else|else
name|access
operator|=
name|ak_public
expr_stmt|;
block|}
else|else
block|{
comment|/* First, check for an access-declaration that gives us more 	 access to the DECL.  The CONST_DECL for an enumeration 	 constant will not have DECL_LANG_SPECIFIC, and thus no 	 DECL_ACCESS.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_DISCRIMINATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|decl_access
init|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_ACCESS
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_access
condition|)
name|access
operator|=
operator|(
operator|(
name|access_kind
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl_access
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|access
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
comment|/* Otherwise, scan our baseclasses, and pick the most favorable 	     access.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|access_kind
name|base_access
init|=
name|BINFO_ACCESS
argument_list|(
name|canonical_binfo
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_access
operator|==
name|ak_none
operator|||
name|base_access
operator|==
name|ak_private
condition|)
comment|/* If it was not accessible in the base, or only 		   accessible as a private member, we can't access it 		   all.  */
name|base_access
operator|=
name|ak_none
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* Public and protected members in the base are 		   protected here.  */
name|base_access
operator|=
name|ak_protected
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|base_binfo
argument_list|)
condition|)
comment|/* Public and protected members in the base are 		   private here.  */
name|base_access
operator|=
name|ak_private
expr_stmt|;
comment|/* See if the new access, via this base, gives more 		 access than our previous best access.  */
if|if
condition|(
name|base_access
operator|!=
name|ak_none
operator|&&
operator|(
name|base_access
operator|==
name|ak_public
operator|||
operator|(
name|base_access
operator|==
name|ak_protected
operator|&&
name|access
operator|!=
name|ak_public
operator|)
operator|||
operator|(
name|base_access
operator|==
name|ak_private
operator|&&
name|access
operator|==
name|ak_none
operator|)
operator|)
condition|)
block|{
name|access
operator|=
name|base_access
expr_stmt|;
comment|/* If the new access is public, we can't do better.  */
if|if
condition|(
name|access
operator|==
name|ak_public
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/* Note the access to DECL in TYPE.  */
name|SET_BINFO_ACCESS
argument_list|(
name|binfo
argument_list|,
name|access
argument_list|)
expr_stmt|;
comment|/* Mark TYPE as visited so that if we reach it again we do not      duplicate our efforts here.  */
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the access to DECL in TYPE.  */
end_comment

begin_function
specifier|static
name|access_kind
name|access_in_type
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We must take into account         [class.paths]         If a name can be reached by several paths through a multiple        inheritance graph, the access is that of the path that gives        most access.        The algorithm we use is to make a post-order depth-first traversal     of the base-class hierarchy.  As we come up the tree, we annotate     each node with the most lenient access.  */
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
name|dfs_access_in_type
argument_list|,
name|shared_unmarked_p
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|shared_marked_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert_canonical_unmarked
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|BINFO_ACCESS
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from dfs_accessible_p via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this class is inherited via private or protected inheritance,      then we can't see it, unless we are a friend of the subclass.  */
if|if
condition|(
operator|!
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|canonical_binfo
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from dfs_accessible_p via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|protected_ok
init|=
name|data
operator|!=
literal|0
decl_stmt|;
name|access_kind
name|access
decl_stmt|;
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|access
operator|=
name|BINFO_ACCESS
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|ak_public
operator|||
operator|(
name|access
operator|==
name|ak_protected
operator|&&
name|protected_ok
operator|)
condition|)
return|return
name|binfo
return|;
elseif|else
if|if
condition|(
name|access
operator|!=
name|ak_none
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|current_scope
argument_list|()
argument_list|)
condition|)
return|return
name|binfo
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if it is OK to access DECL through an object    indiated by BINFO in the context of DERIVED.  */
end_comment

begin_function
specifier|static
name|int
name|protected_accessible_p
parameter_list|(
name|decl
parameter_list|,
name|derived
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|derived
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|access_kind
name|access
decl_stmt|;
comment|/* We're checking this clause from [class.access.base]         m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected.        Here DERIVED is a possible P and DECL is m.  accessible_p will     iterate over various values of N, but the access to m in DERIVED     does not change.      Note that I believe that the passage above is wrong, and should read     "...is private or protected or public"; otherwise you get bizarre results     whereby a public using-decl can prevent you from accessing a protected     member of a base.  (jason 2000/02/28)  */
comment|/* If DERIVED isn't derived from m's class, then it can't be a P.  */
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|,
name|derived
argument_list|)
condition|)
return|return
literal|0
return|;
name|access
operator|=
name|access_in_type
argument_list|(
name|derived
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If m is inaccessible in DERIVED, then it's not a P.  */
if|if
condition|(
name|access
operator|==
name|ak_none
condition|)
return|return
literal|0
return|;
comment|/* [class.protected]       When a friend or a member function of a derived class references      a protected nonstatic member of a base class, an access check      applies in addition to those described earlier in clause      _class.access_) Except when forming a pointer to member      (_expr.unary.op_), the access must be through a pointer to,      reference to, or object of the derived class itself (or any class      derived from that class) (_expr.ref_).  If the access is to form      a pointer to member, the nested-name-specifier shall name the      derived class (or any class derived from that class).  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We can tell through what the reference is occurring by 	 chasing BINFO up to the root.  */
name|tree
name|t
init|=
name|binfo
decl_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|derived
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if SCOPE is a friend of a type which would be able    to access DECL through the object indicated by BINFO.  */
end_comment

begin_function
specifier|static
name|int
name|friend_accessible_p
parameter_list|(
name|scope
parameter_list|,
name|decl
parameter_list|,
name|binfo
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|befriending_classes
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|scope
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|befriending_classes
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Nested classes are implicitly friends of their enclosing types, as      per core issue 45 (this is a change from the standard).  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
for|for
control|(
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
init|;
name|t
operator|&&
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* Perhaps this SCOPE is a member of a class which is a  	 friend.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|friend_accessible_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Or an instantiation of something which is a friend.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|friend_accessible_p
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|friend_accessible_p
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform access control on TYPE_DECL VAL, which was looked up in TYPE.    This is fairly complex, so here's the design:     The lang_extdef nonterminal sets type_lookups to NULL_TREE before we      start to process a top-level declaration.    As we process the decl-specifier-seq for the declaration, any types we      see that might need access control are passed to type_access_control,      which defers checking by adding them to type_lookups.    When we are done with the decl-specifier-seq, we record the lookups we've      seen in the lookups field of the typed_declspecs nonterminal.    When we process the first declarator, either in parse_decl or      begin_function_definition, we call save_type_access_control,      which stores the lookups from the decl-specifier-seq in      current_type_lookups.    As we finish with each declarator, we process everything in type_lookups      via decl_type_access_control, which resets type_lookups to the value of      current_type_lookups for subsequent declarators.    When we enter a function, we set type_lookups to error_mark_node, so all      lookups are processed immediately.  */
end_comment

begin_function
name|void
name|type_access_control
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|)
name|tree
name|type
decl_stmt|,
name|val
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|val
argument_list|)
condition|)
return|return;
if|if
condition|(
name|type_lookups
operator|==
name|error_mark_node
condition|)
name|enforce_access
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|accessible_p
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
condition|)
name|type_lookups
operator|=
name|tree_cons
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|type_lookups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a declaration from a base class of TYPE, which was the    class used to name DECL.  Return non-zero if, in the current    context, DECL is accessible.  If TYPE is actually a BINFO node,    then we can tell in what context the access is occurring by looking    at the most derived class along the path indicated by BINFO.  */
end_comment

begin_function
name|int
name|accessible_p
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Non-zero if it's OK to access DECL if it has protected      accessibility in TYPE.  */
name|int
name|protected_ok
init|=
literal|0
decl_stmt|;
comment|/* If we're not checking access, everything is accessible.  */
if|if
condition|(
operator|!
name|flag_access_control
condition|)
return|return
literal|1
return|;
comment|/* If this declaration is in a block or namespace scope, there's no      access control.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* [class.access.base]       A member m is accessible when named in class N if       --m as a member of N is public, or       --m as a member of N is private, and the reference occurs in a        member or friend of class N, or       --m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected, or       --there exists a base class B of N that is accessible at the point        of reference, and m is accessible when named in class B.        We walk the base class hierarchy, checking these conditions.  */
comment|/* Figure out where the reference is occurring.  Check to see if      DECL is private or protected in this scope, since that will      determine whether protected access is allowed.  */
if|if
condition|(
name|current_class_type
condition|)
name|protected_ok
operator|=
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|current_class_type
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Now, loop through the classes of which we are a friend.  */
if|if
condition|(
operator|!
name|protected_ok
condition|)
name|protected_ok
operator|=
name|friend_accessible_p
argument_list|(
name|current_scope
argument_list|()
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Standardize the binfo that access_in_type will use.  We don't      need to know what path was chosen from this point onwards.  */
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the accessibility of DECL in the class hierarchy      dominated by type.  */
name|access_in_type
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Walk the hierarchy again, looking for a base class that allows      access.  */
name|t
operator|=
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_accessible_p
argument_list|,
name|dfs_accessible_queue_p
argument_list|,
name|protected_ok
condition|?
operator|&
name|protected_ok
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear any mark bits.  Note that we have to walk the whole tree      here, since we have aborted the previous walk from some point      deep in the tree.  */
name|dfs_walk
argument_list|(
name|binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_canonical_queue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert_canonical_unmarked
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|t
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Routine to see if the sub-object denoted by the binfo PARENT can be    found as a base class and sub-object of the object denoted by    BINFO.  MOST_DERIVED is the most derived type of the hierarchy being    searched.  */
end_comment

begin_function
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|parent
parameter_list|,
name|binfo
parameter_list|,
name|most_derived
parameter_list|)
name|tree
name|parent
decl_stmt|,
name|binfo
decl_stmt|,
name|most_derived
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|binfo
condition|)
return|return
literal|1
return|;
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Iterate the base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
comment|/* If we see a TEMPLATE_TYPE_PARM, or some such, as a base 	   class there's no way to descend into it.  */
continue|continue;
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|parent
argument_list|,
name|CANONICAL_BINFO
argument_list|(
name|base_binfo
argument_list|,
name|most_derived
argument_list|)
argument_list|,
name|most_derived
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|lookup_field_info
block|{
comment|/* The type in which we're looking.  */
name|tree
name|type
decl_stmt|;
comment|/* The name of the field for which we're looking.  */
name|tree
name|name
decl_stmt|;
comment|/* If non-NULL, the current result of the lookup.  */
name|tree
name|rval
decl_stmt|;
comment|/* The path to RVAL.  */
name|tree
name|rval_binfo
decl_stmt|;
comment|/* If non-NULL, the lookup was ambiguous, and this is a list of the      candidates.  */
name|tree
name|ambiguous
decl_stmt|;
comment|/* If non-zero, we are looking for types, not data members.  */
name|int
name|want_type
decl_stmt|;
comment|/* If non-zero, RVAL was found by looking through a dependent base.  */
name|int
name|from_dep_base_p
decl_stmt|;
comment|/* If something went wrong, a message indicating what.  */
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Returns non-zero if BINFO is not hidden by the value found by the    lookup so far.  If BINFO is hidden, then there's no need to look in    it.  DATA is really a struct lookup_field_info.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Don't look for constructors or destructors in base classes.  */
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|lfi
operator|->
name|name
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this base class is hidden by the best-known value so far, we      don't need to look.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|from_dep_base_p
operator|&&
name|lfi
operator|->
name|rval_binfo
operator|&&
name|is_subobject_of_p
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|CANONICAL_BINFO
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class, you can refer to the to the    current specialization with the name of the template itself.  For    example:          template<typename T> struct S { S* sp; }     Returns non-zero if DECL is such a declaration in a class TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|template_self_reference_p
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero for a class member means that it is shared between all objects    of that class.     [class.member.lookup]:If the resulting set of declarations are not all    from sub-objects of the same type, or the set has a  nonstatic  member    and  includes members from distinct sub-objects, there is an ambiguity    and the program is ill-formed.     This function checks that T contains no nonstatic members.  */
end_comment

begin_function
specifier|static
name|int
name|shared_member_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
expr|\
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|OVL_NEXT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DATA is really a struct lookup_field_info.  Look for a field with    the name indicated there in BINFO.  If this function returns a    non-NULL value it is the result of the lookup.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_r
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|nval
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|from_dep_base_p
decl_stmt|;
comment|/* First, look for a function.  There can't be a function and a data      member with the same name, and if there's a function and a type      with the same name, the type is hidden by the function.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|want_type
condition|)
block|{
name|int
name|idx
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|nval
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nval
condition|)
comment|/* Look for a data member or type.  */
name|nval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If there is no declaration with the indicated name in this type,      then there's nothing to do.  */
if|if
condition|(
operator|!
name|nval
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we're looking up a type (as with an elaborated type specifier)      we ignore all non-types we find.  */
if|if
condition|(
name|lfi
operator|->
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|nval
argument_list|)
condition|)
block|{
if|if
condition|(
name|lfi
operator|->
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If the aggregate has no user defined constructors, we allow 	     it to have fields with the same name as the enclosing type. 	     If we are looking for that name, find the corresponding 	     TYPE_DECL.  */
for|for
control|(
name|nval
operator|=
name|TREE_CHAIN
argument_list|(
name|nval
argument_list|)
init|;
name|nval
condition|;
name|nval
operator|=
name|TREE_CHAIN
argument_list|(
name|nval
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|nval
argument_list|)
operator|==
name|lfi
operator|->
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|==
name|TYPE_DECL
condition|)
break|break;
block|}
else|else
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|nval
condition|)
block|{
name|nval
operator|=
name|purpose_member
argument_list|(
name|lfi
operator|->
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
condition|)
name|nval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|nval
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
block|}
block|}
comment|/* You must name a template base class with a template-id.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|nval
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|from_dep_base_p
operator|=
name|dependent_base_p
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfi
operator|->
name|from_dep_base_p
operator|&&
operator|!
name|from_dep_base_p
condition|)
block|{
comment|/* If the new declaration is not found via a dependent base, and 	 the old one was, then we must prefer the new one.  We weren't 	 really supposed to be able to find the old one, so we don't 	 want to be affected by a specialization.  Consider:  	   struct B { typedef int I; }; 	   template<typename T> struct D1 : virtual public B {};  	   template<typename T> struct D : 	   public D1, virtual pubic B { I i; };  	 The `I' in `D<T>' is unambigousuly `B::I', regardless of how 	 D1 is specialized.  */
name|lfi
operator|->
name|from_dep_base_p
operator|=
literal|0
expr_stmt|;
name|lfi
operator|->
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
name|lfi
operator|->
name|rval_binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|lfi
operator|->
name|ambiguous
operator|=
name|NULL_TREE
expr_stmt|;
name|lfi
operator|->
name|errstr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|lfi
operator|->
name|from_dep_base_p
operator|&&
name|from_dep_base_p
condition|)
comment|/* Similarly, if the old declaration was not found via a dependent        base, and the new one is, ignore the new one.  */
return|return
name|NULL_TREE
return|;
comment|/* If the lookup already found a match, and the new value doesn't      hide the old one, we might have an ambiguity.  */
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|is_subobject_of_p
argument_list|(
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|binfo
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|nval
operator|==
name|lfi
operator|->
name|rval
operator|&&
name|shared_member_p
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* The two things are really the same.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
condition|)
comment|/* The previous value hides the new one.  */
empty_stmt|;
else|else
block|{
comment|/* We have a real ambiguity.  We keep a chain of all the 	     candidates.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|ambiguous
operator|&&
name|lfi
operator|->
name|rval
condition|)
block|{
comment|/* This is the first time we noticed an ambiguity.  Add 		 what we previously thought was a reasonable candidate 		 to the list.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lfi
operator|->
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add the new value.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|nval
argument_list|,
name|lfi
operator|->
name|ambiguous
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|lfi
operator|->
name|errstr
operator|=
literal|"request for member `%D' is ambiguous"
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|from_dep_base_p
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
comment|/* We need to return a member template class so we can 	     define partial specializations.  Is there a better 	     way?  */
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* The thing we're looking for isn't a type, so the implicit 	   typename extension doesn't apply, so we just pretend we 	   didn't find anything.  */
return|return
name|NULL_TREE
return|;
name|lfi
operator|->
name|rval
operator|=
name|nval
expr_stmt|;
name|lfi
operator|->
name|from_dep_base_p
operator|=
name|from_dep_base_p
expr_stmt|;
name|lfi
operator|->
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look for a member named NAME in an inheritance lattice dominated by    XBASETYPE.  If PROTECT is 0 or two, we do not check access.  If it is    1, we enforce accessibility.  If PROTECT is zero, then, for an    ambiguous lookup, we return NULL.  If PROTECT is 1, we issue an    error message.  If PROTECT is 2, we return a TREE_LIST whose    TREE_TYPE is error_mark_node and whose TREE_VALUEs are the list of    ambiguous candidates.     WANT_TYPE is 1 when we should only return TYPE_DECLs, if no    TYPE_DECL can be found return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_member
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|basetype_path
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|lookup_field_info
name|lfi
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just non-function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      non-function member is found.  */
specifier|const
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|xbasetype
operator|==
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|xbasetype
argument_list|)
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|field
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
condition|)
comment|/* We're in the scope of this class, and the value has already 	   been looked up.  Just return the cached value.  */
return|return
name|field
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|xbasetype
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|980827
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|lfi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lfi
argument_list|)
argument_list|)
expr_stmt|;
name|lfi
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|lfi
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|lfi
operator|.
name|want_type
operator|=
name|want_type
expr_stmt|;
name|bfs_walk
argument_list|(
name|basetype_path
argument_list|,
operator|&
name|lookup_field_r
argument_list|,
operator|&
name|lookup_field_queue_p
argument_list|,
operator|&
name|lfi
argument_list|)
expr_stmt|;
name|rval
operator|=
name|lfi
operator|.
name|rval
expr_stmt|;
name|rval_binfo
operator|=
name|lfi
operator|.
name|rval_binfo
expr_stmt|;
if|if
condition|(
name|rval_binfo
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|rval_binfo
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|lfi
operator|.
name|errstr
expr_stmt|;
comment|/* If we are not interested in ambiguities, don't report them;      just return NULL_TREE.  */
if|if
condition|(
operator|!
name|protect
operator|&&
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|protect
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|lfi
operator|.
name|ambiguous
return|;
else|else
name|protect
operator|=
literal|0
expr_stmt|;
block|}
comment|/* [class.access]       In the case of overloaded function names, access control is      applied to the function selected by overloaded resolution.  */
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
operator|&&
operator|!
name|enforce_access
argument_list|(
name|xbasetype
argument_list|,
name|rval
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
name|print_candidates
argument_list|(
name|lfi
operator|.
name|ambiguous
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If the thing we found was found via the implicit typename      extension, build the typename type.  */
if|if
condition|(
name|rval
operator|&&
name|lfi
operator|.
name|from_dep_base_p
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|rval
argument_list|)
condition|)
name|rval
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|build_typename_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
condition|)
block|{
comment|/* Note that the binfo we put in the baselink is the binfo where 	 we found the functions, which we need for overload 	 resolution, but which should not be passed to enforce_access; 	 rather, enforce_access wants a binfo which refers to the 	 scope in which we started looking for the function.  This 	 will generally be the binfo passed into this function as 	 xbasetype.  */
name|rval
operator|=
name|tree_cons
argument_list|(
name|rval_binfo
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_BASELINK_P
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|,
name|want_type
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|,
name|want_type
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
name|want_type
argument_list|)
decl_stmt|;
comment|/* Ignore functions.  */
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a non-function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|xbasetype
parameter_list|,
name|name
parameter_list|,
name|protect
parameter_list|)
specifier|register
name|tree
name|xbasetype
decl_stmt|,
name|name
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
comment|/*want_type=*/
literal|0
argument_list|)
decl_stmt|;
comment|/* Ignore non-functions.  */
if|if
condition|(
name|rval
operator|&&
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
name|int
name|lookup_fnfields_1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|method_vec
init|=
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
comment|/* Constructors are first...  */
if|if
condition|(
name|name
operator|==
name|ctor_identifier
condition|)
return|return
operator|(
name|methods
index|[
name|CLASSTYPE_CONSTRUCTOR_SLOT
index|]
condition|?
name|CLASSTYPE_CONSTRUCTOR_SLOT
else|:
operator|-
literal|1
operator|)
return|;
comment|/* and destructors are second.  */
if|if
condition|(
name|name
operator|==
name|dtor_identifier
condition|)
return|return
operator|(
name|methods
index|[
name|CLASSTYPE_DESTRUCTOR_SLOT
index|]
condition|?
name|CLASSTYPE_DESTRUCTOR_SLOT
else|:
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|i
operator|<
name|len
operator|&&
name|methods
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|tmp
operator|=
name|OVL_CURRENT
argument_list|(
name|methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
operator|==
name|name
condition|)
return|return
name|i
return|;
comment|/* If the type is complete and we're past the conversion ops, 	     switch to binary search.  */
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|tmp
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|lo
init|=
name|i
operator|+
literal|1
decl_stmt|,
name|hi
init|=
name|len
decl_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|tmp
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|methods
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|name
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|<
name|name
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|i
return|;
block|}
break|break;
block|}
block|}
comment|/* If we didn't find it, it might have been a template 	 conversion operator.  (Note that we don't look for this case 	 above so that we will always find specializations first.)  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|i
operator|<
name|len
operator|&&
name|methods
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|tmp
operator|=
name|OVL_CURRENT
argument_list|(
name|methods
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
comment|/* Since all conversion operators come first, we know 		     there is no such operator.  */
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the class hierarchy dominated by TYPE.  FN is called for each    type in the hierarchy, in a breadth-first preorder traversal.    If it ever returns a non-NULL value, that value is immediately    returned and the walk is terminated.  At each node, FN is passed a    BINFO indicating the path from the curently visited base-class to    TYPE.  Before each base-class is walked QFN is called.  If the    value returned is non-zero, the base-class is walked; otherwise it    is not.  If QFN is NULL, it is treated as a function which always    returns 1.  Both FN and QFN are passed the DATA whenever they are    called.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|bfs_walk
parameter_list|(
name|binfo
parameter_list|,
name|fn
parameter_list|,
name|qfn
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|size_t
name|head
decl_stmt|;
name|size_t
name|tail
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* An array of the base classes of BINFO.  These will be built up in      breadth-first order, except where QFN prunes the search.  */
name|varray_type
name|bfs_bases
decl_stmt|;
comment|/* Start with enough room for ten base classes.  That will be enough      for most hierarchies.  */
name|VARRAY_TREE_INIT
argument_list|(
name|bfs_bases
argument_list|,
literal|10
argument_list|,
literal|"search_stack"
argument_list|)
expr_stmt|;
comment|/* Put the first type into the stack.  */
name|VARRAY_TREE
argument_list|(
name|bfs_bases
argument_list|,
literal|0
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|tail
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|head
operator|=
literal|0
init|;
name|head
operator|<
name|tail
condition|;
operator|++
name|head
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
comment|/* Pull the next type out of the queue.  */
name|binfo
operator|=
name|VARRAY_TREE
argument_list|(
name|bfs_bases
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* If this is the one we're looking for, we're done.  */
name|rval
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
break|break;
comment|/* Queue up the base types.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfn
condition|)
name|base_binfo
operator|=
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
block|{
if|if
condition|(
name|tail
operator|==
name|VARRAY_SIZE
argument_list|(
name|bfs_bases
argument_list|)
condition|)
name|VARRAY_GROW
argument_list|(
name|bfs_bases
argument_list|,
literal|2
operator|*
name|VARRAY_SIZE
argument_list|(
name|bfs_bases
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_TREE
argument_list|(
name|bfs_bases
argument_list|,
name|tail
argument_list|)
operator|=
name|base_binfo
expr_stmt|;
operator|++
name|tail
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean up.  */
name|VARRAY_FREE
argument_list|(
name|bfs_bases
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Exactly like bfs_walk, except that a depth-first traversal is    performed, and PREFN is called in preorder, while POSTFN is called    in postorder.  */
end_comment

begin_function_decl
name|tree
name|dfs_walk_real
parameter_list|(
name|binfo
parameter_list|,
name|prefn
parameter_list|,
name|postfn
parameter_list|,
name|qfn
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*prefn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*postfn
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_baselinks
decl_stmt|;
name|tree
name|binfos
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Call the pre-order walking function.  */
if|if
condition|(
name|prefn
condition|)
block|{
name|rval
operator|=
call|(
modifier|*
name|prefn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
comment|/* Process the basetypes.  */
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|BINFO_N_BASETYPES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qfn
condition|)
name|base_binfo
operator|=
call|(
modifier|*
name|qfn
call|)
argument_list|(
name|base_binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
condition|)
block|{
name|rval
operator|=
name|dfs_walk_real
argument_list|(
name|base_binfo
argument_list|,
name|prefn
argument_list|,
name|postfn
argument_list|,
name|qfn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
block|}
comment|/* Call the post-order walking function.  */
if|if
condition|(
name|postfn
condition|)
name|rval
operator|=
call|(
modifier|*
name|postfn
call|)
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_comment
comment|/* Exactly like bfs_walk, except that a depth-first post-order traversal is    performed.  */
end_comment

begin_function_decl
name|tree
name|dfs_walk
parameter_list|(
name|binfo
parameter_list|,
name|fn
parameter_list|,
name|qfn
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
function_decl|tree
parameter_list|(
function_decl|*fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|tree
argument_list|(
argument|*qfn
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|dfs_walk_real
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|qfn
argument_list|,
name|data
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Returns> 0 if a function with type DRETTYPE overriding a function    with type BRETTYPE is covariant, as defined in [class.virtual].     Returns 1 if trivial covariance, 2 if non-trivial (requiring runtime    adjustment), or -1 if pedantically invalid covariance.  */
end_comment

begin_function
specifier|static
name|int
name|covariant_return_p
parameter_list|(
name|brettype
parameter_list|,
name|drettype
parameter_list|)
name|tree
name|brettype
decl_stmt|,
name|drettype
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
name|base_kind
name|kind
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|drettype
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|brettype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TYPE_QUALS
argument_list|(
name|brettype
argument_list|)
operator|==
name|TYPE_QUALS
argument_list|(
name|drettype
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|can_convert
argument_list|(
name|brettype
argument_list|,
name|drettype
argument_list|)
condition|)
return|return
literal|0
return|;
name|brettype
operator|=
name|TREE_TYPE
argument_list|(
name|brettype
argument_list|)
expr_stmt|;
name|drettype
operator|=
name|TREE_TYPE
argument_list|(
name|drettype
argument_list|)
expr_stmt|;
comment|/* If not pedantic, allow any standard pointer conversion.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|drettype
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|brettype
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|drettype
argument_list|,
name|brettype
argument_list|,
name|ba_check
operator||
name|ba_quiet
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
operator|&&
name|kind
operator|!=
name|bk_via_virtual
condition|)
return|return
literal|1
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Check that virtual overrider OVERRIDER is acceptable for base function    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */
end_comment

begin_function
specifier|static
name|int
name|check_final_overrider
parameter_list|(
name|overrider
parameter_list|,
name|basefn
parameter_list|)
name|tree
name|overrider
decl_stmt|,
name|basefn
decl_stmt|;
block|{
name|tree
name|over_type
init|=
name|TREE_TYPE
argument_list|(
name|overrider
argument_list|)
decl_stmt|;
name|tree
name|base_type
init|=
name|TREE_TYPE
argument_list|(
name|basefn
argument_list|)
decl_stmt|;
name|tree
name|over_return
init|=
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
decl_stmt|;
name|tree
name|base_return
init|=
name|TREE_TYPE
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|tree
name|over_throw
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|over_type
argument_list|)
decl_stmt|;
name|tree
name|base_throw
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|base_return
argument_list|,
name|over_return
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|covariant_return_p
argument_list|(
name|base_return
argument_list|,
name|over_return
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|sorry
argument_list|(
literal|"adjusting pointers for covariant returns"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"invalid covariant return type for `%#D'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  overriding `%#D' (must be pointer or reference to class)"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_2
argument_list|(
name|base_return
argument_list|,
name|over_return
argument_list|)
operator|&&
name|same_or_base_type_p
argument_list|(
name|base_return
argument_list|,
name|over_return
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"invalid covariant return type for `%#D'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#D' (must use pointer or reference)"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|overrider
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"conflicting return type specified for `%#D'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#D'"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|overrider
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|overrider
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check throw specifier is subset.  */
if|if
condition|(
operator|!
name|comp_except_specs
argument_list|(
name|base_throw
argument_list|,
name|over_throw
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"looser throw specifier for `%#F'"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  overriding `%#F'"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a class TYPE, and a function decl FNDECL, look for    virtual functions in TYPE's hierarchy which FNDECL overrides.    We do not look in TYPE itself, only its bases.        Returns non-zero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we    find that it overrides anything.        We check that every function which is overridden, is correctly    overridden.  */
end_comment

begin_function
name|int
name|look_for_overrides
parameter_list|(
name|type
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|basebinfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|nbasebinfos
init|=
name|basebinfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|basebinfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|nbasebinfos
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|basebinfos
argument_list|,
name|ix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|found
operator|+=
name|look_for_overrides_r
argument_list|(
name|basetype
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Look in TYPE for virtual functions with the same signature as FNDECL.    This differs from get_matching_virtual in that it will only return    a function from TYPE.  */
end_comment

begin_function
name|tree
name|look_for_overrides_here
parameter_list|(
name|type
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|ix
operator|=
name|CLASSTYPE_DESTRUCTOR_SLOT
expr_stmt|;
else|else
name|ix
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
name|tree
name|fns
init|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Not a virtual.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|!=
name|type
condition|)
comment|/* Introduced with a using declaration.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|btypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|dtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
elseif|else
if|if
condition|(
name|same_signature_p
argument_list|(
name|fndecl
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look in TYPE for virtual functions overridden by FNDECL. Check both    TYPE itself and its bases. */
end_comment

begin_function
specifier|static
name|int
name|look_for_overrides_r
parameter_list|(
name|type
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|look_for_overrides_here
argument_list|(
name|type
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* A static member function cannot match an inherited 	     virtual member function.  */
name|cp_error_at
argument_list|(
literal|"`%#D' cannot be declared"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  since `%#D' declared in base class"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's definitely virtual, even if not explicitly set.  */
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|check_final_overrider
argument_list|(
name|fndecl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* We failed to find one declared in this class. Look in its bases.  */
return|return
name|look_for_overrides
argument_list|(
name|type
argument_list|,
name|fndecl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A queue function for dfs_walk that skips any nonprimary virtual    bases and any already marked bases.  */
end_comment

begin_function
name|tree
name|dfs_skip_nonprimary_vbases_unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* This is a non-primary virtual base.  Skip it.  */
return|return
name|NULL_TREE
return|;
return|return
name|unmarkedp
argument_list|(
name|binfo
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A queue function for dfs_walk that skips any nonprimary virtual    bases and any unmarked bases.  */
end_comment

begin_function
name|tree
name|dfs_skip_nonprimary_vbases_markedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* This is a non-primary virtual base.  Skip it.  */
return|return
name|NULL_TREE
return|;
return|return
name|markedp
argument_list|(
name|binfo
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If BINFO is a non-primary virtual baseclass (in the hierarchy    dominated by TYPE), and no primary copy appears anywhere in the    hierarchy, return the shared copy.  If a primary copy appears    elsewhere, return NULL_TREE.  Otherwise, return BINFO itself; it is    either a non-virtual base or a primary virtual base.  */
end_comment

begin_function
specifier|static
name|tree
name|get_shared_vbase_if_not_primary
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|type
operator|=
name|TREE_PURPOSE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* This is a non-primary virtual base.  If there is no primary 	 version, get the shared version.  */
name|binfo
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* A queue function to use with dfs_walk that prevents travel into any    nonprimary virtual base, or its baseclasses.  DATA should be the    type of the complete object, or a TREE_LIST whose TREE_PURPOSE is    the type of the complete object.  By using this function as a queue    function, you will walk over exactly those BINFOs that actually    exist in the complete object, including those for virtual base    classes.  If you SET_BINFO_MARKED for each binfo you process, you    are further guaranteed that you will walk into each virtual base    class exactly once.  */
end_comment

begin_function
name|tree
name|dfs_unmarked_real_bases_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|binfo
operator|=
name|get_shared_vbase_if_not_primary
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|binfo
condition|?
name|unmarkedp
argument_list|(
name|binfo
argument_list|,
name|NULL
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like dfs_unmarked_real_bases_queue_p but walks only into things    that are marked, rather than unmarked.  */
end_comment

begin_function
name|tree
name|dfs_marked_real_bases_queue_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|binfo
operator|=
name|get_shared_vbase_if_not_primary
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|binfo
condition|?
name|markedp
argument_list|(
name|binfo
argument_list|,
name|NULL
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* A queue function that skips all virtual bases (and their     bases).  */
end_comment

begin_function
name|tree
name|dfs_skip_vbases
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from dfs_get_pure_virtuals.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_get_pure_virtuals
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
comment|/* We're not interested in primary base classes; the derived class      of which they are a primary base will contain the information we      need.  */
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|virtuals
decl_stmt|;
for|for
control|(
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
control|)
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
condition|)
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set CLASSTYPE_PURE_VIRTUALS for TYPE.  */
end_comment

begin_function
name|void
name|get_pure_virtuals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
comment|/* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there      is going to be overridden.  */
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now, run through all the bases which are not primary bases, and      collect the pure virtual functions.  We look at the vtable in      each class to determine what pure virtual functions are present.      (A primary base is not interesting because the derived class of      which it is a primary base will contain vtable entries for the      pure virtuals in the base class.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_get_pure_virtuals
argument_list|,
name|dfs_unmarked_real_bases_queue_p
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_marked_real_bases_queue_p
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Put the pure virtuals in dfs order.  */
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|virtuals
decl_stmt|;
for|for
control|(
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
control|)
block|{
name|tree
name|base_fndecl
init|=
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NEEDS_FINAL_OVERRIDER_P
argument_list|(
name|base_fndecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%#D' needs a final overrider"
argument_list|,
name|base_fndecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* DEPTH-FIRST SEARCH ROUTINES.  */
end_comment

begin_function
name|tree
name|markedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|!
name|BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|marked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|unmarked_vtable_pathp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|!
name|BINFO_VTABLE_PATH_MARKED
argument_list|(
name|binfo
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|marked_pushdecls_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmarked_pushdecls_p
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|CLASS_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|&&
operator|!
name|BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
operator|)
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* The worker functions for `dfs_walk'.  These do not need to    test anything (vis a vis marking) if they are paired with    a predicate function (above).  */
end_comment

begin_function
name|tree
name|dfs_unmark
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|CLEAR_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* get virtual base class types.    This adds type to the vbase_types list in reverse dfs order.    Ordering is very important, so don't change it.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_get_vbase_types
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from mark_primary_bases.  Builds the    inheritance graph order list of BINFOs.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_build_inheritance_graph_order
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
modifier|*
name|last_binfo
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|*
name|last_binfo
condition|)
name|TREE_CHAIN
argument_list|(
operator|*
name|last_binfo
argument_list|)
operator|=
name|binfo
expr_stmt|;
operator|*
name|last_binfo
operator|=
name|binfo
expr_stmt|;
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set CLASSTYPE_VBASECLASSES for TYPE.  */
end_comment

begin_function
name|void
name|get_vbase_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|last_binfo
decl_stmt|;
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_get_vbase_types
argument_list|,
name|unmarkedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now      reverse it so that we get normal dfs ordering.  */
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|nreverse
argument_list|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Thread the BINFOs in inheritance-graph order.  */
name|last_binfo
operator|=
name|NULL
expr_stmt|;
name|dfs_walk_real
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_build_inheritance_graph_order
argument_list|,
name|NULL
argument_list|,
name|unmarkedp
argument_list|,
operator|&
name|last_binfo
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from find_vbase_instance via dfs_walk.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_find_vbase_instance
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|base
init|=
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
return|return
name|binfo
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Find the real occurrence of the virtual BASE (a class type) in the    hierarchy dominated by TYPE.  */
end_comment

begin_function
name|tree
name|find_vbase_instance
parameter_list|(
name|base
parameter_list|,
name|type
parameter_list|)
name|tree
name|base
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|instance
decl_stmt|;
name|instance
operator|=
name|binfo_for_vbase
argument_list|(
name|base
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|instance
argument_list|)
condition|)
return|return
name|instance
return|;
return|return
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_find_vbase_instance
argument_list|,
name|NULL
argument_list|,
name|build_tree_list
argument_list|(
name|type
argument_list|,
name|base
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug info for C++ classes can get very large; try to avoid    emitting it everywhere.     Note that this optimization wins even when the target supports    BINCL (if only slightly), and reduces the amount of work for the    linker.  */
end_comment

begin_function
name|void
name|maybe_suppress_debug_info
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
comment|/* We can't do the usual TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which      does not support name references between translation units.  It supports      symbolic references between translation units, but only within a single      executable or shared library.       For DWARF 2, we handle TYPE_DECL_SUPPRESS_DEBUG by pretending      that the type was never defined, so we only get the members we      actually define.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
return|return;
comment|/* We might have set this earlier in cp_finish_decl.  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If we already know how we're handling this class, handle debug info      the same way.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* else don't set it.  */
block|}
comment|/* If the class has a vtable, write out the debug info along with      the vtable.  */
elseif|else
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, just emit the debug info normally.  */
block|}
end_function

begin_comment
comment|/* Note that we want debugging information for a base class of a class    whose vtable is being emitted.  Normally, this would happen because    calling the constructor for a derived class implies calling the    constructors for all bases, which involve initializing the    appropriate vptr with the vtable for the base class; but in the    presence of optimization, this initialization may be optimized    away, so we tell finish_vtable_vardecl that we want the debugging    information anyway.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_debug_mark
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns BINFO if we haven't already noted that we want debugging    info for this base class.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_debug_unmarkedp
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|?
name|binfo
else|:
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the debugging information for TYPE, whose vtable is being    emitted.  Also walk through our bases and note that we want to    write out information for them.  This avoids the problem of not    writing any debug info for intermediate basetypes whose    constructors, and thus the references to their vtables, and thus    the vtables themselves, were optimized away.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|type
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|dfs_debug_unmarkedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of push_class_decls ().  */
end_comment

begin_comment
comment|/* Returns 1 iff BINFO is a base we shouldn't really be able to see into,    because it (or one of the intermediate bases) depends on template parms.  */
end_comment

begin_function
specifier|static
name|int
name|dependent_base_p
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
for|for
control|(
init|;
name|binfo
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|currently_open_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_class_bindings
parameter_list|(
name|name
parameter_list|,
name|type_binding_p
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|type_binding_p
decl_stmt|;
block|{
name|tree
name|type_binding
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|value_binding
decl_stmt|;
comment|/* If we've already done the lookup for this declaration, we're      done.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return;
comment|/* First, deal with the type binding.  */
if|if
condition|(
name|type_binding_p
condition|)
block|{
name|type_binding
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|type_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|type_binding
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|type_binding
argument_list|)
expr_stmt|;
block|}
comment|/* Now, do the value binding.  */
name|value_binding
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_binding_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|value_binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
comment|/* We found a type-binding, even when looking for a non-type        binding.  This means that we already processed this binding        above.  */
name|my_friendly_assert
argument_list|(
name|type_binding_p
argument_list|,
literal|19990401
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value_binding
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|value_binding
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|BASELINK_P
argument_list|(
name|value_binding
argument_list|)
condition|)
comment|/* NAME is some overloaded functions.  */
name|value_binding
operator|=
name|TREE_VALUE
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Push class-level declarations for any names appearing in BINFO that    are TYPE_DECLS.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_push_type_decls
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|fields
decl_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
operator|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|fields
argument_list|)
operator|)
condition|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't just use BINFO_MARKED because envelope_add_decl uses      DERIVED_FROM_P, which calls get_base_distance.  */
name|SET_BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Push class-level declarations for any names appearing in BINFO that    are not TYPE_DECLS.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_push_decls
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|method_vec
decl_stmt|;
name|int
name|dep_base_p
decl_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|dep_base_p
operator|=
operator|(
name|processing_template_decl
operator|&&
name|type
operator|!=
name|current_class_type
operator|&&
name|dependent_base_p
argument_list|(
name|binfo
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dep_base_p
condition|)
block|{
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|USING_DECL
condition|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|dfs_push_decls
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|method_vec
operator|=
operator|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|method_vec
condition|)
block|{
name|tree
modifier|*
name|methods
decl_stmt|;
name|tree
modifier|*
name|end
decl_stmt|;
comment|/* Farm out constructors and destructors.  */
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
for|for
control|(
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|2
argument_list|)
init|;
operator|*
name|methods
operator|&&
name|methods
operator|!=
name|end
condition|;
name|methods
operator|++
control|)
name|setup_class_bindings
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
argument_list|,
comment|/*type_binding_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|CLEAR_BINFO_PUSHDECLS_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* When entering the scope of a class, we cache all of the    fields that that class provides within its inheritance    lattice.  Where ambiguities result, we mark them    with `error_mark_node' so that if they are encountered    without explicit qualification, we can emit an error    message.  */
end_comment

begin_function
name|void
name|push_class_decls
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|search_stack
operator|=
name|push_search_level
argument_list|(
name|search_stack
argument_list|,
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
comment|/* Enter type declarations and mark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_push_type_decls
argument_list|,
name|unmarked_pushdecls_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enter non-type declarations and unmark.  */
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_push_decls
argument_list|,
name|marked_pushdecls_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_unuse_fields
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|unuse_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unuse_fields
argument_list|,
name|unmarkedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_class_decls
parameter_list|()
block|{
comment|/* We haven't pushed a search level when dealing with cached classes,      so we'd better not try to pop it.  */
if|if
condition|(
name|search_stack
condition|)
name|search_stack
operator|=
name|pop_search_level
argument_list|(
name|search_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* GATHER_STATISTICS */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
name|void
name|init_search_processing
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|search_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
specifier|static
name|tree
name|add_conversions
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|conversions
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Some builtin types have no method vector, not even an empty one.  */
if|if
condition|(
operator|!
name|method_vec
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmp
init|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|||
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
break|break;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we don't already have this conversion.  */
if|if
condition|(
operator|!
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
condition|)
block|{
operator|*
name|conversions
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|tmp
argument_list|,
operator|*
name|conversions
argument_list|)
expr_stmt|;
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a TREE_LIST containing all the non-hidden user-defined    conversion functions for TYPE (and its base-classes).  The    TREE_VALUE of each node is a FUNCTION_DECL or an OVERLOAD    containing the conversion functions.  The TREE_PURPOSE is the BINFO    from which the conversion functions in this node were selected.  */
end_comment

begin_function
name|tree
name|lookup_conversions
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|conversions
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|bfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|add_conversions
argument_list|,
literal|0
argument_list|,
operator|&
name|conversions
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|conversions
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|IDENTIFIER_MARKED
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|conversions
return|;
block|}
end_function

begin_struct
struct|struct
name|overlap_info
block|{
name|tree
name|compare_type
decl_stmt|;
name|int
name|found_overlap
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Check whether the empty class indicated by EMPTY_BINFO is also present    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_check_overlap
parameter_list|(
name|empty_binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|empty_binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|overlap_info
modifier|*
name|oi
init|=
operator|(
expr|struct
name|overlap_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|oi
operator|->
name|compare_type
argument_list|)
init|;
condition|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|binfo
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|empty_binfo
argument_list|)
condition|)
block|{
name|oi
operator|->
name|found_overlap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Trivial function to stop base traversal when we find something.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_no_overlap_yet
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|overlap_info
modifier|*
name|oi
init|=
operator|(
expr|struct
name|overlap_info
operator|*
operator|)
name|data
decl_stmt|;
return|return
operator|!
name|oi
operator|->
name|found_overlap
condition|?
name|binfo
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at    offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */
end_comment

begin_function
name|int
name|types_overlap_p
parameter_list|(
name|empty_type
parameter_list|,
name|next_type
parameter_list|)
name|tree
name|empty_type
decl_stmt|,
name|next_type
decl_stmt|;
block|{
name|struct
name|overlap_info
name|oi
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|next_type
argument_list|)
condition|)
return|return
literal|0
return|;
name|oi
operator|.
name|compare_type
operator|=
name|next_type
expr_stmt|;
name|oi
operator|.
name|found_overlap
operator|=
literal|0
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|empty_type
argument_list|)
argument_list|,
name|dfs_check_overlap
argument_list|,
name|dfs_no_overlap_yet
argument_list|,
operator|&
name|oi
argument_list|)
expr_stmt|;
return|return
name|oi
operator|.
name|found_overlap
return|;
block|}
end_function

begin_comment
comment|/* Given a vtable VAR, determine which of the inherited classes the vtable    inherits (in a loose sense) functions from.     FIXME: This does not work with the new ABI.  */
end_comment

begin_function
name|tree
name|binfo_for_vtable
parameter_list|(
name|var
parameter_list|)
name|tree
name|var
decl_stmt|;
block|{
name|tree
name|main_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_binfo
operator|!=
name|NULL_TREE
operator|&&
name|BINFO_VTABLE
argument_list|(
name|base_binfo
argument_list|)
operator|==
name|var
condition|)
return|return
name|base_binfo
return|;
block|}
comment|/* If no secondary base classes matched, return the primary base, if      there is one.   */
if|if
condition|(
name|CLASSTYPE_HAS_PRIMARY_BASE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|main_binfo
argument_list|)
argument_list|)
condition|)
return|return
name|get_primary_binfo
argument_list|(
name|main_binfo
argument_list|)
return|;
return|return
name|main_binfo
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo of the first direct or indirect virtual base derived    from BINFO, or NULL if binfo is not via virtual.  */
end_comment

begin_function
name|tree
name|binfo_from_vbase
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
for|for
control|(
init|;
name|binfo
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo of the first direct or indirect virtual base derived    from BINFO up to the TREE_TYPE, LIMIT, or NULL if binfo is not    via virtual.  */
end_comment

begin_function
name|tree
name|binfo_via_virtual
parameter_list|(
name|binfo
parameter_list|,
name|limit
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|limit
decl_stmt|;
block|{
for|for
control|(
init|;
name|binfo
operator|&&
operator|(
operator|!
name|limit
operator|||
operator|!
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|limit
argument_list|)
operator|)
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the BINFO (if any) for the virtual baseclass T of the class    C from the CLASSTYPE_VBASECLASSES list.  */
end_comment

begin_function
name|tree
name|binfo_for_vbase
parameter_list|(
name|basetype
parameter_list|,
name|classtype
parameter_list|)
name|tree
name|basetype
decl_stmt|;
name|tree
name|classtype
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|;
name|binfo
operator|=
name|purpose_member
argument_list|(
name|basetype
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|classtype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|binfo
condition|?
name|TREE_VALUE
argument_list|(
name|binfo
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

end_unit

