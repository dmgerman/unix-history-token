begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Breadth-first and depth-first routines for    searching multiple-inheritance lattice for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_function_decl
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_lookup_base
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_dcast_hint_pre
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_dcast_hint_post
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_debug_mark
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_walk_once_r
parameter_list|(
name|tree
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dfs_unmark_r
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_hidden_convs
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|split_conversions
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_conversions_r
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|look_for_overrides_r
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_field_r
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_accessible_post
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_walk_once_accessible_r
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_walk_once_accessible
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_access_in_type
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|access_kind
name|access_in_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|protected_accessible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|friend_accessible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|template_self_reference_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_get_pure_virtuals
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Variables for gathering statistics.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|n_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_field
decl_stmt|,
name|n_calls_lookup_field_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_lookup_fnfields
decl_stmt|,
name|n_calls_lookup_fnfields_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_calls_get_base_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_outer_fields_searched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_contexts_saved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GATHER_STATISTICS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Data for lookup_base and its workers.  */
end_comment

begin_struct
struct|struct
name|lookup_base_data_s
block|{
name|tree
name|t
decl_stmt|;
comment|/* type being searched.  */
name|tree
name|base
decl_stmt|;
comment|/* The base type we're looking for.  */
name|tree
name|binfo
decl_stmt|;
comment|/* Found binfo.  */
name|bool
name|via_virtual
decl_stmt|;
comment|/* Found via a virtual path.  */
name|bool
name|ambiguous
decl_stmt|;
comment|/* Found multiply ambiguous */
name|bool
name|repeated_base
decl_stmt|;
comment|/* Whether there are repeated bases in the 			    hierarchy.  */
name|bool
name|want_any
decl_stmt|;
comment|/* Whether we want any matching binfo.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Worker function for lookup_base.  See if we've found the desired    base and update DATA_ (a pointer to LOOKUP_BASE_DATA_S).  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_lookup_base
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data_
parameter_list|)
block|{
name|struct
name|lookup_base_data_s
modifier|*
name|data
init|=
operator|(
expr|struct
name|lookup_base_data_s
operator|*
operator|)
name|data_
decl_stmt|;
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|data
operator|->
name|base
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|data
operator|->
name|binfo
condition|)
block|{
name|data
operator|->
name|binfo
operator|=
name|binfo
expr_stmt|;
name|data
operator|->
name|via_virtual
operator|=
name|binfo_via_virtual
argument_list|(
name|data
operator|->
name|binfo
argument_list|,
name|data
operator|->
name|t
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|repeated_base
condition|)
comment|/* If there are no repeated bases, we can stop now.  */
return|return
name|binfo
return|;
if|if
condition|(
name|data
operator|->
name|want_any
operator|&&
operator|!
name|data
operator|->
name|via_virtual
condition|)
comment|/* If this is a non-virtual base, then we can't do 	       better.  */
return|return
name|binfo
return|;
return|return
name|dfs_skip_bases
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|binfo
operator|!=
name|data
operator|->
name|binfo
argument_list|)
expr_stmt|;
comment|/* We've found more than one matching binfo.  */
if|if
condition|(
operator|!
name|data
operator|->
name|want_any
condition|)
block|{
comment|/* This is immediately ambiguous.  */
name|data
operator|->
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|data
operator|->
name|ambiguous
operator|=
name|true
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Prefer one via a non-virtual path.  */
if|if
condition|(
operator|!
name|binfo_via_virtual
argument_list|(
name|binfo
argument_list|,
name|data
operator|->
name|t
argument_list|)
condition|)
block|{
name|data
operator|->
name|binfo
operator|=
name|binfo
expr_stmt|;
name|data
operator|->
name|via_virtual
operator|=
name|false
expr_stmt|;
return|return
name|binfo
return|;
block|}
comment|/* There must be repeated bases, otherwise we'd have stopped 	     on the first base we found.  */
return|return
name|dfs_skip_bases
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns true if type BASE is accessible in T.  (BASE is known to be    a (possibly non-proper) base class of T.)  If CONSIDER_LOCAL_P is    true, consider any special access of the current scope, or access    bestowed by friendship.  */
end_comment

begin_function
name|bool
name|accessible_base_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|base
parameter_list|,
name|bool
name|consider_local_p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* [class.access.base]       A base class is said to be accessible if an invented public      member of the base class is accessible.       If BASE is a non-proper base, this condition is trivially      true.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|t
argument_list|,
name|base
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Rather than inventing a public member, we use the implicit      public typedef created in the scope of every class.  */
name|decl
operator|=
name|TYPE_FIELDS
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|DECL_SELF_REFERENCE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|accessible_p
argument_list|(
name|t
argument_list|,
name|decl
argument_list|,
name|consider_local_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup BASE in the hierarchy dominated by T.  Do access checking as    ACCESS specifies.  Return the binfo we discover.  If KIND_PTR is    non-NULL, fill with information about what kind of base we    discovered.     If the base is inaccessible, or ambiguous, and the ba_quiet bit is    not set in ACCESS, then an error is issued and error_mark_node is    returned.  If the ba_quiet bit is set, then no error is issued and    NULL_TREE is returned.  */
end_comment

begin_function
name|tree
name|lookup_base
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|base
parameter_list|,
name|base_access
name|access
parameter_list|,
name|base_kind
modifier|*
name|kind_ptr
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|t_binfo
decl_stmt|;
name|base_kind
name|bk
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
name|base
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|kind_ptr
condition|)
operator|*
name|kind_ptr
operator|=
name|bk_not_base
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t_binfo
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|base
operator|=
name|complete_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_binfo
condition|)
block|{
name|struct
name|lookup_base_data_s
name|data
decl_stmt|;
name|data
operator|.
name|t
operator|=
name|t
expr_stmt|;
name|data
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|data
operator|.
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|data
operator|.
name|ambiguous
operator|=
name|data
operator|.
name|via_virtual
operator|=
name|false
expr_stmt|;
name|data
operator|.
name|repeated_base
operator|=
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|data
operator|.
name|want_any
operator|=
name|access
operator|==
name|ba_any
expr_stmt|;
name|dfs_walk_once
argument_list|(
name|t_binfo
argument_list|,
name|dfs_lookup_base
argument_list|,
name|NULL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|data
operator|.
name|binfo
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
name|bk
operator|=
name|data
operator|.
name|ambiguous
condition|?
name|bk_ambig
else|:
name|bk_not_base
expr_stmt|;
elseif|else
if|if
condition|(
name|binfo
operator|==
name|t_binfo
condition|)
name|bk
operator|=
name|bk_same_type
expr_stmt|;
elseif|else
if|if
condition|(
name|data
operator|.
name|via_virtual
condition|)
name|bk
operator|=
name|bk_via_virtual
expr_stmt|;
else|else
name|bk
operator|=
name|bk_proper_base
expr_stmt|;
block|}
else|else
block|{
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|bk
operator|=
name|bk_not_base
expr_stmt|;
block|}
comment|/* Check that the base is unambiguous and accessible.  */
if|if
condition|(
name|access
operator|!=
name|ba_any
condition|)
switch|switch
condition|(
name|bk
condition|)
block|{
case|case
name|bk_not_base
case|:
break|break;
case|case
name|bk_ambig
case|:
if|if
condition|(
operator|!
operator|(
name|access
operator|&
name|ba_quiet
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%qT is an ambiguous base of %qT"
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|error_mark_node
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|access
operator|&
name|ba_check_bit
operator|)
comment|/* If BASE is incomplete, then BASE and TYPE are probably 	       the same, in which case BASE is accessible.  If they 	       are not the same, then TYPE is invalid.  In that case, 	       there's no need to issue another error here, and 	       there's no implicit typedef to use in the code that 	       follows, so we skip the check.  */
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
name|accessible_base_p
argument_list|(
name|t
argument_list|,
name|base
argument_list|,
operator|!
operator|(
name|access
operator|&
name|ba_ignore_scope
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|access
operator|&
name|ba_quiet
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%qT is an inaccessible base of %qT"
argument_list|,
name|base
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|bk
operator|=
name|bk_inaccessible
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|kind_ptr
condition|)
operator|*
name|kind_ptr
operator|=
name|bk
expr_stmt|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* Data for dcast_base_hint walker.  */
end_comment

begin_struct
struct|struct
name|dcast_data_s
block|{
name|tree
name|subtype
decl_stmt|;
comment|/* The base type we're looking for.  */
name|int
name|virt_depth
decl_stmt|;
comment|/* Number of virtual bases encountered from most 		     derived.  */
name|tree
name|offset
decl_stmt|;
comment|/* Best hint offset discovered so far.  */
name|bool
name|repeated_base
decl_stmt|;
comment|/* Whether there are repeated bases in the 			  hierarchy.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Worker for dcast_base_hint.  Search for the base type being cast    from.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_dcast_hint_pre
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data_
parameter_list|)
block|{
name|struct
name|dcast_data_s
modifier|*
name|data
init|=
operator|(
expr|struct
name|dcast_data_s
operator|*
operator|)
name|data_
decl_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
name|data
operator|->
name|virt_depth
operator|++
expr_stmt|;
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|data
operator|->
name|subtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|virt_depth
condition|)
block|{
name|data
operator|->
name|offset
operator|=
name|ssize_int
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|offset
return|;
block|}
if|if
condition|(
name|data
operator|->
name|offset
condition|)
name|data
operator|->
name|offset
operator|=
name|ssize_int
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
else|else
name|data
operator|->
name|offset
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|repeated_base
condition|?
name|dfs_skip_bases
else|:
name|data
operator|->
name|offset
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Worker for dcast_base_hint.  Track the virtual depth.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_dcast_hint_post
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data_
parameter_list|)
block|{
name|struct
name|dcast_data_s
modifier|*
name|data
init|=
operator|(
expr|struct
name|dcast_data_s
operator|*
operator|)
name|data_
decl_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
name|data
operator|->
name|virt_depth
operator|--
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* The dynamic cast runtime needs a hint about how the static SUBTYPE type    started from is related to the required TARGET type, in order to optimize    the inheritance graph search. This information is independent of the    current context, and ignores private paths, hence get_base_distance is    inappropriate. Return a TREE specifying the base offset, BOFF.    BOFF>= 0, there is only one public non-virtual SUBTYPE base at offset BOFF,       and there are no public virtual SUBTYPE bases.    BOFF == -1, SUBTYPE occurs as multiple public virtual or non-virtual bases.    BOFF == -2, SUBTYPE is not a public base.    BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.  */
end_comment

begin_function
name|tree
name|dcast_base_hint
parameter_list|(
name|tree
name|subtype
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|struct
name|dcast_data_s
name|data
decl_stmt|;
name|data
operator|.
name|subtype
operator|=
name|subtype
expr_stmt|;
name|data
operator|.
name|virt_depth
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|offset
operator|=
name|NULL_TREE
expr_stmt|;
name|data
operator|.
name|repeated_base
operator|=
name|CLASSTYPE_REPEATED_BASE_P
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|dfs_walk_once_accessible
argument_list|(
name|TYPE_BINFO
argument_list|(
name|target
argument_list|)
argument_list|,
comment|/*friends=*/
name|false
argument_list|,
name|dfs_dcast_hint_pre
argument_list|,
name|dfs_dcast_hint_post
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|offset
condition|?
name|data
operator|.
name|offset
else|:
name|ssize_int
argument_list|(
operator|-
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search for a member with name NAME in a multiple inheritance    lattice specified by TYPE.  If it does not exist, return NULL_TREE.    If the member is ambiguously referenced, return `error_mark_node'.    Otherwise, return a DECL with the indicated name.  If WANT_TYPE is    true, type declarations are preferred.  */
end_comment

begin_comment
comment|/* Do a 1-level search for NAME as a member of TYPE.  The caller must    figure out whether it can access this field.  (Since it is only one    level, this is reasonable.)  */
end_comment

begin_function
name|tree
name|lookup_field_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|,
name|bool
name|want_type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
comment|/* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM and        BOUND_TEMPLATE_TEMPLATE_PARM are not fields at all;        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,        the code often worked even when we treated the index as a list        of fields!)        The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|fields
init|=
operator|&
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|->
name|elts
index|[
literal|0
index|]
decl_stmt|;
name|int
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|DECL_SORTED_FIELDS
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|->
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|>
name|name
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|<
name|name
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|field
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We might have a nested class and a field with the 		 same name; we sorted them appropriately via 		 field_decl_cmp, so just look for the first or last 		 field with this name.  */
if|if
condition|(
name|want_type
condition|)
block|{
do|do
name|field
operator|=
name|fields
index|[
name|i
operator|--
index|]
expr_stmt|;
do|while
condition|(
name|i
operator|>=
name|lo
operator|&&
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|==
name|name
condition|)
do|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|field
argument_list|)
condition|)
name|field
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
do|do
name|field
operator|=
name|fields
index|[
name|i
operator|++
index|]
expr_stmt|;
do|while
condition|(
name|i
operator|<
name|hi
operator|&&
name|DECL_NAME
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|==
name|name
condition|)
do|;
block|}
return|return
name|field
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|lookup_field_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|name
argument_list|,
name|want_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
comment|/* We generally treat class-scope using-declarations as 	     ARM-style access specifications, because support for the 	     ISO semantics has not been implemented.  So, in general, 	     there's no reason to return a USING_DECL, and the rest of 	     the compiler cannot handle that.  Once the class is 	     defined, USING_DECLs are purged from TYPE_FIELDS; see 	     handle_using_decl.  However, we make special efforts to 	     make using-declarations in class templates and class 	     template partial specializations work correctly.  */
if|if
condition|(
operator|!
name|DECL_DEPENDENT_P
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
operator|&&
operator|(
operator|!
name|want_type
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|field
argument_list|)
operator|)
condition|)
return|return
name|field
return|;
block|}
comment|/* Not found.  */
if|if
condition|(
name|name
operator|==
name|vptr_identifier
condition|)
block|{
comment|/* Give the user what s/he thinks s/he wants.  */
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the FUNCTION_DECL, RECORD_TYPE, UNION_TYPE, or    NAMESPACE_DECL corresponding to the innermost non-block scope.  */
end_comment

begin_function
name|tree
name|current_scope
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There are a number of cases we need to be aware of here: 			 current_class_type	current_function_decl      global			NULL			NULL      fn-local			NULL			SET      class-local		SET			NULL      class->fn			SET			SET      fn->class			SET			SET       Those last two make life interesting.  If we're in a function which is      itself inside a class, we need decls to go into the fn's decls (our      second case below).  But if we're in a class and the class itself is      inside a function, we need decls to go into the decls for the class.  To      achieve this last goal, we must see if, when both current_class_ptr and      current_function_decl are set, the class was declared inside that      function.  If so, we know to put the decls into the class's scope.  */
if|if
condition|(
name|current_function_decl
operator|&&
name|current_class_type
operator|&&
operator|(
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|||
operator|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|)
condition|)
return|return
name|current_function_decl
return|;
if|if
condition|(
name|current_class_type
condition|)
return|return
name|current_class_type
return|;
if|if
condition|(
name|current_function_decl
condition|)
return|return
name|current_function_decl
return|;
return|return
name|current_namespace
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if we are currently in a function scope.  Note    that this function returns zero if we are within a local class, but    not within a member function body of the local class.  */
end_comment

begin_function
name|int
name|at_function_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
return|return
name|cs
operator|&&
name|TREE_CODE
argument_list|(
name|cs
argument_list|)
operator|==
name|FUNCTION_DECL
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the innermost active scope is a class scope.  */
end_comment

begin_function
name|bool
name|at_class_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
return|return
name|cs
operator|&&
name|TYPE_P
argument_list|(
name|cs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the innermost active scope is a namespace scope.  */
end_comment

begin_function
name|bool
name|at_namespace_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
return|return
name|cs
operator|&&
name|TREE_CODE
argument_list|(
name|cs
argument_list|)
operator|==
name|NAMESPACE_DECL
return|;
block|}
end_function

begin_comment
comment|/* Return the scope of DECL, as appropriate when doing name-lookup.  */
end_comment

begin_function
name|tree
name|context_for_name_lookup
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* [class.union]       For the purposes of name lookup, after the anonymous union      definition, the members of the anonymous union are considered to      have been defined in the scope in which the anonymous union is      declared.  */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|context
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* The accessibility routines use BINFO_ACCESS for scratch space    during the computation of the accessibility of some declaration.  */
end_comment

begin_define
define|#
directive|define
name|BINFO_ACCESS
parameter_list|(
name|NODE
parameter_list|)
define|\
value|((access_kind) ((TREE_PUBLIC (NODE)<< 1) | TREE_PRIVATE (NODE)))
end_define

begin_comment
comment|/* Set the access associated with NODE to ACCESS.  */
end_comment

begin_define
define|#
directive|define
name|SET_BINFO_ACCESS
parameter_list|(
name|NODE
parameter_list|,
name|ACCESS
parameter_list|)
define|\
value|((TREE_PUBLIC (NODE) = ((ACCESS)& 2) != 0),	\    (TREE_PRIVATE (NODE) = ((ACCESS)& 1) != 0))
end_define

begin_comment
comment|/* Called from access_in_type via dfs_walk.  Calculate the access to    DATA (which is really a DECL) in BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_access_in_type
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|access_kind
name|access
init|=
name|ak_none
decl_stmt|;
if|if
condition|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
operator|==
name|type
condition|)
block|{
comment|/* If we have descended to the scope of DECL, just note the 	 appropriate access.  */
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|ak_private
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|access
operator|=
name|ak_protected
expr_stmt|;
else|else
name|access
operator|=
name|ak_public
expr_stmt|;
block|}
else|else
block|{
comment|/* First, check for an access-declaration that gives us more 	 access to the DECL.  The CONST_DECL for an enumeration 	 constant will not have DECL_LANG_SPECIFIC, and thus no 	 DECL_ACCESS.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_DISCRIMINATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|decl_access
init|=
name|purpose_member
argument_list|(
name|type
argument_list|,
name|DECL_ACCESS
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_access
condition|)
block|{
name|decl_access
operator|=
name|TREE_VALUE
argument_list|(
name|decl_access
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_access
operator|==
name|access_public_node
condition|)
name|access
operator|=
name|ak_public
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_access
operator|==
name|access_protected_node
condition|)
name|access
operator|=
name|ak_protected
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_access
operator|==
name|access_private_node
condition|)
name|access
operator|=
name|ak_private
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|access
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|accesses
expr_stmt|;
comment|/* Otherwise, scan our baseclasses, and pick the most favorable 	     access.  */
name|accesses
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_access
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|accesses
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|access_kind
name|base_access_now
init|=
name|BINFO_ACCESS
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_access_now
operator|==
name|ak_none
operator|||
name|base_access_now
operator|==
name|ak_private
condition|)
comment|/* If it was not accessible in the base, or only 		   accessible as a private member, we can't access it 		   all.  */
name|base_access_now
operator|=
name|ak_none
expr_stmt|;
elseif|else
if|if
condition|(
name|base_access
operator|==
name|access_protected_node
condition|)
comment|/* Public and protected members in the base become 		   protected here.  */
name|base_access_now
operator|=
name|ak_protected
expr_stmt|;
elseif|else
if|if
condition|(
name|base_access
operator|==
name|access_private_node
condition|)
comment|/* Public and protected members in the base become 		   private here.  */
name|base_access_now
operator|=
name|ak_private
expr_stmt|;
comment|/* See if the new access, via this base, gives more 		 access than our previous best access.  */
if|if
condition|(
name|base_access_now
operator|!=
name|ak_none
operator|&&
operator|(
name|access
operator|==
name|ak_none
operator|||
name|base_access_now
operator|<
name|access
operator|)
condition|)
block|{
name|access
operator|=
name|base_access_now
expr_stmt|;
comment|/* If the new access is public, we can't do better.  */
if|if
condition|(
name|access
operator|==
name|ak_public
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/* Note the access to DECL in TYPE.  */
name|SET_BINFO_ACCESS
argument_list|(
name|binfo
argument_list|,
name|access
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the access to DECL in TYPE.  */
end_comment

begin_function
specifier|static
name|access_kind
name|access_in_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* We must take into account         [class.paths]         If a name can be reached by several paths through a multiple        inheritance graph, the access is that of the path that gives        most access.      The algorithm we use is to make a post-order depth-first traversal     of the base-class hierarchy.  As we come up the tree, we annotate     each node with the most lenient access.  */
name|dfs_walk_once
argument_list|(
name|binfo
argument_list|,
name|NULL
argument_list|,
name|dfs_access_in_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|BINFO_ACCESS
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it is OK to access DECL through an object    indicated by BINFO in the context of DERIVED.  */
end_comment

begin_function
specifier|static
name|int
name|protected_accessible_p
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|derived
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|access_kind
name|access
decl_stmt|;
comment|/* We're checking this clause from [class.access.base]         m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected.      Here DERIVED is a possible P and DECL is m.  accessible_p will     iterate over various values of N, but the access to m in DERIVED     does not change.      Note that I believe that the passage above is wrong, and should read     "...is private or protected or public"; otherwise you get bizarre results     whereby a public using-decl can prevent you from accessing a protected     member of a base.  (jason 2000/02/28)  */
comment|/* If DERIVED isn't derived from m's class, then it can't be a P.  */
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|,
name|derived
argument_list|)
condition|)
return|return
literal|0
return|;
name|access
operator|=
name|access_in_type
argument_list|(
name|derived
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If m is inaccessible in DERIVED, then it's not a P.  */
if|if
condition|(
name|access
operator|==
name|ak_none
condition|)
return|return
literal|0
return|;
comment|/* [class.protected]       When a friend or a member function of a derived class references      a protected nonstatic member of a base class, an access check      applies in addition to those described earlier in clause      _class.access_) Except when forming a pointer to member      (_expr.unary.op_), the access must be through a pointer to,      reference to, or object of the derived class itself (or any class      derived from that class) (_expr.ref_).  If the access is to form      a pointer to member, the nested-name-specifier shall name the      derived class (or any class derived from that class).  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We can tell through what the reference is occurring by 	 chasing BINFO up to the root.  */
name|tree
name|t
init|=
name|binfo
decl_stmt|;
while|while
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|derived
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if SCOPE is a friend of a type which would be able    to access DECL through the object indicated by BINFO.  */
end_comment

begin_function
specifier|static
name|int
name|friend_accessible_p
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|befriending_classes
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|scope
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|befriending_classes
operator|=
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|scope
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|befriending_classes
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Nested classes have the same access as their enclosing types, as      per DR 45 (this is a change from the standard).  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
for|for
control|(
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
init|;
name|t
operator|&&
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|t
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
comment|/* Perhaps this SCOPE is a member of a class which is a 	 friend.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|friend_accessible_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Or an instantiation of something which is a friend.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Increment processing_template_decl to make sure that 	     dependent_type_p works correctly.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|ret
operator|=
name|friend_accessible_p
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|scope
argument_list|)
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk_once_accessible from accessible_p */
end_comment

begin_function
specifier|static
name|tree
name|dfs_accessible_post
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|BINFO_ACCESS
argument_list|(
name|binfo
argument_list|)
operator|!=
name|ak_none
condition|)
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|&&
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|scope
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* DECL is a declaration from a base class of TYPE, which was the    class used to name DECL.  Return nonzero if, in the current    context, DECL is accessible.  If TYPE is actually a BINFO node,    then we can tell in what context the access is occurring by looking    at the most derived class along the path indicated by BINFO.  If    CONSIDER_LOCAL is true, do consider special access the current    scope or friendship thereof we might have.  */
end_comment

begin_function
name|int
name|accessible_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|,
name|bool
name|consider_local_p
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|access_kind
name|access
decl_stmt|;
comment|/* Nonzero if it's OK to access DECL if it has protected      accessibility in TYPE.  */
name|int
name|protected_ok
init|=
literal|0
decl_stmt|;
comment|/* If this declaration is in a block or namespace scope, there's no      access control.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* There is no need to perform access checks inside a thunk.  */
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|scope
operator|&&
name|DECL_THUNK_P
argument_list|(
name|scope
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* In a template declaration, we cannot be sure whether the      particular specialization that is instantiated will be a friend      or not.  Therefore, all access checks are deferred until      instantiation.  However, PROCESSING_TEMPLATE_DECL is set in the      parameter list for a template (because we may see dependent types      in default arguments for template parameters), and access      checking should be performed in the outermost parameter list.  */
if|if
condition|(
name|processing_template_decl
operator|&&
operator|(
operator|!
name|processing_template_parmlist
operator|||
name|processing_template_decl
operator|>
literal|1
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* [class.access.base]       A member m is accessible when named in class N if       --m as a member of N is public, or       --m as a member of N is private, and the reference occurs in a        member or friend of class N, or       --m as a member of N is protected, and the reference occurs in a        member or friend of class N, or in a member or friend of a        class P derived from N, where m as a member of P is private or        protected, or       --there exists a base class B of N that is accessible at the point        of reference, and m is accessible when named in class B.      We walk the base class hierarchy, checking these conditions.  */
if|if
condition|(
name|consider_local_p
condition|)
block|{
comment|/* Figure out where the reference is occurring.  Check to see if 	 DECL is private or protected in this scope, since that will 	 determine whether protected access is allowed.  */
if|if
condition|(
name|current_class_type
condition|)
name|protected_ok
operator|=
name|protected_accessible_p
argument_list|(
name|decl
argument_list|,
name|current_class_type
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
comment|/* Now, loop through the classes of which we are a friend.  */
if|if
condition|(
operator|!
name|protected_ok
condition|)
name|protected_ok
operator|=
name|friend_accessible_p
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
block|}
comment|/* Standardize the binfo that access_in_type will use.  We don't      need to know what path was chosen from this point onwards.  */
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the accessibility of DECL in the class hierarchy      dominated by type.  */
name|access
operator|=
name|access_in_type
argument_list|(
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|ak_public
operator|||
operator|(
name|access
operator|==
name|ak_protected
operator|&&
name|protected_ok
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|consider_local_p
condition|)
return|return
literal|0
return|;
comment|/* Walk the hierarchy again, looking for a base class that allows      access.  */
return|return
name|dfs_walk_once_accessible
argument_list|(
name|binfo
argument_list|,
comment|/*friends=*/
name|true
argument_list|,
name|NULL
argument_list|,
name|dfs_accessible_post
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_struct
struct|struct
name|lookup_field_info
block|{
comment|/* The type in which we're looking.  */
name|tree
name|type
decl_stmt|;
comment|/* The name of the field for which we're looking.  */
name|tree
name|name
decl_stmt|;
comment|/* If non-NULL, the current result of the lookup.  */
name|tree
name|rval
decl_stmt|;
comment|/* The path to RVAL.  */
name|tree
name|rval_binfo
decl_stmt|;
comment|/* If non-NULL, the lookup was ambiguous, and this is a list of the      candidates.  */
name|tree
name|ambiguous
decl_stmt|;
comment|/* If nonzero, we are looking for types, not data members.  */
name|int
name|want_type
decl_stmt|;
comment|/* If something went wrong, a message indicating what.  */
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Within the scope of a template class, you can refer to the to the    current specialization with the name of the template itself.  For    example:       template<typename T> struct S { S* sp; }     Returns nonzero if DECL is such a declaration in a class TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|template_self_reference_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero for a class member means that it is shared between all objects    of that class.     [class.member.lookup]:If the resulting set of declarations are not all    from sub-objects of the same type, or the set has a  nonstatic  member    and  includes members from distinct sub-objects, there is an ambiguity    and the program is ill-formed.     This function checks that T contains no nonstatic members.  */
end_comment

begin_function
name|int
name|shared_member_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
expr|\
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|OVL_NEXT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Routine to see if the sub-object denoted by the binfo PARENT can be    found as a base class and sub-object of the object denoted by    BINFO.  */
end_comment

begin_function
specifier|static
name|int
name|is_subobject_of_p
parameter_list|(
name|tree
name|parent
parameter_list|,
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|parent
init|;
name|probe
condition|;
name|probe
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
if|if
condition|(
name|probe
operator|==
name|binfo
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|probe
argument_list|)
condition|)
return|return
operator|(
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* DATA is really a struct lookup_field_info.  Look for a field with    the name indicated there in BINFO.  If this function returns a    non-NULL value it is the result of the lookup.  Called from    lookup_field via breadth_first_search.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_field_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|lookup_field_info
modifier|*
name|lfi
init|=
operator|(
expr|struct
name|lookup_field_info
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|nval
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If this is a dependent base, don't look in it.  */
if|if
condition|(
name|BINFO_DEPENDENT_BASE_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If this base class is hidden by the best-known value so far, we      don't need to look.  */
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
operator|==
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|dfs_skip_bases
return|;
comment|/* First, look for a function.  There can't be a function and a data      member with the same name, and if there's a function and a type      with the same name, the type is hidden by the function.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|want_type
condition|)
block|{
name|int
name|idx
init|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|nval
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nval
condition|)
comment|/* Look for a data member or type.  */
name|nval
operator|=
name|lookup_field_1
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|name
argument_list|,
name|lfi
operator|->
name|want_type
argument_list|)
expr_stmt|;
comment|/* If there is no declaration with the indicated name in this type,      then there's nothing to do.  */
if|if
condition|(
operator|!
name|nval
condition|)
goto|goto
name|done
goto|;
comment|/* If we're looking up a type (as with an elaborated type specifier)      we ignore all non-types we find.  */
if|if
condition|(
name|lfi
operator|->
name|want_type
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|nval
argument_list|)
condition|)
block|{
if|if
condition|(
name|lfi
operator|->
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If the aggregate has no user defined constructors, we allow 	     it to have fields with the same name as the enclosing type. 	     If we are looking for that name, find the corresponding 	     TYPE_DECL.  */
for|for
control|(
name|nval
operator|=
name|TREE_CHAIN
argument_list|(
name|nval
argument_list|)
init|;
name|nval
condition|;
name|nval
operator|=
name|TREE_CHAIN
argument_list|(
name|nval
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|nval
argument_list|)
operator|==
name|lfi
operator|->
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|nval
argument_list|)
operator|==
name|TYPE_DECL
condition|)
break|break;
block|}
else|else
name|nval
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|nval
operator|&&
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|binding_entry
name|e
init|=
name|binding_table_find
argument_list|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|type
argument_list|)
argument_list|,
name|lfi
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|nval
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|e
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
goto|goto
name|done
goto|;
block|}
block|}
comment|/* You must name a template base class with a template-id.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|lfi
operator|->
name|type
argument_list|)
operator|&&
name|template_self_reference_p
argument_list|(
name|type
argument_list|,
name|nval
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* If the lookup already found a match, and the new value doesn't      hide the old one, we might have an ambiguity.  */
if|if
condition|(
name|lfi
operator|->
name|rval_binfo
operator|&&
operator|!
name|is_subobject_of_p
argument_list|(
name|lfi
operator|->
name|rval_binfo
argument_list|,
name|binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|nval
operator|==
name|lfi
operator|->
name|rval
operator|&&
name|shared_member_p
argument_list|(
name|nval
argument_list|)
condition|)
comment|/* The two things are really the same.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|is_subobject_of_p
argument_list|(
name|binfo
argument_list|,
name|lfi
operator|->
name|rval_binfo
argument_list|)
condition|)
comment|/* The previous value hides the new one.  */
empty_stmt|;
else|else
block|{
comment|/* We have a real ambiguity.  We keep a chain of all the 	     candidates.  */
if|if
condition|(
operator|!
name|lfi
operator|->
name|ambiguous
operator|&&
name|lfi
operator|->
name|rval
condition|)
block|{
comment|/* This is the first time we noticed an ambiguity.  Add 		 what we previously thought was a reasonable candidate 		 to the list.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lfi
operator|->
name|rval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add the new value.  */
name|lfi
operator|->
name|ambiguous
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|nval
argument_list|,
name|lfi
operator|->
name|ambiguous
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lfi
operator|->
name|ambiguous
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|lfi
operator|->
name|errstr
operator|=
literal|"request for member %qD is ambiguous"
expr_stmt|;
block|}
block|}
else|else
block|{
name|lfi
operator|->
name|rval
operator|=
name|nval
expr_stmt|;
name|lfi
operator|->
name|rval_binfo
operator|=
name|binfo
expr_stmt|;
block|}
name|done
label|:
comment|/* Don't look for constructors or destructors in base classes.  */
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|lfi
operator|->
name|name
argument_list|)
condition|)
return|return
name|dfs_skip_bases
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return a "baselink" with BASELINK_BINFO, BASELINK_ACCESS_BINFO,    BASELINK_FUNCTIONS, and BASELINK_OPTYPE set to BINFO, ACCESS_BINFO,    FUNCTIONS, and OPTYPE respectively.  */
end_comment

begin_function
name|tree
name|build_baselink
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|access_binfo
parameter_list|,
name|tree
name|functions
parameter_list|,
name|tree
name|optype
parameter_list|)
block|{
name|tree
name|baselink
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|OVERLOAD
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|optype
operator|||
name|TYPE_P
argument_list|(
name|optype
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|functions
argument_list|)
argument_list|)
expr_stmt|;
name|baselink
operator|=
name|make_node
argument_list|(
name|BASELINK
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
name|BASELINK_BINFO
argument_list|(
name|baselink
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|BASELINK_ACCESS_BINFO
argument_list|(
name|baselink
argument_list|)
operator|=
name|access_binfo
expr_stmt|;
name|BASELINK_FUNCTIONS
argument_list|(
name|baselink
argument_list|)
operator|=
name|functions
expr_stmt|;
name|BASELINK_OPTYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|optype
expr_stmt|;
return|return
name|baselink
return|;
block|}
end_function

begin_comment
comment|/* Look for a member named NAME in an inheritance lattice dominated by    XBASETYPE.  If PROTECT is 0 or two, we do not check access.  If it    is 1, we enforce accessibility.  If PROTECT is zero, then, for an    ambiguous lookup, we return NULL.  If PROTECT is 1, we issue error    messages about inaccessible or ambiguous lookup.  If PROTECT is 2,    we return a TREE_LIST whose TREE_TYPE is error_mark_node and whose    TREE_VALUEs are the list of ambiguous candidates.     WANT_TYPE is 1 when we should only return TYPE_DECLs.     If nothing can be found return NULL_TREE and do not issue an error.  */
end_comment

begin_function
name|tree
name|lookup_member
parameter_list|(
name|tree
name|xbasetype
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|protect
parameter_list|,
name|bool
name|want_type
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|,
name|rval_binfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|,
name|basetype_path
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|lookup_field_info
name|lfi
decl_stmt|;
comment|/* rval_binfo is the binfo associated with the found member, note,      this can be set with useful information, even when rval is not      set, because it must deal with ALL members, not just non-function      members.  It is used for ambiguity checking and the hidden      checks.  Whereas rval is only set if a proper (not hidden)      non-function member is found.  */
specifier|const
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
operator|==
name|TREE_BINFO
condition|)
block|{
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|xbasetype
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|xbasetype
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|xbasetype
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|xbasetype
expr_stmt|;
name|xbasetype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype_path
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basetype_path
condition|)
return|return
name|NULL_TREE
return|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_field
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|memset
argument_list|(
operator|&
name|lfi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lfi
argument_list|)
argument_list|)
expr_stmt|;
name|lfi
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|lfi
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|lfi
operator|.
name|want_type
operator|=
name|want_type
expr_stmt|;
name|dfs_walk_all
argument_list|(
name|basetype_path
argument_list|,
operator|&
name|lookup_field_r
argument_list|,
name|NULL
argument_list|,
operator|&
name|lfi
argument_list|)
expr_stmt|;
name|rval
operator|=
name|lfi
operator|.
name|rval
expr_stmt|;
name|rval_binfo
operator|=
name|lfi
operator|.
name|rval_binfo
expr_stmt|;
if|if
condition|(
name|rval_binfo
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|rval_binfo
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|lfi
operator|.
name|errstr
expr_stmt|;
comment|/* If we are not interested in ambiguities, don't report them;      just return NULL_TREE.  */
if|if
condition|(
operator|!
name|protect
operator|&&
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|protect
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
return|return
name|lfi
operator|.
name|ambiguous
return|;
else|else
name|protect
operator|=
literal|0
expr_stmt|;
block|}
comment|/* [class.access]       In the case of overloaded function names, access control is      applied to the function selected by overloaded resolution.         We cannot check here, even if RVAL is only a single non-static      member function, since we do not know what the "this" pointer      will be.  For:          class A { protected: void f(); };         class B : public A {            void g(A *p) {             f(); // OK             p->f(); // Not OK.           }         };      only the first call to "f" is valid.  However, if the function is     static, we can check.  */
if|if
condition|(
name|rval
operator|&&
name|protect
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|rval
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|rval
argument_list|)
operator|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|basetype_path
argument_list|,
name|rval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|&&
name|protect
condition|)
block|{
name|error
argument_list|(
name|errstr
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfi
operator|.
name|ambiguous
condition|)
name|print_candidates
argument_list|(
name|lfi
operator|.
name|ambiguous
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|is_overloaded_fn
argument_list|(
name|rval
argument_list|)
condition|)
name|rval
operator|=
name|build_baselink
argument_list|(
name|rval_binfo
argument_list|,
name|basetype_path
argument_list|,
name|rval
argument_list|,
operator|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
else|:
name|NULL_TREE
operator|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_field
parameter_list|(
name|tree
name|xbasetype
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|protect
parameter_list|,
name|bool
name|want_type
parameter_list|)
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
name|want_type
argument_list|)
decl_stmt|;
comment|/* Ignore functions, but propagate the ambiguity list.  */
if|if
condition|(
operator|!
name|error_operand_p
argument_list|(
name|rval
argument_list|)
operator|&&
operator|(
name|rval
operator|&&
name|BASELINK_P
argument_list|(
name|rval
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_member, except that if we find a non-function member we    return NULL_TREE.  */
end_comment

begin_function
name|tree
name|lookup_fnfields
parameter_list|(
name|tree
name|xbasetype
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|protect
parameter_list|)
block|{
name|tree
name|rval
init|=
name|lookup_member
argument_list|(
name|xbasetype
argument_list|,
name|name
argument_list|,
name|protect
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
decl_stmt|;
comment|/* Ignore non-functions, but propagate the ambiguity list.  */
if|if
condition|(
operator|!
name|error_operand_p
argument_list|(
name|rval
argument_list|)
operator|&&
operator|(
name|rval
operator|&&
operator|!
name|BASELINK_P
argument_list|(
name|rval
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Return the index in the CLASSTYPE_METHOD_VEC for CLASS_TYPE    corresponding to "operator TYPE ()", or -1 if there is no such    operator.  Only CLASS_TYPE itself is searched; this routine does    not scan the base classes of CLASS_TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_conversion_operator
parameter_list|(
name|tree
name|class_type
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|tpl_slot
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|class_type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|,
name|i
argument_list|,
name|fn
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* All the conversion operators come near the beginning of 	     the class.  Therefore, if FN is not a conversion 	     operator, there is no matching conversion operator in 	     CLASS_TYPE.  */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* All the templated conversion functions are on the same 	       slot, so remember it.  */
name|tpl_slot
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|DECL_CONV_FN_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|i
return|;
block|}
block|}
return|return
name|tpl_slot
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type. Return the index of the fields within    the method vector with name NAME, or -1 is no such field exists.  */
end_comment

begin_function
name|int
name|lookup_fnfields_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|method_vec
expr_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|==
name|ctor_identifier
operator|||
name|name
operator|==
name|base_ctor_identifier
operator|||
name|name
operator|==
name|complete_ctor_identifier
operator|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_LAZY_DEFAULT_CTOR
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_constructor
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_LAZY_COPY_CTOR
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_copy_constructor
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
operator|&&
name|CLASSTYPE_LAZY_ASSIGNMENT_OP
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_assignment_operator
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|name
operator|==
name|dtor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|||
name|name
operator|==
name|complete_dtor_identifier
operator|||
name|name
operator|==
name|deleting_dtor_identifier
operator|)
operator|&&
name|CLASSTYPE_LAZY_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_destructor
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_vec
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_calls_lookup_fnfields_1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
comment|/* Constructors are first...  */
if|if
condition|(
name|name
operator|==
name|ctor_identifier
condition|)
block|{
name|fn
operator|=
name|CLASSTYPE_CONSTRUCTORS
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|fn
condition|?
name|CLASSTYPE_CONSTRUCTOR_SLOT
else|:
operator|-
literal|1
return|;
block|}
comment|/* and destructors are second.  */
if|if
condition|(
name|name
operator|==
name|dtor_identifier
condition|)
block|{
name|fn
operator|=
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|fn
condition|?
name|CLASSTYPE_DESTRUCTOR_SLOT
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|lookup_conversion_operator
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
comment|/* Skip the conversion operators.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|method_vec
argument_list|,
name|i
argument_list|,
name|fn
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* If the type is complete, use binary search.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|lo
decl_stmt|;
name|int
name|hi
decl_stmt|;
name|lo
operator|=
name|i
expr_stmt|;
name|hi
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|i
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
name|tmp
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|method_vec
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|name
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|<
name|name
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|i
return|;
block|}
block|}
else|else
for|for
control|(
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|method_vec
argument_list|,
name|i
argument_list|,
name|fn
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_outer_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|name
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like lookup_fnfields_1, except that the name is extracted from    FUNCTION, which is a FUNCTION_DECL or a TEMPLATE_DECL.  */
end_comment

begin_function
name|int
name|class_method_index_for_fn
parameter_list|(
name|tree
name|class_type
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lookup_fnfields_1
argument_list|(
name|class_type
argument_list|,
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|?
name|ctor_identifier
else|:
name|DECL_DESTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|?
name|dtor_identifier
else|:
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is the result of a qualified name lookup.  QUALIFYING_SCOPE is    the class or namespace used to qualify the name.  CONTEXT_CLASS is    the class corresponding to the object in which DECL will be used.    Return a possibly modified version of DECL that takes into account    the CONTEXT_CLASS.     In particular, consider an expression like `B::m' in the context of    a derived class `D'.  If `B::m' has been resolved to a BASELINK,    then the most derived class indicated by the BASELINK_BINFO will be    `B', not `D'.  This function makes that adjustment.  */
end_comment

begin_function
name|tree
name|adjust_result_of_qualified_name_lookup
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|qualifying_scope
parameter_list|,
name|tree
name|context_class
parameter_list|)
block|{
if|if
condition|(
name|context_class
operator|&&
name|context_class
operator|!=
name|error_mark_node
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context_class
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|qualifying_scope
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|qualifying_scope
argument_list|,
name|context_class
argument_list|)
operator|&&
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|base
decl_stmt|;
comment|/* Look for the QUALIFYING_SCOPE as a base of the CONTEXT_CLASS. 	 Because we do not yet know which function will be chosen by 	 overload resolution, we cannot yet check either accessibility 	 or ambiguity -- in either case, the choice of a static member 	 function might make the usage valid.  */
name|base
operator|=
name|lookup_base
argument_list|(
name|context_class
argument_list|,
name|qualifying_scope
argument_list|,
name|ba_unique
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|BASELINK_ACCESS_BINFO
argument_list|(
name|decl
argument_list|)
operator|=
name|base
expr_stmt|;
name|BASELINK_BINFO
argument_list|(
name|decl
argument_list|)
operator|=
name|lookup_base
argument_list|(
name|base
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BASELINK_BINFO
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|ba_unique
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the class hierarchy within BINFO, in a depth-first traversal.    PRE_FN is called in preorder, while POST_FN is called in postorder.    If PRE_FN returns DFS_SKIP_BASES, child binfos will not be    walked.  If PRE_FN or POST_FN returns a different non-NULL value,    that value is immediately returned and the walk is terminated.  One    of PRE_FN and POST_FN can be NULL.  At each node, PRE_FN and    POST_FN are passed the binfo to examine and the caller's DATA    value.  All paths are walked, thus virtual and morally virtual    binfos can be multiply walked.  */
end_comment

begin_function
name|tree
name|dfs_walk_all
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
comment|/* Call the pre-order walking function.  */
if|if
condition|(
name|pre_fn
condition|)
block|{
name|rval
operator|=
name|pre_fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|dfs_skip_bases
condition|)
goto|goto
name|skip_bases
goto|;
return|return
name|rval
return|;
block|}
block|}
comment|/* Find the next child binfo to walk.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|rval
operator|=
name|dfs_walk_all
argument_list|(
name|base_binfo
argument_list|,
name|pre_fn
argument_list|,
name|post_fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
name|skip_bases
label|:
comment|/* Call the post-order walking function.  */
if|if
condition|(
name|post_fn
condition|)
block|{
name|rval
operator|=
name|post_fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rval
operator|!=
name|dfs_skip_bases
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Worker for dfs_walk_once.  This behaves as dfs_walk_all, except    that binfos are walked at most once.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_walk_once_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
comment|/* Call the pre-order walking function.  */
if|if
condition|(
name|pre_fn
condition|)
block|{
name|rval
operator|=
name|pre_fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|dfs_skip_bases
condition|)
goto|goto
name|skip_bases
goto|;
return|return
name|rval
return|;
block|}
block|}
comment|/* Find the next child binfo to walk.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|rval
operator|=
name|dfs_walk_once_r
argument_list|(
name|base_binfo
argument_list|,
name|pre_fn
argument_list|,
name|post_fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
name|skip_bases
label|:
comment|/* Call the post-order walking function.  */
if|if
condition|(
name|post_fn
condition|)
block|{
name|rval
operator|=
name|post_fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rval
operator|!=
name|dfs_skip_bases
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Worker for dfs_walk_once. Recursively unmark the virtual base binfos of    BINFO.  */
end_comment

begin_function
specifier|static
name|void
name|dfs_unmark_r
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
comment|/* Process the basetypes.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Only walk, if it can contain more virtual bases.  */
if|if
condition|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
name|dfs_unmark_r
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like dfs_walk_all, except that binfos are not multiply walked.  For    non-diamond shaped hierarchies this is the same as dfs_walk_all.    For diamond shaped hierarchies we must mark the virtual bases, to    avoid multiple walks.  */
end_comment

begin_function
name|tree
name|dfs_walk_once
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|static
name|int
name|active
init|=
literal|0
decl_stmt|;
comment|/* We must not be called recursively. */
name|tree
name|rval
decl_stmt|;
name|gcc_assert
argument_list|(
name|pre_fn
operator|||
name|post_fn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|active
argument_list|)
expr_stmt|;
name|active
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_DIAMOND_SHAPED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
comment|/* We are not diamond shaped, and therefore cannot encounter the        same binfo twice.  */
name|rval
operator|=
name|dfs_walk_all
argument_list|(
name|binfo
argument_list|,
name|pre_fn
argument_list|,
name|post_fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|dfs_walk_once_r
argument_list|(
name|binfo
argument_list|,
name|pre_fn
argument_list|,
name|post_fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* We are at the top of the hierarchy, and can use the 	     CLASSTYPE_VBASECLASSES list for unmarking the virtual 	     bases.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vbases
expr_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|,
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vbases
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|dfs_unmark_r
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
name|active
operator|--
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Worker function for dfs_walk_once_accessible.  Behaves like    dfs_walk_once_r, except (a) FRIENDS_P is true if special    access given by the current context should be considered, (b) ONCE    indicates whether bases should be marked during traversal.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_walk_once_accessible_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|bool
name|friends_p
parameter_list|,
name|bool
name|once
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
comment|/* Call the pre-order walking function.  */
if|if
condition|(
name|pre_fn
condition|)
block|{
name|rval
operator|=
name|pre_fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|dfs_skip_bases
condition|)
goto|goto
name|skip_bases
goto|;
return|return
name|rval
return|;
block|}
block|}
comment|/* Find the next child binfo to walk.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|bool
name|mark
init|=
name|once
operator|&&
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|mark
operator|&&
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
comment|/* If the base is inherited via private or protected 	 inheritance, then we can't see it, unless we are a friend of 	 the current binfo.  */
if|if
condition|(
name|BINFO_BASE_ACCESS
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|)
operator|!=
name|access_public_node
condition|)
block|{
name|tree
name|scope
decl_stmt|;
if|if
condition|(
operator|!
name|friends_p
condition|)
continue|continue;
name|scope
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scope
operator|||
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
operator|!
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|scope
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|mark
condition|)
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|dfs_walk_once_accessible_r
argument_list|(
name|base_binfo
argument_list|,
name|friends_p
argument_list|,
name|once
argument_list|,
name|pre_fn
argument_list|,
name|post_fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
name|skip_bases
label|:
comment|/* Call the post-order walking function.  */
if|if
condition|(
name|post_fn
condition|)
block|{
name|rval
operator|=
name|post_fn
argument_list|(
name|binfo
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rval
operator|!=
name|dfs_skip_bases
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like dfs_walk_once except that only accessible bases are walked.    FRIENDS_P indicates whether friendship of the local context    should be considered when determining accessibility.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_walk_once_accessible
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|bool
name|friends_p
parameter_list|,
name|tree
function_decl|(
modifier|*
name|pre_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|tree
function_decl|(
modifier|*
name|post_fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bool
name|diamond_shaped
init|=
name|CLASSTYPE_DIAMOND_SHAPED_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|dfs_walk_once_accessible_r
argument_list|(
name|binfo
argument_list|,
name|friends_p
argument_list|,
name|diamond_shaped
argument_list|,
name|pre_fn
argument_list|,
name|post_fn
argument_list|,
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|diamond_shaped
condition|)
block|{
if|if
condition|(
operator|!
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* We are at the top of the hierarchy, and can use the 	     CLASSTYPE_VBASECLASSES list for unmarking the virtual 	     bases.  */
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vbases
expr_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
operator|,
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vbases
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|dfs_unmark_r
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Check that virtual overrider OVERRIDER is acceptable for base function    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */
end_comment

begin_function
specifier|static
name|int
name|check_final_overrider
parameter_list|(
name|tree
name|overrider
parameter_list|,
name|tree
name|basefn
parameter_list|)
block|{
name|tree
name|over_type
init|=
name|TREE_TYPE
argument_list|(
name|overrider
argument_list|)
decl_stmt|;
name|tree
name|base_type
init|=
name|TREE_TYPE
argument_list|(
name|basefn
argument_list|)
decl_stmt|;
name|tree
name|over_return
init|=
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
decl_stmt|;
name|tree
name|base_return
init|=
name|TREE_TYPE
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|tree
name|over_throw
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|over_type
argument_list|)
decl_stmt|;
name|tree
name|base_throw
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_INVALID_OVERRIDER_P
argument_list|(
name|overrider
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|base_return
argument_list|,
name|over_return
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|CLASS_TYPE_P
argument_list|(
name|over_return
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|base_return
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base_return
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|over_return
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|base_return
argument_list|)
operator|)
condition|)
block|{
comment|/* Potentially covariant.  */
name|unsigned
name|base_quals
decl_stmt|,
name|over_quals
decl_stmt|;
name|fail
operator|=
operator|!
name|POINTER_TYPE_P
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|fail
operator|=
name|cp_type_quals
argument_list|(
name|base_return
argument_list|)
operator|!=
name|cp_type_quals
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
name|base_return
operator|=
name|TREE_TYPE
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
name|over_return
operator|=
name|TREE_TYPE
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
block|}
name|base_quals
operator|=
name|cp_type_quals
argument_list|(
name|base_return
argument_list|)
expr_stmt|;
name|over_quals
operator|=
name|cp_type_quals
argument_list|(
name|over_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|base_quals
operator|&
name|over_quals
operator|)
operator|!=
name|over_quals
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|base_return
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|over_return
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|over_return
argument_list|,
name|base_return
argument_list|,
name|ba_check
operator||
name|ba_quiet
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|can_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
argument_list|)
condition|)
comment|/* GNU extension, allow trivial pointer conversions such as 	   converting to void *, or qualification conversion.  */
block|{
comment|/* can_convert will permit user defined conversion from a 	     (reference to) class type. We must reject them.  */
name|over_return
operator|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|over_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|over_return
argument_list|)
condition|)
name|fail
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"deprecated covariant return type for %q+#D"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"  overriding %q+#D"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fail
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|fail
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fail
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"invalid covariant return type for %q+#D"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  overriding %q+#D"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"conflicting return type specified for %q+#D"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  overriding %q+#D"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
block|}
name|DECL_INVALID_OVERRIDER_P
argument_list|(
name|overrider
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check throw specifier is at least as strict.  */
if|if
condition|(
operator|!
name|comp_except_specs
argument_list|(
name|base_throw
argument_list|,
name|over_throw
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"looser throw specifier for %q+#F"
argument_list|,
name|overrider
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  overriding %q+#F"
argument_list|,
name|basefn
argument_list|)
expr_stmt|;
name|DECL_INVALID_OVERRIDER_P
argument_list|(
name|overrider
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a class TYPE, and a function decl FNDECL, look for    virtual functions in TYPE's hierarchy which FNDECL overrides.    We do not look in TYPE itself, only its bases.     Returns nonzero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we    find that it overrides anything.     We check that every function which is overridden, is correctly    overridden.  */
end_comment

begin_function
name|int
name|look_for_overrides
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|found
operator|+=
name|look_for_overrides_r
argument_list|(
name|basetype
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Look in TYPE for virtual functions with the same signature as    FNDECL.  */
end_comment

begin_function
name|tree
name|look_for_overrides_here
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|int
name|ix
decl_stmt|;
comment|/* If there are no methods in TYPE (meaning that only implicitly      declared methods will ever be provided for TYPE), then there are      no virtual functions.  */
if|if
condition|(
operator|!
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|ix
operator|=
name|CLASSTYPE_DESTRUCTOR_SLOT
expr_stmt|;
else|else
name|ix
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
name|tree
name|fns
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Not a virtual.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|!=
name|type
condition|)
comment|/* Introduced with a using declaration.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|btypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|dtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|btypes
argument_list|)
argument_list|,
name|dtypes
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
elseif|else
if|if
condition|(
name|same_signature_p
argument_list|(
name|fndecl
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look in TYPE for virtual functions overridden by FNDECL. Check both    TYPE itself and its bases.  */
end_comment

begin_function
specifier|static
name|int
name|look_for_overrides_r
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|fn
init|=
name|look_for_overrides_here
argument_list|(
name|type
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* A static member function cannot match an inherited 	     virtual member function.  */
name|error
argument_list|(
literal|"%q+#D cannot be declared"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  since %q+#D declared in base class"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's definitely virtual, even if not explicitly set.  */
name|DECL_VIRTUAL_P
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|check_final_overrider
argument_list|(
name|fndecl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* We failed to find one declared in this class. Look in its bases.  */
return|return
name|look_for_overrides
argument_list|(
name|type
argument_list|,
name|fndecl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called via dfs_walk from dfs_get_pure_virtuals.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_get_pure_virtuals
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
comment|/* We're not interested in primary base classes; the derived class      of which they are a primary base will contain the information we      need.  */
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|virtuals
decl_stmt|;
for|for
control|(
name|virtuals
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
init|;
name|virtuals
condition|;
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
control|)
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
argument_list|,
name|BV_FN
argument_list|(
name|virtuals
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set CLASSTYPE_PURE_VIRTUALS for TYPE.  */
end_comment

begin_function
name|void
name|get_pure_virtuals
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there      is going to be overridden.  */
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Now, run through all the bases which are not primary bases, and      collect the pure virtual functions.  We look at the vtable in      each class to determine what pure virtual functions are present.      (A primary base is not interesting because the derived class of      which it is a primary base will contain vtable entries for the      pure virtuals in the base class.  */
name|dfs_walk_once
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|dfs_get_pure_virtuals
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug info for C++ classes can get very large; try to avoid    emitting it everywhere.     Note that this optimization wins even when the target supports    BINCL (if only slightly), and reduces the amount of work for the    linker.  */
end_comment

begin_function
name|void
name|maybe_suppress_debug_info
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
return|return;
comment|/* We might have set this earlier in cp_finish_decl.  */
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Always emit the information for each class every time. */
if|if
condition|(
name|flag_emit_class_debug_always
condition|)
return|return;
comment|/* If we already know how we're handling this class, handle debug info      the same way.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* else don't set it.  */
block|}
comment|/* If the class has a vtable, write out the debug info along with      the vtable.  */
elseif|else
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, just emit the debug info normally.  */
block|}
end_function

begin_comment
comment|/* Note that we want debugging information for a base class of a class    whose vtable is being emitted.  Normally, this would happen because    calling the constructor for a derived class implies calling the    constructors for all bases, which involve initializing the    appropriate vptr with the vtable for the base class; but in the    presence of optimization, this initialization may be optimized    away, so we tell finish_vtable_vardecl that we want the debugging    information anyway.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_debug_mark
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|dfs_skip_bases
return|;
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Write out the debugging information for TYPE, whose vtable is being    emitted.  Also walk through our bases and note that we want to    write out information for them.  This avoids the problem of not    writing any debug info for intermediate basetypes whose    constructors, and thus the references to their vtables, and thus    the vtables themselves, were optimized away.  */
end_comment

begin_function
name|void
name|note_debug_info_needed
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|type
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dfs_walk_all
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_debug_mark
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_search_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fields searched in %d[%d] calls to lookup_field[_1]\n"
argument_list|,
name|n_fields_searched
argument_list|,
name|n_calls_lookup_field
argument_list|,
name|n_calls_lookup_field_1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d fnfields searched in %d calls to lookup_fnfields\n"
argument_list|,
name|n_outer_fields_searched
argument_list|,
name|n_calls_lookup_fnfields
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d calls to get_base_type\n"
argument_list|,
name|n_calls_get_base_type
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* GATHER_STATISTICS */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no search statistics\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_function
name|void
name|reinit_search_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_field
operator|=
literal|0
operator|,
name|n_calls_lookup_field_1
operator|=
literal|0
expr_stmt|;
name|n_calls_lookup_fnfields
operator|=
literal|0
operator|,
name|n_calls_lookup_fnfields_1
operator|=
literal|0
expr_stmt|;
name|n_calls_get_base_type
operator|=
literal|0
expr_stmt|;
name|n_outer_fields_searched
operator|=
literal|0
expr_stmt|;
name|n_contexts_saved
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* GATHER_STATISTICS */
block|}
end_function

begin_comment
comment|/* Helper for lookup_conversions_r.  TO_TYPE is the type converted to    by a conversion op in base BINFO.  VIRTUAL_DEPTH is nonzero if    BINFO is morally virtual, and VIRTUALNESS is nonzero if virtual    bases have been encountered already in the tree walk.  PARENT_CONVS    is the list of lists of conversion functions that could hide CONV    and OTHER_CONVS is the list of lists of conversion functions that    could hide or be hidden by CONV, should virtualness be involved in    the hierarchy.  Merely checking the conversion op's name is not    enough because two conversion operators to the same type can have    different names.  Return nonzero if we are visible.  */
end_comment

begin_function
specifier|static
name|int
name|check_hidden_convs
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|int
name|virtual_depth
parameter_list|,
name|int
name|virtualness
parameter_list|,
name|tree
name|to_type
parameter_list|,
name|tree
name|parent_convs
parameter_list|,
name|tree
name|other_convs
parameter_list|)
block|{
name|tree
name|level
decl_stmt|,
name|probe
decl_stmt|;
comment|/* See if we are hidden by a parent conversion.  */
for|for
control|(
name|level
operator|=
name|parent_convs
init|;
name|level
condition|;
name|level
operator|=
name|TREE_CHAIN
argument_list|(
name|level
argument_list|)
control|)
for|for
control|(
name|probe
operator|=
name|TREE_VALUE
argument_list|(
name|level
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|probe
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|virtual_depth
operator|||
name|virtualness
condition|)
block|{
comment|/* In a virtual hierarchy, we could be hidden, or could hide a 	conversion function on the other_convs list.  */
for|for
control|(
name|level
operator|=
name|other_convs
init|;
name|level
condition|;
name|level
operator|=
name|TREE_CHAIN
argument_list|(
name|level
argument_list|)
control|)
block|{
name|int
name|we_hide_them
decl_stmt|;
name|int
name|they_hide_us
decl_stmt|;
name|tree
modifier|*
name|prev
decl_stmt|,
name|other
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|virtual_depth
operator|||
name|TREE_STATIC
argument_list|(
name|level
argument_list|)
operator|)
condition|)
comment|/* Neither is morally virtual, so cannot hide each other.  */
continue|continue;
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|level
argument_list|)
condition|)
comment|/* They evaporated away already.  */
continue|continue;
name|they_hide_us
operator|=
operator|(
name|virtual_depth
operator|&&
name|original_binfo
argument_list|(
name|binfo
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|level
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|we_hide_them
operator|=
operator|(
operator|!
name|they_hide_us
operator|&&
name|TREE_STATIC
argument_list|(
name|level
argument_list|)
operator|&&
name|original_binfo
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|level
argument_list|)
argument_list|,
name|binfo
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|we_hide_them
operator|||
name|they_hide_us
operator|)
condition|)
comment|/* Neither is within the other, so no hiding can occur.  */
continue|continue;
for|for
control|(
name|prev
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|level
argument_list|)
operator|,
name|other
operator|=
operator|*
name|prev
init|;
name|other
condition|;
control|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|other
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|they_hide_us
condition|)
comment|/* We are hidden.  */
return|return
literal|0
return|;
if|if
condition|(
name|we_hide_them
condition|)
block|{
comment|/* We hide the other one.  */
name|other
operator|=
name|TREE_CHAIN
argument_list|(
name|other
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|other
expr_stmt|;
continue|continue;
block|}
block|}
name|prev
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|other
operator|=
operator|*
name|prev
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Helper for lookup_conversions_r.  PARENT_CONVS is a list of lists    of conversion functions, the first slot will be for the current    binfo, if MY_CONVS is non-NULL.  CHILD_CONVS is the list of lists    of conversion functions from children of the current binfo,    concatenated with conversions from elsewhere in the hierarchy --    that list begins with OTHER_CONVS.  Return a single list of lists    containing only conversions from the current binfo and its    children.  */
end_comment

begin_function
specifier|static
name|tree
name|split_conversions
parameter_list|(
name|tree
name|my_convs
parameter_list|,
name|tree
name|parent_convs
parameter_list|,
name|tree
name|child_convs
parameter_list|,
name|tree
name|other_convs
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|prev
decl_stmt|;
comment|/* Remove the original other_convs portion from child_convs.  */
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|t
operator|=
name|child_convs
init|;
name|t
operator|!=
name|other_convs
condition|;
name|prev
operator|=
name|t
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
continue|continue;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|child_convs
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Attach the child convs to any we had at this level.  */
if|if
condition|(
name|my_convs
condition|)
block|{
name|my_convs
operator|=
name|parent_convs
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|my_convs
argument_list|)
operator|=
name|child_convs
expr_stmt|;
block|}
else|else
name|my_convs
operator|=
name|child_convs
expr_stmt|;
return|return
name|my_convs
return|;
block|}
end_function

begin_comment
comment|/* Worker for lookup_conversions.  Lookup conversion functions in    BINFO and its children.  VIRTUAL_DEPTH is nonzero, if BINFO is in    a morally virtual base, and VIRTUALNESS is nonzero, if we've    encountered virtual bases already in the tree walk.  PARENT_CONVS&    PARENT_TPL_CONVS are lists of list of conversions within parent    binfos.  OTHER_CONVS and OTHER_TPL_CONVS are conversions found    elsewhere in the tree.  Return the conversions found within this    portion of the graph in CONVS and TPL_CONVS.  Return nonzero is we    encountered virtualness.  We keep template and non-template    conversions separate, to avoid unnecessary type comparisons.     The located conversion functions are held in lists of lists.  The    TREE_VALUE of the outer list is the list of conversion functions    found in a particular binfo.  The TREE_PURPOSE of both the outer    and inner lists is the binfo at which those conversions were    found.  TREE_STATIC is set for those lists within of morally    virtual binfos.  The TREE_VALUE of the inner list is the conversion    function or overload itself.  The TREE_TYPE of each inner list node    is the converted-to type.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_conversions_r
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|int
name|virtual_depth
parameter_list|,
name|int
name|virtualness
parameter_list|,
name|tree
name|parent_convs
parameter_list|,
name|tree
name|parent_tpl_convs
parameter_list|,
name|tree
name|other_convs
parameter_list|,
name|tree
name|other_tpl_convs
parameter_list|,
name|tree
modifier|*
name|convs
parameter_list|,
name|tree
modifier|*
name|tpl_convs
parameter_list|)
block|{
name|int
name|my_virtualness
init|=
literal|0
decl_stmt|;
name|tree
name|my_convs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|my_tpl_convs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|child_convs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|child_tpl_convs
init|=
name|NULL_TREE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|method_vec
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|tree
name|conv
decl_stmt|;
comment|/* If we have no conversion operators, then don't look.  */
if|if
condition|(
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|convs
operator|=
operator|*
name|tpl_convs
operator|=
name|NULL_TREE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
name|virtual_depth
operator|++
expr_stmt|;
comment|/* First, locate the unhidden ones at this level.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|method_vec
argument_list|,
name|i
argument_list|,
name|conv
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|cur
init|=
name|OVL_CURRENT
argument_list|(
name|conv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|cur
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* Only template conversions can be overloaded, and we must 	     flatten them out and check each one individually.  */
name|tree
name|tpls
decl_stmt|;
for|for
control|(
name|tpls
operator|=
name|conv
init|;
name|tpls
condition|;
name|tpls
operator|=
name|OVL_NEXT
argument_list|(
name|tpls
argument_list|)
control|)
block|{
name|tree
name|tpl
init|=
name|OVL_CURRENT
argument_list|(
name|tpls
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|DECL_CONV_FN_TYPE
argument_list|(
name|tpl
argument_list|)
decl_stmt|;
if|if
condition|(
name|check_hidden_convs
argument_list|(
name|binfo
argument_list|,
name|virtual_depth
argument_list|,
name|virtualness
argument_list|,
name|type
argument_list|,
name|parent_tpl_convs
argument_list|,
name|other_tpl_convs
argument_list|)
condition|)
block|{
name|my_tpl_convs
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|tpl
argument_list|,
name|my_tpl_convs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|my_tpl_convs
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|virtual_depth
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|my_tpl_convs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|my_virtualness
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|DECL_CONV_FN_TYPE
argument_list|(
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|check_hidden_convs
argument_list|(
name|binfo
argument_list|,
name|virtual_depth
argument_list|,
name|virtualness
argument_list|,
name|type
argument_list|,
name|parent_convs
argument_list|,
name|other_convs
argument_list|)
condition|)
block|{
name|my_convs
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|conv
argument_list|,
name|my_convs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|my_convs
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|virtual_depth
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|my_convs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|my_virtualness
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_MARKED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|my_convs
condition|)
block|{
name|parent_convs
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|my_convs
argument_list|,
name|parent_convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_depth
condition|)
name|TREE_STATIC
argument_list|(
name|parent_convs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|my_tpl_convs
condition|)
block|{
name|parent_tpl_convs
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|my_tpl_convs
argument_list|,
name|parent_tpl_convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_depth
condition|)
name|TREE_STATIC
argument_list|(
name|parent_tpl_convs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|child_convs
operator|=
name|other_convs
expr_stmt|;
name|child_tpl_convs
operator|=
name|other_tpl_convs
expr_stmt|;
comment|/* Now iterate over each base, looking for more conversions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_convs
decl_stmt|,
name|base_tpl_convs
decl_stmt|;
name|unsigned
name|base_virtualness
decl_stmt|;
name|base_virtualness
operator|=
name|lookup_conversions_r
argument_list|(
name|base_binfo
argument_list|,
name|virtual_depth
argument_list|,
name|virtualness
argument_list|,
name|parent_convs
argument_list|,
name|parent_tpl_convs
argument_list|,
name|child_convs
argument_list|,
name|child_tpl_convs
argument_list|,
operator|&
name|base_convs
argument_list|,
operator|&
name|base_tpl_convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_virtualness
condition|)
name|my_virtualness
operator|=
name|virtualness
operator|=
literal|1
expr_stmt|;
name|child_convs
operator|=
name|chainon
argument_list|(
name|base_convs
argument_list|,
name|child_convs
argument_list|)
expr_stmt|;
name|child_tpl_convs
operator|=
name|chainon
argument_list|(
name|base_tpl_convs
argument_list|,
name|child_tpl_convs
argument_list|)
expr_stmt|;
block|}
comment|/* Unmark the conversions found at this level  */
for|for
control|(
name|conv
operator|=
name|my_convs
init|;
name|conv
condition|;
name|conv
operator|=
name|TREE_CHAIN
argument_list|(
name|conv
argument_list|)
control|)
name|IDENTIFIER_MARKED
argument_list|(
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|conv
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|convs
operator|=
name|split_conversions
argument_list|(
name|my_convs
argument_list|,
name|parent_convs
argument_list|,
name|child_convs
argument_list|,
name|other_convs
argument_list|)
expr_stmt|;
operator|*
name|tpl_convs
operator|=
name|split_conversions
argument_list|(
name|my_tpl_convs
argument_list|,
name|parent_tpl_convs
argument_list|,
name|child_tpl_convs
argument_list|,
name|other_tpl_convs
argument_list|)
expr_stmt|;
return|return
name|my_virtualness
return|;
block|}
end_function

begin_comment
comment|/* Return a TREE_LIST containing all the non-hidden user-defined    conversion functions for TYPE (and its base-classes).  The    TREE_VALUE of each node is the FUNCTION_DECL of the conversion    function.  The TREE_PURPOSE is the BINFO from which the conversion    functions in this node were selected.  This function is effectively    performing a set of member lookups as lookup_fnfield does, but    using the type being converted to as the unique key, rather than the    field name.  */
end_comment

begin_function
name|tree
name|lookup_conversions
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|convs
decl_stmt|,
name|tpl_convs
decl_stmt|;
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|lookup_conversions_r
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|convs
argument_list|,
operator|&
name|tpl_convs
argument_list|)
expr_stmt|;
comment|/* Flatten the list-of-lists */
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|probe
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|probe
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|tpl_convs
condition|;
name|tpl_convs
operator|=
name|TREE_CHAIN
argument_list|(
name|tpl_convs
argument_list|)
control|)
block|{
name|tree
name|probe
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|TREE_VALUE
argument_list|(
name|tpl_convs
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|probe
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo of the first direct or indirect virtual base derived    from BINFO, or NULL if binfo is not via virtual.  */
end_comment

begin_function
name|tree
name|binfo_from_vbase
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
for|for
control|(
init|;
name|binfo
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns the binfo of the first direct or indirect virtual base derived    from BINFO up to the TREE_TYPE, LIMIT, or NULL if binfo is not    via virtual.  */
end_comment

begin_function
name|tree
name|binfo_via_virtual
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|&&
operator|!
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|limit
argument_list|)
condition|)
comment|/* LIMIT has no virtual bases, so BINFO cannot be via one.  */
return|return
name|NULL_TREE
return|;
for|for
control|(
init|;
name|binfo
operator|&&
operator|!
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|limit
argument_list|)
condition|;
name|binfo
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
return|return
name|binfo
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* BINFO is a base binfo in the complete type BINFO_TYPE (HERE).    Find the equivalent binfo within whatever graph HERE is located.    This is the inverse of original_binfo.  */
end_comment

begin_function
name|tree
name|copied_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|here
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|here
init|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
continue|continue;
name|result
operator|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|cbinfo
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|cbinfo
operator|=
name|copied_binfo
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|here
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|cbinfo
argument_list|,
name|ix
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|base_binfo
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|here
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|binfo_for_vbase
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vbases
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|,
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vbases
argument_list|,
name|ix
argument_list|,
name|binfo
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|base
argument_list|)
condition|)
return|return
name|binfo
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* BINFO is some base binfo of HERE, within some other    hierarchy. Return the equivalent binfo, but in the hierarchy    dominated by HERE.  This is the inverse of copied_binfo.  If BINFO    is not a base binfo of HERE, returns NULL_TREE.  */
end_comment

begin_function
name|tree
name|original_binfo
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|here
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|here
expr_stmt|;
elseif|else
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
name|result
operator|=
operator|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
argument_list|)
condition|?
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|here
argument_list|)
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|base_binfos
decl_stmt|;
name|base_binfos
operator|=
name|original_binfo
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|here
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfos
condition|)
block|{
name|int
name|ix
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
operator|(
name|base_binfo
operator|=
name|BINFO_BASE_BINFO
argument_list|(
name|base_binfos
argument_list|,
name|ix
argument_list|)
operator|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|base_binfo
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

