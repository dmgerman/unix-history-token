begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Code to maintain a C++ template repository.    Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.    Contributed by Jason Merrill (jason@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* My strategy here is as follows:     Everything should be emitted in a translation unit where it is used.    The results of the automatic process should be easily reproducible with    explicit code.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|extract_string
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_base_filename
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|open_repo_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|afgets
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|reopen_repo_file_for_write
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_repo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repo_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|old_args
decl_stmt|,
modifier|*
name|old_dir
decl_stmt|,
modifier|*
name|old_main
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|temporary_obstack_initialized_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse a reasonable subset of shell quoting syntax.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_string
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|backquote
init|=
literal|0
decl_stmt|;
name|int
name|inside
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|backquote
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|backquote
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inside
operator|&&
name|c
operator|==
literal|' '
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|inside
operator|&&
name|c
operator|==
literal|'\\'
condition|)
name|backquote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
else|else
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_base_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
name|int
name|compiling
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
name|output
operator|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-c"
argument_list|)
operator|==
literal|0
condition|)
name|compiling
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|compiling
operator|&&
name|output
condition|)
return|return
name|output
return|;
if|if
condition|(
name|p
operator|&&
operator|!
name|compiling
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-frepo must be used with -c"
argument_list|)
expr_stmt|;
name|flag_use_repository
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|lbasename
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|open_repo_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|get_base_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|lbasename
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|repo_name
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|p
operator|-
name|s
operator|+
literal|5
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|repo_name
argument_list|,
name|s
argument_list|,
name|p
operator|-
name|s
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|repo_name
operator|+
operator|(
name|p
operator|-
name|s
operator|)
argument_list|,
literal|".rpo"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
name|fopen
argument_list|(
name|repo_name
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|afgets
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|init_repo
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|FILE
modifier|*
name|repo_file
decl_stmt|;
if|if
condition|(
operator|!
name|flag_use_repository
condition|)
return|return;
comment|/* When a PCH file is loaded, the entire identifier table is      replaced, with the result that IDENTIFIER_REPO_CHOSEN is cleared.      So, we have to reread the repository file.  */
name|lang_post_pch_load
operator|=
name|init_repo
expr_stmt|;
if|if
condition|(
operator|!
name|temporary_obstack_initialized_p
condition|)
name|gcc_obstack_init
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|repo_file
operator|=
name|open_repo_file
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|repo_file
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|buf
operator|=
name|afgets
argument_list|(
name|repo_file
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
name|old_args
operator|=
name|ggc_strdup
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|old_dir
operator|=
name|ggc_strdup
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|old_main
operator|=
name|ggc_strdup
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* A symbol that we were able to define the last time this 	     file was compiled.  */
break|break;
case|case
literal|'C'
case|:
comment|/* A symbol that the prelinker has requested that we 	     define.  */
block|{
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
decl_stmt|;
name|IDENTIFIER_REPO_CHOSEN
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"mysterious repository information in %s"
argument_list|,
name|repo_name
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|repo_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|reopen_repo_file_for_write
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|repo_file
init|=
name|fopen
argument_list|(
name|repo_name
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|repo_file
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"can't create repository information file %qs"
argument_list|,
name|repo_name
argument_list|)
expr_stmt|;
name|flag_use_repository
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|repo_file
return|;
block|}
end_function

begin_comment
comment|/* Emit any pending repos.  */
end_comment

begin_function
name|void
name|finish_repo
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|args
decl_stmt|;
name|FILE
modifier|*
name|repo_file
decl_stmt|;
if|if
condition|(
operator|!
name|flag_use_repository
condition|)
return|return;
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
name|repo_file
operator|=
name|reopen_repo_file_for_write
argument_list|()
expr_stmt|;
if|if
condition|(
name|repo_file
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|fprintf
argument_list|(
name|repo_file
argument_list|,
literal|"M %s\n"
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
name|dir
operator|=
name|getpwd
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|repo_file
argument_list|,
literal|"D %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|args
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|fprintf
argument_list|(
name|repo_file
argument_list|,
literal|"A %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* If -frandom-seed is not among the ARGS, then add the value 	 that we chose.  That will ensure that the names of types from 	 anonymous namespaces will get the same mangling when this 	 file is recompiled.  */
if|if
condition|(
operator|!
name|strstr
argument_list|(
name|args
argument_list|,
literal|"'-frandom-seed="
argument_list|)
condition|)
name|fprintf
argument_list|(
name|repo_file
argument_list|,
literal|" '-frandom-seed=%s'"
argument_list|,
name|flag_random_seed
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|repo_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|pending_repo
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|char
name|type
init|=
name|IDENTIFIER_REPO_CHOSEN
argument_list|(
name|name
argument_list|)
condition|?
literal|'C'
else|:
literal|'O'
decl_stmt|;
name|fprintf
argument_list|(
name|repo_file
argument_list|,
literal|"%c %s\n"
argument_list|,
name|type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|repo_file
condition|)
name|fclose
argument_list|(
name|repo_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL or VAR_DECL with vague linkage whose    definition is available in this translation unit.  Returns 0 if    this definition should not be emitted in this translation unit    because it will be emitted elsewhere.  Returns 1 if the repository    file indicates that that DECL should be emitted in this translation    unit, or 2 if the repository file is not in use.  */
end_comment

begin_function
name|int
name|repo_emit_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|DECL_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When not using the repository, emit everything.  */
if|if
condition|(
operator|!
name|flag_use_repository
condition|)
return|return
literal|2
return|;
comment|/* Only template instantiations are managed by the repository.  This      is an artificial restriction; the code in the prelinker and here      will work fine if all entities with vague linkage are managed by      the repository.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
condition|)
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
literal|2
return|;
comment|/* Static data members initialized by constant expressions must 	 be processed where needed so that their definitions are 	 available.  */
if|if
condition|(
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* For constructors and destructors, the repository contains      information about the clones -- not the original function --      because only the clones are emitted in the object file.  */
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|emit_p
init|=
literal|0
decl_stmt|;
name|tree
name|clone
decl_stmt|;
comment|/* There is no early exit from this loop because we want to 	 ensure that all of the clones are marked as available in this 	 object file.  */
name|FOR_EACH_CLONE
argument_list|(
argument|clone
argument_list|,
argument|decl
argument_list|)
comment|/* The only possible results from the recursive call to 	   repo_emit_p are 0 or 1.  */
if|if
condition|(
name|repo_emit_p
argument_list|(
name|clone
argument_list|)
condition|)
name|emit_p
operator|=
literal|1
expr_stmt|;
return|return
name|emit_p
return|;
block|}
comment|/* Keep track of all available entities.  */
if|if
condition|(
operator|!
name|DECL_REPO_AVAILABLE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_REPO_AVAILABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pending_repo
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|pending_repo
argument_list|)
expr_stmt|;
block|}
return|return
name|IDENTIFIER_REPO_CHOSEN
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff the prelinker has explicitly marked CLASS_TYPE for    export from this translation unit.  */
end_comment

begin_function
name|bool
name|repo_export_class_p
parameter_list|(
name|tree
name|class_type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_use_repository
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|CLASSTYPE_VTABLES
argument_list|(
name|class_type
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the virtual table has been assigned to this translation unit,      export the class.  */
return|return
operator|(
name|IDENTIFIER_REPO_CHOSEN
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|CLASSTYPE_VTABLES
argument_list|(
name|class_type
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-repo.h"
end_include

end_unit

