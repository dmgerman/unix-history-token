begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Some code common to C++ and ObjC++ front ends.    Copyright (C) 2004 Free Software Foundation, Inc.    Contributed by Ziemowit Laski<zlaski@apple.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"cxx-pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"cp-objcp-common.h"
end_include

begin_comment
comment|/* Special routine to get the alias set for C++.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|cxx_get_alias_set
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|IS_FAKE_BASE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
comment|/* The base variant of a type must be in the same alias set as the        complete type.  */
return|return
name|get_alias_set
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
comment|/* Punt on PMFs until we canonicalize functions properly.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|c_common_get_alias_set
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from check_global_declarations.  */
end_comment

begin_function
name|bool
name|cxx_warn_unused_global_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Const variables take the place of #defines in C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Langhook for expr_size: Tell the backend that the value of an expression    of non-POD class type does not include any tail padding; a derived class    might have allocated something there.  */
end_comment

begin_function
name|tree
name|cp_expr_size
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The backend should not be interested in the size of an expression 	 of a type with both of these set; all copies of such types must go 	 through a constructor or assignment op.  */
name|gcc_assert
argument_list|(
operator|!
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|type
argument_list|)
comment|/* But storing a CONSTRUCTOR isn't a copy.  */
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
comment|/* And, the gimplifier will sometimes make a copy of 		     an aggregate.  In particular, for a case like:  			struct S { S(); }; 			struct X { int a; S s; }; 			X x = { 0 };  		     the gimplifier will create a temporary with 		     static storage duration, perform static 		     initialization of the temporary, and then copy 		     the result.  Since the "s" subobject is never 		     constructed, this is a valid transformation.  */
operator|||
name|CP_AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This would be wrong for a type with virtual bases, but they are 	 caught by the assert above.  */
return|return
operator|(
name|is_empty_class
argument_list|(
name|type
argument_list|)
condition|?
name|size_zero_node
else|:
name|CLASSTYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
else|else
comment|/* Use the default code.  */
return|return
name|lhd_expr_size
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Langhook for tree_size: determine size of our 'x' and 'c' nodes.  */
end_comment

begin_function
name|size_t
name|cp_tree_size
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TINST_LEVEL
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tinst_level_s
argument_list|)
return|;
case|case
name|PTRMEM_CST
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|ptrmem_cst
argument_list|)
return|;
case|case
name|BASELINK
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_baselink
argument_list|)
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
return|return
sizeof|sizeof
argument_list|(
name|template_parm_index
argument_list|)
return|;
case|case
name|DEFAULT_ARG
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_default_arg
argument_list|)
return|;
case|case
name|OVERLOAD
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tree_overload
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Returns true if T is a variably modified type, in the sense of C99.    FN is as passed to variably_modified_p.    This routine needs only check cases that cannot be handled by the    language-independent logic in tree.c.  */
end_comment

begin_function
name|bool
name|cp_var_mod_type_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
comment|/* If TYPE is a pointer-to-member, it is variably modified if either      the class or the member are variably modified.  */
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
name|variably_modified_type_p
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|||
name|variably_modified_type_p
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|)
return|;
comment|/* All other types are not variably modified.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Construct a C++-aware pretty-printer for CONTEXT.  It is assumed    that CONTEXT->printer is an already constructed basic pretty_printer.  */
end_comment

begin_function
name|void
name|cxx_initialize_diagnostics
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|pretty_printer
modifier|*
name|base
init|=
name|context
operator|->
name|printer
decl_stmt|;
name|cxx_pretty_printer
modifier|*
name|pp
init|=
name|XNEW
argument_list|(
name|cxx_pretty_printer
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|pp_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|pretty_printer
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_pretty_printer_init
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|context
operator|->
name|printer
operator|=
operator|(
name|pretty_printer
operator|*
operator|)
name|pp
expr_stmt|;
comment|/* It is safe to free this object because it was previously malloc()'d.  */
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This compares two types for equivalence ("compatible" in C-based languages).    This routine should only return 1 if it is sure.  It should not be used    in contexts where erroneously returning 0 causes problems.  */
end_comment

begin_function
name|int
name|cxx_types_compatible_p
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|y
parameter_list|)
block|{
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Once we get to the middle-end, references and pointers are      interchangeable.  FIXME should we try to replace all references with      pointers?  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|y
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|y
argument_list|)
operator|&&
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|y
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|tree
name|cxx_staticp
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|BASELINK
case|:
return|return
name|staticp
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Stubs to keep c-opts.c happy.  */
end_comment

begin_function
name|void
name|push_file_scope
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|pop_file_scope
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* c-pragma.c needs to query whether a decl has extern "C" linkage.  */
end_comment

begin_function
name|bool
name|has_c_linkage
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_map_marked_p"
argument|), param_is (struct tree_map))
argument_list|)
name|htab_t
name|shadowed_var_for_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lookup a shadowed var for FROM, and return it if we find one.  */
end_comment

begin_function
name|tree
name|decl_shadowed_for_var_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|tree_map
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|shadowed_var_for_decl
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Insert a mapping FROM->TO in the shadowed var hashtable.  */
end_comment

begin_function
name|void
name|decl_shadowed_for_var_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|tree_map
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|shadowed_var_for_decl
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_shadowed_var_for_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|shadowed_var_for_decl
operator|=
name|htab_create_ggc
argument_list|(
literal|512
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APPLE LOCAL begin radar 5741070  */
end_comment

begin_comment
comment|/* Given an IDENTIFIER tree for a class interface, find (if possible) and  return the record type for the class interface.  */
end_comment

begin_function
name|tree
name|c_return_interface_record_type
parameter_list|(
name|tree
name|typename
parameter_list|)
block|{
name|enum
name|tree_code_class
name|class
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|retval
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
return|return
name|retval
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|IDENTIFIER_NODE
operator|||
name|class
operator|!=
name|tcc_exceptional
condition|)
return|return
name|retval
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|typename
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|typename
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|retval
operator|=
name|TREE_TYPE
argument_list|(
name|typename
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|&&
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|retval
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* APPLE LOCAL end radar 5741070  */
end_comment

begin_include
include|#
directive|include
file|"gt-cp-cp-objcp-common.h"
end_include

end_unit

