begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-level data type conversion for GNU C++.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains the functions for converting C++ expressions    to different data types.  The only entry point is `convert'.    Every language front end must have a `convert' function    but what kind of conversions it does will depend on the language.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_function_decl
specifier|static
name|tree
name|cp_convert_to_pointer
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_to_pointer_force
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_type_conversion
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_up_reference
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_ref_binding
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Change of width--truncation and extension of integers or reals--    is represented with NOP_EXPR.  Proper functioning of many things    assumes that no other conversions can be NOP_EXPRs.     Conversion between integer and pointer is represented with CONVERT_EXPR.    Converting integer to real uses FLOAT_EXPR    and real to integer uses FIX_TRUNC_EXPR.     Here is a list of all the functions that assume that widening and    narrowing is always done with a NOP_EXPR:      In convert.c, convert_to_integer.      In c-typeck.c, build_binary_op_nodefault (boolean ops), 	and c_common_truthvalue_conversion.      In expr.c: expand_expr, for operands of a MULT_EXPR.      In fold-const.c: fold.      In tree.c: get_narrower and get_unwidened.     C++: in multiple-inheritance, converting between pointers may involve    adjusting them by a delta stored within the class definition.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `convert'.  */
end_comment

begin_comment
comment|/* if converting pointer to pointer      if dealing with classes, check for derived->base or vice versa      else if dealing with method pointers, delegate      else convert blindly    else if converting class, pass off to build_type_conversion    else try C-style pointer conversion.  If FORCE is true then allow    conversions via virtual bases (these are permitted by reinterpret_cast,    but not static_cast).  */
end_comment

begin_function
specifier|static
name|tree
name|cp_convert_to_pointer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|form
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|intype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|intype
operator|=
name|complete_type
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't convert from incomplete type %qT to %qT"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"conversion of %qE from %qT to %qT is ambiguous"
argument_list|,
name|expr
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|convert_member_func_to_ptr
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|intype
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|intype_class
decl_stmt|;
name|tree
name|type_class
decl_stmt|;
name|bool
name|same_p
decl_stmt|;
name|intype_class
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|type_class
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|same_p
operator|=
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype_class
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_class
argument_list|)
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Try derived to base conversion.  */
if|if
condition|(
operator|!
name|same_p
condition|)
name|binfo
operator|=
name|lookup_base
argument_list|(
name|intype_class
argument_list|,
name|type_class
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_p
operator|&&
operator|!
name|binfo
condition|)
block|{
comment|/* Try base to derived conversion.  */
name|binfo
operator|=
name|lookup_base
argument_list|(
name|type_class
argument_list|,
name|intype_class
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|binfo
operator|||
name|same_p
condition|)
block|{
if|if
condition|(
name|binfo
condition|)
name|expr
operator|=
name|build_base_path
argument_list|(
name|code
argument_list|,
name|expr
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add any qualifier conversions.  */
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot convert %qE from type %qT to type %qT"
argument_list|,
name|expr
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|tree
name|b1
decl_stmt|;
name|tree
name|b2
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|base_kind
name|bk
decl_stmt|;
name|b1
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|b2
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|,
name|ba_check
argument_list|,
operator|&
name|bk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|binfo
operator|=
name|lookup_base
argument_list|(
name|b2
argument_list|,
name|b1
argument_list|,
name|ba_check
argument_list|,
operator|&
name|bk
argument_list|)
expr_stmt|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|bk
operator|==
name|bk_via_virtual
condition|)
block|{
if|if
condition|(
name|force
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"pointer to member cast from %qT to %qT is via"
literal|" virtual base"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"pointer to member cast from %qT to %qT is"
literal|" via virtual base"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* This is a reinterpret cast, whose result is unspecified. 	     We choose to do nothing.  */
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
name|expr
operator|=
name|cplus_expand_constant
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|size_binop
argument_list|(
name|code
argument_list|,
name|build_nop
argument_list|(
name|sizetype
argument_list|,
name|expr
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
condition|)
return|return
name|build_ptrmemfunc
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|,
comment|/*c_cast_p=*/
name|false
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|warn_pmf2ptr
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
return|return
name|cp_convert_to_pointer
argument_list|(
name|type
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|expr
argument_list|)
argument_list|,
name|force
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|tree
name|object
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|object
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"cannot convert %qE from type %qT to type %qT"
argument_list|,
name|expr
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_ptrmemfunc
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|,
comment|/*c_cast_p=*/
name|false
argument_list|)
return|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* A NULL pointer-to-member is represented by -1, not by 	     zero.  */
name|expr
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix up the representation of -1 if appropriate.  */
name|expr
operator|=
name|force_fit_type
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INTEGRAL_CODE_P
argument_list|(
name|form
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid conversion from %qT to %qT"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|form
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_SIZE
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|expr
operator|=
name|cp_convert
argument_list|(
name|c_common_type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Modes may be different but sizes should be the same.  There 	 is supposed to be some integral type that is the same width 	 as a pointer.  */
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|tf_warning_or_error
argument_list|)
return|;
name|error
argument_list|(
literal|"cannot convert %qE from type %qT to type %qT"
argument_list|,
name|expr
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like convert, except permit conversions to take place which    are not normally allowed due to access restrictions    (such as conversion from sub-type to private super-type).  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_pointer_force
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
block|{
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|intype
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ba_unique
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|ba_unique
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|binfo
condition|)
block|{
name|expr
operator|=
name|build_base_path
argument_list|(
name|code
argument_list|,
name|expr
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Add any qualifier conversions.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
block|}
return|return
name|cp_convert_to_pointer
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We are passing something to a function which requires a reference.    The type we are interested in is in TYPE. The initial    value we have to begin with is in ARG.     FLAGS controls how we manage access checking.    DIRECT_BIND in FLAGS controls how any temporaries are generated.      If DIRECT_BIND is set, DECL is the reference we're binding to.  */
end_comment

begin_function
specifier|static
name|tree
name|build_up_reference
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|argtype
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DIRECT_BIND
operator|)
operator|&&
operator|!
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Create a new temporary variable.  We can't just use a TARGET_EXPR 	 here because it needs to live as long as DECL.  */
name|tree
name|targ
init|=
name|arg
decl_stmt|;
name|arg
operator|=
name|make_temporary_var_for_ref_to_temp
argument_list|(
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the initializer for the declaration.  */
name|DECL_INITIAL
argument_list|(
name|arg
argument_list|)
operator|=
name|targ
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|arg
argument_list|,
name|targ
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
operator||
name|DIRECT_BIND
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DIRECT_BIND
operator|)
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|get_target_expr
argument_list|(
name|arg
argument_list|)
return|;
comment|/* If we had a way to wrap this up, and say, if we ever needed its      address, transform all occurrences of the register, into a memory      reference we could win better.  */
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PROTECT
operator|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|argtype
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|target_type
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|argtype
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
comment|/* We go through lookup_base for the access control.  */
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|argtype
argument_list|,
name|target_type
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
return|return
name|error_not_base_type
argument_list|(
name|target_type
argument_list|,
name|argtype
argument_list|)
return|;
name|rval
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rval
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|convert_to_pointer_force
argument_list|(
name|build_pointer_type
argument_list|(
name|target_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|rval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of convert_to_reference. REFTYPE is the target reference type.    INTYPE is the original rvalue type and DECL is an optional _DECL node    for diagnostics.     [dcl.init.ref] says that if an rvalue is used to    initialize a reference, then the reference must be to a    non-volatile const type.  */
end_comment

begin_function
specifier|static
name|void
name|warn_ref_binding
parameter_list|(
name|tree
name|reftype
parameter_list|,
name|tree
name|intype
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|reftype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|ttl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|ttl
argument_list|)
operator|&&
name|decl
condition|)
name|msg
operator|=
literal|"initialization of volatile reference type %q#T from"
literal|" rvalue of type %qT"
expr_stmt|;
elseif|else
if|if
condition|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|ttl
argument_list|)
condition|)
name|msg
operator|=
literal|"conversion to volatile reference type %q#T "
literal|" from rvalue of type %qT"
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
condition|)
name|msg
operator|=
literal|"initialization of non-const reference type %q#T from"
literal|" rvalue of type %qT"
expr_stmt|;
else|else
name|msg
operator|=
literal|"conversion to non-const reference type %q#T from"
literal|" rvalue of type %qT"
expr_stmt|;
name|pedwarn
argument_list|(
name|msg
argument_list|,
name|reftype
argument_list|,
name|intype
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For C++: Only need to do one-level references, but cannot    get tripped up on signed/unsigned differences.     DECL is either NULL_TREE or the _DECL node for a reference that is being    initialized.  It can be error_mark_node if we don't know the _DECL but    we know it's an initialization.  */
end_comment

begin_function
name|tree
name|convert_to_reference
parameter_list|(
name|tree
name|reftype
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|convtype
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|reftype
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|intype
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rval_as_conversion
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|can_convert_intype_to_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|unknown_type_node
condition|)
name|expr
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
condition|?
name|tf_warning_or_error
else|:
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|reftype
argument_list|)
operator|==
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|can_convert_intype_to_type
operator|=
name|can_convert
argument_list|(
name|type
argument_list|,
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_convert_intype_to_type
operator|&&
operator|(
name|convtype
operator|&
name|CONV_IMPLICIT
operator|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
condition|)
block|{
comment|/* Look for a user-defined conversion to lvalue that we can use.  */
name|rval_as_conversion
operator|=
name|build_type_conversion
argument_list|(
name|reftype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval_as_conversion
operator|&&
name|rval_as_conversion
operator|!=
name|error_mark_node
operator|&&
name|real_lvalue_p
argument_list|(
name|rval_as_conversion
argument_list|)
condition|)
block|{
name|expr
operator|=
name|rval_as_conversion
expr_stmt|;
name|rval_as_conversion
operator|=
name|NULL_TREE
expr_stmt|;
name|intype
operator|=
name|type
expr_stmt|;
name|can_convert_intype_to_type
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|convtype
operator|&
name|CONV_STATIC
operator|)
operator|&&
name|can_convert
argument_list|(
name|intype
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|convtype
operator|&
name|CONV_IMPLICIT
operator|)
operator|&&
name|can_convert_intype_to_type
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|reftype
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|lvalue_type
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
name|warn_ref_binding
argument_list|(
name|reftype
argument_list|,
name|intype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|convtype
operator|&
name|CONV_CONST
operator|)
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"conversion from %qT to %qT discards qualifiers"
argument_list|,
name|ttr
argument_list|,
name|reftype
argument_list|)
expr_stmt|;
block|}
return|return
name|build_up_reference
argument_list|(
name|reftype
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|,
name|decl
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|convtype
operator|&
name|CONV_REINTERPRET
operator|)
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* When casting an lvalue to a reference type, just convert into 	 a pointer to the new type and deference it.  This is allowed 	 by San Diego WP section 5.2.9 paragraph 12, though perhaps it 	 should be done directly (jason).  (int&)ri ---> *(int*)&ri */
comment|/* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they 	 meant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|type
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_DERIVED
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"casting %qT to %qT does not dereference pointer"
argument_list|,
name|intype
argument_list|,
name|reftype
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
name|rval
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|reftype
argument_list|)
argument_list|)
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|reftype
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|,
literal|"converting"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NULL_TREE
operator|||
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|rval
return|;
name|warn_ref_binding
argument_list|(
name|reftype
argument_list|,
name|intype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_up_reference
argument_list|(
name|reftype
argument_list|,
name|rval
argument_list|,
name|flags
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rval
condition|)
block|{
comment|/* If we found a way to convert earlier, then use it.  */
return|return
name|rval
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"cannot convert type %qT to type %qT"
argument_list|,
name|intype
argument_list|,
name|reftype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* We are using a reference VAL for its value. Bash that reference all the    way down to its lowest form.  */
end_comment

begin_function
name|tree
name|convert_from_reference
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|t
init|=
name|canonical_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
decl_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	  so that we get the proper error message if the result is used 	  to assign to.  Also,&* is supposed to be a no-op.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|)
expr_stmt|;
name|REFERENCE_REF_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|ref
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Really perform an lvalue-to-rvalue conversion, including copying an    argument of class type into a temporary.  */
end_comment

begin_function
name|tree
name|force_rvalue
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|TARGET_EXPR
condition|)
name|expr
operator|=
name|ocp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* C++ conversions, preference to static cast conversions.  */
end_comment

begin_function
name|tree
name|cp_convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|CONV_OLD_CONVERT
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Conversion...     FLAGS indicates how we should behave.  */
end_comment

begin_function
name|tree
name|ocp_convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|convtype
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_conv_diag
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|e
argument_list|)
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|invalid_conv_diag
operator|=
name|targetm
operator|.
name|invalid_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_conv_diag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|e
operator|=
name|integral_constant_value
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|convtype
operator|&
name|CONV_FORCE_TEMP
operator|)
comment|/* Some internal structures (vtable_entry_type, sigtbl_ptr_type) 	 don't go through finish_struct, so they don't have the synthesized 	 constructors.  So don't force a temporary.  */
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
comment|/* We need a new temporary; don't take this shortcut.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
comment|/* The call to fold will not always remove the NOP_EXPR as 	   might be expected, since if one of the types is a typedef; 	   the comparison in fold is just equality of pointers, not a 	   call to comptypes.  We don't call fold in this case because 	   that can result in infinite recursion; fold will call 	   convert, which will call ocp_convert, etc.  */
return|return
name|e
return|;
comment|/* For complex data types, we need to perform componentwise 	 conversion.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
comment|/* Don't build a NOP_EXPR of class type.  Instead, change the 	     type of the temporary.  Only allow this for cv-qual changes, 	     though.  */
name|gcc_assert
argument_list|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TARGET_EXPR_SLOT
argument_list|(
name|e
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|e
return|;
block|}
else|else
block|{
comment|/* We shouldn't be treating objects of ADDRESSABLE type as 	     rvalues.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|build_nop
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
operator|&&
operator|(
name|convtype
operator|&
name|CONV_STATIC
operator|)
condition|)
block|{
name|e
operator|=
name|convert_to_void
argument_list|(
name|e
argument_list|,
comment|/*implicit=*/
name|NULL
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|/* enum = enum, enum = int, enum = float, (enum)pointer are all 	 errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
operator|(
operator|(
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|intype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
operator|(
name|convtype
operator|&
name|CONV_STATIC
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|pedwarn
argument_list|(
literal|"conversion from %q#T to %q#T"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"%q#T used where a %qT was expected"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|cp_truthvalue_conversion
argument_list|(
name|e
argument_list|)
return|;
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|cp_convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|tree
name|in_vtype
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|in_vtype
argument_list|)
condition|)
block|{
name|tree
name|ret_val
decl_stmt|;
name|ret_val
operator|=
name|build_type_conversion
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"%q#T used where a %qT was expected"
argument_list|,
name|in_vtype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_vector
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"%q#T used where a floating point value was expected"
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
comment|/* New C++ semantics:  since assignment is now based on      memberwise copying,  if the rhs type is derived from the      lhs type, then we may still do a conversion.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|tree
name|dtype
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|tree
name|ctor
init|=
name|NULL_TREE
decl_stmt|;
name|dtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
comment|/* Conversion between aggregate types.  New C++ semantics allow 	 objects of derived type to be cast to objects of base type. 	 Old semantics only allowed this between pointers.  	 There may be some ambiguity between using a constructor 	 vs. using a type conversion operator when both apply.  */
name|ctor
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
operator|&&
operator|!
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|dtype
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|type
argument_list|,
name|dtype
argument_list|)
operator|)
condition|)
comment|/* For copy-initialization, first we create a temp of the proper type 	   with a user-defined conversion sequence, then we direct-initialize 	   the target with the temp (see [dcl.init]).  */
name|ctor
operator|=
name|build_user_type_conversion
argument_list|(
name|type
argument_list|,
name|ctor
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|ctor
operator|=
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ctor
argument_list|)
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctor
condition|)
return|return
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|ctor
argument_list|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"conversion from %qT to non-scalar type %qT requested"
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* When an expression is used in a void context, its value is discarded and    no lvalue-rvalue and similar conversions happen [expr.static.cast/4,    stmt.expr/1, expr.comma/1].  This permits dereferencing an incomplete type    in a void context. The C++ standard does not define what an `access' to an    object is, but there is reason to believe that it is the lvalue to rvalue    conversion -- if it were not, `*&*p = 1' would violate [expr]/4 in that it    accesses `*p' not to calculate the value to be stored. But, dcl.type.cv/8    indicates that volatile semantics should be the same between C and C++    where ever possible. C leaves it implementation defined as to what    constitutes an access to a volatile. So, we interpret `*vp' as a read of    the volatile object `vp' points to, unless that is an incomplete type. For    volatile references we do not do this interpretation, because that would    make it impossible to ignore the reference return value from functions. We    issue warnings in the confusing cases.     IMPLICIT is tells us the context of an implicit void conversion.  */
end_comment

begin_function
name|tree
name|convert_to_void
parameter_list|(
name|tree
name|expr
parameter_list|,
specifier|const
name|char
modifier|*
name|implicit
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|invalid_nonstatic_memfn_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PSEUDO_DTOR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"pseudo-destructor is not called"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
block|{
comment|/* The two parts of a cond expr might be separate lvalues.  */
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|op2
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|new_op1
init|=
name|convert_to_void
argument_list|(
name|op1
argument_list|,
operator|(
name|implicit
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|op2
argument_list|)
condition|?
literal|"second operand of conditional"
else|:
name|NULL
operator|)
argument_list|)
decl_stmt|;
name|tree
name|new_op2
init|=
name|convert_to_void
argument_list|(
name|op2
argument_list|,
operator|(
name|implicit
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|op1
argument_list|)
condition|?
literal|"third operand of conditional"
else|:
name|NULL
operator|)
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_op1
argument_list|,
name|new_op2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|COMPOUND_EXPR
case|:
block|{
comment|/* The second part of a compound expr contains the value.  */
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|new_op1
init|=
name|convert_to_void
argument_list|(
name|op1
argument_list|,
operator|(
name|implicit
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|expr
argument_list|)
condition|?
literal|"right-hand operand of comma"
else|:
name|NULL
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_op1
operator|!=
name|op1
condition|)
block|{
name|tree
name|t
init|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|new_op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_op1
argument_list|)
decl_stmt|;
name|expr
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* These have already decayed to rvalue.  */
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* We have a special meaning for volatile void fn().  */
break|break;
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|int
name|is_reference
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
decl_stmt|;
name|int
name|is_volatile
init|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_complete
init|=
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Can't load the value if we don't know the type.  */
if|if
condition|(
name|is_volatile
operator|&&
operator|!
name|is_complete
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"object of incomplete type %qT will not be accessed in %s"
argument_list|,
name|type
argument_list|,
name|implicit
condition|?
name|implicit
else|:
literal|"void context"
argument_list|)
expr_stmt|;
comment|/* Don't load the value if this is an implicit dereference, or if 	   the type needs to be handled by ctors/dtors.  */
elseif|else
if|if
condition|(
name|is_volatile
operator|&&
operator|(
name|is_reference
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"object of type %qT will not be accessed in %s"
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|implicit
condition|?
name|implicit
else|:
literal|"void context"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reference
operator|||
operator|!
name|is_volatile
operator|||
operator|!
name|is_complete
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VAR_DECL
case|:
block|{
comment|/* External variables might be incomplete.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|int
name|is_complete
init|=
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|is_complete
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"object %qE of incomplete type %qT will not be accessed in %s"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|implicit
condition|?
name|implicit
else|:
literal|"void context"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TARGET_EXPR
case|:
comment|/* Don't bother with the temporary object returned from a function if 	 we don't use it and don't need to destroy it.  We'll still 	 allocate space for it in expand_call or declare_return_variable, 	 but we don't need to track it through all the tree phases.  */
if|if
condition|(
name|TARGET_EXPR_IMPLICIT_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|TARGET_EXPR_INITIAL
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|AGGR_INIT_EXPR
operator|&&
operator|!
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|{
name|tree
name|probe
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|probe
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|probe
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|probe
argument_list|)
condition|)
block|{
comment|/* [over.over] enumerates the places where we can take the address 	   of an overloaded function, and this is not one of them.  */
name|pedwarn
argument_list|(
literal|"%s cannot resolve address of overloaded function"
argument_list|,
name|implicit
condition|?
name|implicit
else|:
literal|"void cast"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|void_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|implicit
operator|&&
name|probe
operator|==
name|expr
operator|&&
name|is_overloaded_fn
argument_list|(
name|probe
argument_list|)
condition|)
block|{
comment|/* Only warn when there is no&.  */
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"%s is a reference, not call, to function %qE"
argument_list|,
name|implicit
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|implicit
operator|&&
name|warn_unused_value
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|expr
argument_list|)
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* The middle end does not warn about expressions that have 	     been explicitly cast to void, so we must do so here.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wunused_value
argument_list|,
literal|"%s has no effect"
argument_list|,
name|implicit
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|e
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|tree_code_class
name|class
decl_stmt|;
name|e
operator|=
name|expr
expr_stmt|;
comment|/* We might like to warn about (say) "(int) f()", as the 		 cast has no effect, but the compiler itself will 		 generate implicit conversions under some 		 circumstances.  (For example a block copy will be 		 turned into a call to "__builtin_memcpy", with a 		 conversion of the return value to an appropriate 		 type.)  So, to avoid false positives, we strip 		 conversions.  Do not use STRIP_NOPs because it will 		 not strip conversions to "void", as that is not a 		 mode-preserving conversion.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|e
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|tcc_comparison
operator|||
name|class
operator|==
name|tcc_unary
operator|||
operator|(
name|class
operator|==
name|tcc_binary
operator|&&
operator|!
operator|(
name|code
operator|==
name|MODIFY_EXPR
operator|||
name|code
operator|==
name|INIT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
operator|||
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wunused_value
argument_list|,
literal|"value computed is not used"
argument_list|)
expr_stmt|;
block|}
block|}
name|expr
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|void_zero_node
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Create an expression whose value is that of EXPR,    converted to type TYPE.  The TREE_TYPE of the value    is always TYPE.  This function implements all reasonable    conversions; callers should filter out those that are    not permitted by the language being compiled.     Most of this routine is from build_reinterpret_cast.     The backend cannot call cp_convert (what was convert) because    conversions to/from basetypes may involve memory references    (vbases) and adding or subtracting small values (multiple    inheritance), but it calls convert from the constant folding code    on subtrees of already built trees after it has ripped them apart.     Also, if we ever support range variables, we'll probably also have to    do a little bit more work.  */
end_comment

begin_function
name|tree
name|convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|intype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|intype
argument_list|)
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|CONV_OLD_CONVERT
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like cp_convert, except permit conversions to take place which    are not normally allowed due to access restrictions    (such as conversion from sub-type to private super-type).  */
end_comment

begin_function
name|tree
name|convert_force
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|convtype
parameter_list|)
block|{
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
operator|(
name|fold_if_not_in_template
argument_list|(
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|e
argument_list|,
name|CONV_C_CAST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_pointer_force
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
comment|/* From typeck.c convert_for_assignment */
if|if
condition|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|||
name|integer_zerop
argument_list|(
name|e
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* compatible pointer to member functions.  */
return|return
name|build_ptrmemfunc
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|e
argument_list|,
literal|1
argument_list|,
comment|/*c_cast_p=*/
literal|1
argument_list|)
return|;
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|e
argument_list|,
name|CONV_C_CAST
operator||
name|convtype
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an aggregate EXPR to type XTYPE.  If a conversion    exists, return the attempted conversion.  This may    return ERROR_MARK_NODE if the conversion is not    allowed (references private members, etc).    If no conversion exists, NULL_TREE is returned.     FIXME: Ambiguity checking is wrong.  Should choose one by the implicit    object parameter, or by the second standard conversion sequence if    that doesn't do it.  This will probably wait for an overloading rewrite.    (jason 8/9/95)  */
end_comment

begin_function
specifier|static
name|tree
name|build_type_conversion
parameter_list|(
name|tree
name|xtype
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
comment|/* C++: check to see if we can convert this aggregate type      into the required type.  */
return|return
name|build_user_type_conversion
argument_list|(
name|xtype
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert the given EXPR to one of a group of types suitable for use in an    expression.  DESIRES is a combination of various WANT_* flags (q.v.)    which indicates which types are suitable.  If COMPLAIN is true, complain    about ambiguity; otherwise, the caller will deal with it.  */
end_comment

begin_function
name|tree
name|build_expr_type_conversion
parameter_list|(
name|int
name|desires
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|conv
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|winner
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|null_node
operator|&&
operator|(
name|desires
operator|&
name|WANT_INT
operator|)
operator|&&
operator|!
operator|(
name|desires
operator|&
name|WANT_NULL
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wconversion
argument_list|,
literal|"converting NULL to non-pointer type"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
operator|(
name|desires
operator|&
name|WANT_NULL
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* else fall through...  */
case|case
name|BOOLEAN_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_INT
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_ENUM
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
case|case
name|REAL_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_FLOAT
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
case|case
name|POINTER_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_POINTER
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_POINTER
operator|)
condition|?
name|decay_conversion
argument_list|(
name|expr
argument_list|)
else|:
name|NULL_TREE
return|;
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
operator|(
name|desires
operator|&
name|WANT_VECTOR
operator|)
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_INT
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_ENUM
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
case|case
name|REAL_TYPE
case|:
return|return
operator|(
name|desires
operator|&
name|WANT_FLOAT
operator|)
condition|?
name|expr
else|:
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* The code for conversions from class type is currently only used for      delete expressions.  Other expressions are handled by build_new_op.  */
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|basetype
argument_list|,
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|conv
operator|=
name|lookup_conversions
argument_list|(
name|basetype
argument_list|)
init|;
name|conv
condition|;
name|conv
operator|=
name|TREE_CHAIN
argument_list|(
name|conv
argument_list|)
control|)
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
name|tree
name|candidate
decl_stmt|;
name|tree
name|cand
init|=
name|TREE_VALUE
argument_list|(
name|conv
argument_list|)
decl_stmt|;
if|if
condition|(
name|winner
operator|&&
name|winner
operator|==
name|cand
condition|)
continue|continue;
name|candidate
operator|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_INT
operator|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_ENUM
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_FLOAT
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_POINTER
operator|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
operator|(
name|desires
operator|&
name|WANT_VECTOR
operator|)
operator|==
literal|0
condition|)
break|break;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidate
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_INT
operator|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_ENUM
operator|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|win
operator|=
operator|(
name|desires
operator|&
name|WANT_FLOAT
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|win
condition|)
block|{
if|if
condition|(
name|winner
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous default type conversion from %qT"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  candidate conversions include %qD and %qD"
argument_list|,
name|winner
argument_list|,
name|cand
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
else|else
name|winner
operator|=
name|cand
expr_stmt|;
block|}
block|}
if|if
condition|(
name|winner
condition|)
block|{
name|tree
name|type
init|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|winner
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_user_type_conversion
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Implements integral promotion (4.1) and float->double promotion.  */
end_comment

begin_function
name|tree
name|type_promotes_to
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* bool always promotes to int (not unsigned), even if it's the same      size.  */
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
comment|/* Normally convert enums to int, but convert wide enums to something      wider.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|type
operator|==
name|wchar_type_node
condition|)
block|{
name|int
name|precision
init|=
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|totype
init|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|totype
argument_list|)
condition|)
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|totype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Retain unsignedness if really not getting bigger.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|double_type_node
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* The routines below this point are carefully written to conform to    the standard.  They use the same terminology, and follow the rules    closely.  Although they are used only in pt.c at the moment, they    should presumably be used everywhere in the future.  */
end_comment

begin_comment
comment|/* Attempt to perform qualification conversions on EXPR to convert it    to TYPE.  Return the resulting expression, or error_mark_node if    the conversion was impossible.  */
end_comment

begin_function
name|tree
name|perform_qualification_conversions
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|expr_type
decl_stmt|;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|expr_type
argument_list|)
condition|)
return|return
name|expr
return|;
elseif|else
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|comp_ptr_ttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr_type
argument_list|)
argument_list|)
condition|)
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|expr_type
argument_list|)
argument_list|)
operator|&&
name|comp_ptr_ttypes
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|expr_type
argument_list|)
argument_list|)
condition|)
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
end_function

end_unit

