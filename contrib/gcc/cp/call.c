begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to invoking methods and overloaded functions.    Copyright (C) 1987, 92-97, 1998, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) and    modified by Brendan Kehoe (brendan@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|int
name|inhibit_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|ctor_label
decl_stmt|,
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_new_method_call
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_field_call
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_scoped_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|tourney
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|joust
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|struct
name|z_candidate
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_ics
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_over_call
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_like
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|op_error
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_object_call
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|resolve_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_user_type_conversion_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_z_candidates
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_this
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|splice_viable
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|any_viable
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|unification_kind_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate_real
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|unification_kind_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_conv_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidates
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_complete
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_builtin_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_conv_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_function_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|implicit_conversion
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|standard_conversion
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|reference_binding
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|strip_top_quals
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|non_reference
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_conv
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_subseq
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_handle_ref_bind
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_handle_implicit_object
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_candidate
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|source_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_warning
name|PROTO
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_vfield_ref
parameter_list|(
name|datum
parameter_list|,
name|type
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a member of an object.  I.e., one that overloads    operator ()(), or is a pointer-to-function or pointer-to-method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_call
parameter_list|(
name|basetype_path
parameter_list|,
name|instance_ptr
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|instance_ptr
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|,
name|instance
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|ctor_identifier
operator|||
name|name
operator|==
name|dtor_identifier
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Speed up the common case.  */
if|if
condition|(
name|instance_ptr
operator|==
name|current_class_ptr
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|error_mark_node
operator|||
name|field
operator|==
name|NULL_TREE
condition|)
return|return
name|field
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* If it's a field, try overloading operator (), 	 or calling if the field is a pointer-to-function.  */
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_component_ref_1
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|parms
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|find_scoped_type
parameter_list|(
name|type
parameter_list|,
name|inner_name
parameter_list|,
name|inner_types
parameter_list|)
name|tree
name|type
decl_stmt|,
name|inner_name
decl_stmt|,
name|inner_types
decl_stmt|;
block|{
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* The TREE_PURPOSE of an enum tag (which becomes a member of the 	 enclosing class) is set to the name for the enum type.  So, if 	 inner_name is `bar', and we strike `baz' for `enum bar { baz }', 	 then this test will be true.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|inner_name
condition|)
block|{
if|if
condition|(
name|inner_types
operator|==
name|NULL_TREE
condition|)
return|return
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
return|;
return|return
name|resolve_scope_to_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
block|}
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a TYPE_DECL.  */
for|for
control|(
name|tags
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tags
condition|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tags
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|tags
argument_list|)
operator|==
name|inner_name
condition|)
block|{
comment|/* Code by raeburn.  */
if|if
condition|(
name|inner_types
operator|==
name|NULL_TREE
condition|)
return|return
name|tags
return|;
return|return
name|resolve_scope_to_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Resolve an expression NAME1::NAME2::...::NAMEn to    the name that names the above nested type.  INNER_TYPES    is a chain of nested type names (held together by SCOPE_REFs);    OUTER_TYPE is the type we know to enclose INNER_TYPES.    Returns NULL_TREE if there is an error.  */
end_comment

begin_function
name|tree
name|resolve_scope_to_name
parameter_list|(
name|outer_type
parameter_list|,
name|inner_stuff
parameter_list|)
name|tree
name|outer_type
decl_stmt|,
name|inner_stuff
decl_stmt|;
block|{
specifier|register
name|tree
name|tmp
decl_stmt|;
name|tree
name|inner_name
decl_stmt|,
name|inner_type
decl_stmt|;
if|if
condition|(
name|outer_type
operator|==
name|NULL_TREE
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We first try to look for a nesting in our current class context,          then try any enclosing classes.  */
name|tree
name|type
init|=
name|current_class_type
decl_stmt|;
while|while
condition|(
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|tree
name|rval
init|=
name|resolve_scope_to_name
argument_list|(
name|type
argument_list|,
name|inner_stuff
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
operator|!=
name|NULL_TREE
condition|)
return|return
name|rval
return|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_stuff
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|inner_name
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_stuff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_stuff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inner_name
operator|=
name|inner_stuff
expr_stmt|;
name|inner_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|outer_type
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|x
decl_stmt|;
comment|/* If we have something that's already a type by itself, 	 use that.  */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|inner_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|inner_type
condition|)
return|return
name|resolve_scope_to_name
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|inner_name
argument_list|)
argument_list|,
name|inner_type
argument_list|)
return|;
return|return
name|inner_name
return|;
block|}
name|x
operator|=
name|lookup_name
argument_list|(
name|inner_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|x
operator|=
name|lookup_namespace_name
argument_list|(
name|x
argument_list|,
name|inner_type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|outer_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Look for member classes or enums.  */
name|tmp
operator|=
name|find_scoped_type
argument_list|(
name|outer_type
argument_list|,
name|inner_name
argument_list|,
name|inner_type
argument_list|)
expr_stmt|;
comment|/* If it's not a type in this class, then go down into the      base classes and search there.  */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|TYPE_BINFO
argument_list|(
name|outer_type
argument_list|)
condition|)
block|{
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|outer_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|resolve_scope_to_name
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|inner_stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
block|}
name|tmp
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff the destructor name specified in NAME    (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many    forms...  */
end_comment

begin_function
name|int
name|check_dtor_name
parameter_list|(
name|basetype
parameter_list|,
name|name
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|name
decl_stmt|;
block|{
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Just accept something we've already complained about.  */
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
name|name
operator|=
name|basetype
expr_stmt|;
else|else
name|name
operator|=
name|get_type_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|980605
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.    This is how virtual function calls are avoided.  */
end_comment

begin_function
name|tree
name|build_scoped_method_call
parameter_list|(
name|exp
parameter_list|,
name|basetype
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|basetype
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
block|{
comment|/* Because this syntactic form does not allow      a pointer to a base class to be `stolen',      we need not protect the derived->base conversion      that happens here.            @@ But we do have to check access privileges later.  */
name|tree
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|type
init|=
name|get_aggr_from_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|name
operator|=
name|build_min_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|build_min_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|build_min_nt
argument_list|(
name|METHOD_CALL_EXPR
argument_list|,
name|name
argument_list|,
name|exp
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|binfo
operator|=
name|basetype
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check the destructor call syntax.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
comment|/* We can get here if someone writes their destructor call like 	 `obj.NS::~T()'; this isn't really a scoped method call, so hand 	 it off.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
if|if
condition|(
operator|!
name|check_dtor_name
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"qualified type `%T' does not match destructor name `~%T'"
argument_list|,
name|basetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Destructors can be "called" for simple types; see 5.2.4 and 12.4 Note 	 that explicit ~int is caught in the parser; this deals with typedefs 	 and template parms.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"type of `%E' does not match destructor type `%T' (type was `%T')"
argument_list|,
name|exp
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"base object `%E' of scoped method call is of non-aggregate type `%T'"
argument_list|,
name|exp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|binfo
operator|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|binfo
condition|)
name|error_not_base_type
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_scoped_ref
argument_list|(
name|exp
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* Call to a destructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Call to a method.  */
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* We want the address of a function or method.  We avoid creating a    pointer-to-member function.  */
end_comment

begin_function
name|tree
name|build_addr_func
parameter_list|(
name|function
parameter_list|)
name|tree
name|function
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
comment|/* We have to do these by hand to avoid real pointer to member      functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|addr
decl_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|function
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or function counts 	 as a constant */
if|if
condition|(
name|staticp
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|addr
expr_stmt|;
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
end_function

begin_comment
comment|/* Build a CALL_EXPR, we can handle FUNCTION_TYPEs, METHOD_TYPEs, or    POINTER_TYPE to those.  Note, pointer to member function types    (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */
end_comment

begin_function
name|tree
name|build_call
parameter_list|(
name|function
parameter_list|,
name|result_type
parameter_list|,
name|parms
parameter_list|)
name|tree
name|function
decl_stmt|,
name|result_type
decl_stmt|,
name|parms
decl_stmt|;
block|{
name|int
name|is_constructor
init|=
literal|0
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"unable to call pointer to member function here"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|is_constructor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|990125
argument_list|)
expr_stmt|;
comment|/* Don't pass empty class objects by value.  This is useful      for tags in STL, which are used to control overload resolution.      We don't need to handle other cases of copying empty classes.  */
if|if
condition|(
operator|!
name|decl
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
for|for
control|(
name|tmp
operator|=
name|parms
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|is_empty_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|function
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|function
argument_list|)
operator|=
name|is_constructor
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|result_type
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|function
return|;
block|}
end_function

begin_comment
comment|/* Build something of the form ptr->method (args)    or object.method (args).  This can also build    calls to constructors, and find friends.     Member functions always take their class variable    as a pointer.     INSTANCE is a class instance.     NAME is the name of the method desired, usually an IDENTIFIER_NODE.     PARMS help to figure out what that NAME really refers to.     BASETYPE_PATH, if non-NULL, contains a chain from the type of INSTANCE    down to the real instance type to use for access checking.  We need this    information to get protected accesses correct.  This parameter is used    by build_member_call.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     If this is all OK, calls build_function_call with the resolved    member function.     This function must also handle being called to perform    initialization, promotion/coercion of arguments, and    instantiation of default parameters.     Note that NAME may refer to an instance variable name.  If    `operator()()' is defined for the type of that field, then we return    that result.  */
end_comment

begin_function
name|tree
name|build_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|,
name|instance_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_build_method_call
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
operator|||
operator|(
name|instance
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* We need to process template parm names here so that tsubst catches 	 them properly.  Other type names can wait.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|get_aggr_from_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|name
operator|=
name|build_min_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|build_min_nt
argument_list|(
name|METHOD_CALL_EXPR
argument_list|,
name|name
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
name|parms
condition|)
name|error
argument_list|(
literal|"destructors take no parameters"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_dtor_name
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"destructor name `~%T' does not match type `%T' of expression"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|complete_type
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|instance
argument_list|)
return|;
name|instance
operator|=
name|default_conversion
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|build_new_method_call
argument_list|(
name|instance
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* New overloading code.  */
end_comment

begin_struct
struct|struct
name|z_candidate
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|convs
decl_stmt|;
name|tree
name|second_conv
decl_stmt|;
name|int
name|viable
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|tree
name|warnings
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IDENTITY_RANK
value|0
end_define

begin_define
define|#
directive|define
name|EXACT_RANK
value|1
end_define

begin_define
define|#
directive|define
name|PROMO_RANK
value|2
end_define

begin_define
define|#
directive|define
name|STD_RANK
value|3
end_define

begin_define
define|#
directive|define
name|PBOOL_RANK
value|4
end_define

begin_define
define|#
directive|define
name|USER_RANK
value|5
end_define

begin_define
define|#
directive|define
name|ELLIPSIS_RANK
value|6
end_define

begin_define
define|#
directive|define
name|BAD_RANK
value|7
end_define

begin_define
define|#
directive|define
name|ICS_RANK
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(ICS_BAD_FLAG (NODE) ? BAD_RANK   \    : ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK	\    : ICS_USER_FLAG (NODE) ? USER_RANK		\    : ICS_STD_RANK (NODE))
end_define

begin_define
define|#
directive|define
name|ICS_STD_RANK
parameter_list|(
name|NODE
parameter_list|)
value|TREE_COMPLEXITY (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_USER_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_0 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_ELLIPSIS_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_1 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_THIS_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_2 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_BAD_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_3 (NODE)
end_define

begin_define
define|#
directive|define
name|USER_CONV_CAND
parameter_list|(
name|NODE
parameter_list|)
define|\
value|((struct z_candidate *)WRAPPER_PTR (TREE_OPERAND (NODE, 1)))
end_define

begin_define
define|#
directive|define
name|USER_CONV_FN
parameter_list|(
name|NODE
parameter_list|)
value|(USER_CONV_CAND (NODE)->fn)
end_define

begin_function
name|int
name|null_ptr_cst_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|null_node
operator|||
operator|(
name|integer_zerop
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_conv
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|from
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|from
decl_stmt|;
block|{
name|tree
name|t
init|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|from
argument_list|)
decl_stmt|;
name|int
name|rank
init|=
name|ICS_STD_RANK
argument_list|(
name|from
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PTR_CONV
case|:
case|case
name|PMEM_CONV
case|:
case|case
name|BASE_CONV
case|:
case|case
name|STD_CONV
case|:
if|if
condition|(
name|rank
operator|<
name|STD_RANK
condition|)
name|rank
operator|=
name|STD_RANK
expr_stmt|;
break|break;
case|case
name|QUAL_CONV
case|:
if|if
condition|(
name|rank
operator|<
name|EXACT_RANK
condition|)
name|rank
operator|=
name|EXACT_RANK
expr_stmt|;
default|default:
break|break;
block|}
name|ICS_STD_RANK
argument_list|(
name|t
argument_list|)
operator|=
name|rank
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|t
argument_list|)
operator|=
name|ICS_USER_FLAG
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|non_reference
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|strip_top_quals
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|t
return|;
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the standard conversion path (see [conv]) from type FROM to type    TO, if any.  For proper handling of null pointer constants, you must    also pass the expression EXPR to convert from.  */
end_comment

begin_function
specifier|static
name|tree
name|standard_conversion
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|expr
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|fcode
decl_stmt|,
name|tcode
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|int
name|fromref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|fromref
operator|=
literal|1
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|strip_top_quals
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|=
name|strip_top_quals
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|to
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|tcode
operator|=
name|TREE_CODE
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|LVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcode
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|LVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fromref
operator|||
operator|(
name|expr
operator|&&
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|RVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|to
condition|)
return|return
name|conv
return|;
if|if
condition|(
operator|(
name|tcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
name|expr
operator|&&
name|null_ptr_cst_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|fcode
operator|==
name|POINTER_TYPE
condition|)
block|{
name|enum
name|tree_code
name|ufcode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|utcode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|utcode
operator|==
name|VOID_TYPE
operator|&&
name|ufcode
operator|!=
name|OFFSET_TYPE
operator|&&
name|ufcode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ufcode
operator|==
name|OFFSET_TYPE
operator|&&
name|utcode
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|tree
name|fbase
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tbase
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|fbase
argument_list|,
name|tbase
argument_list|)
operator|&&
operator|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|from
operator|=
name|build_offset_type
argument_list|(
name|tbase
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PMEM_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|from
operator|=
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|QUAL_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|&&
name|string_conv_p
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* converting from string constant to char *.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|QUAL_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptr_reasonably_similar
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|from
operator|=
name|to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|tree
name|fromfn
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tofn
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fbase
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tbase
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|tofn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|fbase
argument_list|,
name|tbase
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fromfn
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tofn
argument_list|)
argument_list|)
operator|||
operator|!
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|tofn
argument_list|)
argument_list|)
argument_list|)
operator|||
name|CP_TYPE_QUALS
argument_list|(
name|fbase
argument_list|)
operator|!=
name|CP_TYPE_QUALS
argument_list|(
name|tbase
argument_list|)
condition|)
return|return
literal|0
return|;
name|from
operator|=
name|cp_build_qualified_type
argument_list|(
name|tbase
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|fbase
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_cplus_method_type
argument_list|(
name|from
argument_list|,
name|TREE_TYPE
argument_list|(
name|fromfn
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PMEM_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|fcode
argument_list|)
operator|||
name|fcode
operator|==
name|REAL_TYPE
operator|||
name|fcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
operator|&&
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|<
name|PBOOL_RANK
operator|)
condition|)
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|PBOOL_RANK
expr_stmt|;
block|}
comment|/* We don't check for ENUMERAL_TYPE here because there are no standard      conversions to enum type.  */
elseif|else
if|if
condition|(
name|tcode
operator|==
name|INTEGER_TYPE
operator|||
name|tcode
operator|==
name|BOOLEAN_TYPE
operator|||
name|tcode
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|fcode
argument_list|)
operator|||
name|fcode
operator|==
name|REAL_TYPE
operator|)
condition|)
return|return
literal|0
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* Give this a better rank if it's a promotion.  */
if|if
condition|(
name|to
operator|==
name|type_promotes_to
argument_list|(
name|from
argument_list|)
operator|&&
name|ICS_STD_RANK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|PROMO_RANK
condition|)
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|PROMO_RANK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|to
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|from
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|RVALUE_CONV
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Returns the conversion path from type FROM to reference type TO for    purposes of reference binding.  For lvalue binding, either pass a    reference type to FROM or an lvalue expression to EXPR.     Currently does not distinguish in the generated trees between binding to    an lvalue and a temporary.  Should it?  */
end_comment

begin_function
specifier|static
name|tree
name|reference_binding
parameter_list|(
name|rto
parameter_list|,
name|rfrom
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|rto
decl_stmt|,
name|rfrom
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|conv
decl_stmt|;
name|int
name|lvalue
init|=
literal|1
decl_stmt|;
name|tree
name|to
init|=
name|TREE_TYPE
argument_list|(
name|rto
argument_list|)
decl_stmt|;
name|tree
name|from
init|=
name|rfrom
decl_stmt|;
name|int
name|related
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|expr
operator|||
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
name|lvalue
operator|=
literal|0
expr_stmt|;
name|related
operator|=
operator|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|)
operator|||
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|to
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|from
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|lvalue
operator|&&
name|related
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
else|else
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|STD_RANK
expr_stmt|;
block|}
block|}
else|else
name|conv
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|conv
condition|)
block|{
name|conv
operator|=
name|standard_conversion
argument_list|(
name|to
argument_list|,
name|rfrom
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* Bind directly to a base subobject of a class rvalue.  Do it              after building the conversion for proper handling of ICS_RANK.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BASE_CONV
condition|)
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conv
operator|&&
operator|(
operator|(
operator|!
operator|(
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|to
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NO_TEMP_BIND
operator|)
operator|==
literal|0
operator|)
operator|)
comment|/* If T1 is reference-related to T2, cv1 must be the same 		 cv-qualification as, or greater cv-qualification than, 		 cv2; otherwise, the program is ill-formed.  */
operator|||
operator|(
name|related
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|)
operator|)
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Returns the implicit conversion sequence (see [over.ics]) from type FROM    to type TO.  The optional expression EXPR may affect the conversion.    FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is    significant.  */
end_comment

begin_function
specifier|static
name|tree
name|implicit_conversion
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|conv
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|conv
operator|=
name|reference_binding
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|conv
operator|=
name|standard_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|non_reference
argument_list|(
name|from
argument_list|)
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|non_reference
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
operator|==
literal|0
condition|)
block|{
name|cand
operator|=
name|build_user_type_conversion_1
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
name|conv
operator|=
name|cand
operator|->
name|second_conv
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|conv
operator|||
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NO_TEMP_BIND
operator|)
operator|==
literal|0
condition|)
block|{
name|cand
operator|=
name|build_user_type_conversion_1
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
if|if
condition|(
operator|!
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|conv
operator|||
operator|(
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|>
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|to
argument_list|,
name|cand
operator|->
name|second_conv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to the list of candidates.  Used by the add_*_candidate    functions.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fn
parameter_list|,
name|convs
parameter_list|,
name|viable
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|convs
decl_stmt|;
name|int
name|viable
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
name|scratchalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|z_candidate
argument_list|)
argument_list|)
decl_stmt|;
name|cand
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|cand
operator|->
name|convs
operator|=
name|convs
expr_stmt|;
name|cand
operator|->
name|second_conv
operator|=
name|NULL_TREE
expr_stmt|;
name|cand
operator|->
name|viable
operator|=
name|viable
expr_stmt|;
name|cand
operator|->
name|basetype_path
operator|=
name|NULL_TREE
expr_stmt|;
name|cand
operator|->
name|template
operator|=
name|NULL_TREE
expr_stmt|;
name|cand
operator|->
name|warnings
operator|=
name|NULL_TREE
expr_stmt|;
name|cand
operator|->
name|next
operator|=
name|candidates
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_comment
comment|/* Create an overload candidate for the function or method FN called with    the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on    to implicit_conversion.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_function_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fn
parameter_list|,
name|arglist
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|parmlist
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|tree
name|convs
decl_stmt|;
name|tree
name|parmnode
decl_stmt|,
name|argnode
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|;
comment|/* The `this', `in_chrg', and `vlist' arguments to constructors are      not considered in overload resolution.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_HAS_VLIST
operator|)
operator|&&
name|DECL_CONSTRUCTOR_FOR_PVBASE_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_VLIST
operator|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_FOR_PVBASE_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Ok */
empty_stmt|;
else|else
block|{
comment|/* The ctor expects a vlist and the arguments don't have 	     one, or vice versa, so fn is not even a candidate, since 	     the corresponding ctor would be the candidate.  */
return|return
name|candidates
return|;
block|}
block|}
name|len
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|convs
operator|=
name|make_scratch_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 13.3.2 - Viable functions [over.match.viable]      First, to be a viable function, a candidate function shall have enough      parameters to agree in number with the arguments in the list.       We need to check this first; otherwise, checking the ICSes might cause      us to produce an ill-formed template instantiation.  */
name|parmnode
operator|=
name|parmlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|parmnode
operator|==
name|NULL_TREE
operator|||
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
operator|&&
name|parmnode
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
comment|/* Make sure there are default args for the rest of the parms.  */
else|else
for|for
control|(
init|;
name|parmnode
operator|&&
name|parmnode
operator|!=
name|void_list_node
condition|;
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|parmnode
argument_list|)
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|viable
condition|)
goto|goto
name|out
goto|;
comment|/* Second, for F to be a viable function, there shall exist for each      argument an implicit conversion sequence that converts that argument      to the corresponding parameter of F.  */
name|parmnode
operator|=
name|parmlist
expr_stmt|;
name|argnode
operator|=
name|arglist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|argnode
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
if|if
condition|(
name|parmnode
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parmnode
argument_list|)
decl_stmt|;
comment|/* [over.match.funcs] For conversion functions, the function is 	     considered to be a member of the class of the implicit object 	     argument for the purpose of defining the type of the implicit 	     object parameter.  	     Since build_over_call ignores the ICS for the `this' parameter, 	     we can just change the parm type.  */
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|parmtype
operator|=
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|,
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|build_pointer_type
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|implicit_conversion
argument_list|(
name|parmtype
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|ICS_THIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|parmnode
condition|)
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
name|argnode
operator|=
name|TREE_CHAIN
argument_list|(
name|argnode
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|convs
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an overload candidate for the conversion function FN which will    be invoked for expression OBJ, producing a pointer-to-function which    will in turn be called with the argument list ARGLIST, and add it to    CANDIDATES.  FLAGS is passed on to implicit_conversion.     Actually, we don't really care about FN; we care about the type it    converts to.  There may be multiple conversion functions that will    convert to that type, and we rely on build_user_type_conversion_1 to    choose the best one; so when we create our candidate, we record the type    instead of the function.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_conv_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fn
parameter_list|,
name|obj
parameter_list|,
name|arglist
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|obj
decl_stmt|,
name|arglist
decl_stmt|;
block|{
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parmlist
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|list_length
argument_list|(
name|arglist
argument_list|)
operator|+
literal|1
decl_stmt|;
name|tree
name|convs
init|=
name|make_scratch_vec
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|tree
name|parmnode
init|=
name|parmlist
decl_stmt|;
name|tree
name|argnode
init|=
name|arglist
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_NORMAL
decl_stmt|;
comment|/* Don't bother looking up the same type twice.  */
if|if
condition|(
name|candidates
operator|&&
name|candidates
operator|->
name|fn
operator|==
name|totype
condition|)
return|return
name|candidates
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|i
operator|==
literal|0
condition|?
name|obj
else|:
name|TREE_VALUE
argument_list|(
name|argnode
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|t
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
elseif|else
if|if
condition|(
name|parmnode
condition|)
name|t
operator|=
name|implicit_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmnode
argument_list|)
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|parmnode
condition|)
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
name|argnode
operator|=
name|TREE_CHAIN
argument_list|(
name|argnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|parmnode
operator|&&
name|parmnode
operator|!=
name|void_list_node
condition|;
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|parmnode
argument_list|)
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|totype
argument_list|,
name|convs
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_builtin_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fnname
parameter_list|,
name|type1
parameter_list|,
name|type2
parameter_list|,
name|args
parameter_list|,
name|argtypes
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fnname
decl_stmt|,
name|type1
decl_stmt|,
name|type2
decl_stmt|,
decl|*
name|args
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|t
decl_stmt|,
name|convs
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|;
name|types
index|[
literal|0
index|]
operator|=
name|type1
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
name|type2
expr_stmt|;
name|convs
operator|=
name|make_scratch_vec
argument_list|(
name|args
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|args
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
break|break;
name|t
operator|=
name|implicit_conversion
argument_list|(
name|types
index|[
name|i
index|]
argument_list|,
name|argtypes
index|[
name|i
index|]
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
comment|/* We need something for printing the candidate.  */
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|types
index|[
name|i
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* For COND_EXPR we rearranged the arguments; undo that now.  */
if|if
condition|(
name|args
index|[
literal|2
index|]
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|2
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|argtypes
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
else|else
name|viable
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|convs
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|is_complete
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Create any builtin operator overload candidates for the operator in    question given the converted operand types TYPE1 and TYPE2.  The other    args are passed through from add_builtin_candidates to    build_builtin_candidate.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidate
parameter_list|(
name|candidates
parameter_list|,
name|code
parameter_list|,
name|code2
parameter_list|,
name|fnname
parameter_list|,
name|type1
parameter_list|,
name|type2
parameter_list|,
name|args
parameter_list|,
name|argtypes
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|,
name|code2
decl_stmt|;
name|tree
name|fnname
decl_stmt|,
name|type1
decl_stmt|,
name|type2
decl_stmt|,
decl|*
name|args
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|args
index|[
literal|1
index|]
operator|=
name|integer_zero_node
expr_stmt|;
name|type2
operator|=
name|integer_type_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,      and  VQ  is  either  volatile or empty, there exist candidate operator      functions of the form 	     VQ T&   operator++(VQ T&); 	     T       operator++(VQ T&, int);    5 For every pair T, VQ), where T is an enumeration type or an arithmetic      type  other than bool, and VQ is either volatile or empty, there exist      candidate operator functions of the form 	     VQ T&   operator--(VQ T&); 	     T       operator--(VQ T&, int);    6 For every pair T, VQ), where T is  a  cv-qualified  or  cv-unqualified      complete  object type, and VQ is either volatile or empty, there exist      candidate operator functions of the form 	     T*VQ&   operator++(T*VQ&); 	     T*VQ&   operator--(T*VQ&); 	     T*      operator++(T*VQ&, int); 	     T*      operator--(T*VQ&, int);  */
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|candidates
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|)
operator|||
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
comment|/* 7 For every cv-qualified or cv-unqualified complete object type T, there      exist candidate operator functions of the form  	     T&      operator*(T*);     8 For every function type T, there exist candidate operator functions of      the form 	     T&      operator*(T*);  */
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 9 For every type T, there exist candidate operator functions of the form 	     T*      operator+(T*);     10For  every  promoted arithmetic type T, there exist candidate operator      functions of the form 	     T       operator+(T); 	     T       operator-(T);  */
case|case
name|CONVERT_EXPR
case|:
comment|/* unary + */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 11For every promoted integral type T,  there  exist  candidate  operator      functions of the form 	     T       operator~(T);  */
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1      is the same type as C2 or is a derived class of C2, T  is  a  complete      object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,      there exist candidate operator functions of the form 	     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);      where CV12 is the union of CV1 and CV2.  */
case|case
name|MEMBER_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
block|{
name|tree
name|c1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|tree
name|c2
init|=
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
condition|?
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
argument_list|)
else|:
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|c1
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|&&
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|is_complete
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
return|return
name|candidates
return|;
comment|/* 13For every pair of promoted arithmetic types L and R, there exist  can-      didate operator functions of the form 	     LR      operator*(L, R); 	     LR      operator/(L, R); 	     LR      operator+(L, R); 	     LR      operator-(L, R); 	     bool    operator<(L, R); 	     bool    operator>(L, R); 	     bool    operator<=(L, R); 	     bool    operator>=(L, R); 	     bool    operator==(L, R); 	     bool    operator!=(L, R);      where  LR  is  the  result of the usual arithmetic conversions between      types L and R.     14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-      unqualified  complete  object  type and I is a promoted integral type,      there exist candidate operator functions of the form 	     T*      operator+(T*, I); 	     T&      operator[](T*, I); 	     T*      operator-(T*, I); 	     T*      operator+(I, T*); 	     T&      operator[](I, T*);     15For every T, where T is a pointer to complete object type, there exist      candidate operator functions of the form112) 	     ptrdiff_t operator-(T, T);     16For  every pointer type T, there exist candidate operator functions of      the form 	     bool    operator<(T, T); 	     bool    operator>(T, T); 	     bool    operator<=(T, T); 	     bool    operator>=(T, T); 	     bool    operator==(T, T); 	     bool    operator!=(T, T);     17For every pointer to member type T,  there  exist  candidate  operator      functions of the form 	     bool    operator==(T, T); 	     bool    operator!=(T, T);  */
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
comment|/* 18For  every pair of promoted integral types L and R, there exist candi-      date operator functions of the form 	     LR      operator%(L, R); 	     LR      operator&(L, R); 	     LR      operator^(L, R); 	     LR      operator|(L, R); 	     L       operator<<(L, R); 	     L       operator>>(L, R);      where LR is the result of the  usual  arithmetic  conversions  between      types L and R.  */
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration      type, VQ is either volatile or empty, and R is a  promoted  arithmetic      type, there exist candidate operator functions of the form 	     VQ L&   operator=(VQ L&, R); 	     VQ L&   operator*=(VQ L&, R); 	     VQ L&   operator/=(VQ L&, R); 	     VQ L&   operator+=(VQ L&, R); 	     VQ L&   operator-=(VQ L&, R);     20For  every  pair T, VQ), where T is any type and VQ is either volatile      or empty, there exist candidate operator functions of the form 	     T*VQ&   operator=(T*VQ&, T*);     21For every pair T, VQ), where T is a pointer to member type and  VQ  is      either  volatile or empty, there exist candidate operator functions of      the form 	     VQ T&   operator=(VQ T&, T);     22For every triple  T,  VQ,  I),  where  T  is  a  cv-qualified  or  cv-      unqualified  complete object type, VQ is either volatile or empty, and      I is a promoted integral type, there exist  candidate  operator  func-      tions of the form 	     T*VQ&   operator+=(T*VQ&, I); 	     T*VQ&   operator-=(T*VQ&, I);     23For  every  triple  L,  VQ,  R), where L is an integral or enumeration      type, VQ is either volatile or empty, and R  is  a  promoted  integral      type, there exist candidate operator functions of the form  	     VQ L&   operator%=(VQ L&, R); 	     VQ L&   operator<<=(VQ L&, R); 	     VQ L&   operator>>=(VQ L&, R); 	     VQ L&   operator&=(VQ L&, R); 	     VQ L&   operator^=(VQ L&, R); 	     VQ L&   operator|=(VQ L&, R);  */
case|case
name|MODIFY_EXPR
case|:
switch|switch
condition|(
name|code2
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|367
argument_list|)
expr_stmt|;
block|}
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
comment|/* Kludge around broken overloading rules whereby 	 bool ? const char& : enum is ambiguous 	 (between int and const char&).  */
name|flags
operator||=
name|LOOKUP_NO_TEMP_BIND
expr_stmt|;
comment|/* Extension: Support ?: of enumeral type.  Hopefully this will not          be an extension for long.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|type1
operator|==
name|type2
condition|)
break|break;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|candidates
return|;
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|candidates
return|;
if|if
condition|(
operator|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|367
argument_list|)
expr_stmt|;
block|}
comment|/* If we're dealing with two pointer types, we need candidates      for both of them.  */
if|if
condition|(
name|type2
operator|&&
name|type1
operator|!=
name|type2
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|)
condition|)
block|{
name|candidates
operator|=
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type1
argument_list|,
name|type1
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type2
argument_list|,
name|type2
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
block|}
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_function
name|tree
name|type_decays_to
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* There are three conditions of builtin candidates:     1) bool-taking candidates.  These are the same regardless of the input.    2) pointer-pair taking candidates.  These are generated for each type       one of the input types converts to.    3) arithmetic candidates.  According to the WP, we should generate       all of these, but I'm trying not to... */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidates
parameter_list|(
name|candidates
parameter_list|,
name|code
parameter_list|,
name|code2
parameter_list|,
name|fnname
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|,
name|code2
decl_stmt|;
name|tree
name|fnname
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ref1
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|argtypes
index|[
literal|3
index|]
decl_stmt|,
name|types
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|argtypes
index|[
name|i
index|]
operator|=
name|lvalue_type
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|argtypes
index|[
name|i
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,      and  VQ  is  either  volatile or empty, there exist candidate operator      functions of the form 		 VQ T&   operator++(VQ T&);  */
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
name|ref1
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 24There also exist candidate operator functions of the form 	     bool    operator!(bool); 	     bool    operator&&(bool, bool); 	     bool    operator||(bool, bool);  */
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|boolean_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|boolean_type_node
argument_list|,
name|boolean_type_node
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|candidates
return|;
default|default:
name|ref1
operator|=
literal|0
expr_stmt|;
block|}
name|types
index|[
literal|0
index|]
operator|=
name|types
index|[
literal|1
index|]
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|tree
name|convs
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|code
operator|==
name|MODIFY_EXPR
operator|&&
name|code2
operator|==
name|NOP_EXPR
condition|)
return|return
name|candidates
return|;
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|convs
condition|)
return|return
name|candidates
return|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ref1
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
name|ref1
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|value_member
argument_list|(
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|real_lvalue_p
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
name|ref1
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|types
index|[
name|i
index|]
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|types
index|[
literal|0
index|]
condition|;
name|types
index|[
literal|0
index|]
operator|=
name|TREE_CHAIN
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
control|)
block|{
if|if
condition|(
name|types
index|[
literal|1
index|]
condition|)
for|for
control|(
name|type
operator|=
name|types
index|[
literal|1
index|]
init|;
name|type
condition|;
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
name|candidates
operator|=
name|add_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|TREE_VALUE
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|candidates
operator|=
name|add_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|TREE_VALUE
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|candidates
return|;
block|}
end_block

begin_comment
comment|/* If TMPL can be successfully instantiated as indicated by    EXPLICIT_TARGS and ARGLIST, adds the instantiation to CANDIDATES.     TMPL is the template.  EXPLICIT_TARGS are any explicit template    arguments.  ARGLIST is the arguments provided at the call-site.    The RETURN_TYPE is the desired type for conversion operators.  If    OBJ is NULL_TREE, FLAGS are as for add_function_candidate.  If an    OBJ is supplied, FLAGS are ignored, and OBJ is as for    add_conv_candidate.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate_real
parameter_list|(
name|candidates
parameter_list|,
name|tmpl
parameter_list|,
name|explicit_targs
parameter_list|,
name|arglist
parameter_list|,
name|return_type
parameter_list|,
name|flags
parameter_list|,
name|obj
parameter_list|,
name|strict
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|arglist
decl_stmt|,
name|return_type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|obj
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_scratch_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|i
operator|=
name|fn_type_unification
argument_list|(
name|tmpl
argument_list|,
name|explicit_targs
argument_list|,
name|targs
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
name|strict
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|candidates
return|;
name|fn
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|candidates
return|;
if|if
condition|(
name|obj
operator|!=
name|NULL_TREE
condition|)
comment|/* Aha, this is a conversion function.  */
name|cand
operator|=
name|add_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
else|else
name|cand
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
operator|!=
name|tmpl
condition|)
comment|/* This situation can occur if a member template of a template        class is specialized.  Then, instantiate_template might return        an instantiation of the specialization, in which case the        DECL_TI_TEMPLATE field will point at the original        specialization.  For example:  	 template<class T> struct S { template<class U> void f(U); 				       template<> void f(int) {}; }; 	 S<double> sd; 	 sd.f(3);         Here, TMPL will be template<class U> S<double>::f(U).        And, instantiate template will give us the specialization        template<> S<double>::f(int).  But, the DECL_TI_TEMPLATE field        for this will point at template<class T> template<> S<T>::f(int),        so that we can find the definition.  For the purposes of        overload resolution, however, we want the original TMPL.  */
name|cand
operator|->
name|template
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|cand
operator|->
name|template
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate
parameter_list|(
name|candidates
parameter_list|,
name|tmpl
parameter_list|,
name|explicit_targs
parameter_list|,
name|arglist
parameter_list|,
name|return_type
parameter_list|,
name|flags
parameter_list|,
name|strict
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|arglist
decl_stmt|,
name|return_type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
block|{
return|return
name|add_template_candidate_real
argument_list|(
name|candidates
argument_list|,
name|tmpl
argument_list|,
name|explicit_targs
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_conv_candidate
parameter_list|(
name|candidates
parameter_list|,
name|tmpl
parameter_list|,
name|obj
parameter_list|,
name|arglist
parameter_list|,
name|return_type
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|obj
decl_stmt|,
name|arglist
decl_stmt|,
name|return_type
decl_stmt|;
block|{
return|return
name|add_template_candidate_real
argument_list|(
name|candidates
argument_list|,
name|tmpl
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|DEDUCE_CONV
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|any_viable
parameter_list|(
name|cands
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cands
decl_stmt|;
block|{
for|for
control|(
init|;
name|cands
condition|;
name|cands
operator|=
name|cands
operator|->
name|next
control|)
if|if
condition|(
name|pedantic
condition|?
name|cands
operator|->
name|viable
operator|==
literal|1
else|:
name|cands
operator|->
name|viable
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|splice_viable
parameter_list|(
name|cands
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cands
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
modifier|*
name|p
init|=
operator|&
name|cands
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|pedantic
condition|?
operator|(
operator|*
name|p
operator|)
operator|->
name|viable
operator|==
literal|1
else|:
operator|(
operator|*
name|p
operator|)
operator|->
name|viable
condition|)
name|p
operator|=
operator|&
operator|(
operator|(
operator|*
name|p
operator|)
operator|->
name|next
operator|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
name|cands
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_this
parameter_list|(
name|obj
parameter_list|)
name|tree
name|obj
decl_stmt|;
block|{
comment|/* Fix this to work on non-lvalues.  */
if|if
condition|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
condition|)
return|return
name|obj
return|;
else|else
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_z_candidates
parameter_list|(
name|candidates
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
for|for
control|(
init|;
name|candidates
condition|;
name|candidates
operator|=
name|candidates
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|candidates
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|candidates
operator|->
name|fn
operator|==
name|ansi_opname
index|[
name|COND_EXPR
index|]
condition|)
name|cp_error
argument_list|(
literal|"%s %D(%T, %T, %T)<builtin>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|candidates
operator|->
name|convs
argument_list|)
operator|==
literal|2
condition|)
name|cp_error
argument_list|(
literal|"%s %D(%T, %T)<builtin>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"%s %D(%T)<builtin>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|candidates
operator|->
name|fn
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"%s %T<conversion>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"%s %+#D%s"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|candidates
operator|->
name|viable
operator|==
operator|-
literal|1
condition|?
literal|"<near match>"
else|:
literal|""
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the best overload candidate to perform the requested    conversion.  This function is used for three the overloading situations    described in [over.match.copy], [over.match.conv], and [over.match.ref].    If TOTYPE is a REFERENCE_TYPE, we're trying to find an lvalue binding as    per [dcl.init.ref], so we ignore temporary bindings.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_user_type_conversion_1
parameter_list|(
name|totype
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|totype
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fromtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|ctors
init|=
name|NULL_TREE
decl_stmt|,
name|convs
init|=
name|NULL_TREE
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
condition|)
name|ctors
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|ctor_identifier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|fromtype
argument_list|)
operator|&&
operator|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
operator|||
operator|!
name|DERIVED_FROM_P
argument_list|(
name|totype
argument_list|,
name|fromtype
argument_list|)
operator|)
condition|)
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|fromtype
argument_list|)
expr_stmt|;
name|candidates
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|LOOKUP_NO_CONVERSION
expr_stmt|;
if|if
condition|(
name|ctors
condition|)
block|{
name|tree
name|t
init|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|totype
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|totype
argument_list|)
operator|&&
operator|!
name|flag_vtable_thunks_compat
condition|)
block|{
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vlist_zero_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_VLIST
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|totype
argument_list|)
condition|)
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ctors
operator|=
name|TREE_VALUE
argument_list|(
name|ctors
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|ctors
condition|;
name|ctors
operator|=
name|OVL_NEXT
argument_list|(
name|ctors
argument_list|)
control|)
block|{
name|tree
name|ctor
init|=
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NONCONVERTING_P
argument_list|(
name|ctor
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ctor
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|ctor
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|ctor
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
block|{
name|candidates
operator|->
name|second_conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|totype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|candidates
operator|->
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|convs
condition|)
name|args
operator|=
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|int
name|convflags
init|=
name|LOOKUP_NO_CONVERSION
decl_stmt|;
name|tree
name|ics
decl_stmt|;
comment|/* If we are called to convert to a reference type, we are trying to 	 find an lvalue binding, so don't even consider temporaries.  If 	 we don't find an lvalue binding, the caller will try again to 	 look for a temporary binding.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|convflags
operator||=
name|LOOKUP_NO_TEMP_BIND
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
name|ics
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|convflags
argument_list|)
expr_stmt|;
else|else
comment|/* We can't compute this yet.  */
name|ics
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|ics
operator|&&
name|ICS_BAD_FLAG
argument_list|(
name|ics
argument_list|)
condition|)
comment|/* ignore the near match.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|ics
condition|)
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|old_candidates
init|=
name|candidates
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|totype
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CONV
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|!=
name|old_candidates
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|ics
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|convflags
argument_list|)
expr_stmt|;
name|candidates
operator|->
name|second_conv
operator|=
name|ics
expr_stmt|;
name|candidates
operator|->
name|basetype_path
operator|=
name|TREE_PURPOSE
argument_list|(
name|convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ics
operator|==
name|NULL_TREE
condition|)
name|candidates
operator|->
name|viable
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|candidates
operator|->
name|viable
operator|==
literal|1
operator|&&
name|ICS_BAD_FLAG
argument_list|(
name|ics
argument_list|)
condition|)
name|candidates
operator|->
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (flags& LOOKUP_COMPLAIN) 	{ 	  if (candidates&& ! candidates->next)
comment|/* say why this one won't work or try to be loose */
block|; 	  else 	    cp_error ("no viable candidates"); 	}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error
argument_list|(
literal|"conversion from `%T' to `%T' is ambiguous"
argument_list|,
name|fromtype
argument_list|,
name|totype
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
name|cand
operator|=
name|candidates
expr_stmt|;
comment|/* any one will do */
name|cand
operator|->
name|second_conv
operator|=
name|build1
argument_list|(
name|AMBIG_CONV
argument_list|,
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cand
return|;
block|}
for|for
control|(
name|p
operator|=
operator|&
operator|(
name|cand
operator|->
name|second_conv
operator|)
init|;
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|;
control|)
name|p
operator|=
operator|&
operator|(
name|TREE_OPERAND
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* Pedantically, normal function declarations are never considered      to refer to template instantiations, so we only do this with      -fguiding-decls.  */
if|if
condition|(
name|flag_guiding_decls
operator|&&
name|templates
operator|&&
operator|!
name|cand
operator|->
name|template
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|add_maybe_template
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|build
argument_list|(
name|USER_CONV
argument_list|,
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
condition|?
name|totype
else|:
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|,
name|expr
argument_list|,
name|build_expr_ptr_wrapper
argument_list|(
name|cand
argument_list|)
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|viable
operator|==
operator|-
literal|1
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_function
name|tree
name|build_user_type_conversion
parameter_list|(
name|totype
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|totype
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|build_user_type_conversion_1
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
name|error_mark_node
return|;
return|return
name|convert_from_reference
argument_list|(
name|convert_like
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Do any initial processing on the arguments to a function call.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|args
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|resolve_offset_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_function
name|tree
name|build_new_function_call
parameter_list|(
name|fn
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|template_only
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|t1
operator|=
name|fn
init|;
name|t1
condition|;
name|t1
operator|=
name|OVL_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|OVL_FUNCTION
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|old_candidates
init|=
name|candidates
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|explicit_targs
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|template_only
condition|)
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|!=
name|old_candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
if|if
condition|(
name|candidates
operator|&&
operator|!
name|candidates
operator|->
name|next
condition|)
return|return
name|build_function_call
argument_list|(
name|candidates
operator|->
name|fn
argument_list|,
name|args
argument_list|)
return|;
name|cp_error
argument_list|(
literal|"no matching function for call to `%D (%A)'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"call of overloaded `%D (%A)' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Pedantically, normal function declarations are never considered 	 to refer to template instantiations, so we only do this with 	 -fguiding-decls.  */
if|if
condition|(
name|flag_guiding_decls
operator|&&
name|templates
operator|&&
operator|!
name|cand
operator|->
name|template
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
condition|)
name|add_maybe_template
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* This is not really overloaded. */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_object_call
parameter_list|(
name|obj
parameter_list|,
name|args
parameter_list|)
name|tree
name|obj
decl_stmt|,
name|args
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|convs
decl_stmt|,
name|mem_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* It's no good looking for an overloaded operator() on a 	 pointer-to-member-function.  */
name|cp_error
argument_list|(
literal|"pointer-to-member function %E cannot be called"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"without an object; consider using .* or ->*"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|ansi_opname
index|[
name|CALL_EXPR
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|base
init|=
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|mem_args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|mem_args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|mem_args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|base
expr_stmt|;
block|}
block|}
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|candidates
operator|=
name|add_template_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|totype
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|TREE_PURPOSE
argument_list|(
name|convs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"no match for call to `(%T) (%A)'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"call of `(%T) (%A)' is ambiguous"
argument_list|,
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Since cand->fn will be a type, not a function, for a conversion      function, we must be careful not to unconditionally look at      DECL_NAME here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|ansi_opname
index|[
name|CALL_EXPR
index|]
condition|)
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|mem_args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
name|obj
operator|=
name|convert_like
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|)
expr_stmt|;
comment|/* FIXME */
return|return
name|build_function_call
argument_list|(
name|obj
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|op_error
parameter_list|(
name|code
parameter_list|,
name|code2
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|problem
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|,
name|code2
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
specifier|const
name|char
modifier|*
name|problem
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
operator|(
name|code
operator|==
name|MODIFY_EXPR
condition|?
name|assignop_tab
index|[
name|code2
index|]
else|:
name|opname_tab
index|[
name|code
index|]
operator|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|cp_error
argument_list|(
literal|"%s for `%T ? %T : %T'"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|error_type
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|error_type
argument_list|(
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|cp_error
argument_list|(
literal|"%s for `%T%s'"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|opname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|cp_error
argument_list|(
literal|"%s for `%T[%T]'"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|error_type
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arg2
condition|)
name|cp_error
argument_list|(
literal|"%s for `%T %s %T'"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|opname
argument_list|,
name|error_type
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"%s for `%s%T'"
argument_list|,
name|problem
argument_list|,
name|opname
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|build_new_op
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|mem_arglist
init|=
name|NULL_TREE
decl_stmt|,
name|arglist
decl_stmt|,
name|fnname
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|NOP_EXPR
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* This can happen if a template takes all non-type parameters, e.g.      undeclared_template<1, 5, 72>a;  */
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' must be declared before use"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|NULL_TREE
expr_stmt|;
name|fnname
operator|=
name|ansi_assopname
index|[
name|code2
index|]
expr_stmt|;
block|}
else|else
name|fnname
operator|=
name|ansi_opname
index|[
name|code
index|]
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
case|case
name|VEC_NEW_EXPR
case|:
case|case
name|VEC_DELETE_EXPR
case|:
case|case
name|DELETE_EXPR
case|:
comment|/* Use build_op_new_call and build_op_delete_call instead. */
name|my_friendly_abort
argument_list|(
literal|981018
argument_list|)
expr_stmt|;
case|case
name|CALL_EXPR
case|:
return|return
name|build_object_call
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* The comma operator can have void args.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg1
operator|=
name|resolve_offset_ref
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg2
operator|=
name|resolve_offset_ref
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
operator|&&
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg3
operator|=
name|resolve_offset_ref
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|arg2
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|builtin
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|arg2
operator|||
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|builtin
goto|;
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
condition|)
name|arg2
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|arg2
operator|&&
name|arg3
condition|)
name|arglist
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|,
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg2
condition|)
name|arglist
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arglist
operator|=
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|fns
operator|=
name|lookup_function_nonclass
argument_list|(
name|fnname
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|&&
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|fnname
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|fns
return|;
block|}
else|else
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|basetype
init|=
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|mem_arglist
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|this_arglist
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|this_arglist
operator|=
name|mem_arglist
expr_stmt|;
else|else
name|this_arglist
operator|=
name|arglist
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* A member template. */
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|this_arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|fnname
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|this_arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|basetype
expr_stmt|;
block|}
block|}
block|{
name|tree
name|args
index|[
literal|3
index|]
decl_stmt|;
comment|/* Rearrange the arguments for ?: so that add_builtin_candidate only has        to know about two args; a builtin candidate will always have a first        parameter of type bool.  We'll handle that in        build_builtin_candidate.  */
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|candidates
operator|=
name|add_builtin_candidates
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Look for an `operator++ (int)'.  If they didn't have 	     one, then we fall back to the old way of doing things.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|cp_pedwarn
argument_list|(
literal|"no `%D (int)' declared for postfix `%s', trying prefix operator instead"
argument_list|,
name|fnname
argument_list|,
name|opname_tab
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|code
operator|=
name|PREINCREMENT_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|PREDECREMENT_EXPR
expr_stmt|;
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|flags
argument_list|,
name|arg1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* The caller will deal with these.  */
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|NULL_TREE
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|op_error
argument_list|(
name|code
argument_list|,
name|code2
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|op_error
argument_list|(
name|code
argument_list|,
name|code2
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"ambiguous overload"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|extern
name|int
name|warn_synth
decl_stmt|;
if|if
condition|(
name|warn_synth
operator|&&
name|fnname
operator|==
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|candidates
operator|->
name|next
operator|&&
operator|!
name|candidates
operator|->
name|next
operator|->
name|next
condition|)
block|{
name|cp_warning
argument_list|(
literal|"using synthesized `%#D' for copy assignment"
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  where cfront would use `%#D'"
argument_list|,
name|cand
operator|==
name|candidates
condition|?
name|candidates
operator|->
name|next
operator|->
name|fn
else|:
name|candidates
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Pedantically, normal function declarations are never considered 	 to refer to template instantiations, so we only do this with 	 -fguiding-decls.  */
if|if
condition|(
name|flag_guiding_decls
operator|&&
name|templates
operator|&&
operator|!
name|cand
operator|->
name|template
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|add_maybe_template
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|mem_arglist
else|:
name|arglist
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* Check for comparison of different enum types.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"comparison between `%#T' and `%#T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* We need to strip any leading REF_BIND so that bitfields don't cause      errors.  This should not remove any important conversions, because      builtins don't apply to class objects directly.  */
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
block|{
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg3
condition|)
block|{
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
name|builtin
label|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
return|return
name|build_modify_expr
argument_list|(
name|arg1
argument_list|,
name|code2
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
literal|"unary *"
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build_binary_op_nodefault
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|code
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|candidates
operator|!=
literal|0
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
return|return
name|build_array_ref
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
return|;
case|case
name|MEMBER_REF
case|:
return|return
name|build_m_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|arg2
argument_list|)
return|;
comment|/* The caller will deal with these.  */
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
return|return
name|NULL_TREE
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|367
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build up a call to operator new.  This has to be handled differently    from other operators in the way lookup is handled; first members are    considered, then globals.  CODE is either NEW_EXPR or VEC_NEW_EXPR.    TYPE is the type to be created.  ARGS are any new-placement args.    FLAGS are the usual overloading flags.  */
end_comment

begin_function
name|tree
name|build_op_new_call
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fnname
init|=
name|ansi_opname
index|[
name|code
index|]
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
operator|&&
operator|(
name|TYPE_GETS_NEW
argument_list|(
name|type
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|code
operator|==
name|VEC_NEW_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
return|return
name|build_method_call
argument_list|(
name|build_dummy_object
argument_list|(
name|type
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
return|;
block|}
else|else
return|return
name|build_new_function_call
argument_list|(
name|lookup_function_nonclass
argument_list|(
name|fnname
argument_list|,
name|args
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a call to operator delete.  This has to be handled very specially,    because the restrictions on what signatures match are different from all    other call instances.  For a normal delete, only a delete taking (void *)    or (void *, size_t) is accepted.  For a placement delete, only an exact    match with the placement new is accepted.     CODE is either DELETE_EXPR or VEC_DELETE_EXPR.    ADDR is the pointer to be deleted.  For placement delete, it is also      used to determine what the corresponding new looked like.    SIZE is the size of the memory block to be deleted.    FLAGS are the usual overloading flags.    PLACEMENT is the corresponding placement new call, or 0.  */
end_comment

begin_function
name|tree
name|build_op_delete_call
parameter_list|(
name|code
parameter_list|,
name|addr
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|,
name|placement
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|size
decl_stmt|,
name|placement
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|,
name|fns
decl_stmt|,
name|fnname
decl_stmt|,
name|fntype
decl_stmt|,
name|argtypes
decl_stmt|,
name|args
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|ansi_opname
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
condition|)
comment|/* In [class.free]         If the result of the lookup is ambiguous or inaccessible, or if        the lookup selects a placement deallocation function, the        program is ill-formed.           Therefore, we ask lookup_fnfields to complain ambout ambiguity.  */
block|{
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
name|fns
operator|=
name|lookup_name_nonclass
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|placement
condition|)
block|{
comment|/* placement is a CALL_EXPR around an ADDR_EXPR around a function.  */
comment|/* Extract the function.  */
name|argtypes
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|placement
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then the second parm type.  */
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtypes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also the second argument.  */
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|placement
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First try it without the size argument.  */
name|argtypes
operator|=
name|void_list_node
expr_stmt|;
name|args
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
comment|/* Strip const and volatile from addr.  */
if|if
condition|(
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|addr
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|fntype
argument_list|,
name|fns
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Member functions.  */
name|enforce_access
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we are doing placement delete we do nothing if we don't find a      matching op delete.  */
if|if
condition|(
name|placement
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Normal delete; now try to find a match including the size argument.  */
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|fntype
argument_list|,
name|fns
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
comment|/* Member functions.  */
name|enforce_access
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* finish_function passes LOOKUP_SPECULATIVELY if we're in a      destructor, in which case the error should be deferred      until someone actually tries to delete one of these.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
name|cp_error
argument_list|(
literal|"no suitable operator delete for `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* If the current scope isn't allowed to access DECL along    BASETYPE_PATH, give an error.  The most derived class in    BASETYPE_PATH is the one used to qualify DECL.  */
end_comment

begin_function
name|int
name|enforce_access
parameter_list|(
name|basetype_path
parameter_list|,
name|decl
parameter_list|)
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|accessible
decl_stmt|;
name|accessible
operator|=
name|accessible_p
argument_list|(
name|basetype_path
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|accessible
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%+#D' is private"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%+#D' is protected"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"`%+#D' is inaccessible"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Perform the conversions in CONVS on the expression EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_like
parameter_list|(
name|convs
parameter_list|,
name|expr
parameter_list|)
name|tree
name|convs
decl_stmt|,
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|convs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|USER_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|AMBIG_CONV
condition|)
block|{
name|tree
name|t
init|=
name|convs
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
condition|)
block|{
name|expr
operator|=
name|convert_like
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
name|convert_like
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
break|break;
block|}
return|return
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"conversion"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
condition|)
block|{
case|case
name|USER_CONV
case|:
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|WRAPPER_PTR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|cand
operator|->
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_NORMAL
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_vtable_thunks_compat
condition|)
block|{
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vlist_zero_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|flags
operator|!=
name|LOOKUP_HAS_VLIST
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|build_this
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* If this is a constructor or a function returning an aggr type, 	   we need to build up a TARGET_EXPR.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|expr
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
case|case
name|IDENTITY_CONV
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
case|case
name|AMBIG_CONV
case|:
comment|/* Call build_user_type_conversion again for the error.  */
return|return
name|build_user_type_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
default|default:
break|break;
block|}
empty_stmt|;
name|expr
operator|=
name|convert_like
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
condition|)
block|{
case|case
name|RVALUE_CONV
case|:
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* else fall through */
case|case
name|BASE_CONV
case|:
block|{
name|tree
name|cvt_expr
init|=
name|build_user_type_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cvt_expr
condition|)
block|{
comment|/* This can occur if, for example, the EXPR has incomplete 	       type.  We can't check for that before attempting the 	       conversion because the type might be an incomplete 	       array type, which is OK if some constructor for the 	       destination type takes a pointer argument.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|)
condition|)
name|incomplete_type_error
argument_list|(
name|expr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"could not convert `%E' (with incomplete type `%T') to `%T'"
argument_list|,
name|expr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"could not convert `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|cvt_expr
return|;
block|}
case|case
name|REF_BIND
case|:
return|return
name|convert_to_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NO_CONVERSION
argument_list|,
name|error_mark_node
argument_list|)
return|;
case|case
name|LVALUE_CONV
case|:
return|return
name|decay_conversion
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|QUAL_CONV
case|:
comment|/* Warn about deprecated conversion if appropriate.  */
name|string_conv_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ocp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARG is being passed to a varargs function.  Perform any conversions    required.  Return the converted value.  */
end_comment

begin_function
name|tree
name|convert_arg_to_ellipsis
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|arg
operator|=
name|cp_convert
argument_list|(
name|double_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"cannot pass objects of type `%T' through `...'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|require_complete_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* ARG is a default argument expression being passed to a parameter of    the indicated TYPE, which is a parameter to FN.  Do any required    conversions.  Return the converted value.  */
end_comment

begin_function
name|tree
name|convert_default_arg
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|,
name|fn
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|fn
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* This default argument came from a template.  Instantiate the 	 default argument here, not in tsubst.  In the case of 	 something like:   	   template<class T> 	   struct S { 	     static T t(); 	     void f(T = t()); 	   };  	 we must be careful to do name lookup in the scope of S<T>, 	 rather than in the current class.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|pushclass
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tsubst_expr
argument_list|(
name|arg
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|popclass
argument_list|()
expr_stmt|;
comment|/* Make sure the default argument is reasonable.  */
name|arg
operator|=
name|check_default_argument
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|break_out_target_exprs
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|arg
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"default argument"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This could get clobbered by the following call.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|arg
argument_list|)
condition|)
name|arg
operator|=
name|copy_node
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"default argument"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|arg
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_over_call
parameter_list|(
name|cand
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|cand
operator|->
name|fn
decl_stmt|;
name|tree
name|convs
init|=
name|cand
operator|->
name|convs
decl_stmt|;
name|tree
name|converted_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parm
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|conv
decl_stmt|,
name|arg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|is_method
init|=
literal|0
decl_stmt|;
comment|/* Give any warnings we noticed during overload resolution.  */
if|if
condition|(
name|cand
operator|->
name|warnings
condition|)
for|for
control|(
name|val
operator|=
name|cand
operator|->
name|warnings
init|;
name|val
condition|;
name|val
operator|=
name|TREE_CHAIN
argument_list|(
name|val
argument_list|)
control|)
name|joust
argument_list|(
name|cand
argument_list|,
name|WRAPPER_PTR
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
name|enforce_access
argument_list|(
name|cand
operator|->
name|basetype_path
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|args
operator|=
name|build_scratch_list
argument_list|(
name|NULL_TREE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|args
expr_stmt|;
comment|/* The implicit parameters to a constructor are not considered by overload      resolution, and must be of the proper type.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_HAS_VLIST
condition|)
block|{
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bypass access control for 'this' parameter.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as `this' argument of `%#D' discards qualifiers"
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* [class.mfct.nonstatic]: If a nonstatic member function of a class 	 X is called for an object that is not of type X, or of a type 	 derived from X, the behavior is undefined.           So we can assume that anything passed as 'this' is non-null, and 	 optimize accordingly.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|t
operator|=
name|convert_pointer_to_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* This happens with signatures.  */
name|t
operator|=
name|convert_force
argument_list|(
name|parmtype
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|CONV_C_CAST
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|is_method
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|arg
operator|&&
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|conv
decl_stmt|;
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
block|{
name|val
operator|=
name|convert_like
argument_list|(
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
break|break;
block|}
name|val
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"argument passing"
argument_list|,
name|fn
argument_list|,
name|i
operator|-
name|is_method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Issue warnings about peculiar, but legal, uses of NULL.  */
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
operator|==
name|null_node
condition|)
name|cp_warning
argument_list|(
literal|"converting NULL to non-pointer type"
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
block|}
comment|/* Default arguments */
for|for
control|(
init|;
name|parm
operator|&&
name|parm
operator|!=
name|void_list_node
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* Ellipsis */
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|converted_args
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert_arg_to_ellipsis
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|nreverse
argument_list|(
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
operator|)
condition|)
name|check_function_format
argument_list|(
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* Avoid actually calling copy constructors and copy assignment operators,      if possible.  */
if|if
condition|(
operator|!
name|flag_elide_constructors
condition|)
comment|/* Do things the hard way.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|convs
argument_list|)
operator|==
literal|1
operator|&&
name|copy_args_p
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|targ
decl_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_HAS_VLIST
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Pull out the real argument, disregarding const-correctness.  */
name|targ
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
argument_list|)
condition|)
name|targ
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|targ
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|targ
condition|)
name|arg
operator|=
name|targ
expr_stmt|;
else|else
name|arg
operator|=
name|build_indirect_ref
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* [class.copy]: the copy constructor is implicitly defined even if 	 the implementation elided its use.  */
if|if
condition|(
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If we're creating a temp and we already have one, don't create a          new one.  If we're not creating a temp but we get one, use          INIT_EXPR to collapse the temp into our target.  Otherwise, if the          ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a          temp or an INIT_EXPR otherwise.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|val
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|address
decl_stmt|;
name|tree
name|to
init|=
name|stabilize_reference
argument_list|(
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we're initializing an empty class, then we actually 	     have to use a MODIFY_EXPR rather than an INIT_EXPR.  The 	     reason is that the dummy padding member in the target may 	     not actually be allocated if TO is a base class 	     subobject.  Since we've set TYPE_NONCOPIED_PARTS on the 	     padding, a MODIFY_EXPR will preserve its value, which is 	     the right thing to do if it's not really padding at all. 	   	     It's not safe to just throw away the ARG if we're looking 	     at an empty class because the ARG might contain a 	     TARGET_EXPR which wants to be bound to TO.  If it is not, 	     expand_expr will assign a dummy slot for the TARGET_EXPR, 	     and we will call a destructor for it, which is wrong, 	     because we will also destroy TO, but will never have 	     constructed it.  */
name|val
operator|=
name|build
argument_list|(
name|is_empty_class
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|address
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid a warning about this expression, if the address is 	     never used.  */
name|TREE_USED
argument_list|(
name|address
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|address
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
operator|==
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
operator|&&
name|copy_args_p
argument_list|(
name|fn
argument_list|)
operator|&&
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|to
init|=
name|stabilize_reference
argument_list|(
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|converted_args
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
name|build_signature_method_call
argument_list|(
name|fn
argument_list|,
name|converted_args
argument_list|)
return|;
elseif|else
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|t
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|save_expr
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_vfn_ref
argument_list|(
name|p
argument_list|,
name|build_indirect_ref
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|inline_conversion
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
name|fn
operator|=
name|build_addr_func
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|converted_args
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|fn
return|;
name|fn
operator|=
name|require_complete_type
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|fn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_new_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|args
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|mem_args
init|=
name|NULL_TREE
decl_stmt|,
name|fns
decl_stmt|,
name|instance_ptr
decl_stmt|;
name|tree
name|pretty_name
decl_stmt|;
name|tree
name|user_args
init|=
name|args
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|template_only
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If there is an extra argument for controlling virtual bases,      remove it for error reporting.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
condition|)
name|user_args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_HAS_VLIST
condition|)
name|user_args
operator|=
name|TREE_CHAIN
argument_list|(
name|user_args
argument_list|)
expr_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
condition|)
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|instance
operator|=
name|resolve_offset_ref
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|instance
operator|=
name|convert_from_reference
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX this should be handled before we get here.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|basetype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|basetype
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
operator|&&
name|basetype
operator|!=
name|error_mark_node
condition|)
name|cp_error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|name
argument_list|,
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If `instance' is a signature pointer/reference and `name' is 	 not a constructor, we are calling a signature member function. 	 In that case set the `basetype' to the signature type.  */
if|if
condition|(
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|basetype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|basetype
argument_list|)
operator|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|!=
name|name
condition|)
name|basetype
operator|=
name|SIGNATURE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
condition|)
block|{
name|instance_ptr
operator|=
name|build_this
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template_only
condition|)
block|{
comment|/* XXX this should be handled before we get here.  */
name|fns
operator|=
name|build_field_call
argument_list|(
name|basetype_path
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
condition|)
return|return
name|fns
return|;
block|}
block|}
else|else
block|{
name|instance_ptr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
name|pretty_name
operator|=
operator|(
name|name
operator|==
name|ctor_identifier
condition|?
name|constructor_name
argument_list|(
name|basetype
argument_list|)
else|:
name|name
operator|)
expr_stmt|;
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|ctor_identifier
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
operator|!
name|flag_vtable_thunks_compat
operator|||
operator|(
name|name
operator|==
name|dtor_identifier
operator|)
operator|)
condition|)
block|{
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vlist_zero_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_VLIST
expr_stmt|;
block|}
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|mem_args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|args
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|this_arglist
decl_stmt|;
comment|/* We can end up here for copy-init of same or base class.  */
if|if
condition|(
name|name
operator|==
name|ctor_identifier
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
operator|&&
name|DECL_NONCONVERTING_P
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|this_arglist
operator|=
name|mem_args
expr_stmt|;
else|else
name|this_arglist
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* A member template. */
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|explicit_targs
argument_list|,
name|this_arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|template_only
condition|)
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|this_arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
comment|/* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
name|incomplete_type_error
argument_list|(
name|instance_ptr
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"no matching function for call to `%T::%D (%A)%V'"
argument_list|,
name|basetype
argument_list|,
name|pretty_name
argument_list|,
name|user_args
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"call of overloaded `%D(%A)' is ambiguous"
argument_list|,
name|pretty_name
argument_list|,
name|user_args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|instance
operator|==
name|current_class_ref
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|value_member
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"abstract virtual `%#D' called from constructor"
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|is_dummy_object
argument_list|(
name|instance_ptr
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot call member function `%D' without object"
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
operator|(
operator|(
name|instance
operator|==
name|current_class_ref
operator|&&
operator|(
name|dtor_label
operator|||
name|ctor_label
operator|)
operator|)
operator|||
name|resolves_to_fixed_type_p
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
comment|/* Pedantically, normal function declarations are never considered      to refer to template instantiations, so we only do this with      -fguiding-decls.  */
if|if
condition|(
name|flag_guiding_decls
operator|&&
name|templates
operator|&&
operator|!
name|cand
operator|->
name|template
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
condition|)
name|add_maybe_template
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|mem_args
else|:
name|args
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff standard conversion sequence ICS1 is a proper    subsequence of ICS2.  */
end_comment

begin_function
specifier|static
name|int
name|is_subseq
parameter_list|(
name|ics1
parameter_list|,
name|ics2
parameter_list|)
name|tree
name|ics1
decl_stmt|,
name|ics2
decl_stmt|;
block|{
comment|/* We can assume that a conversion of the same code      between the same types indicates a subsequence since we only get      here if the types we are converting from are the same.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|RVALUE_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|LVALUE_CONV
condition|)
name|ics1
operator|=
name|TREE_OPERAND
argument_list|(
name|ics1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|RVALUE_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|LVALUE_CONV
condition|)
name|ics2
operator|=
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|AMBIG_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
comment|/* At this point, ICS1 cannot be a proper subsequence of 	   ICS2.  We can get a USER_CONV when we are comparing the 	   second standard conversion sequence of two user conversion 	   sequences.  */
return|return
literal|0
return|;
name|ics2
operator|=
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|ics2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ics1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ics1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero iff DERIVED is derived from BASE.  The inputs may    be any _TYPE nodes.  */
end_comment

begin_function
name|int
name|is_properly_derived_from
parameter_list|(
name|derived
parameter_list|,
name|base
parameter_list|)
name|tree
name|derived
decl_stmt|;
name|tree
name|base
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|derived
argument_list|)
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We only allow proper derivation here.  The DERIVED_FROM_P macro      considers every class derived from itself.  */
return|return
operator|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|derived
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|base
argument_list|,
name|derived
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We build the ICS for an implicit object parameter as a pointer    conversion sequence.  However, such a sequence should be compared    as if it were a reference conversion sequence.  If ICS is the    implicit conversion sequence for an implicit object parameter,    modify it accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_handle_implicit_object
parameter_list|(
name|ics
parameter_list|)
name|tree
modifier|*
name|ics
decl_stmt|;
block|{
if|if
condition|(
name|ICS_THIS_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
condition|)
block|{
comment|/* [over.match.funcs] 	  	 For non-static member functions, the type of the 	 implicit object parameter is "reference to cv X" 	 where X is the class of which the function is a 	 member and cv is the cv-qualification on the member 	 function declaration.  */
name|tree
name|t
init|=
operator|*
name|ics
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|QUAL_CONV
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTR_CONV
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|ics
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ICS_STD_RANK
argument_list|(
name|t
argument_list|)
operator|=
name|ICS_STD_RANK
argument_list|(
operator|*
name|ics
argument_list|)
expr_stmt|;
operator|*
name|ics
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If ICS is a REF_BIND, modify it appropriately, set TARGET_TYPE    to the type the reference originally referred to, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_handle_ref_bind
parameter_list|(
name|ics
parameter_list|,
name|target_type
parameter_list|)
name|tree
modifier|*
name|ics
decl_stmt|;
name|tree
modifier|*
name|target_type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|ics
argument_list|)
operator|==
name|REF_BIND
condition|)
block|{
comment|/* [over.ics.rank]  	  	 When a parameter of reference type binds directly 	 (_dcl.init.ref_) to an argument expression, the implicit 	 conversion sequence is the identity conversion, unless the 	 argument expression has a type that is a derived class of the 	 parameter type, in which case the implicit conversion 	 sequence is a derived-to-base Conversion. 	  	 If the parameter binds directly to the result of applying a 	 conversion function to the argument expression, the implicit 	 conversion sequence is a user-defined conversion sequence 	 (_over.ics.user_), with the second standard conversion 	 sequence either an identity conversion or, if the conversion 	 function returns an entity of a type that is a derived class 	 of the parameter type, a derived-to-base Conversion. 	  	 When a parameter of reference type is not bound directly to 	 an argument expression, the conversion sequence is the one 	 required to convert the argument expression to the underlying 	 type of the reference according to _over.best.ics_. 	 Conceptually, this conversion sequence corresponds to 	 copy-initializing a temporary of the underlying type with the 	 argument expression.  Any difference in top-level 	 cv-qualification is subsumed by the initialization itself and 	 does not constitute a conversion.  */
name|tree
name|old_ics
init|=
operator|*
name|ics
decl_stmt|;
operator|*
name|target_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|ics
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ics
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|ics
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|ics
argument_list|)
operator|==
name|IDENTITY_CONV
operator|&&
name|is_properly_derived_from
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|ics
argument_list|)
argument_list|,
operator|*
name|target_type
argument_list|)
condition|)
operator|*
name|ics
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
operator|*
name|target_type
argument_list|,
operator|*
name|ics
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
operator|=
name|ICS_USER_FLAG
argument_list|(
name|old_ics
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
name|old_ics
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare two implicit conversion sequences according to the rules set out in    [over.ics.rank].  Return values:        1: ics1 is better than ics2      -1: ics2 is better than ics1       0: ics1 and ics2 are indistinguishable */
end_comment

begin_function
specifier|static
name|int
name|compare_ics
parameter_list|(
name|ics1
parameter_list|,
name|ics2
parameter_list|)
name|tree
name|ics1
decl_stmt|,
name|ics2
decl_stmt|;
block|{
name|tree
name|from_type1
decl_stmt|;
name|tree
name|from_type2
decl_stmt|;
name|tree
name|to_type1
decl_stmt|;
name|tree
name|to_type2
decl_stmt|;
name|tree
name|deref_from_type1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_from_type2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_to_type1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_to_type2
init|=
name|NULL_TREE
decl_stmt|;
comment|/* REF_BINDING is non-zero if the result of the conversion sequence      is a reference type.   In that case TARGET_TYPE is the      type referred to by the reference.  */
name|int
name|ref_binding1
decl_stmt|;
name|int
name|ref_binding2
decl_stmt|;
name|tree
name|target_type1
decl_stmt|;
name|tree
name|target_type2
decl_stmt|;
comment|/* Handle implicit object parameters.  */
name|maybe_handle_implicit_object
argument_list|(
operator|&
name|ics1
argument_list|)
expr_stmt|;
name|maybe_handle_implicit_object
argument_list|(
operator|&
name|ics2
argument_list|)
expr_stmt|;
comment|/* Handle reference parameters.  */
name|ref_binding1
operator|=
name|maybe_handle_ref_bind
argument_list|(
operator|&
name|ics1
argument_list|,
operator|&
name|target_type1
argument_list|)
expr_stmt|;
name|ref_binding2
operator|=
name|maybe_handle_ref_bind
argument_list|(
operator|&
name|ics2
argument_list|,
operator|&
name|target_type2
argument_list|)
expr_stmt|;
comment|/* [over.ics.rank]       When  comparing  the  basic forms of implicit conversion sequences (as      defined in _over.best.ics_)       --a standard conversion sequence (_over.ics.scs_) is a better        conversion sequence than a user-defined conversion sequence        or an ellipsis conversion sequence, and            --a user-defined conversion sequence (_over.ics.user_) is a        better conversion sequence than an ellipsis conversion sequence        (_over.ics.ellipsis_).  */
if|if
condition|(
name|ICS_RANK
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ICS_RANK
argument_list|(
name|ics1
argument_list|)
operator|==
name|BAD_RANK
condition|)
block|{
comment|/* Both ICS are bad.  We try to make a decision based on what 	 would have happenned if they'd been good.  */
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_USER_FLAG
argument_list|(
name|ics2
argument_list|)
operator|||
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_USER_FLAG
argument_list|(
name|ics2
argument_list|)
operator|||
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We couldn't make up our minds; try to figure it out below.  */
block|}
if|if
condition|(
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|ics1
argument_list|)
condition|)
comment|/* Both conversions are ellipsis conversions.  */
return|return
literal|0
return|;
comment|/* User-defined  conversion sequence U1 is a better conversion sequence      than another user-defined conversion sequence U2 if they contain the      same user-defined conversion operator or constructor and if the sec-      ond standard conversion sequence of U1 is  better  than  the  second      standard conversion sequence of U2.  */
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|ics1
init|;
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|USER_CONV
condition|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t2
operator|=
name|ics2
init|;
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|USER_CONV
condition|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USER_CONV_FN
argument_list|(
name|t1
argument_list|)
operator|!=
name|USER_CONV_FN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We can just fall through here, after setting up 	 FROM_TYPE1 and FROM_TYPE2.  */
name|from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're dealing with two standard conversion sequences.   	 [over.ics.rank] 	  	 Standard conversion sequence S1 is a better conversion 	 sequence than standard conversion sequence S2 if       	 --S1 is a proper subsequence of S2 (comparing the conversion 	   sequences in the canonical form defined by _over.ics.scs_, 	   excluding any Lvalue Transformation; the identity 	   conversion sequence is considered to be a subsequence of 	   any non-identity conversion sequence */
name|from_type1
operator|=
name|ics1
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|from_type1
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|from_type1
operator|=
name|TREE_OPERAND
argument_list|(
name|from_type1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|ics2
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|from_type2
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|from_type2
operator|=
name|TREE_OPERAND
argument_list|(
name|from_type2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_subseq
argument_list|(
name|ics1
argument_list|,
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_subseq
argument_list|(
name|ics2
argument_list|,
name|ics1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Otherwise, one sequence cannot be a subsequence of the other; they      don't start with the same type.  This can happen when comparing the      second standard conversion sequence in two user-defined conversion      sequences.  */
comment|/* [over.ics.rank]       Or, if not that,       --the rank of S1 is better than the rank of S2 (by the rules        defined below):      Standard conversion sequences are ordered by their ranks: an Exact     Match is a better conversion than a Promotion, which is a better     conversion than a Conversion.      Two conversion sequences with the same rank are indistinguishable     unless one of the following rules applies:      --A conversion that is not a conversion of a pointer, or pointer       to member, to bool is better than another conversion that is such       a conversion.        The ICS_STD_RANK automatically handles the pointer-to-bool rule,     so that we do not have to check it explicitly.  */
if|if
condition|(
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|to_type1
operator|=
name|TREE_TYPE
argument_list|(
name|ics1
argument_list|)
expr_stmt|;
name|to_type2
operator|=
name|TREE_TYPE
argument_list|(
name|ics2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
name|deref_to_type1
operator|=
name|TREE_TYPE
argument_list|(
name|to_type1
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TREE_TYPE
argument_list|(
name|to_type2
argument_list|)
expr_stmt|;
block|}
comment|/* The rules for pointers to members A::* are just like the rules      for pointers A*, except opposite: if B is derived from A then      A::* converts to B::*, not vice versa.  For that reason, we      switch the from_ and to_ variables here.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_to_type1
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
argument_list|)
expr_stmt|;
name|deref_from_type1
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to_type1
argument_list|)
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to_type2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_to_type1
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
name|deref_from_type1
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|to_type1
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|to_type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deref_from_type1
operator|!=
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_from_type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_from_type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This was one of the pointer or pointer-like conversions.    	 [over.ics.rank] 	  	 --If class B is derived directly or indirectly from class A, 	   conversion of B* to A* is better than conversion of B* to 	   void*, and conversion of A* to void* is better than 	   conversion of B* to void*.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type2
argument_list|,
name|deref_from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_to_type1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* We know that DEREF_TO_TYPE1 is `void' here.  */
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* [over.ics.rank]  	     --If class B is derived directly or indirectly from class A 	       and class C is derived directly or indirectly from B, 	      	     --conversion of C* to B* is better than conversion of C* to 	       A*,  	      	     --conversion of B* to A* is better than conversion of C* to 	       A*  */
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_to_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_to_type2
argument_list|,
name|deref_to_type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_to_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type2
argument_list|,
name|deref_from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|from_type1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
block|{
comment|/* [over.ics.rank] 	  	 --binding of an expression of type C to a reference of type 	   B& is better than binding an expression of type C to a 	   reference of type A&  	 --conversion of C to B is better than conversion of C to A,  */
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|to_type1
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|to_type2
argument_list|,
name|to_type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|to_type1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
block|{
comment|/* [over.ics.rank]  	 --binding of an expression of type B to a reference of type 	   A& is better than binding an expression of type C to a 	   reference of type A&,   	 --onversion of B to A is better than conversion of C to A  */
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|to_type1
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from_type2
argument_list|,
name|to_type1
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type2
argument_list|,
name|from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* [over.ics.rank]       --S1 and S2 differ only in their qualification conversion and  yield        similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-        qualification signature of type T1 is a proper subset of  the  cv-        qualification signature of type T2  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|QUAL_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|QUAL_CONV
operator|&&
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
return|return
name|comp_cv_qual_signature
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
return|;
comment|/* [over.ics.rank]            --S1 and S2 are reference bindings (_dcl.init.ref_), and the      types to which the references refer are the same type except for      top-level cv-qualifiers, and the type to which the reference      initialized by S2 refers is more cv-qualified than the type to      which the reference initialized by S1 refers */
if|if
condition|(
name|ref_binding1
operator|&&
name|ref_binding2
operator|&&
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to_type1
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|to_type2
argument_list|)
argument_list|)
condition|)
return|return
name|comp_cv_qualification
argument_list|(
name|target_type2
argument_list|,
name|target_type1
argument_list|)
return|;
comment|/* Neither conversion sequence is better than the other.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The source type for this standard conversion sequence.  */
end_comment

begin_function
specifier|static
name|tree
name|source_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|1823
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note a warning about preferring WINNER to LOSER.  We do this by storing    a pointer to LOSER and re-running joust to produce the warning if WINNER    is actually used.  */
end_comment

begin_function
specifier|static
name|void
name|add_warning
parameter_list|(
name|winner
parameter_list|,
name|loser
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|winner
decl_stmt|,
decl|*
name|loser
decl_stmt|;
end_function

begin_block
block|{
name|winner
operator|->
name|warnings
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_PTR
argument_list|,
name|build_expr_ptr_wrapper
argument_list|(
name|loser
argument_list|)
argument_list|,
name|winner
operator|->
name|warnings
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compare two candidates for overloading as described in    [over.match.best].  Return values:        1: cand1 is better than cand2      -1: cand2 is better than cand1       0: cand1 and cand2 are indistinguishable */
end_comment

begin_function
specifier|static
name|int
name|joust
parameter_list|(
name|cand1
parameter_list|,
name|cand2
parameter_list|,
name|warn
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cand1
decl_stmt|,
decl|*
name|cand2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|warn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off1
init|=
literal|0
decl_stmt|,
name|off2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
comment|/* Candidates that involve bad conversions are always worse than those      that don't.  */
if|if
condition|(
name|cand1
operator|->
name|viable
operator|>
name|cand2
operator|->
name|viable
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cand1
operator|->
name|viable
operator|<
name|cand2
operator|->
name|viable
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we have two pseudo-candidates for conversions to the same type,      arbitrarily pick one.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
name|cand1
operator|->
name|fn
operator|==
name|cand2
operator|->
name|fn
condition|)
return|return
literal|1
return|;
comment|/* a viable function F1      is defined to be a better function than another viable function F2  if      for  all arguments i, ICSi(F1) is not a worse conversion sequence than      ICSi(F2), and then */
comment|/* for some argument j, ICSj(F1) is a better conversion  sequence  than      ICSj(F2) */
comment|/* For comparing static and non-static member functions, we ignore the      implicit object parameter of the non-static function.  The WP says to      pretend that the static function has an object parm, but that won't      work with operator overloading.  */
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|cand2
operator|->
name|convs
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
condition|)
name|off2
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
condition|)
block|{
name|off1
operator|=
literal|1
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
decl_stmt|;
name|int
name|comp
init|=
name|compare_ics
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|warn_sign_promo
operator|&&
name|ICS_RANK
argument_list|(
name|t1
argument_list|)
operator|+
name|ICS_RANK
argument_list|(
name|t2
argument_list|)
operator|==
name|STD_RANK
operator|+
name|PROMO_RANK
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|STD_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|STD_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|w
decl_stmt|,
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|comp
operator|>
literal|0
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|,
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|,
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
else|else
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|,
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|,
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|cp_warning
argument_list|(
literal|"passing `%T' chooses `%T' over `%T'"
argument_list|,
name|type
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"  in call to `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|winner
operator|&&
name|comp
operator|!=
name|winner
condition|)
block|{
name|winner
operator|=
literal|0
expr_stmt|;
goto|goto
name|tweak
goto|;
block|}
name|winner
operator|=
name|comp
expr_stmt|;
block|}
block|}
comment|/* warn about confusing overload resolution for user-defined conversions,      either between a constructor and a conversion op, or between two      conversion ops.  */
if|if
condition|(
name|winner
operator|&&
name|cand1
operator|->
name|second_conv
operator|&&
operator|(
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|!=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|)
comment|/* Don't warn if the two conv ops convert to the same type...  */
operator|||
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|comp
init|=
name|compare_ics
argument_list|(
name|cand1
operator|->
name|second_conv
argument_list|,
name|cand2
operator|->
name|second_conv
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
name|winner
condition|)
block|{
name|struct
name|z_candidate
modifier|*
name|w
decl_stmt|,
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|winner
operator|==
literal|1
condition|)
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
else|else
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|tree
name|source
init|=
name|source_type
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|w
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|w
operator|->
name|fn
argument_list|)
condition|)
name|source
operator|=
name|TREE_TYPE
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"choosing `%D' over `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|,
name|l
operator|->
name|fn
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"  for conversion from `%T' to `%T'"
argument_list|,
name|source
argument_list|,
name|TREE_TYPE
argument_list|(
name|w
operator|->
name|second_conv
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"  because conversion sequence for the argument is better"
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
comment|/* or, if not that,      F1 is a non-template function and F2 is a template function */
if|if
condition|(
operator|!
name|cand1
operator|->
name|template
operator|&&
name|cand2
operator|->
name|template
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cand1
operator|->
name|template
operator|&&
operator|!
name|cand2
operator|->
name|template
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|cand1
operator|->
name|template
operator|&&
name|cand2
operator|->
name|template
condition|)
name|winner
operator|=
name|more_specialized
argument_list|(
name|TI_TEMPLATE
argument_list|(
name|cand1
operator|->
name|template
argument_list|)
argument_list|,
name|TI_TEMPLATE
argument_list|(
name|cand2
operator|->
name|template
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* or, if not that,      the  context  is  an  initialization by user-defined conversion (see      _dcl.init_  and  _over.match.user_)  and  the  standard   conversion      sequence  from  the return type of F1 to the destination type (i.e.,      the type of the entity being initialized)  is  a  better  conversion      sequence  than the standard conversion sequence from the return type      of F2 to the destination type.  */
if|if
condition|(
operator|!
name|winner
operator|&&
name|cand1
operator|->
name|second_conv
condition|)
name|winner
operator|=
name|compare_ics
argument_list|(
name|cand1
operator|->
name|second_conv
argument_list|,
name|cand2
operator|->
name|second_conv
argument_list|)
expr_stmt|;
comment|/* If the built-in candidates are the same, arbitrarily pick one.  */
if|if
condition|(
operator|!
name|winner
operator|&&
name|cand1
operator|->
name|fn
operator|==
name|cand2
operator|->
name|fn
operator|&&
name|TREE_CODE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Kludge around broken overloading rules whereby 	 Integer a, b; test ? a : b; is ambiguous, since there's a builtin 	 that takes references and another that takes values.  */
if|if
condition|(
name|cand1
operator|->
name|fn
operator|==
name|ansi_opname
index|[
name|COND_EXPR
index|]
condition|)
block|{
name|tree
name|c1
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|c2
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|t1
init|=
name|strip_top_quals
argument_list|(
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|c1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|strip_top_quals
argument_list|(
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|c2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c1
argument_list|)
operator|==
name|REF_BIND
operator|&&
name|TREE_CODE
argument_list|(
name|c2
argument_list|)
operator|!=
name|REF_BIND
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c1
argument_list|)
operator|!=
name|REF_BIND
operator|&&
name|TREE_CODE
argument_list|(
name|c2
argument_list|)
operator|==
name|REF_BIND
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|tweak
label|:
comment|/* Extension: If the worst conversion for one candidate is worse than the      worst conversion for the other, take the first.  */
if|if
condition|(
operator|!
name|winner
operator|&&
operator|!
name|pedantic
condition|)
block|{
name|int
name|rank1
init|=
name|IDENTITY_RANK
decl_stmt|,
name|rank2
init|=
name|IDENTITY_RANK
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
argument_list|)
operator|>
name|rank1
condition|)
name|rank1
operator|=
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
argument_list|)
operator|>
name|rank2
condition|)
name|rank2
operator|=
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rank1
operator|<
name|rank2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|rank1
operator|>
name|rank2
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|winner
return|;
block|}
end_block

begin_comment
comment|/* Given a list of candidates for overloading, find the best one, if any.    This algorithm has a worst case of O(2n) (winner is last), and a best    case of O(n/2) (totally ambiguous); much better than a sorting    algorithm.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|tourney
parameter_list|(
name|candidates
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|champ
init|=
name|candidates
decl_stmt|,
modifier|*
name|challenger
decl_stmt|;
name|int
name|fate
decl_stmt|;
name|int
name|champ_compared_to_predecessor
init|=
literal|0
decl_stmt|;
comment|/* Walk through the list once, comparing each current champ to the next      candidate, knocking out a candidate or two with each comparison.  */
for|for
control|(
name|challenger
operator|=
name|champ
operator|->
name|next
init|;
name|challenger
condition|;
control|)
block|{
name|fate
operator|=
name|joust
argument_list|(
name|champ
argument_list|,
name|challenger
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
name|challenger
operator|=
name|challenger
operator|->
name|next
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|champ
operator|=
name|challenger
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|champ
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|champ_compared_to_predecessor
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|champ
operator|=
name|challenger
expr_stmt|;
name|champ_compared_to_predecessor
operator|=
literal|1
expr_stmt|;
block|}
name|challenger
operator|=
name|champ
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Make sure the champ is better than all the candidates it hasn't yet      been compared to.  */
for|for
control|(
name|challenger
operator|=
name|candidates
init|;
name|challenger
operator|!=
name|champ
operator|&&
operator|!
operator|(
name|champ_compared_to_predecessor
operator|&&
name|challenger
operator|->
name|next
operator|==
name|champ
operator|)
condition|;
name|challenger
operator|=
name|challenger
operator|->
name|next
control|)
block|{
name|fate
operator|=
name|joust
argument_list|(
name|champ
argument_list|,
name|challenger
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_function
name|int
name|can_convert
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
name|tree
name|t
init|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
return|return
operator|(
name|t
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|can_convert_arg
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|arg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|arg
decl_stmt|;
block|{
name|tree
name|t
init|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
return|return
operator|(
name|t
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

