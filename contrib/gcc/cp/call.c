begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to invoking methods and overloaded functions.    Copyright (C) 1987, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) and    hacked by Brendan Kehoe (brendan@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"class.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|void
name|sorry
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|inhibit_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|flag_assume_nonnull_objects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|ctor_label
decl_stmt|,
name|dtor_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From typeck.c:  */
end_comment

begin_function_decl
specifier|extern
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Compute the ease with which a conversion can be performed    between an expected and the given type.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|harshness_code
name|convert_harshness
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EVIL_RETURN
parameter_list|(
name|ARG
parameter_list|)
value|((ARG).code = EVIL_CODE, (ARG))
end_define

begin_define
define|#
directive|define
name|STD_RETURN
parameter_list|(
name|ARG
parameter_list|)
value|((ARG).code = STD_CODE, (ARG))
end_define

begin_define
define|#
directive|define
name|QUAL_RETURN
parameter_list|(
name|ARG
parameter_list|)
value|((ARG).code = QUAL_CODE, (ARG))
end_define

begin_define
define|#
directive|define
name|TRIVIAL_RETURN
parameter_list|(
name|ARG
parameter_list|)
value|((ARG).code = TRIVIAL_CODE, (ARG))
end_define

begin_define
define|#
directive|define
name|ZERO_RETURN
parameter_list|(
name|ARG
parameter_list|)
value|((ARG).code = 0, (ARG))
end_define

begin_comment
comment|/* Ordering function for overload resolution.  Compare two candidates    by gross quality.  */
end_comment

begin_function
name|int
name|rank_for_overload
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|candidate
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|y
operator|->
name|h
operator|.
name|code
operator|&
operator|(
name|EVIL_CODE
operator||
name|ELLIPSIS_CODE
operator||
name|USER_CODE
operator|)
condition|)
return|return
name|y
operator|->
name|h
operator|.
name|code
operator|-
name|x
operator|->
name|h
operator|.
name|code
return|;
if|if
condition|(
name|x
operator|->
name|h
operator|.
name|code
operator|&
operator|(
name|EVIL_CODE
operator||
name|ELLIPSIS_CODE
operator||
name|USER_CODE
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* This is set by compute_conversion_costs, for calling a non-const      member function from a const member function.  */
if|if
condition|(
operator|(
name|y
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator|&
name|CONST_CODE
operator|)
operator|^
operator|(
name|x
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator|&
name|CONST_CODE
operator|)
condition|)
return|return
name|y
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator|-
name|x
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
return|;
if|if
condition|(
name|y
operator|->
name|h
operator|.
name|code
operator|&
name|STD_CODE
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|h
operator|.
name|code
operator|&
name|STD_CODE
condition|)
return|return
name|y
operator|->
name|h
operator|.
name|distance
operator|-
name|x
operator|->
name|h
operator|.
name|distance
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|->
name|h
operator|.
name|code
operator|&
name|STD_CODE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|y
operator|->
name|h
operator|.
name|code
operator|-
name|x
operator|->
name|h
operator|.
name|code
return|;
block|}
end_block

begin_comment
comment|/* Compare two candidates, argument by argument.  */
end_comment

begin_function
name|int
name|rank_for_ideal
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|candidate
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|h_len
operator|!=
name|y
operator|->
name|h_len
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|h_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|-
name|x
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|code
condition|)
return|return
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|-
name|x
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|code
return|;
if|if
condition|(
operator|(
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|&
name|STD_CODE
operator|)
operator|&&
operator|(
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|distance
operator|-
name|x
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|distance
operator|)
condition|)
return|return
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|distance
operator|-
name|x
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|distance
return|;
comment|/* They're both the same code.  Now see if we're dealing with an 	 integral promotion that needs a finer grain of accuracy.  */
if|if
condition|(
name|y
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator|&
name|PROMO_CODE
operator|&&
operator|(
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
operator|^
name|x
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
operator|)
condition|)
return|return
name|y
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
operator|-
name|x
operator|->
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* TYPE is the type we wish to convert to.  PARM is the parameter    we have to work with.  We use a somewhat arbitrary cost function    to measure this conversion.  */
end_comment

begin_function
specifier|static
name|struct
name|harshness_code
name|convert_harshness
parameter_list|(
name|type
parameter_list|,
name|parmtype
parameter_list|,
name|parm
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|,
name|parmtype
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
name|struct
name|harshness_code
name|h
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|codel
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
name|int
name|lvalue
decl_stmt|;
name|h
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
name|h
operator|.
name|int_penalty
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_convert_harshness
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|parm
condition|)
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
name|lvalue
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
condition|)
name|lvalue
operator|=
name|lvalue_p
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|lvalue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|parmtype
argument_list|)
condition|)
name|parmtype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
name|codel
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|ZERO_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|constp
init|=
name|parm
condition|?
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
else|:
name|TYPE_READONLY
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
operator|(
name|parm
condition|?
name|TREE_THIS_VOLATILE
argument_list|(
name|parm
argument_list|)
else|:
name|TYPE_VOLATILE
argument_list|(
name|parmtype
argument_list|)
operator|)
decl_stmt|;
specifier|register
name|tree
name|intype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|int
name|penalty
init|=
literal|0
decl_stmt|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Only allow const reference binding if we were given a parm to deal          with, since it isn't really a conversion.  This is a hack to          prevent build_type_conversion from finding this conversion, but          still allow overloading to find it.  */
if|if
condition|(
operator|!
name|lvalue
operator|&&
operator|!
operator|(
name|parm
operator|&&
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|)
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|<
name|constp
operator|||
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|<
name|volatilep
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
comment|/* When passing a non-const argument into a const reference, dig it a 	 little, so a non-const reference is preferred over this one.  */
name|penalty
operator|=
operator|(
operator|(
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|>
name|constp
operator|)
operator|+
operator|(
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|>
name|volatilep
operator|)
operator|)
expr_stmt|;
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
name|ttr
operator|=
name|intype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|ZERO_RETURN
argument_list|(
name|h
argument_list|)
return|;
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
name|h
operator|=
name|convert_harshness
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|penalty
operator|&&
name|h
operator|.
name|code
operator|==
literal|0
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|QUAL_CODE
expr_stmt|;
name|h
operator|.
name|int_penalty
operator|=
name|penalty
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|fntype_p
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|struct
name|harshness_code
name|h1
decl_stmt|,
name|h2
decl_stmt|;
comment|/* Get to the METHOD_TYPE or FUNCTION_TYPE that this might be.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|type
operator|!=
name|parmtype
operator|&&
name|coder
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|ttl
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|h
operator|.
name|distance
operator|=
operator|-
name|b_or_d
expr_stmt|;
block|}
else|else
name|h
operator|.
name|distance
operator|=
name|b_or_d
expr_stmt|;
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We allow the default conversion between function type 	 and pointer-to-function type for free.  */
if|if
condition|(
name|comptypes
argument_list|(
name|type
argument_list|,
name|parmtype
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|h
return|;
if|if
condition|(
name|pedantic
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
comment|/* Compare return types.  */
name|p1
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
name|h2
operator|=
name|convert_harshness
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2
operator|.
name|code
operator|&
name|EVIL_CODE
condition|)
return|return
name|h2
return|;
name|h1
operator|.
name|code
operator|=
name|TRIVIAL_CODE
expr_stmt|;
name|h1
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h2
operator|.
name|distance
operator|!=
literal|0
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
comment|/* This only works for pointers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|p1
operator|=
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
comment|/* Don't die if we happen to be dealing with void*.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|p1
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|p2
argument_list|)
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|h2
operator|.
name|distance
operator|<
literal|0
condition|)
name|binfo
operator|=
name|get_binfo
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|binfo
operator|=
name|get_binfo
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|static int explained = 0; 	      if (h2.distance< 0) 		message_2_types (sorry, "cannot cast `%s' to `%s' at function call site", p2, p1); 	      else 		message_2_types (sorry, "cannot cast `%s' to `%s' at function call site", p1, p2);  	      if (! explained++) 		sorry ("(because pointer values change during conversion)");
endif|#
directive|endif
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
block|}
name|h1
operator|.
name|code
operator||=
name|h2
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|h2
operator|.
name|distance
operator|>
name|h1
operator|.
name|distance
condition|)
name|h1
operator|.
name|distance
operator|=
name|h2
operator|.
name|distance
expr_stmt|;
name|p1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|p2
operator|&&
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|h2
operator|=
name|convert_harshness
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2
operator|.
name|code
operator|&
name|EVIL_CODE
condition|)
return|return
name|h2
return|;
if|if
condition|(
name|h2
operator|.
name|distance
condition|)
block|{
comment|/* This only works for pointers and references. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|h2
operator|.
name|distance
operator|=
operator|-
name|h2
operator|.
name|distance
expr_stmt|;
block|}
name|h1
operator|.
name|code
operator||=
name|h2
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|h2
operator|.
name|distance
operator|>
name|h1
operator|.
name|distance
condition|)
name|h1
operator|.
name|distance
operator|=
name|h2
operator|.
name|distance
expr_stmt|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
name|h1
return|;
if|if
condition|(
name|p2
condition|)
block|{
if|if
condition|(
name|p1
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|h1
operator|.
name|code
operator||=
name|ELLIPSIS_CODE
expr_stmt|;
return|return
name|h1
return|;
block|}
if|if
condition|(
name|p1
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|h1
operator|.
name|code
operator||=
name|EVIL_CODE
expr_stmt|;
return|return
name|h1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
comment|/* Get to the OFFSET_TYPE that this might be.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|ttl
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
name|ttr
condition|)
name|h
operator|.
name|code
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|h
operator|.
name|distance
operator|=
operator|-
name|b_or_d
expr_stmt|;
block|}
else|else
name|h
operator|.
name|distance
operator|=
name|b_or_d
expr_stmt|;
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
block|}
comment|/* Now test the OFFSET_TYPE's target compatibility.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|codel
operator|==
name|FUNCTION_TYPE
operator|||
name|codel
operator|==
name|METHOD_TYPE
operator|||
operator|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
condition|)
return|return
name|TRIVIAL_RETURN
argument_list|(
name|h
argument_list|)
return|;
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|codel
operator|==
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|coder
argument_list|)
operator|||
name|coder
operator|==
name|REAL_TYPE
condition|)
return|return
name|STD_RETURN
argument_list|(
name|h
argument_list|)
return|;
elseif|else
if|if
condition|(
name|coder
operator|==
name|POINTER_TYPE
operator|||
name|coder
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Make this worse than any conversion to another pointer. 	     FIXME this is how I think the language should work, but it may not 	     end up being how the language is standardized (jason 1/30/95).  */
name|h
operator|.
name|distance
operator|=
literal|32767
expr_stmt|;
return|return
name|STD_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|codel
argument_list|)
condition|)
block|{
comment|/* Control equivalence of ints an enums.  */
if|if
condition|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
name|flag_int_enum_equivalence
operator|==
literal|0
condition|)
block|{
comment|/* Enums can be converted to ints, but not vice-versa.  */
if|if
condition|(
name|coder
operator|!=
name|ENUMERAL_TYPE
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
comment|/* else enums and ints (almost) freely interconvert.  */
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|coder
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_promotes_to
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|PROMO_CODE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* What purpose does this serve?  -jason */
comment|/* A char, short, wchar_t, etc., should promote to an int if 		 it can handle it, otherwise to an unsigned.  So we'll make 		 an unsigned.  */
block|if (type != integer_type_node) 		h.int_penalty = 1;
endif|#
directive|endif
block|}
else|else
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
return|return
name|h
return|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
return|return
name|h
return|;
block|}
block|}
if|if
condition|(
name|codel
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_promotes_to
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|h
operator|.
name|code
operator|=
name|PROMO_CODE
expr_stmt|;
else|else
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
return|return
name|h
return|;
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|coder
argument_list|)
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
return|return
name|h
return|;
block|}
block|}
comment|/* Convert arrays which have not previously been converted.  */
if|#
directive|if
literal|0
block|if (codel == ARRAY_TYPE)     codel = POINTER_TYPE;
endif|#
directive|endif
if|if
condition|(
name|coder
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|coder
operator|=
name|POINTER_TYPE
expr_stmt|;
if|if
condition|(
name|parm
condition|)
block|{
name|parm
operator|=
name|decay_conversion
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
name|parmtype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Conversions among pointers */
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|penalty
init|=
literal|4
operator|*
operator|(
name|ttl
operator|!=
name|ttr
operator|)
decl_stmt|;
comment|/* Anything converts to void *.  Since this may be `const void *' 	 (etc.) use VOID_TYPE instead of void_type_node.  Otherwise, the 	 targets must be the same, except that we do allow (at some cost) 	 conversion between signed and unsigned pointer types.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|penalty
condition|?
name|STD_CODE
else|:
literal|0
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
return|return
name|h
return|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|VOID_TYPE
operator|||
operator|!
name|parm
operator|||
operator|!
name|integer_zerop
argument_list|(
name|parm
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
name|penalty
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|parmtype
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
operator|&&
operator|(
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
operator|,
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
operator|,
name|penalty
operator|=
literal|10
operator|,
literal|0
operator|)
operator|)
operator|||
operator|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|penalty
operator|==
literal|10
operator|||
name|ttr
operator|==
name|ttl
condition|)
block|{
name|tree
name|tmp1
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|,
name|tmp2
init|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
comment|/* If one was unsigned but the other wasn't, then we need to 	     do a standard conversion from T to unsigned T.  */
if|if
condition|(
name|penalty
operator|==
literal|10
condition|)
name|h
operator|.
name|code
operator|=
name|PROMO_CODE
expr_stmt|;
comment|/* was STD_CODE */
else|else
name|h
operator|.
name|code
operator|=
literal|0
expr_stmt|;
comment|/* Note conversion from `T*' to `const T*', 	                       or `T*' to `volatile T*'.  */
if|if
condition|(
name|ttl
operator|==
name|ttr
operator|&&
operator|(
operator|(
name|TYPE_READONLY
argument_list|(
name|tmp1
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|tmp2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_VOLATILE
argument_list|(
name|tmp1
argument_list|)
operator|!=
name|TYPE_VOLATILE
argument_list|(
name|tmp2
argument_list|)
operator|)
operator|)
condition|)
name|h
operator|.
name|code
operator||=
name|QUAL_CODE
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
return|return
name|h
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|h
operator|.
name|distance
operator|=
operator|-
name|b_or_d
expr_stmt|;
block|}
else|else
name|h
operator|.
name|distance
operator|=
name|b_or_d
expr_stmt|;
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
return|return
name|h
return|;
block|}
comment|/* If converting from a `class*' to a `void*', make it 	 less favorable than any inheritance relationship.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
name|h
operator|.
name|distance
operator|=
name|CLASSTYPE_MAX_DEPTH
argument_list|(
name|ttr
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|h
return|;
block|}
name|h
operator|.
name|code
operator|=
name|penalty
condition|?
name|STD_CODE
else|:
name|PROMO_CODE
expr_stmt|;
comment|/* Catch things like `const char *' -> `const void *' 	 vs `const char *' -> `void *'.  */
if|if
condition|(
name|ttl
operator|!=
name|ttr
condition|)
block|{
name|tree
name|tmp1
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|,
name|tmp2
init|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_READONLY
argument_list|(
name|tmp1
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|tmp2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_VOLATILE
argument_list|(
name|tmp1
argument_list|)
operator|!=
name|TYPE_VOLATILE
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
name|h
operator|.
name|code
operator||=
name|QUAL_CODE
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* This is not a bad match, but don't let it beat 	 integer-enum combinations.  */
if|if
condition|(
name|parm
operator|&&
name|integer_zerop
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
return|return
name|h
return|;
block|}
block|}
comment|/* C++: Since the `this' parameter of a signature member function      is represented as a signature pointer to handle default implementations      correctly, we can have the case that `type' is a signature pointer      while `parmtype' is a pointer to a signature table.  We don't really      do any conversions in this case, so just return 0.  */
if|if
condition|(
name|codel
operator|==
name|RECORD_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
operator|&&
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
return|return
name|ZERO_RETURN
argument_list|(
name|h
argument_list|)
return|;
if|if
condition|(
name|codel
operator|==
name|RECORD_TYPE
operator|&&
name|coder
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|parmtype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
block|{
name|b_or_d
operator|=
name|get_base_distance
argument_list|(
name|parmtype
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
name|h
operator|.
name|distance
operator|=
operator|-
name|b_or_d
expr_stmt|;
block|}
else|else
name|h
operator|.
name|distance
operator|=
name|b_or_d
expr_stmt|;
name|h
operator|.
name|code
operator|=
name|STD_CODE
expr_stmt|;
return|return
name|h
return|;
block|}
return|return
name|EVIL_RETURN
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A clone of build_type_conversion for checking user-defined conversions in    overload resolution.  */
end_comment

begin_function
name|int
name|user_harshness
parameter_list|(
name|type
parameter_list|,
name|parmtype
parameter_list|,
name|parm
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|,
name|parmtype
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
name|tree
name|conv
decl_stmt|;
name|tree
name|winner
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|tree
name|typename
init|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|typename
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|conv
operator|=
name|lookup_conversions
argument_list|(
name|parmtype
argument_list|)
init|;
name|conv
condition|;
name|conv
operator|=
name|TREE_CHAIN
argument_list|(
name|conv
argument_list|)
control|)
block|{
name|struct
name|harshness_code
name|tmp
decl_stmt|;
if|if
condition|(
name|winner
operator|&&
name|TREE_PURPOSE
argument_list|(
name|winner
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|conv
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|=
name|convert_harshness
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|conv
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
operator|,
name|tmp
operator|.
name|code
operator|<
name|USER_CODE
operator|&&
name|tmp
operator|.
name|distance
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|winner
condition|)
return|return
name|EVIL_CODE
return|;
else|else
block|{
name|winner
operator|=
name|conv
expr_stmt|;
name|code
operator|=
name|tmp
operator|.
name|code
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|winner
condition|)
return|return
name|code
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|can_convert
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
name|struct
name|harshness_code
name|h
decl_stmt|;
name|h
operator|=
name|convert_harshness
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|h
operator|.
name|code
operator|<
name|USER_CODE
operator|&&
name|h
operator|.
name|distance
operator|>=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|can_convert_arg
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|arg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|arg
decl_stmt|;
block|{
name|struct
name|harshness_code
name|h
decl_stmt|;
name|h
operator|=
name|convert_harshness
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|h
operator|.
name|code
operator|<
name|USER_CODE
operator|&&
name|h
operator|.
name|distance
operator|>=
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_MATCHING
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|print_harshness
parameter_list|(
name|h
parameter_list|)
name|struct
name|harshness_code
modifier|*
name|h
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|tmp
index|[
literal|1024
index|]
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
literal|1024
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"codes=["
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|EVIL_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"EVIL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|CONST_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" CONST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|ELLIPSIS_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" ELLIPSIS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|USER_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|STD_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" STD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|PROMO_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" PROMO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|QUAL_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" QUAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|code
operator|&
name|TRIVIAL_CODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" TRIVIAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"] distance=%d int_penalty=%d"
argument_list|,
name|h
operator|->
name|distance
argument_list|,
name|h
operator|->
name|int_penalty
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Algorithm: For each argument, calculate how difficult it is to    make FUNCTION accept that argument.  If we can easily tell that    FUNCTION won't be acceptable to one of the arguments, then we    don't need to compute the ease of converting the other arguments,    since it will never show up in the intersection of all arguments'    favorite functions.     Conversions between builtin and user-defined types are allowed, but    no function involving such a conversion is preferred to one which    does not require such a conversion.  Furthermore, such conversions    must be unique.  */
end_comment

begin_function
name|void
name|compute_conversion_costs
parameter_list|(
name|function
parameter_list|,
name|tta_in
parameter_list|,
name|cp
parameter_list|,
name|arglen
parameter_list|)
name|tree
name|function
decl_stmt|;
name|tree
name|tta_in
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|int
name|arglen
decl_stmt|;
block|{
name|tree
name|ttf_in
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ttf
init|=
name|ttf_in
decl_stmt|;
name|tree
name|tta
init|=
name|tta_in
decl_stmt|;
comment|/* Start out with no strikes against.  */
name|int
name|evil_strikes
init|=
literal|0
decl_stmt|;
name|int
name|ellipsis_strikes
init|=
literal|0
decl_stmt|;
name|int
name|user_strikes
init|=
literal|0
decl_stmt|;
name|int
name|b_or_d_strikes
init|=
literal|0
decl_stmt|;
name|int
name|easy_strikes
init|=
literal|0
decl_stmt|;
name|int
name|strike_index
init|=
literal|0
decl_stmt|,
name|win
decl_stmt|;
name|struct
name|harshness_code
name|lose
decl_stmt|;
specifier|extern
name|int
name|cp_silent
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_compute_conversion_costs
operator|++
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DEBUG_MATCHING
comment|/* We don't emit any warnings or errors while trying out each candidate.  */
name|cp_silent
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|arg
operator|=
name|tta
condition|?
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
literal|0
expr_stmt|;
comment|/* optimistic!  */
name|cp
operator|->
name|h
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|h
operator|.
name|int_penalty
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|->
name|harshness
argument_list|,
operator|(
name|cp
operator|->
name|h_len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|harshness_code
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ttf
operator|&&
name|tta
condition|)
block|{
name|struct
name|harshness_code
name|h
decl_stmt|;
if|if
condition|(
name|ttf
operator|==
name|void_list_node
condition|)
break|break;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Must perform some instantiation here.  */
name|tree
name|rhs
init|=
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
decl_stmt|;
comment|/* Keep quiet about possible contravariance violations.  */
name|int
name|old_inhibit_warnings
init|=
name|inhibit_warnings
decl_stmt|;
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
comment|/* @@ This is to undo what `grokdeclarator' does to 	     parameter types.  It really should go through 	     something more general.  */
name|TREE_TYPE
argument_list|(
name|tta
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inhibit_warnings
operator|=
name|old_inhibit_warnings
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
else|else
name|h
operator|=
name|convert_harshness
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_MATCHING
specifier|static
name|tree
name|old_function
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|old_function
operator|||
name|function
operator|!=
name|old_function
condition|)
block|{
name|cp_error
argument_list|(
literal|"trying %D"
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|old_function
operator|=
name|function
expr_stmt|;
block|}
name|cp_error
argument_list|(
literal|"      doing (%T) %E against arg %T"
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
name|convert_harshness
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MATCHING
name|cp_error
argument_list|(
literal|"     evaluated %s"
argument_list|,
name|print_harshness
argument_list|(
operator|&
name|h
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
operator|)
operator|||
operator|(
operator|(
name|h
operator|.
name|code
operator|&
name|STD_CODE
operator|)
operator|&&
name|h
operator|.
name|distance
operator|<
literal|0
operator|)
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
name|strike_index
expr_stmt|;
name|evil_strikes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|.
name|code
operator|&
name|ELLIPSIS_CODE
condition|)
name|ellipsis_strikes
operator|+=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is never set by `convert_harshness'.  */
if|else if (h.code& USER_CODE) 	{ 	  user_strikes += 1; 	}
endif|#
directive|endif
else|else
block|{
if|if
condition|(
operator|(
name|h
operator|.
name|code
operator|&
name|STD_CODE
operator|)
operator|&&
name|h
operator|.
name|distance
condition|)
block|{
if|if
condition|(
name|h
operator|.
name|distance
operator|>
name|b_or_d_strikes
condition|)
name|b_or_d_strikes
operator|=
name|h
operator|.
name|distance
expr_stmt|;
block|}
else|else
name|easy_strikes
operator|+=
operator|(
name|h
operator|.
name|code
operator|&
operator|(
name|STD_CODE
operator||
name|PROMO_CODE
operator||
name|TRIVIAL_CODE
operator|)
operator|)
expr_stmt|;
name|cp
operator|->
name|h
operator|.
name|code
operator||=
name|h
operator|.
name|code
expr_stmt|;
comment|/* Make sure we communicate this.  */
name|cp
operator|->
name|h
operator|.
name|int_penalty
operator|+=
name|h
operator|.
name|int_penalty
expr_stmt|;
block|}
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|strike_index
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tta
condition|)
block|{
comment|/* ran out of formals, and parmlist is fixed size.  */
if|if
condition|(
name|ttf
comment|/* == void_type_node */
condition|)
block|{
name|cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|1
expr_stmt|;
name|cp_silent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|harshness_code
name|h
decl_stmt|;
name|int
name|l
init|=
name|list_length
argument_list|(
name|tta
argument_list|)
decl_stmt|;
name|ellipsis_strikes
operator|+=
name|l
expr_stmt|;
name|h
operator|.
name|code
operator|=
name|ELLIPSIS_CODE
expr_stmt|;
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
name|h
operator|.
name|int_penalty
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
condition|;
operator|--
name|l
control|)
name|cp
operator|->
name|harshness
index|[
name|strike_index
operator|++
index|]
operator|=
name|h
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ttf
operator|&&
name|ttf
operator|!=
name|void_list_node
condition|)
block|{
comment|/* ran out of actuals, and no defaults.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|ttf
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|2
expr_stmt|;
name|cp_silent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Store index of first default.  */
name|cp
operator|->
name|harshness
index|[
name|arglen
index|]
operator|.
name|distance
operator|=
name|strike_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|harshness
index|[
name|arglen
index|]
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
comment|/* Argument list lengths work out, so don't need to check them again.  */
if|if
condition|(
name|evil_strikes
condition|)
block|{
comment|/* We do not check for derived->base conversions here, since in 	 no case would they give evil strike counts, unless such conversions 	 are somehow ambiguous.  */
comment|/* See if any user-defined conversions apply.          But make sure that we do not loop.  */
specifier|static
name|int
name|dont_convert_types
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dont_convert_types
condition|)
block|{
name|cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
name|cp_silent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|win
operator|=
literal|0
expr_stmt|;
comment|/* Only get one chance to win.  */
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tta
operator|=
name|tta_in
expr_stmt|;
name|strike_index
operator|=
literal|0
expr_stmt|;
name|evil_strikes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ttf
operator|&&
name|tta
condition|)
block|{
if|if
condition|(
name|ttf
operator|==
name|void_list_node
condition|)
break|break;
name|lose
operator|=
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|lose
operator|.
name|code
operator|&
name|EVIL_CODE
operator|)
operator|||
operator|(
operator|(
name|lose
operator|.
name|code
operator|&
name|STD_CODE
operator|)
operator|&&
name|lose
operator|.
name|distance
operator|<
literal|0
operator|)
condition|)
block|{
name|tree
name|actual_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|formal_type
init|=
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
decl_stmt|;
name|int
name|extra_conversions
init|=
literal|0
decl_stmt|;
name|dont_convert_types
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|formal_type
operator|=
name|TREE_TYPE
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|actual_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|actual_type
operator|=
name|TREE_TYPE
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|!=
name|error_mark_node
operator|&&
name|actual_type
operator|!=
name|error_mark_node
condition|)
block|{
name|formal_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
name|actual_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|formal_type
argument_list|)
condition|)
block|{
comment|/* If it has a constructor for this type, 			 try to use it.  */
comment|/* @@ There is no way to save this result yet, so 			 success is a NULL_TREE for now.  */
if|if
condition|(
name|convert_to_aggr
argument_list|(
name|formal_type
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|win
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|actual_type
argument_list|)
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
block|{
name|int
name|extra
init|=
name|user_harshness
argument_list|(
name|formal_type
argument_list|,
name|actual_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|extra
operator|==
name|EVIL_CODE
condition|)
name|win
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|extra
operator|>=
literal|0
condition|)
block|{
name|win
operator|++
expr_stmt|;
name|extra_conversions
operator|=
name|extra
expr_stmt|;
block|}
block|}
block|}
name|dont_convert_types
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|1
condition|)
block|{
name|user_strikes
operator|+=
literal|1
expr_stmt|;
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
operator|.
name|code
operator|=
name|USER_CODE
operator||
operator|(
name|extra_conversions
condition|?
name|STD_CODE
else|:
literal|0
operator|)
expr_stmt|;
name|win
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|>
name|strike_index
condition|)
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
name|strike_index
expr_stmt|;
name|evil_strikes
operator|=
name|win
condition|?
literal|2
else|:
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|strike_index
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Const member functions get a small penalty because defaulting      to const is less useful than defaulting to non-const. */
comment|/* This is bogus, it does not correspond to anything in the ARM.      This code will be fixed when this entire section is rewritten      to conform to the ARM.  (mrs)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|this_parm
init|=
name|TREE_VALUE
argument_list|(
name|ttf_in
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|this_parm
argument_list|)
operator|==
name|RECORD_TYPE
comment|/* Is `this' a sig ptr?  */
condition|?
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|this_parm
argument_list|)
argument_list|)
argument_list|)
argument_list|)
else|:
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_parm
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator||=
name|TRIVIAL_CODE
expr_stmt|;
operator|++
name|easy_strikes
expr_stmt|;
block|}
else|else
block|{
comment|/* Calling a non-const member function from a const member function 	     is probably invalid, but for now we let it only draw a warning. 	     We indicate that such a mismatch has occurred by setting the 	     harshness to a maximum value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta_in
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta_in
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator||=
name|CONST_CODE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|evil_strikes
condition|)
name|cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
if|if
condition|(
name|ellipsis_strikes
condition|)
name|cp
operator|->
name|h
operator|.
name|code
operator||=
name|ELLIPSIS_CODE
expr_stmt|;
if|if
condition|(
name|user_strikes
condition|)
name|cp
operator|->
name|h
operator|.
name|code
operator||=
name|USER_CODE
expr_stmt|;
name|cp_silent
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MATCHING
name|cp_error
argument_list|(
literal|"final eval %s"
argument_list|,
name|print_harshness
argument_list|(
operator|&
name|cp
operator|->
name|h
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Subroutine of ideal_candidate.  See if X or Y is a better match    than the other.  */
end_comment

begin_function
specifier|static
name|int
name|strictly_better
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|unsigned
name|short
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|unsigned
name|short
name|xor
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|0
return|;
name|xor
operator|=
name|x
operator|^
name|y
expr_stmt|;
if|if
condition|(
name|xor
operator|>=
name|x
operator|||
name|xor
operator|>=
name|y
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When one of several possible overloaded functions and/or methods    can be called, choose the best candidate for overloading.     BASETYPE is the context from which we start method resolution    or NULL if we are comparing overloaded functions.    CANDIDATES is the array of candidates we have to choose from.    N_CANDIDATES is the length of CANDIDATES.    PARMS is a TREE_LIST of parameters to the function we'll ultimately    choose.  It is modified in place when resolving methods.  It is not    modified in place when resolving overloaded functions.    LEN is the length of the parameter list.  */
end_comment

begin_function
specifier|static
name|struct
name|candidate
modifier|*
name|ideal_candidate
parameter_list|(
name|basetype
parameter_list|,
name|candidates
parameter_list|,
name|n_candidates
parameter_list|,
name|parms
parameter_list|,
name|len
parameter_list|)
name|tree
name|basetype
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|int
name|n_candidates
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|candidate
modifier|*
name|cp
init|=
name|candidates
operator|+
name|n_candidates
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
operator|-
literal|1
decl_stmt|,
name|best_code
decl_stmt|;
comment|/* For each argument, sort the functions from best to worst for the arg.      For each function that's not best for this arg, set its overall      harshness to EVIL so that other args won't like it.  The candidate      list for the last argument is the intersection of all the best-liked      functions.  */
if|#
directive|if
literal|0
block|for (i = 0; i< len; i++)     {       qsort (candidates, n_candidates, sizeof (struct candidate), 	     rank_for_overload);       best_code = cp[-1].h.code;
comment|/* To find out functions that are worse than that represented 	 by BEST_CODE, we can't just do a comparison like h.code>best_code. 	 The total harshness for the "best" fn may be 8|8 for two args, and 	 the harshness for the next-best may be 8|2.  If we just compared, 	 that would be checking 8>10, which would lead to the next-best 	 being disqualified.  What we actually want to do is get rid 	 of functions that are definitely worse than that represented 	 by best_code, i.e. those which have bits set higher than the 	 highest in best_code.  Sooooo, what we do is clear out everything 	 represented by best_code, and see if we still come up with something 	 higher.  If so (e.g., 8|8 vs 8|16), it'll disqualify it properly.  */
block|for (j = n_candidates-2; j>= 0; j--) 	if ((candidates[j].h.code& ~best_code)> best_code) 	  candidates[j].h.code = EVIL_CODE;     }    if (cp[-1].h.code& EVIL_CODE)     return NULL;
else|#
directive|else
name|qsort
argument_list|(
name|candidates
argument_list|,
name|n_candidates
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|,
name|rank_for_overload
argument_list|)
expr_stmt|;
name|best_code
operator|=
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|h
operator|.
name|code
expr_stmt|;
endif|#
directive|endif
comment|/* If they're at least as good as each other, do an arg-by-arg check.  */
if|if
condition|(
operator|!
name|strictly_better
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|h
operator|.
name|code
argument_list|,
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|h
operator|.
name|code
argument_list|)
condition|)
block|{
name|int
name|better
init|=
literal|0
decl_stmt|;
name|int
name|worse
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_candidates
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strictly_better
argument_list|(
name|candidates
index|[
name|j
index|]
operator|.
name|h
operator|.
name|code
argument_list|,
name|best_code
argument_list|)
condition|)
break|break;
name|qsort
argument_list|(
name|candidates
operator|+
name|j
argument_list|,
name|n_candidates
operator|-
name|j
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|,
name|rank_for_ideal
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|<
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|code
condition|)
name|better
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|>
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|code
condition|)
name|worse
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|&
name|STD_CODE
condition|)
block|{
comment|/* If it involves a standard conversion, let the 		 inheritance lattice be the final arbiter.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|distance
operator|>
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|distance
condition|)
name|worse
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|distance
operator|<
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|distance
condition|)
name|better
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|code
operator|&
name|PROMO_CODE
condition|)
block|{
comment|/* For integral promotions, take into account a finer 		 granularity for determining which types should be favored 		 over others in such promotions.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
operator|>
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
condition|)
name|worse
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
operator|<
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|i
index|]
operator|.
name|int_penalty
condition|)
name|better
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|better
operator|||
name|worse
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|cp
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assume that if the class referred to is not in the    current class hierarchy, that it may be remote.    PARENT is assumed to be of aggregate type here.  */
end_comment

begin_function
specifier|static
name|int
name|may_be_remote
parameter_list|(
name|parent
parameter_list|)
name|tree
name|parent
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|parent
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|parent
operator|==
name|current_class_type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|parent
argument_list|,
name|current_class_type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|tree
name|build_vfield_ref
parameter_list|(
name|datum
parameter_list|,
name|type
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|int
name|old_assume_nonnull_objects
init|=
name|flag_assume_nonnull_objects
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Vtable references are always made from non-null objects.  */
name|flag_assume_nonnull_objects
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flag_assume_nonnull_objects
operator|=
name|old_assume_nonnull_objects
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a member of an object.  I.e., one that overloads    operator ()(), or is a pointer-to-function or pointer-to-method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_call
parameter_list|(
name|basetype_path
parameter_list|,
name|instance_ptr
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|instance_ptr
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|,
name|instance
decl_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|current_class_decl
condition|)
block|{
comment|/* Check to see if we really have a reference to an instance variable 	 with `operator()()' overloaded.  */
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"`this' has no member named `%D'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* If it's a field, try overloading operator (), 	     or calling if the field is a pointer-to-function.  */
name|instance
operator|=
name|build_component_ref_1
argument_list|(
name|C_C_D
argument_list|,
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|parms
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_decl
argument_list|,
name|parms
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check to see if this is not really a reference to an instance variable      with `operator()()' overloaded.  */
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen if the reference was ambiguous or for access      violations.  */
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
condition|)
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ftype
operator|=
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|ftype
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|ftype
argument_list|)
condition|)
block|{
comment|/* Make the next search for this field very short.  */
name|basetype
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|build_component_ref_1
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* This is a member which is a pointer to function.  */
name|tree
name|ref
init|=
name|build_component_ref_1
argument_list|(
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|field
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_function_call
argument_list|(
name|ref
argument_list|,
name|parms
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid call via pointer-to-member function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|find_scoped_type
parameter_list|(
name|type
parameter_list|,
name|inner_name
parameter_list|,
name|inner_types
parameter_list|)
name|tree
name|type
decl_stmt|,
name|inner_name
decl_stmt|,
name|inner_types
decl_stmt|;
block|{
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
comment|/* The TREE_PURPOSE of an enum tag (which becomes a member of the 	 enclosing class) is set to the name for the enum type.  So, if 	 inner_name is `bar', and we strike `baz' for `enum bar { baz }', 	 then this test will be true.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
operator|==
name|inner_name
condition|)
block|{
if|if
condition|(
name|inner_types
operator|==
name|NULL_TREE
condition|)
return|return
name|DECL_NESTED_TYPENAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|resolve_scope_to_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
block|}
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX This needs to be fixed better.  */
block|if (TREE_CODE (type) == UNINSTANTIATED_P_TYPE)     {       sorry ("nested class lookup in template type");       return NULL_TREE;     }
endif|#
directive|endif
comment|/* Look for a TYPE_DECL.  */
for|for
control|(
name|tags
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tags
condition|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tags
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|tags
argument_list|)
operator|==
name|inner_name
condition|)
block|{
comment|/* Code by raeburn.  */
if|if
condition|(
name|inner_types
operator|==
name|NULL_TREE
condition|)
return|return
name|DECL_NESTED_TYPENAME
argument_list|(
name|tags
argument_list|)
return|;
return|return
name|resolve_scope_to_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|inner_types
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Resolve an expression NAME1::NAME2::...::NAMEn to    the name that names the above nested type.  INNER_TYPES    is a chain of nested type names (held together by SCOPE_REFs);    OUTER_TYPE is the type we know to enclose INNER_TYPES.    Returns NULL_TREE if there is an error.  */
end_comment

begin_function
name|tree
name|resolve_scope_to_name
parameter_list|(
name|outer_type
parameter_list|,
name|inner_stuff
parameter_list|)
name|tree
name|outer_type
decl_stmt|,
name|inner_stuff
decl_stmt|;
block|{
specifier|register
name|tree
name|tmp
decl_stmt|;
name|tree
name|inner_name
decl_stmt|,
name|inner_type
decl_stmt|;
if|if
condition|(
name|outer_type
operator|==
name|NULL_TREE
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We first try to look for a nesting in our current class context,          then try any enclosing classes.  */
name|tree
name|type
init|=
name|current_class_type
decl_stmt|;
while|while
condition|(
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
block|{
name|tree
name|rval
init|=
name|resolve_scope_to_name
argument_list|(
name|type
argument_list|,
name|inner_stuff
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
operator|!=
name|NULL_TREE
condition|)
return|return
name|rval
return|;
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_stuff
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|inner_name
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_stuff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_stuff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inner_name
operator|=
name|inner_stuff
expr_stmt|;
name|inner_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|outer_type
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|x
decl_stmt|;
comment|/* If we have something that's already a type by itself, 	 use that.  */
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|inner_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|inner_type
condition|)
return|return
name|resolve_scope_to_name
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|inner_name
argument_list|)
argument_list|,
name|inner_type
argument_list|)
return|;
return|return
name|inner_name
return|;
block|}
name|x
operator|=
name|lookup_name
argument_list|(
name|inner_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|x
operator|=
name|lookup_namespace_name
argument_list|(
name|x
argument_list|,
name|inner_type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|outer_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Look for member classes or enums.  */
name|tmp
operator|=
name|find_scoped_type
argument_list|(
name|outer_type
argument_list|,
name|inner_name
argument_list|,
name|inner_type
argument_list|)
expr_stmt|;
comment|/* If it's not a type in this class, then go down into the      base classes and search there.  */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|TYPE_BINFO
argument_list|(
name|outer_type
argument_list|)
condition|)
block|{
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|outer_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|resolve_scope_to_name
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|inner_stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
block|}
name|tmp
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.    This is how virtual function calls are avoided.  */
end_comment

begin_function
name|tree
name|build_scoped_method_call
parameter_list|(
name|exp
parameter_list|,
name|scopes
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|scopes
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
block|{
comment|/* Because this syntactic form does not allow      a pointer to a base class to be `stolen',      we need not protect the derived->base conversion      that happens here.            @@ But we do have to check access privileges later.  */
name|tree
name|basename
init|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|scopes
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|basename
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Destructors can be "called" for simple types; see 5.2.4 and 12.4 Note      that explicit ~int is caught in the parser; this deals with typedefs      and template parms.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
operator|!
name|is_aggr_typedef
argument_list|(
name|basename
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|basetype
condition|)
name|cp_error
argument_list|(
literal|"type of `%E' does not match destructor type `%T' (type was `%T')"
argument_list|,
name|exp
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|!=
name|get_type_value
argument_list|(
name|name
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"qualified type `%T' does not match destructor name `~%T'"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|basename
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"base object `%E' of scoped method call is of non-aggregate type `%T'"
argument_list|,
name|exp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_scoped_ref
argument_list|(
name|exp
argument_list|,
name|scopes
argument_list|)
expr_stmt|;
comment|/* Call to a destructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
comment|/* Explicit call to destructor.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|name
operator|==
name|constructor_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|get_type_value
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"qualified type `%T' does not match destructor name `~%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Call to a method.  */
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_candidates
parameter_list|(
name|candidates
parameter_list|)
name|tree
name|candidates
decl_stmt|;
block|{
name|cp_error_at
argument_list|(
literal|"candidates are: %D"
argument_list|,
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|TREE_CHAIN
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
while|while
condition|(
name|candidates
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"                %D"
argument_list|,
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|TREE_CHAIN
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_n_candidates
parameter_list|(
name|candidates
parameter_list|,
name|n
parameter_list|)
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|cp_error_at
argument_list|(
literal|"candidates are: %D"
argument_list|,
name|candidates
index|[
literal|0
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|cp_error_at
argument_list|(
literal|"                %D"
argument_list|,
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build something of the form ptr->method (args)    or object.method (args).  This can also build    calls to constructors, and find friends.     Member functions always take their class variable    as a pointer.     INSTANCE is a class instance.     NAME is the name of the method desired, usually an IDENTIFIER_NODE.     PARMS help to figure out what that NAME really refers to.     BASETYPE_PATH, if non-NULL, contains a chain from the type of INSTANCE    down to the real instance type to use for access checking.  We need this    information to get protected accesses correct.  This parameter is used    by build_member_call.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     If this is all OK, calls build_function_call with the resolved    member function.     This function must also handle being called to perform    initialization, promotion/coercion of arguments, and    instantiation of default parameters.     Note that NAME may refer to an instance variable name.  If    `operator()()' is defined for the type of that field, then we return    that result.  */
end_comment

begin_function
name|tree
name|build_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|function
decl_stmt|,
name|fntype
decl_stmt|,
name|value_type
decl_stmt|;
specifier|register
name|tree
name|basetype
decl_stmt|,
name|save_basetype
decl_stmt|;
specifier|register
name|tree
name|baselink
decl_stmt|,
name|result
decl_stmt|,
name|method_name
decl_stmt|,
name|parmtypes
decl_stmt|,
name|parm
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|enum
name|access_type
name|access
init|=
name|access_public
decl_stmt|;
comment|/* Range of cases for vtable optimization.  */
enum|enum
name|vtable_needs
block|{
name|not_needed
block|,
name|maybe_needed
block|,
name|unneeded
block|,
name|needed
block|}
enum|;
name|enum
name|vtable_needs
name|need_vtbl
init|=
name|not_needed
decl_stmt|;
name|char
modifier|*
name|name_kind
decl_stmt|;
name|int
name|ever_seen
init|=
literal|0
decl_stmt|;
name|tree
name|instance_ptr
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|all_virtual
init|=
name|flag_all_virtual
decl_stmt|;
name|int
name|static_call_context
init|=
literal|0
decl_stmt|;
name|tree
name|found_fns
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Keep track of `const' and `volatile' objects.  */
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_build_method_call
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
operator|||
operator|(
name|instance
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* This is the logic that magically deletes the second argument to      operator delete, if it is not needed. */
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|&&
name|list_length
argument_list|(
name|parms
argument_list|)
operator|==
literal|2
condition|)
block|{
name|tree
name|save_last
init|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* get rid of unneeded argument */
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|result
operator|=
name|build_method_call
argument_list|(
name|instance
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|flags
operator|)
operator|&
operator|~
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
comment|/* If it finds a match, return it. */
if|if
condition|(
name|result
condition|)
return|return
name|build_method_call
argument_list|(
name|instance
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
name|flags
argument_list|)
return|;
comment|/* If it doesn't work, two argument delete must work */
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|save_last
expr_stmt|;
block|}
comment|/* We already know whether it's needed or not for vec delete.  */
elseif|else
if|if
condition|(
name|name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
operator|&&
operator|!
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|flags
operator||=
name|LOOKUP_DESTRUCTOR
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
condition|)
name|error
argument_list|(
literal|"destructors take no parameters"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
operator|)
operator|||
name|basetype
operator|==
name|get_type_value
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"destructor name `~%D' does not match type `%T' of expression"
argument_list|,
name|name
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|instance
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|instance
argument_list|)
return|;
name|instance
operator|=
name|default_conversion
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|{
name|char
modifier|*
name|xref_name
decl_stmt|;
comment|/* Initialize name for error reporting.  */
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|xref_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|xref_name
argument_list|,
literal|"operator %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|xref_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xref_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|xref_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
condition|)
block|{
name|basetype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check cases where this is really a call to raise 	 an exception.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|basetype
operator|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|basetype
operator|=
name|purpose_member
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* call to a constructor... */
elseif|else
if|if
condition|(
name|basetype_path
condition|)
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|constructor_name_full
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|typedef_name
init|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedef_name
operator|&&
name|TREE_CODE
argument_list|(
name|typedef_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Canonicalize the typedef name.  */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|typedef_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"no constructor named `%T' in scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|non_aggr_error
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|cp_error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|name
argument_list|,
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|C_C_D
operator|||
name|instance
operator|==
name|current_class_decl
condition|)
block|{
comment|/* When doing initialization, we side-effect the TREE_TYPE of 	 C_C_D, hence we cannot set up BASETYPE from CURRENT_CLASS_TYPE.  */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|C_C_D
argument_list|)
expr_stmt|;
comment|/* Anything manifestly `this' in constructors and destructors 	 has a known type, so virtual function tables are not needed.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
condition|)
name|need_vtbl
operator|=
operator|(
name|dtor_label
operator|||
name|ctor_label
operator|)
condition|?
name|unneeded
else|:
name|maybe_needed
expr_stmt|;
comment|/* If `this' is a signature pointer and `name' is not a constructor, 	 we are calling a signature member function.  In that case, set the 	 `basetype' to the signature type and dereference the `optr' field.  */
if|if
condition|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|!=
name|name
condition|)
block|{
name|basetype
operator|=
name|SIGNATURE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|build_optr_ref
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|instance
operator|=
name|C_C_D
expr_stmt|;
name|instance_ptr
operator|=
name|current_class_decl
expr_stmt|;
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_field_call
argument_list|(
name|basetype_path
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* Should we ever have to make a virtual function reference 	 from a RESULT_DECL, know that it must be of fixed type 	 within the scope of this function.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|need_vtbl
operator|=
name|maybe_needed
expr_stmt|;
name|instance_ptr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The MAIN_VARIANT of the type that `instance_ptr' winds up being.  */
name|tree
name|inst_ptr_basetype
decl_stmt|;
name|static_call_context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|instance
operator|=
name|resolve_offset_ref
argument_list|(
name|instance
argument_list|)
expr_stmt|;
comment|/* the base type of an instance variable is pointer to class */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
goto|goto
name|non_aggr_error
goto|;
comment|/* Call to convert not needed because we are remaining 	     within the same type.  */
name|instance_ptr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|inst_ptr_basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|basetype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|basetype
argument_list|)
operator|)
operator|)
condition|)
goto|goto
name|non_aggr_error
goto|;
comment|/* If `instance' is a signature pointer/reference and `name' is 	     not a constructor, we are calling a signature member function. 	     In that case set the `basetype' to the signature type.  */
if|if
condition|(
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|basetype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|basetype
argument_list|)
operator|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|!=
name|name
condition|)
name|basetype
operator|=
name|SIGNATURE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|instance_ptr
operator|=
name|instance
operator|)
operator|)
operator|||
operator|(
name|lvalue_p
argument_list|(
name|instance
argument_list|)
operator|&&
operator|(
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance_ptr
operator|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* A cast is not an lvalue.  Initialize a fresh temp 		 with the value we are casting from, and proceed with 		 that temporary.  We can't cast to a reference type, 		 so that simplifies the initialization to something 		 we can manage.  */
name|tree
name|temp
init|=
name|get_temp_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|temp
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|store_init_value
argument_list|(
name|temp
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|instance
operator|=
name|temp
expr_stmt|;
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
name|my_friendly_abort
argument_list|(
literal|125
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
condition|)
name|instance
operator|=
name|build_cplus_new
argument_list|(
name|basetype
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|instance
operator|=
name|get_temp_name
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|instance
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* @@ Should we call comp_target_types here?  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
name|inst_ptr_basetype
operator|=
name|basetype
expr_stmt|;
else|else
name|inst_ptr_basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|inst_ptr_basetype
argument_list|)
condition|)
name|basetype
operator|=
name|inst_ptr_basetype
expr_stmt|;
else|else
block|{
name|instance_ptr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* After converting `instance_ptr' above, `inst_ptr_basetype' was 	 not updated, so we use `basetype' instead.  */
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
operator|&&
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
operator|||
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|inst_ptr_basetype
argument_list|)
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|inst_ptr_basetype
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|basetype_path
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance_ptr
argument_list|)
condition|)
block|{
comment|/* This action is needed because the instance is needed 		 for providing the base of the virtual function table. 		 Without using a SAVE_EXPR, the function we are building 		 may be called twice, or side effects on the instance 		 variable (such as a post-increment), may happen twice.  */
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* This happens when called for operator new ().  */
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|need_vtbl
operator|=
name|maybe_needed
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is worth complaining about, I think.  */
name|cp_error
argument_list|(
literal|"cannot lookup method in incomplete type `%T'"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|save_basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (all_virtual == 1&& (! strncmp (IDENTIFIER_POINTER (name), OPERATOR_METHOD_FORMAT, 		     OPERATOR_METHOD_LENGTH) 	  || instance_ptr == NULL_TREE 	  || (TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype) == 0)))     all_virtual = 0;
endif|#
directive|endif
name|last
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|parmtypes
operator|=
name|NULL_TREE
operator|,
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Convert OFFSET_TYPE entities to their normal selves.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|resolve_offset_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This breaks reference-to-array parameters.  */
block|if (TREE_CODE (t) == ARRAY_TYPE) 	{
comment|/* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place. 	     This eliminates needless calls to `compute_conversion_costs'.  */
block|TREE_VALUE (parm) = default_conversion (TREE_VALUE (parm)); 	  t = TREE_TYPE (TREE_VALUE (parm)); 	}
endif|#
directive|endif
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|last
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|chainon
argument_list|(
name|parmtypes
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|&&
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* @@ Should this be the constp/volatilep flags for the optr field 	 of the signature pointer?  */
name|constp
operator|=
name|TYPE_READONLY
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TYPE_VOLATILE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
condition|)
block|{
comment|/* TREE_READONLY (instance) fails for references.  */
name|constp
operator|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw constructors are always in charge.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
block|}
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|instance_ptr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL_TREE
condition|)
name|last
operator|=
name|parmtypes
expr_stmt|;
comment|/* Look up function name in the structure type definition.  */
if|if
condition|(
operator|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|!=
name|UNINSTANTIATED_P_TYPE
operator|)
operator|||
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|basetype
operator|||
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
condition|)
name|tmp
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|get_binfo
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
condition|)
block|{
name|name_kind
operator|=
literal|"constructor"
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
comment|/* Constructors called for initialization 		 only are never in charge.  */
name|tree
name|tmplist
decl_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|tmplist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|tmplist
expr_stmt|;
name|tmplist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|tmplist
expr_stmt|;
block|}
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|name_kind
operator|=
literal|"method"
expr_stmt|;
block|}
else|else
name|name_kind
operator|=
literal|"method"
expr_stmt|;
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
operator|||
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* Now, go look for this method name.  We do not find destructors here.       Putting `void_list_node' on the end of the parmtypes      fakes out `build_decl_overload' into doing the right thing.  */
block|TREE_CHAIN (last) = void_list_node;   method_name = build_decl_overload (name, parmtypes, 				     1 + (name == constructor_name (save_basetype) 					  || name == constructor_name_full (save_basetype)));   TREE_CHAIN (last) = NULL_TREE;
endif|#
directive|endif
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|best
init|=
literal|1
decl_stmt|;
comment|/* This increments every time we go up the type hierarchy. 	 The idea is to prefer a function of the derived class if possible. */
name|int
name|b_or_d
init|=
literal|0
decl_stmt|;
name|baselink
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|candidates
operator|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|ever_seen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|candidates
argument_list|,
operator|(
name|ever_seen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|candidates
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|ever_seen
operator|=
literal|0
expr_stmt|;
comment|/* First see if a global function has a shot at it.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
block|{
name|tree
name|friend_parms
decl_stmt|;
name|tree
name|parm
init|=
name|instance_ptr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|parm
operator|=
name|build_indirect_ref
argument_list|(
name|parm
argument_list|,
literal|"friendifying parms (compiler error)"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|167
argument_list|)
expr_stmt|;
name|friend_parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|h_len
operator|=
name|len
expr_stmt|;
name|cp
operator|->
name|harshness
operator|=
operator|(
expr|struct
name|harshness_code
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|harshness_code
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_overload_call
argument_list|(
name|name
argument_list|,
name|friend_parms
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* If it turns out to be the one we were actually looking for 		 (it was probably a friend function), the return the 		 good result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|result
return|;
while|while
condition|(
operator|(
name|cp
operator|->
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* non-standard uses: set the field to 0 to indicate 		     we are using a non-member function.  */
name|cp
operator|->
name|u
operator|.
name|field
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|.
name|distance
operator|==
literal|0
operator|&&
name|cp
operator|->
name|h
operator|.
name|code
operator|<
name|best
condition|)
name|best
operator|=
name|cp
operator|->
name|h
operator|.
name|code
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|baselink
condition|)
block|{
comment|/* We have a hit (of sorts). If the parameter list is 	     "error_mark_node", or some variant thereof, it won't 	     match any methods.  Since we have verified that the is 	     some method vaguely matching this one (in name at least), 	     silently return. 	      	     Don't stop for friends, however.  */
name|basetype_path
operator|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|basetype_path
operator|=
name|TREE_VALUE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Cast the instance variable if necessary.  */
block|if (basetype != TYPE_MAIN_VARIANT 	      (TREE_TYPE (TREE_TYPE (TREE_VALUE (parms))))) 	    { 	      if (basetype == save_basetype) 		TREE_VALUE (parms) = instance_ptr; 	      else 		{ 		  tree type = build_pointer_type 		    (build_type_variant (basetype, constp, volatilep)); 		  TREE_VALUE (parms) = convert_force (type, instance_ptr, 0); 		} 	    }
comment|/* FIXME: this is the wrong place to get an error.  Hopefully 	     the access-control rewrite will make this change more cleanly.  */
block|if (TREE_VALUE (parms) == error_mark_node) 	    return error_mark_node;
endif|#
directive|endif
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|DECL_CHAIN
argument_list|(
name|function
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|function
condition|;
name|function
operator|=
name|DECL_CHAIN
argument_list|(
name|function
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_inner_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
name|ever_seen
operator|++
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
name|found_fns
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|function
argument_list|,
name|found_fns
argument_list|)
expr_stmt|;
comment|/* Not looking for friends here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
continue|continue;
if|#
directive|if
literal|0
block|if (pass == 0&& DECL_ASSEMBLER_NAME (function) == method_name) 		goto found;
endif|#
directive|endif
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|tree
name|these_parms
init|=
name|parms
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_inner_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|h_len
operator|=
name|len
expr_stmt|;
name|cp
operator|->
name|harshness
operator|=
operator|(
expr|struct
name|harshness_code
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|harshness_code
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|these_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|these_parms
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|function
argument_list|,
name|these_parms
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
operator|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|field
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|basetypes
operator|=
name|basetype_path
expr_stmt|;
comment|/* Don't allow non-converting constructors to convert. */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
operator|&&
name|DECL_NONCONVERTING_P
argument_list|(
name|function
argument_list|)
condition|)
continue|continue;
comment|/* No "two-level" conversions.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|&&
operator|(
name|cp
operator|->
name|h
operator|.
name|code
operator|&
name|USER_CODE
operator|)
condition|)
continue|continue;
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Now we have run through one link's member functions. 	     arrange to head-insert this link's links.  */
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
name|b_or_d
operator|+=
literal|1
expr_stmt|;
comment|/* Don't grab functions from base classes.  lookup_fnfield will 	     do the work to get us down into the right place.  */
name|baselink
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|tree
name|igv
init|=
name|lookup_name_nonclass
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* No exact match could be found.  Now try to find match 	     using default conversions.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
operator|&&
name|igv
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|igv
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ever_seen
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|igv
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|ever_seen
operator|+=
name|count_functions
argument_list|(
name|igv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ever_seen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
name|cp_error
argument_list|(
literal|"no global or member function `%D(%A)' defined"
argument_list|,
name|name
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"no member function `%T::%D(%A)' defined"
argument_list|,
name|save_basetype
argument_list|,
name|name
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
operator|!=
literal|0
condition|)
block|{
comment|/* Rank from worst to best.  Then cp will point to best one. 	     Private fields have their bits flipped.  For unsigned 	     numbers, this should make them look very large. 	     If the best alternate has a (signed) negative value, 	     then all we ever saw were private members.  */
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
block|{
name|int
name|n_candidates
init|=
name|cp
operator|-
name|candidates
decl_stmt|;
specifier|extern
name|int
name|warn_synth
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|instance_ptr
expr_stmt|;
name|cp
operator|=
name|ideal_candidate
argument_list|(
name|save_basetype
argument_list|,
name|candidates
argument_list|,
name|n_candidates
argument_list|,
name|parms
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|cp_error
argument_list|(
literal|"call of overloaded %s `%D(%A)' is ambiguous"
argument_list|,
name|name_kind
argument_list|,
name|name
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|print_n_candidates
argument_list|(
name|candidates
argument_list|,
name|n_candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|cp
operator|->
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|warn_synth
operator|&&
name|DECL_NAME
argument_list|(
name|cp
operator|->
name|function
argument_list|)
operator|==
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|cp
operator|->
name|function
argument_list|)
operator|&&
name|n_candidates
operator|==
literal|2
condition|)
block|{
name|cp_warning
argument_list|(
literal|"using synthesized `%#D' for copy assignment"
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  where cfront would use `%#D'"
argument_list|,
name|candidates
operator|->
name|function
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|cp_error
argument_list|(
literal|"ambiguous type conversion requested for %s `%D'"
argument_list|,
name|name_kind
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|cp
operator|--
expr_stmt|;
comment|/* The global function was the best, so use it.  */
if|if
condition|(
name|cp
operator|->
name|u
operator|.
name|field
operator|==
literal|0
condition|)
block|{
comment|/* We must convert the instance pointer into a reference type. 		 Global overloaded functions can only either take 		 aggregate objects (which come for free from references) 		 or reference data types anyway.  */
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|copy_node
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|cp
operator|->
name|function
argument_list|,
name|parms
argument_list|)
return|;
block|}
name|function
operator|=
name|cp
operator|->
name|function
expr_stmt|;
name|basetype_path
operator|=
name|cp
operator|->
name|basetypes
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|cp
operator|->
name|arg
expr_stmt|;
goto|goto
name|found_and_maybe_warn
goto|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|LOOKUP_COMPLAIN
operator||
name|LOOKUP_SPECULATIVELY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
operator|->
name|function
argument_list|)
condition|)
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|ever_seen
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|static_call_context
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|cp_error
argument_list|(
literal|"object missing in call to `%D'"
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ever_seen
operator|>
literal|1
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|cp_error
argument_list|(
literal|"no matching function for call to `%T::%D (%A)%V'"
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|print_candidates
argument_list|(
name|found_fns
argument_list|)
expr_stmt|;
block|}
else|else
name|report_type_mismatch
argument_list|(
name|cp
argument_list|,
name|parms
argument_list|,
name|name_kind
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error
argument_list|(
literal|"%T has no method named %D"
argument_list|,
name|save_basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
continue|continue;
name|found_and_maybe_warn
label|:
if|if
condition|(
operator|(
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator|.
name|code
operator|&
name|CONST_CODE
operator|)
comment|/* 12.1p2: Constructors can be called for const objects.  */
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cp
operator|->
name|function
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"non-const member function `%D'"
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"called for const object at this point in file"
argument_list|)
expr_stmt|;
block|}
comment|/* Not good enough for a match.  */
else|else
return|return
name|error_mark_node
return|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* Silently return error_mark_node.  */
return|return
name|error_mark_node
return|;
name|found
label|:
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
name|access
operator|=
name|compute_access
argument_list|(
name|basetype_path
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_private
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"%s `%+#D' is %s"
argument_list|,
name|name_kind
argument_list|,
name|function
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|function
argument_list|)
condition|?
literal|"private"
else|:
literal|"from private base class"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|access
operator|==
name|access_protected
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"%s `%+#D' %s"
argument_list|,
name|name_kind
argument_list|,
name|function
argument_list|,
name|TREE_PROTECTED
argument_list|(
name|function
argument_list|)
condition|?
literal|"is protected"
else|:
literal|"has protected accessibility"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* From here on down, BASETYPE is the type that INSTANCE_PTR's      type (if it exists) is a pointer to.  */
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|function
argument_list|)
operator|&&
name|instance
operator|==
name|C_C_D
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|value_member
argument_list|(
name|function
argument_list|,
name|get_abstract_virtuals
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"abstract virtual `%#D' called from constructor"
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|static_call_context
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot call signature member function `%T::%D' without signature pointer/reference"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
return|return
name|build_signature_method_call
argument_list|(
name|basetype
argument_list|,
name|instance
argument_list|,
name|function
argument_list|,
name|parms
argument_list|)
return|;
name|function
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Declare external function if necessary. */
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Is it a synthesized method that needs to be synthesized?  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|function
argument_list|)
operator|&&
operator|!
name|flag_no_inline
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|function
argument_list|)
comment|/* Kludge: don't synthesize for default args.  */
operator|&&
name|current_function_decl
condition|)
name|synthesize_method
argument_list|(
name|function
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pedantic
operator|&&
name|DECL_THIS_INLINE
argument_list|(
name|function
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|function
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|function
argument_list|)
operator|&&
operator|!
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|function
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"inline function `%#D' called before definition"
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* If we are referencing a virtual function from an object      of effectively static type, then there is no need      to go through the virtual function table.  */
if|if
condition|(
name|need_vtbl
operator|==
name|maybe_needed
condition|)
block|{
name|int
name|fixed_type
init|=
name|resolves_to_fixed_type_p
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|all_virtual
operator|==
literal|1
operator|&&
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
operator|&&
name|may_be_remote
argument_list|(
name|basetype
argument_list|)
condition|)
name|need_vtbl
operator|=
name|needed
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
condition|)
name|need_vtbl
operator|=
name|fixed_type
condition|?
name|unneeded
else|:
name|needed
expr_stmt|;
else|else
name|need_vtbl
operator|=
name|not_needed
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|static_call_context
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
comment|/* Let's be nice to the user for now, and give reasonable 	 default behavior.  */
name|instance_ptr
operator|=
name|current_class_decl
expr_stmt|;
if|if
condition|(
name|instance_ptr
condition|)
block|{
if|if
condition|(
name|basetype
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
block|{
name|error_not_base_type
argument_list|(
name|function
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Only allow a static member function to call another static member 	 function.  */
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot call member function `%D' without object"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|value_type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|value_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|parms
operator|=
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|function
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|need_vtbl
operator|==
name|unneeded
condition|)
block|{
name|int
name|sub_flags
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|?
name|flags
else|:
name|LOOKUP_NORMAL
decl_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|function
argument_list|,
name|sub_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|==
literal|0
condition|)
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* First parm could be integer_zerop with casts like 	 ((Object*)0)->Object::IsA()  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Since we can't have inheritance with a union, doing get_binfo 	     on it won't work.  We do all the convert_pointer_to_real 	     stuff to handle MI correctly...for unions, that's not 	     an issue, so we must short-circuit that extra work here.  */
name|tree
name|tmp
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|instance_ptr
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|build_type_variant
argument_list|(
name|basetype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|instance
condition|)
empty_stmt|;
comment|/* The call to `convert_pointer_to' may return error_mark_node.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|instance_ptr
return|;
elseif|else
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|!=
name|instance_ptr
condition|)
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|function
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Constructors do not overload method calls.  */
block|else if (TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype)&& name != TYPE_IDENTIFIER (basetype)&& (TREE_CODE (function) != FUNCTION_DECL 	       || strncmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function)), 			   OPERATOR_METHOD_FORMAT, 			   OPERATOR_METHOD_LENGTH))&& (may_be_remote (basetype) || instance != C_C_D))     {       tree fn_as_int;        parms = TREE_CHAIN (parms);        if (!all_virtual&& TREE_CODE (function) == FUNCTION_DECL) 	fn_as_int = build_unary_op (ADDR_EXPR, function, 0);       else 	fn_as_int = convert (TREE_TYPE (default_conversion (function)), DECL_VINDEX (function));       if (all_virtual == 1) 	fn_as_int = convert (integer_type_node, fn_as_int);        result = build_opfncall (METHOD_CALL_EXPR, LOOKUP_NORMAL, instance, fn_as_int, parms);        if (result == NULL_TREE) 	{ 	  compiler_error ("could not overload `operator->()(...)'"); 	  return error_mark_node; 	}       else if (result == error_mark_node) 	return error_mark_node;
if|#
directive|if
literal|0
comment|/* Do this if we want the result of operator->() to inherit 	 the type of the function it is subbing for.  */
block|TREE_TYPE (result) = value_type;
endif|#
directive|endif
block|return result;     }
endif|#
directive|endif
if|if
condition|(
name|parms
operator|==
name|error_mark_node
operator|||
operator|(
name|parms
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|need_vtbl
operator|==
name|needed
condition|)
block|{
name|function
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|instance
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|is_constructor
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|is_constructor
operator|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is_constructor
operator|=
literal|0
expr_stmt|;
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|result
argument_list|)
operator|=
name|is_constructor
expr_stmt|;
name|result
operator|=
name|convert_from_reference
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to `build_method_call', but for overloaded non-member functions.    The name of this function comes through NAME.  The name depends    on PARMS.     Note that this function must handle simple `C' promotions,    as well as variable numbers of arguments (...), and    default arguments to boot.     If the overloading is successful, we return a tree node which    contains the call to the function.     If overloading produces candidates which are probable, but not definite,    we hold these candidates.  If FINAL_CP is non-zero, then we are free    to assume that final_cp points to enough storage for all candidates that    this function might generate.  The `harshness' array is preallocated for    the first candidate, but not for subsequent ones.     Note that the DECL_RTL of FUNCTION must be made to agree with this    function's new name.  */
end_comment

begin_function
name|tree
name|build_overload_call_real
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|flags
parameter_list|,
name|final_cp
parameter_list|,
name|buildxxx
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
name|int
name|buildxxx
decl_stmt|;
block|{
comment|/* must check for overloading here */
name|tree
name|overload_name
decl_stmt|,
name|functions
decl_stmt|,
name|function
decl_stmt|,
name|parm
decl_stmt|;
name|tree
name|parmtypes
init|=
name|NULL_TREE
decl_stmt|,
name|last
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|outer
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|parmlength
init|=
name|list_length
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|final_cp
condition|)
block|{
name|final_cp
index|[
literal|0
index|]
operator|.
name|h
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|h
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|function
operator|=
literal|0
expr_stmt|;
comment|/* end marker.  */
name|final_cp
index|[
literal|1
index|]
operator|.
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
block|}
for|for
control|(
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
if|#
directive|if
literal|0
comment|/* This breaks reference-to-array parameters.  */
then||| TREE_CODE (t) == ARRAY_TYPE
endif|#
directive|endif
block|{
comment|/* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place. 	     Also convert OFFSET_TYPE entities to their normal selves. 	     This eliminates needless calls to `compute_conversion_costs'.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|chainon
argument_list|(
name|parmtypes
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
else|else
name|parmtypes
operator|=
name|void_list_node
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fnname
argument_list|)
condition|)
block|{
name|functions
operator|=
name|fnname
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fnname
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|fnname
operator|=
name|TREE_PURPOSE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fnname
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|fnname
operator|=
name|DECL_NAME
argument_list|(
name|functions
argument_list|)
expr_stmt|;
block|}
else|else
name|functions
operator|=
name|lookup_name_nonclass
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|functions
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"only member functions apply"
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|IDENTIFIER_OPNAME_P
argument_list|(
name|fnname
argument_list|)
condition|)
block|{
name|functions
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
block|{
comment|/* We are just curious whether this is a viable alternative or              not.  */
name|compute_conversion_costs
argument_list|(
name|functions
argument_list|,
name|parms
argument_list|,
name|final_cp
argument_list|,
name|parmlength
argument_list|)
expr_stmt|;
return|return
name|functions
return|;
block|}
else|else
return|return
name|build_function_call_real
argument_list|(
name|functions
argument_list|,
name|parms
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|cp_error
argument_list|(
literal|"function `%D' declared overloaded, but no instances of that function declared"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|functions
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|length
operator|=
name|count_functions
argument_list|(
name|functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
name|candidates
operator|=
name|final_cp
expr_stmt|;
else|else
block|{
name|candidates
operator|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|candidates
argument_list|,
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|candidates
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|functions
argument_list|)
argument_list|,
literal|169
argument_list|)
expr_stmt|;
name|functions
operator|=
name|get_first_fn
argument_list|(
name|functions
argument_list|)
expr_stmt|;
comment|/* OUTER is the list of FUNCTION_DECLS, in a TREE_LIST.  */
for|for
control|(
name|outer
operator|=
name|functions
init|;
name|outer
condition|;
name|outer
operator|=
name|DECL_CHAIN
argument_list|(
name|outer
argument_list|)
control|)
block|{
name|int
name|template_cost
init|=
literal|0
decl_stmt|;
name|function
operator|=
name|outer
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|function
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TEMPLATE_DECL
condition|)
name|code
operator|=
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
name|cp_error_at
argument_list|(
literal|"enumeral value `%D' conflicts with function of same name"
argument_list|,
name|function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|function
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"variable `%D' conflicts with function of same name"
argument_list|,
name|function
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"constant field `%D' conflicts with function of same name"
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_DECL
condition|)
continue|continue;
else|else
name|my_friendly_abort
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|targs
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|ntparms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|type_unification
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|function
argument_list|)
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|parms
argument_list|,
operator|&
name|template_cost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|function
operator|=
name|instantiate_template
argument_list|(
name|function
argument_list|,
name|targs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* Unconverted template -- failed match.  */
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|4
expr_stmt|;
name|cp
operator|->
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|candidate
modifier|*
name|cp2
decl_stmt|;
comment|/* Check that this decl is not the same as a function that's in 	     the list due to some template instantiation.  */
name|cp2
operator|=
name|candidates
expr_stmt|;
while|while
condition|(
name|cp2
operator|!=
name|cp
condition|)
if|if
condition|(
name|cp2
operator|->
name|function
operator|==
name|function
condition|)
break|break;
else|else
name|cp2
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cp2
operator|->
name|function
operator|==
name|function
condition|)
continue|continue;
name|function
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Can't use alloca here, since result might be 	     passed to calling function.  */
name|cp
operator|->
name|h_len
operator|=
name|parmlength
expr_stmt|;
name|cp
operator|->
name|harshness
operator|=
operator|(
expr|struct
name|harshness_code
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|parmlength
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|harshness_code
argument_list|)
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|function
argument_list|,
name|parms
argument_list|,
name|cp
argument_list|,
name|parmlength
argument_list|)
expr_stmt|;
comment|/* Make sure this is clear as well.  */
name|cp
operator|->
name|h
operator|.
name|int_penalty
operator|+=
name|template_cost
expr_stmt|;
if|if
condition|(
operator|(
name|cp
index|[
literal|0
index|]
operator|.
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
operator|)
operator|==
literal|0
condition|)
block|{
name|cp
index|[
literal|1
index|]
operator|.
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
condition|)
block|{
name|tree
name|rval
init|=
name|error_mark_node
decl_stmt|;
comment|/* Leave marker.  */
name|cp
index|[
literal|0
index|]
operator|.
name|h
operator|.
name|code
operator|=
name|EVIL_CODE
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
block|{
name|struct
name|candidate
modifier|*
name|best_cp
init|=
name|ideal_candidate
argument_list|(
name|NULL_TREE
argument_list|,
name|candidates
argument_list|,
name|cp
operator|-
name|candidates
argument_list|,
name|parms
argument_list|,
name|parmlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|best_cp
operator|==
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error
argument_list|(
literal|"call of overloaded `%D' is ambiguous"
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|print_n_candidates
argument_list|(
name|candidates
argument_list|,
name|cp
operator|-
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
else|else
name|rval
operator|=
name|best_cp
operator|->
name|function
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|h
operator|.
name|code
operator|&
name|EVIL_CODE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
literal|"type conversion ambiguous"
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|cp
operator|->
name|function
expr_stmt|;
block|}
if|if
condition|(
name|final_cp
condition|)
return|return
name|rval
return|;
return|return
name|buildxxx
condition|?
name|build_function_call_real
argument_list|(
name|rval
argument_list|,
name|parms
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
else|:
name|build_function_call_real
argument_list|(
name|rval
argument_list|,
name|parms
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|report_type_mismatch
argument_list|(
name|cp
argument_list|,
name|parms
argument_list|,
literal|"function"
argument_list|,
name|decl_as_string
argument_list|(
name|cp
operator|->
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_overload_call
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|flags
parameter_list|,
name|final_cp
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
block|{
return|return
name|build_overload_call_real
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|flags
argument_list|,
name|final_cp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_overload_call_maybe
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|flags
parameter_list|,
name|final_cp
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
block|{
return|return
name|build_overload_call_real
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|flags
argument_list|,
name|final_cp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

