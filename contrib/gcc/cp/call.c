begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to invoking methods and overloaded functions.    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) and    modified by Brendan Kehoe (brendan@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|inhibit_warnings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_new_method_call
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_field_call
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|tourney
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|equal_functions
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|joust
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|struct
name|z_candidate
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_ics
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_over_call
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_java_interface_fn_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|convert_like
parameter_list|(
name|CONV
parameter_list|,
name|EXPR
parameter_list|)
define|\
value|convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0)
end_define

begin_define
define|#
directive|define
name|convert_like_with_context
parameter_list|(
name|CONV
parameter_list|,
name|EXPR
parameter_list|,
name|FN
parameter_list|,
name|ARGNO
parameter_list|)
define|\
value|convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0)
end_define

begin_decl_stmt
specifier|static
name|tree
name|convert_like_real
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|op_error
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_object_call
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|resolve_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_user_type_conversion_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_z_candidates
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_this
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|splice_viable
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|any_viable
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|unification_kind_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate_real
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|unification_kind_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_conv_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidates
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|enum
name|tree_code
operator|,
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_complete
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_builtin_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_conv_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_function_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|implicit_conversion
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|standard_conversion
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|reference_binding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|non_reference
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_conv
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_subseq
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_handle_ref_bind
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_handle_implicit_object
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_candidate
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|source_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_warning
name|PARAMS
argument_list|(
operator|(
expr|struct
name|z_candidate
operator|*
operator|,
expr|struct
name|z_candidate
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reference_related_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reference_compatible_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_class_to_reference
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|direct_reference_binding
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|promoted_arithmetic_type_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|conditional_conversion
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_vfield_ref
parameter_list|(
name|datum
parameter_list|,
name|type
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|type
argument_list|)
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a member of an object.  I.e., one that overloads    operator ()(), or is a pointer-to-function or pointer-to-method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_call
parameter_list|(
name|basetype_path
parameter_list|,
name|instance_ptr
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|basetype_path
decl_stmt|,
name|instance_ptr
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|,
name|instance
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Speed up the common case.  */
if|if
condition|(
name|instance_ptr
operator|==
name|current_class_ptr
operator|&&
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|error_mark_node
operator|||
name|field
operator|==
name|NULL_TREE
condition|)
return|return
name|field
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* If it's a field, try overloading operator (), 	 or calling if the field is a pointer-to-function.  */
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_component_ref_1
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|parms
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff the destructor name specified in NAME    (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many    forms...  */
end_comment

begin_function
name|int
name|check_dtor_name
parameter_list|(
name|basetype
parameter_list|,
name|name
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|name
decl_stmt|;
block|{
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Just accept something we've already complained about.  */
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
name|name
operator|=
name|basetype
expr_stmt|;
else|else
name|name
operator|=
name|get_type_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* In the case of:               template<class T> struct S { ~S(); };        int i;        i.~S();       NAME will be a class template.  */
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.    This is how virtual function calls are avoided.  */
end_comment

begin_function
name|tree
name|build_scoped_method_call
parameter_list|(
name|exp
parameter_list|,
name|basetype
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|basetype
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
block|{
comment|/* Because this syntactic form does not allow      a pointer to a base class to be `stolen',      we need not protect the derived->base conversion      that happens here.            @@ But we do have to check access privileges later.  */
name|tree
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|type
init|=
name|get_aggr_from_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|name
operator|=
name|build_min_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|build_min_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|build_min_nt
argument_list|(
name|METHOD_CALL_EXPR
argument_list|,
name|name
argument_list|,
name|exp
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|binfo
operator|=
name|basetype
expr_stmt|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
else|else
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check the destructor call syntax.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
comment|/* We can get here if someone writes their destructor call like 	 `obj.NS::~T()'; this isn't really a scoped method call, so hand 	 it off.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
if|if
condition|(
operator|!
name|check_dtor_name
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"qualified type `%T' does not match destructor name `~%T'"
argument_list|,
name|basetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Destructors can be "called" for simple types; see 5.2.4 and 12.4 Note 	 that explicit ~int is caught in the parser; this deals with typedefs 	 and template parms.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
condition|)
name|error
argument_list|(
literal|"type of `%E' does not match destructor type `%T' (type was `%T')"
argument_list|,
name|exp
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"`%D' is a namespace"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"base object `%E' of scoped method call is of non-aggregate type `%T'"
argument_list|,
name|exp
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|binfo
operator|=
name|lookup_base
argument_list|(
name|type
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|binfo
condition|)
name|error_not_base_type
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|decl
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_scoped_ref
argument_list|(
name|exp
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* Call to a destructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Call to a method.  */
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* We want the address of a function or method.  We avoid creating a    pointer-to-member function.  */
end_comment

begin_function
name|tree
name|build_addr_func
parameter_list|(
name|function
parameter_list|)
name|tree
name|function
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
comment|/* We have to do these by hand to avoid real pointer to member      functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|addr
decl_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|function
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or function counts 	 as a constant */
if|if
condition|(
name|staticp
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|function
operator|=
name|addr
expr_stmt|;
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
end_function

begin_comment
comment|/* Build a CALL_EXPR, we can handle FUNCTION_TYPEs, METHOD_TYPEs, or    POINTER_TYPE to those.  Note, pointer to member function types    (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */
end_comment

begin_function
name|tree
name|build_call
parameter_list|(
name|function
parameter_list|,
name|parms
parameter_list|)
name|tree
name|function
decl_stmt|,
name|parms
decl_stmt|;
block|{
name|int
name|is_constructor
init|=
literal|0
decl_stmt|;
name|int
name|nothrow
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|result_type
decl_stmt|;
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"unable to call pointer to member function here"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We check both the decl and the type; a function may be known not to      throw without being declared throw().  */
name|nothrow
operator|=
operator|(
operator|(
name|decl
operator|&&
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|is_constructor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We invoke build_call directly for several library functions. 	 These may have been declared normally if we're building libgcc, 	 so we can't just check DECL_ARTIFICIAL.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
condition|)
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Don't pass empty class objects by value.  This is useful      for tags in STL, which are used to control overload resolution.      We don't need to handle other cases of copying empty classes.  */
if|if
condition|(
operator|!
name|decl
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
for|for
control|(
name|tmp
operator|=
name|parms
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|is_empty_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build
argument_list|(
name|EMPTY_CLASS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|function
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|function
argument_list|)
operator|=
name|is_constructor
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|result_type
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|function
argument_list|)
operator|=
name|nothrow
expr_stmt|;
return|return
name|function
return|;
block|}
end_function

begin_comment
comment|/* Build something of the form ptr->method (args)    or object.method (args).  This can also build    calls to constructors, and find friends.     Member functions always take their class variable    as a pointer.     INSTANCE is a class instance.     NAME is the name of the method desired, usually an IDENTIFIER_NODE.     PARMS help to figure out what that NAME really refers to.     BASETYPE_PATH, if non-NULL, contains a chain from the type of INSTANCE    down to the real instance type to use for access checking.  We need this    information to get protected accesses correct.  This parameter is used    by build_member_call.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     If this is all OK, calls build_function_call with the resolved    member function.     This function must also handle being called to perform    initialization, promotion/coercion of arguments, and    instantiation of default parameters.     Note that NAME may refer to an instance variable name.  If    `operator()()' is defined for the type of that field, then we return    that result.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|n_build_method_call
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|tree
name|build_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|,
name|instance_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_build_method_call
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
operator|||
operator|(
name|instance
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* We need to process template parm names here so that tsubst catches 	 them properly.  Other type names can wait.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|get_aggr_from_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|name
operator|=
name|build_min_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|build_min_nt
argument_list|(
name|METHOD_CALL_EXPR
argument_list|,
name|name
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
name|parms
condition|)
name|error
argument_list|(
literal|"destructors take no parameters"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_dtor_name
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"destructor name `~%T' does not match type `%T' of expression"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|complete_type
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|instance
argument_list|)
return|;
name|instance
operator|=
name|default_conversion
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|build_new_method_call
argument_list|(
name|instance
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* New overloading code.  */
end_comment

begin_struct
struct|struct
name|z_candidate
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|convs
decl_stmt|;
name|tree
name|second_conv
decl_stmt|;
name|int
name|viable
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|tree
name|warnings
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IDENTITY_RANK
value|0
end_define

begin_define
define|#
directive|define
name|EXACT_RANK
value|1
end_define

begin_define
define|#
directive|define
name|PROMO_RANK
value|2
end_define

begin_define
define|#
directive|define
name|STD_RANK
value|3
end_define

begin_define
define|#
directive|define
name|PBOOL_RANK
value|4
end_define

begin_define
define|#
directive|define
name|USER_RANK
value|5
end_define

begin_define
define|#
directive|define
name|ELLIPSIS_RANK
value|6
end_define

begin_define
define|#
directive|define
name|BAD_RANK
value|7
end_define

begin_define
define|#
directive|define
name|ICS_RANK
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(ICS_BAD_FLAG (NODE) ? BAD_RANK   		\    : ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK	\    : ICS_USER_FLAG (NODE) ? USER_RANK		\    : ICS_STD_RANK (NODE))
end_define

begin_define
define|#
directive|define
name|ICS_STD_RANK
parameter_list|(
name|NODE
parameter_list|)
value|TREE_COMPLEXITY (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_USER_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_0 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_ELLIPSIS_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_1 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_THIS_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_2 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_BAD_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_3 (NODE)
end_define

begin_comment
comment|/* In a REF_BIND or a BASE_CONV, this indicates that a temporary    should be created to hold the result of the conversion.  */
end_comment

begin_define
define|#
directive|define
name|NEED_TEMPORARY_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_4 (NODE)
end_define

begin_define
define|#
directive|define
name|USER_CONV_CAND
parameter_list|(
name|NODE
parameter_list|)
define|\
value|((struct z_candidate *)WRAPPER_PTR (TREE_OPERAND (NODE, 1)))
end_define

begin_define
define|#
directive|define
name|USER_CONV_FN
parameter_list|(
name|NODE
parameter_list|)
value|(USER_CONV_CAND (NODE)->fn)
end_define

begin_function
name|int
name|null_ptr_cst_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
comment|/* [conv.ptr]       A null pointer constant is an integral constant expression      (_expr.const_) rvalue of integer type that evaluates to zero.  */
if|if
condition|(
name|t
operator|==
name|null_node
operator|||
operator|(
name|CP_INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if PARMLIST consists of only default parms and/or    ellipsis. */
end_comment

begin_function
name|int
name|sufficient_parms_p
parameter_list|(
name|parmlist
parameter_list|)
name|tree
name|parmlist
decl_stmt|;
block|{
for|for
control|(
init|;
name|parmlist
operator|&&
name|parmlist
operator|!=
name|void_list_node
condition|;
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|parmlist
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_conv
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|from
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|from
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|int
name|rank
init|=
name|ICS_STD_RANK
argument_list|(
name|from
argument_list|)
decl_stmt|;
comment|/* We can't use buildl1 here because CODE could be USER_CONV, which      takes two arguments.  In that case, the caller is responsible for      filling in the second argument.  */
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|from
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PTR_CONV
case|:
case|case
name|PMEM_CONV
case|:
case|case
name|BASE_CONV
case|:
case|case
name|STD_CONV
case|:
if|if
condition|(
name|rank
operator|<
name|STD_RANK
condition|)
name|rank
operator|=
name|STD_RANK
expr_stmt|;
break|break;
case|case
name|QUAL_CONV
case|:
if|if
condition|(
name|rank
operator|<
name|EXACT_RANK
condition|)
name|rank
operator|=
name|EXACT_RANK
expr_stmt|;
default|default:
break|break;
block|}
name|ICS_STD_RANK
argument_list|(
name|t
argument_list|)
operator|=
name|rank
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|t
argument_list|)
operator|=
name|ICS_USER_FLAG
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* If T is a REFERENCE_TYPE return the type to which T refers.    Otherwise, return T itself.  */
end_comment

begin_function
specifier|static
name|tree
name|non_reference
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|strip_top_quals
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|t
return|;
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the standard conversion path (see [conv]) from type FROM to type    TO, if any.  For proper handling of null pointer constants, you must    also pass the expression EXPR to convert from.  */
end_comment

begin_function
specifier|static
name|tree
name|standard_conversion
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|expr
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|fcode
decl_stmt|,
name|tcode
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|int
name|fromref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|fromref
operator|=
literal|1
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|strip_top_quals
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|=
name|strip_top_quals
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|to
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|itf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|tcode
operator|=
name|TREE_CODE
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|LVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcode
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|LVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fromref
operator|||
operator|(
name|expr
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|RVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* Allow conversion between `__complex__' data types  */
if|if
condition|(
name|tcode
operator|==
name|COMPLEX_TYPE
operator|&&
name|fcode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
comment|/* The standard conversion sequence to convert FROM to TO is          the standard conversion sequence to perform componentwise          conversion.  */
name|tree
name|part_conv
init|=
name|standard_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|part_conv
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|TREE_CODE
argument_list|(
name|part_conv
argument_list|)
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|ICS_STD_RANK
argument_list|(
name|part_conv
argument_list|)
expr_stmt|;
block|}
else|else
name|conv
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|conv
return|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
name|conv
return|;
if|if
condition|(
operator|(
name|tcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
name|expr
operator|&&
name|null_ptr_cst_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcode
operator|==
name|INTEGER_TYPE
operator|&&
name|fcode
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|fcode
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
comment|/* For backwards brain damage compatibility, allow interconversion of 	 pointers and integers with a pedwarn.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|ENUMERAL_TYPE
operator|&&
name|fcode
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|to
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|from
argument_list|)
condition|)
block|{
comment|/* For backwards brain damage compatibility, allow interconversion of 	 enums and integers with a pedwarn.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|fcode
operator|==
name|POINTER_TYPE
condition|)
block|{
name|enum
name|tree_code
name|ufcode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|utcode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|utcode
operator|==
name|VOID_TYPE
operator|&&
name|ufcode
operator|!=
name|OFFSET_TYPE
operator|&&
name|ufcode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ufcode
operator|==
name|OFFSET_TYPE
operator|&&
name|utcode
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|tree
name|fbase
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tbase
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|tbase
argument_list|,
name|fbase
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|&&
operator|!
name|binfo_from_vbase
argument_list|(
name|binfo
argument_list|)
operator|&&
operator|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|from
operator|=
name|build_offset_type
argument_list|(
name|tbase
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PMEM_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|from
operator|=
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|QUAL_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|&&
name|string_conv_p
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* converting from string constant to char *.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|QUAL_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptr_reasonably_similar
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|from
operator|=
name|to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|tree
name|fromfn
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tofn
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fbase
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tbase
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|tofn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|tbase
argument_list|,
name|fbase
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binfo
operator|||
name|binfo_from_vbase
argument_list|(
name|binfo
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fromfn
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tofn
argument_list|)
argument_list|)
operator|||
operator|!
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|tofn
argument_list|)
argument_list|)
argument_list|)
operator|||
name|cp_type_quals
argument_list|(
name|fbase
argument_list|)
operator|!=
name|cp_type_quals
argument_list|(
name|tbase
argument_list|)
condition|)
return|return
literal|0
return|;
name|from
operator|=
name|cp_build_qualified_type
argument_list|(
name|tbase
argument_list|,
name|cp_type_quals
argument_list|(
name|fbase
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_cplus_method_type
argument_list|(
name|from
argument_list|,
name|TREE_TYPE
argument_list|(
name|fromfn
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PMEM_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|fcode
argument_list|)
operator|||
name|fcode
operator|==
name|REAL_TYPE
operator|||
name|fcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
operator|&&
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|<
name|PBOOL_RANK
operator|)
condition|)
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|PBOOL_RANK
expr_stmt|;
block|}
comment|/* We don't check for ENUMERAL_TYPE here because there are no standard      conversions to enum type.  */
elseif|else
if|if
condition|(
name|tcode
operator|==
name|INTEGER_TYPE
operator|||
name|tcode
operator|==
name|BOOLEAN_TYPE
operator|||
name|tcode
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|fcode
argument_list|)
operator|||
name|fcode
operator|==
name|REAL_TYPE
operator|)
condition|)
return|return
literal|0
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* Give this a better rank if it's a promotion.  */
if|if
condition|(
name|to
operator|==
name|type_promotes_to
argument_list|(
name|from
argument_list|)
operator|&&
name|ICS_STD_RANK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|PROMO_RANK
condition|)
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|PROMO_RANK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|to
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|from
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|RVALUE_CONV
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* The derived-to-base conversion indicates the initialization 	 of a parameter with base type from an object of a derived 	 type.  A temporary object is created to hold the result of 	 the conversion.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T1 is reference-related to T2.  */
end_comment

begin_function
specifier|static
name|int
name|reference_related_p
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
block|{
name|t1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* [dcl.init.ref]       Given types "cv1 T1" and "cv2 T2," "cv1 T1" is reference-related      to "cv2 T2" if T1 is the same type as T2, or T1 is a base class      of T2.  */
return|return
operator|(
name|same_type_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if T1 is reference-compatible with T2.  */
end_comment

begin_function
specifier|static
name|int
name|reference_compatible_p
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
block|{
comment|/* [dcl.init.ref]       "cv1 T1" is reference compatible with "cv2 T2" if T1 is      reference-related to T2 and cv1 is the same cv-qualification as,      or greater cv-qualification than, cv2.  */
return|return
operator|(
name|reference_related_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether or not the EXPR (of class type S) can be    converted to T as in [over.match.ref].  */
end_comment

begin_function
specifier|static
name|tree
name|convert_class_to_reference
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|expr
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|s
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|conversions
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
comment|/* [over.match.ref]       Assuming that "cv1 T" is the underlying type of the reference      being initialized, and "cv S" is the type of the initializer      expression, with S a class type, the candidate functions are      selected as follows:       --The conversion functions of S and its base classes are        considered.  Those that are not hidden within S and yield type        "reference to cv2 T2", where "cv1 T" is reference-compatible        (_dcl.init.ref_) with "cv2 T2", are candidate functions.       The argument list has one argument, which is the initializer      expression.  */
name|candidates
operator|=
literal|0
expr_stmt|;
comment|/* Conceptually, we should take the address of EXPR and put it in      the argument list.  Unfortunately, however, that can result in      error messages, which we should not issue now because we are just      trying to find a conversion operator.  Therefore, we use NULL,      cast to the appropriate type.  */
name|arglist
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
for|for
control|(
name|conversions
operator|=
name|lookup_conversions
argument_list|(
name|s
argument_list|)
init|;
name|conversions
condition|;
name|conversions
operator|=
name|TREE_CHAIN
argument_list|(
name|conversions
argument_list|)
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|conversions
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|f
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|old_candidates
init|=
name|candidates
decl_stmt|;
comment|/* If this is a template function, try to get an exact              match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|f
argument_list|,
name|s
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|build_reference_type
argument_list|(
name|t
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CONV
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|!=
name|old_candidates
condition|)
block|{
comment|/* Now, see if the conversion function really returns 		     an lvalue of the appropriate type.  From the 		     point of view of unification, simply returning an 		     rvalue of the right type is good enough.  */
name|f
operator|=
name|candidates
operator|->
name|fn
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|!
name|reference_compatible_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|candidates
operator|=
name|candidates
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|reference_compatible_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|f
argument_list|,
name|s
argument_list|,
name|arglist
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|!=
name|old_candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If none of the conversion functions worked out, let our caller      know.  */
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
return|return
name|NULL_TREE
return|;
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|s
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|USER_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|1
argument_list|)
operator|=
name|build_ptr_wrapper
argument_list|(
name|cand
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|viable
operator|==
operator|-
literal|1
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cand
operator|->
name|second_conv
operator|=
name|conv
expr_stmt|;
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* A reference of the indicated TYPE is being bound directly to the    expression represented by the implicit conversion sequence CONV.    Return a conversion sequence for this binding.  */
end_comment

begin_function
specifier|static
name|tree
name|direct_reference_binding
parameter_list|(
name|type
parameter_list|,
name|conv
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|conv
decl_stmt|;
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* [over.ics.rank]             When a parameter of reference type binds directly      (_dcl.init.ref_) to an argument expression, the implicit      conversion sequence is the identity conversion, unless the      argument expression has a type that is a derived class of the      parameter type, in which case the implicit conversion sequence is      a derived-to-base Conversion. 	       If the parameter binds directly to the result of applying a      conversion function to the argument expression, the implicit      conversion sequence is a user-defined conversion sequence      (_over.ics.user_), with the second standard conversion sequence      either an identity conversion or, if the conversion function      returns an entity of a type that is a derived class of the      parameter type, a derived-to-base conversion.  */
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|conv
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Represent the derived-to-base conversion.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|t
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* We will actually be binding to the base-class subobject in 	 the derived class, so we mark this conversion appropriately. 	 That way, convert_like knows not to generate a temporary.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|type
argument_list|,
name|conv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the conversion path from type FROM to reference type TO for    purposes of reference binding.  For lvalue binding, either pass a    reference type to FROM or an lvalue expression to EXPR.  If the    reference will be bound to a temporary, NEED_TEMPORARY_P is set for    the conversion returned.  */
end_comment

begin_function
specifier|static
name|tree
name|reference_binding
parameter_list|(
name|rto
parameter_list|,
name|rfrom
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|rto
decl_stmt|,
name|rfrom
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|conv
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|to
init|=
name|TREE_TYPE
argument_list|(
name|rto
argument_list|)
decl_stmt|;
name|tree
name|from
init|=
name|rfrom
decl_stmt|;
name|int
name|related_p
decl_stmt|;
name|int
name|compatible_p
decl_stmt|;
name|cp_lvalue_kind
name|lvalue_p
init|=
name|clk_none
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|itf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Anything with reference type is an lvalue.  */
name|lvalue_p
operator|=
name|clk_ordinary
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
condition|)
name|lvalue_p
operator|=
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not the types are reference-related and      reference compatible.  We have do do this after stripping      references from FROM.  */
name|related_p
operator|=
name|reference_related_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|compatible_p
operator|=
name|reference_compatible_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvalue_p
operator|&&
name|compatible_p
condition|)
block|{
comment|/* [dcl.init.ref]  	 If the initializer expression  	  	 -- is an lvalue (but not an lvalue for a bit-field), and "cv1 T1" 	    is reference-compatible with "cv2 T2," 	  	 the reference is bound directly to the initializer exprssion 	 lvalue.  */
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|conv
operator|=
name|direct_reference_binding
argument_list|(
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lvalue_p
operator|&
name|clk_bitfield
operator|)
operator|!=
literal|0
operator|&&
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|to
argument_list|)
condition|)
comment|/* For the purposes of overload resolution, we ignore the fact 	   this expression is a bitfield. (In particular, 	   [over.ics.ref] says specifically that a function with a 	   non-const reference parameter is viable even if the 	   argument is a bitfield.)  	   However, when we actually call the function we must create 	   a temporary to which to bind the reference.  If the 	   reference is volatile, or isn't const, then we cannot make 	   a temporary, so we just issue an error when the conversion 	   actually occurs.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|conv
return|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
condition|)
block|{
comment|/* [dcl.init.ref]  	 If the initializer exprsesion  	 -- has a class type (i.e., T2 is a class type) can be 	    implicitly converted to an lvalue of type "cv3 T3," where 	    "cv1 T1" is reference-compatible with "cv3 T3".  (this 	    conversion is selected by enumerating the applicable 	    conversion functions (_over.match.ref_) and choosing the 	    best one through overload resolution.  (_over.match_).           the reference is bound to the lvalue result of the conversion 	in the second case.  */
name|conv
operator|=
name|convert_class_to_reference
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
return|return
name|direct_reference_binding
argument_list|(
name|rto
argument_list|,
name|conv
argument_list|)
return|;
block|}
comment|/* From this point on, we conceptually need temporaries, even if we      elide them.  Only the cases above are "direct bindings".  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NO_TEMP_BIND
condition|)
return|return
name|NULL_TREE
return|;
comment|/* [over.ics.rank]            When a parameter of reference type is not bound directly to an      argument expression, the conversion sequence is the one required      to convert the argument expression to the underlying type of the      reference according to _over.best.ics_.  Conceptually, this      conversion sequence corresponds to copy-initializing a temporary      of the underlying type with the argument expression.  Any      difference in top-level cv-qualification is subsumed by the      initialization itself and does not constitute a conversion.  */
comment|/* [dcl.init.ref]       Otherwise, the reference shall be to a non-volatile const type.  */
if|if
condition|(
operator|!
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* [dcl.init.ref]            If the initializer expression is an rvalue, with T2 a class type,      and "cv1 T1" is reference-compatible with "cv2 T2", the reference      is bound in one of the following ways:            -- The reference is bound to the object represented by the rvalue         or to a sub-object within that object.         In this case, the implicit conversion sequence is supposed to be      same as we would obtain by generating a temporary.  Fortunately,      if the types are reference compatible, then this is either an      identity conversion or the derived-to-base conversion, just as      for direct binding.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|compatible_p
condition|)
block|{
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|direct_reference_binding
argument_list|(
name|rto
argument_list|,
name|conv
argument_list|)
return|;
block|}
comment|/* [dcl.init.ref]       Otherwise, a temporary of type "cv1 T1" is created and      initialized from the initializer expression using the rules for a      non-reference copy initialization.  If T1 is reference-related to      T2, cv1 must be the same cv-qualification as, or greater      cv-qualification than, cv2; otherwise, the program is ill-formed.  */
if|if
condition|(
name|related_p
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
condition|)
return|return
name|NULL_TREE
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* This reference binding, unlike those above, requires the      creation of a temporary.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Returns the implicit conversion sequence (see [over.ics]) from type FROM    to type TO.  The optional expression EXPR may affect the conversion.    FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is    significant.  */
end_comment

begin_function
specifier|static
name|tree
name|implicit_conversion
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|conv
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
comment|/* Resolve expressions like `A::p' that we thought might become      pointers-to-members.  */
if|if
condition|(
name|expr
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|==
name|error_mark_node
operator|||
name|to
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Make sure both the FROM and TO types are complete so that      user-defined conversions are available.  */
name|complete_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|complete_type
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|conv
operator|=
name|reference_binding
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|conv
operator|=
name|standard_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|from
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
operator|==
literal|0
condition|)
block|{
name|cand
operator|=
name|build_user_type_conversion_1
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
name|conv
operator|=
name|cand
operator|->
name|second_conv
expr_stmt|;
comment|/* We used to try to bind a reference to a temporary here, but that 	 is now handled by the recursive call to this function at the end 	 of reference_binding.  */
block|}
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to the list of candidates.  Used by the add_*_candidate    functions.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fn
parameter_list|,
name|convs
parameter_list|,
name|viable
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|convs
decl_stmt|;
name|int
name|viable
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
operator|(
expr|struct
name|z_candidate
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|z_candidate
argument_list|)
argument_list|)
decl_stmt|;
name|cand
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|cand
operator|->
name|convs
operator|=
name|convs
expr_stmt|;
name|cand
operator|->
name|viable
operator|=
name|viable
expr_stmt|;
name|cand
operator|->
name|next
operator|=
name|candidates
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_comment
comment|/* Create an overload candidate for the function or method FN called with    the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on    to implicit_conversion.     CTYPE, if non-NULL, is the type we want to pretend this function    comes from for purposes of overload resolution.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_function_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fn
parameter_list|,
name|ctype
parameter_list|,
name|arglist
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|ctype
decl_stmt|,
name|arglist
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|parmlist
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|tree
name|convs
decl_stmt|;
name|tree
name|parmnode
decl_stmt|,
name|argnode
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|;
comment|/* The `this', `in_chrg' and VTT arguments to constructors are not      considered in overload resolution.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|parmlist
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|convs
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 13.3.2 - Viable functions [over.match.viable]      First, to be a viable function, a candidate function shall have enough      parameters to agree in number with the arguments in the list.       We need to check this first; otherwise, checking the ICSes might cause      us to produce an ill-formed template instantiation.  */
name|parmnode
operator|=
name|parmlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|parmnode
operator|==
name|NULL_TREE
operator|||
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
operator|&&
name|parmnode
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
comment|/* Make sure there are default args for the rest of the parms.  */
elseif|else
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|parmnode
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|viable
condition|)
goto|goto
name|out
goto|;
comment|/* Second, for F to be a viable function, there shall exist for each      argument an implicit conversion sequence that converts that argument      to the corresponding parameter of F.  */
name|parmnode
operator|=
name|parmlist
expr_stmt|;
name|argnode
operator|=
name|arglist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|argnode
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|is_this
decl_stmt|;
if|if
condition|(
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
name|is_this
operator|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|parmnode
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parmnode
argument_list|)
decl_stmt|;
comment|/* The type of the implicit object parameter ('this') for 	     overload resolution is not always the same as for the 	     function itself; conversion functions are considered to 	     be members of the class being converted, and functions 	     introduced by a using-declaration are considered to be 	     members of the class that uses them.  	     Since build_over_call ignores the ICS for the `this' 	     parameter, we can just change the parm type.  */
if|if
condition|(
name|ctype
operator|&&
name|is_this
condition|)
block|{
name|parmtype
operator|=
name|build_qualified_type
argument_list|(
name|ctype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|build_pointer_type
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|implicit_conversion
argument_list|(
name|parmtype
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|is_this
condition|)
name|ICS_THIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|parmnode
condition|)
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
name|argnode
operator|=
name|TREE_CHAIN
argument_list|(
name|argnode
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|convs
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an overload candidate for the conversion function FN which will    be invoked for expression OBJ, producing a pointer-to-function which    will in turn be called with the argument list ARGLIST, and add it to    CANDIDATES.  FLAGS is passed on to implicit_conversion.     Actually, we don't really care about FN; we care about the type it    converts to.  There may be multiple conversion functions that will    convert to that type, and we rely on build_user_type_conversion_1 to    choose the best one; so when we create our candidate, we record the type    instead of the function.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_conv_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fn
parameter_list|,
name|obj
parameter_list|,
name|arglist
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|obj
decl_stmt|,
name|arglist
decl_stmt|;
block|{
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|viable
decl_stmt|,
name|flags
decl_stmt|;
name|tree
name|parmlist
decl_stmt|,
name|convs
decl_stmt|,
name|parmnode
decl_stmt|,
name|argnode
decl_stmt|;
for|for
control|(
name|parmlist
operator|=
name|totype
init|;
name|TREE_CODE
argument_list|(
name|parmlist
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|;
control|)
name|parmlist
operator|=
name|TREE_TYPE
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
operator|+
literal|1
expr_stmt|;
name|convs
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|parmnode
operator|=
name|parmlist
expr_stmt|;
name|argnode
operator|=
name|arglist
expr_stmt|;
name|viable
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|LOOKUP_NORMAL
expr_stmt|;
comment|/* Don't bother looking up the same type twice.  */
if|if
condition|(
name|candidates
operator|&&
name|candidates
operator|->
name|fn
operator|==
name|totype
condition|)
return|return
name|candidates
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|i
operator|==
literal|0
condition|?
name|obj
else|:
name|TREE_VALUE
argument_list|(
name|argnode
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|t
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
elseif|else
if|if
condition|(
name|parmnode
condition|)
name|t
operator|=
name|implicit_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmnode
argument_list|)
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|parmnode
condition|)
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
name|argnode
operator|=
name|TREE_CHAIN
argument_list|(
name|argnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|parmnode
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|totype
argument_list|,
name|convs
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_builtin_candidate
parameter_list|(
name|candidates
parameter_list|,
name|fnname
parameter_list|,
name|type1
parameter_list|,
name|type2
parameter_list|,
name|args
parameter_list|,
name|argtypes
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|fnname
decl_stmt|,
name|type1
decl_stmt|,
name|type2
decl_stmt|,
decl|*
name|args
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|t
decl_stmt|,
name|convs
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|;
name|types
index|[
literal|0
index|]
operator|=
name|type1
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
name|type2
expr_stmt|;
name|convs
operator|=
name|make_tree_vec
argument_list|(
name|args
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|args
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
break|break;
name|t
operator|=
name|implicit_conversion
argument_list|(
name|types
index|[
name|i
index|]
argument_list|,
name|argtypes
index|[
name|i
index|]
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
comment|/* We need something for printing the candidate.  */
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|types
index|[
name|i
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* For COND_EXPR we rearranged the arguments; undo that now.  */
if|if
condition|(
name|args
index|[
literal|2
index|]
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|2
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|argtypes
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
else|else
name|viable
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|convs
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|is_complete
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if TYPE is a promoted arithmetic type.  */
end_comment

begin_function
specifier|static
name|int
name|promoted_arithmetic_type_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* [over.built]       In this section, the term promoted integral type is used to refer      to those integral types which are preserved by integral promotion      (including e.g.  int and long but excluding e.g.  char).      Similarly, the term promoted arithmetic type refers to promoted      integral types plus floating types.  */
return|return
operator|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type_promotes_to
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create any builtin operator overload candidates for the operator in    question given the converted operand types TYPE1 and TYPE2.  The other    args are passed through from add_builtin_candidates to    build_builtin_candidate.          TYPE1 and TYPE2 may not be permissible, and we must filter them.     If CODE is requires candidates operands of the same type of the kind    of which TYPE1 and TYPE2 are, we add both candidates    CODE (TYPE1, TYPE1) and CODE (TYPE2, TYPE2).  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidate
parameter_list|(
name|candidates
parameter_list|,
name|code
parameter_list|,
name|code2
parameter_list|,
name|fnname
parameter_list|,
name|type1
parameter_list|,
name|type2
parameter_list|,
name|args
parameter_list|,
name|argtypes
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|,
name|code2
decl_stmt|;
name|tree
name|fnname
decl_stmt|,
name|type1
decl_stmt|,
name|type2
decl_stmt|,
decl|*
name|args
decl_stmt|,
modifier|*
name|argtypes
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|args
index|[
literal|1
index|]
operator|=
name|integer_zero_node
expr_stmt|;
name|type2
operator|=
name|integer_type_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,      and  VQ  is  either  volatile or empty, there exist candidate operator      functions of the form 	     VQ T&   operator++(VQ T&); 	     T       operator++(VQ T&, int);    5 For every pair T, VQ), where T is an enumeration type or an arithmetic      type  other than bool, and VQ is either volatile or empty, there exist      candidate operator functions of the form 	     VQ T&   operator--(VQ T&); 	     T       operator--(VQ T&, int);    6 For every pair T, VQ), where T is  a  cv-qualified  or  cv-unqualified      complete  object type, and VQ is either volatile or empty, there exist      candidate operator functions of the form 	     T*VQ&   operator++(T*VQ&); 	     T*VQ&   operator--(T*VQ&); 	     T*      operator++(T*VQ&, int); 	     T*      operator--(T*VQ&, int);  */
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|candidates
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
comment|/* 7 For every cv-qualified or cv-unqualified complete object type T, there      exist candidate operator functions of the form  	     T&      operator*(T*);     8 For every function type T, there exist candidate operator functions of      the form 	     T&      operator*(T*);  */
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 9 For every type T, there exist candidate operator functions of the form 	     T*      operator+(T*);     10For  every  promoted arithmetic type T, there exist candidate operator      functions of the form 	     T       operator+(T); 	     T       operator-(T);  */
case|case
name|CONVERT_EXPR
case|:
comment|/* unary + */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 11For every promoted integral type T,  there  exist  candidate  operator      functions of the form 	     T       operator~(T);  */
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1      is the same type as C2 or is a derived class of C2, T  is  a  complete      object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,      there exist candidate operator functions of the form 	     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);      where CV12 is the union of CV1 and CV2.  */
case|case
name|MEMBER_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
block|{
name|tree
name|c1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|tree
name|c2
init|=
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
condition|?
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
argument_list|)
else|:
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|c1
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|&&
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|is_complete
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
return|return
name|candidates
return|;
comment|/* 13For every pair of promoted arithmetic types L and R, there exist  can-      didate operator functions of the form 	     LR      operator*(L, R); 	     LR      operator/(L, R); 	     LR      operator+(L, R); 	     LR      operator-(L, R); 	     bool    operator<(L, R); 	     bool    operator>(L, R); 	     bool    operator<=(L, R); 	     bool    operator>=(L, R); 	     bool    operator==(L, R); 	     bool    operator!=(L, R);      where  LR  is  the  result of the usual arithmetic conversions between      types L and R.     14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-      unqualified  complete  object  type and I is a promoted integral type,      there exist candidate operator functions of the form 	     T*      operator+(T*, I); 	     T&      operator[](T*, I); 	     T*      operator-(T*, I); 	     T*      operator+(I, T*); 	     T&      operator[](I, T*);     15For every T, where T is a pointer to complete object type, there exist      candidate operator functions of the form112) 	     ptrdiff_t operator-(T, T);     16For every pointer or enumeration type T, there exist candidate operator      functions of the form 	     bool    operator<(T, T); 	     bool    operator>(T, T); 	     bool    operator<=(T, T); 	     bool    operator>=(T, T); 	     bool    operator==(T, T); 	     bool    operator!=(T, T);     17For every pointer to member type T,  there  exist  candidate  operator      functions of the form 	     bool    operator==(T, T); 	     bool    operator!=(T, T);  */
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
break|break;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
comment|/* 18For  every pair of promoted integral types L and R, there exist candi-      date operator functions of the form 	     LR      operator%(L, R); 	     LR      operator&(L, R); 	     LR      operator^(L, R); 	     LR      operator|(L, R); 	     L       operator<<(L, R); 	     L       operator>>(L, R);      where LR is the result of the  usual  arithmetic  conversions  between      types L and R.  */
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
comment|/* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration      type, VQ is either volatile or empty, and R is a  promoted  arithmetic      type, there exist candidate operator functions of the form 	     VQ L&   operator=(VQ L&, R); 	     VQ L&   operator*=(VQ L&, R); 	     VQ L&   operator/=(VQ L&, R); 	     VQ L&   operator+=(VQ L&, R); 	     VQ L&   operator-=(VQ L&, R);     20For  every  pair T, VQ), where T is any type and VQ is either volatile      or empty, there exist candidate operator functions of the form 	     T*VQ&   operator=(T*VQ&, T*);     21For every pair T, VQ), where T is a pointer to member type and  VQ  is      either  volatile or empty, there exist candidate operator functions of      the form 	     VQ T&   operator=(VQ T&, T);     22For every triple  T,  VQ,  I),  where  T  is  a  cv-qualified  or  cv-      unqualified  complete object type, VQ is either volatile or empty, and      I is a promoted integral type, there exist  candidate  operator  func-      tions of the form 	     T*VQ&   operator+=(T*VQ&, I); 	     T*VQ&   operator-=(T*VQ&, I);     23For  every  triple  L,  VQ,  R), where L is an integral or enumeration      type, VQ is either volatile or empty, and R  is  a  promoted  integral      type, there exist candidate operator functions of the form  	     VQ L&   operator%=(VQ L&, R); 	     VQ L&   operator<<=(VQ L&, R); 	     VQ L&   operator>>=(VQ L&, R); 	     VQ L&   operator&=(VQ L&, R); 	     VQ L&   operator^=(VQ L&, R); 	     VQ L&   operator|=(VQ L&, R);  */
case|case
name|MODIFY_EXPR
case|:
switch|switch
condition|(
name|code2
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return
name|candidates
return|;
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
return|return
name|candidates
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
comment|/* [over.built]  	 For every pair of promoted arithmetic types L and R, there 	 exist candidate operator functions of the form   	 LR operator?(bool, L, R);   	 where LR is the result of the usual arithmetic conversions 	 between types L and R.  	 For every type T, where T is a pointer or pointer-to-member 	 type, there exist candidate operator functions of the form T 	 operator?(bool, T, T);  */
if|if
condition|(
name|promoted_arithmetic_type_p
argument_list|(
name|type1
argument_list|)
operator|&&
name|promoted_arithmetic_type_p
argument_list|(
name|type2
argument_list|)
condition|)
comment|/* That's OK.  */
break|break;
comment|/* Otherwise, the types should be pointers.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
return|return
name|candidates
return|;
comment|/* We don't check that the two types are the same; the logic 	 below will actually create two candidates; one in which both 	 parameter types are TYPE1, and one in which both parameter 	 types are TYPE2.  */
break|break;
comment|/* These arguments do not make for a legal overloaded operator.  */
return|return
name|candidates
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we're dealing with two pointer types or two enumeral types,      we need candidates for both of them.  */
if|if
condition|(
name|type2
operator|&&
operator|!
name|same_type_p
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|candidates
operator|=
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type1
argument_list|,
name|type1
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type2
argument_list|,
name|type2
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
block|}
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_block

begin_function
name|tree
name|type_decays_to
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* There are three conditions of builtin candidates:     1) bool-taking candidates.  These are the same regardless of the input.    2) pointer-pair taking candidates.  These are generated for each type       one of the input types converts to.    3) arithmetic candidates.  According to the standard, we should generate       all of these, but I'm trying not to...        Here we generate a superset of the possible candidates for this particular    case.  That is a subset of the full set the standard defines, plus some    other cases which the standard disallows. add_builtin_candidate will    filter out the illegal set.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_builtin_candidates
parameter_list|(
name|candidates
parameter_list|,
name|code
parameter_list|,
name|code2
parameter_list|,
name|fnname
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|,
name|code2
decl_stmt|;
name|tree
name|fnname
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ref1
decl_stmt|,
name|i
decl_stmt|;
name|int
name|enum_p
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|argtypes
index|[
literal|3
index|]
decl_stmt|;
comment|/* TYPES[i] is the set of possible builtin-operator parameter types      we will consider for the Ith argument.  These are represented as      a TREE_LIST; the TREE_VALUE of each node is the potential      parameter type.  */
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|argtypes
index|[
name|i
index|]
operator|=
name|lvalue_type
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|argtypes
index|[
name|i
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,      and  VQ  is  either  volatile or empty, there exist candidate operator      functions of the form 		 VQ T&   operator++(VQ T&);  */
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
name|ref1
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 24There also exist candidate operator functions of the form 	     bool    operator!(bool); 	     bool    operator&&(bool, bool); 	     bool    operator||(bool, bool);  */
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|boolean_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|boolean_type_node
argument_list|,
name|boolean_type_node
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|candidates
return|;
case|case
name|COND_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|enum_p
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ref1
operator|=
literal|0
expr_stmt|;
block|}
name|types
index|[
literal|0
index|]
operator|=
name|types
index|[
literal|1
index|]
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|tree
name|convs
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|code
operator|==
name|MODIFY_EXPR
operator|&&
name|code2
operator|==
name|NOP_EXPR
condition|)
return|return
name|candidates
return|;
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|convs
condition|)
return|return
name|candidates
return|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ref1
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
name|ref1
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enum_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|value_member
argument_list|(
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|real_lvalue_p
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
name|ref1
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enum_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Run through the possible parameter types of both arguments,      creating candidates with those parameter types.  */
for|for
control|(
init|;
name|types
index|[
literal|0
index|]
condition|;
name|types
index|[
literal|0
index|]
operator|=
name|TREE_CHAIN
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
control|)
block|{
if|if
condition|(
name|types
index|[
literal|1
index|]
condition|)
for|for
control|(
name|type
operator|=
name|types
index|[
literal|1
index|]
init|;
name|type
condition|;
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
name|candidates
operator|=
name|add_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|TREE_VALUE
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|candidates
operator|=
name|add_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|TREE_VALUE
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|candidates
return|;
block|}
end_block

begin_comment
comment|/* If TMPL can be successfully instantiated as indicated by    EXPLICIT_TARGS and ARGLIST, adds the instantiation to CANDIDATES.     TMPL is the template.  EXPLICIT_TARGS are any explicit template    arguments.  ARGLIST is the arguments provided at the call-site.    The RETURN_TYPE is the desired type for conversion operators.  If    OBJ is NULL_TREE, FLAGS and CTYPE are as for add_function_candidate.    If an OBJ is supplied, FLAGS and CTYPE are ignored, and OBJ is as for    add_conv_candidate.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate_real
parameter_list|(
name|candidates
parameter_list|,
name|tmpl
parameter_list|,
name|ctype
parameter_list|,
name|explicit_targs
parameter_list|,
name|arglist
parameter_list|,
name|return_type
parameter_list|,
name|flags
parameter_list|,
name|obj
parameter_list|,
name|strict
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|ctype
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|arglist
decl_stmt|,
name|return_type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|obj
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_tree_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|tree
name|args_without_in_chrg
init|=
name|arglist
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* We don't do deduction on the in-charge parameter, the VTT      parameter or 'this'.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
condition|)
name|args_without_in_chrg
operator|=
name|TREE_CHAIN
argument_list|(
name|args_without_in_chrg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|||
name|DECL_BASE_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
condition|)
name|args_without_in_chrg
operator|=
name|TREE_CHAIN
argument_list|(
name|args_without_in_chrg
argument_list|)
expr_stmt|;
name|i
operator|=
name|fn_type_unification
argument_list|(
name|tmpl
argument_list|,
name|explicit_targs
argument_list|,
name|targs
argument_list|,
name|args_without_in_chrg
argument_list|,
name|return_type
argument_list|,
name|strict
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|candidates
return|;
name|fn
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|candidates
return|;
if|if
condition|(
name|obj
operator|!=
name|NULL_TREE
condition|)
comment|/* Aha, this is a conversion function.  */
name|cand
operator|=
name|add_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
else|else
name|cand
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|ctype
argument_list|,
name|arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
operator|!=
name|tmpl
condition|)
comment|/* This situation can occur if a member template of a template        class is specialized.  Then, instantiate_template might return        an instantiation of the specialization, in which case the        DECL_TI_TEMPLATE field will point at the original        specialization.  For example:  	 template<class T> struct S { template<class U> void f(U); 				       template<> void f(int) {}; }; 	 S<double> sd; 	 sd.f(3);         Here, TMPL will be template<class U> S<double>::f(U).        And, instantiate template will give us the specialization        template<> S<double>::f(int).  But, the DECL_TI_TEMPLATE field        for this will point at template<class T> template<> S<T>::f(int),        so that we can find the definition.  For the purposes of        overload resolution, however, we want the original TMPL.  */
name|cand
operator|->
name|template
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|cand
operator|->
name|template
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate
parameter_list|(
name|candidates
parameter_list|,
name|tmpl
parameter_list|,
name|ctype
parameter_list|,
name|explicit_targs
parameter_list|,
name|arglist
parameter_list|,
name|return_type
parameter_list|,
name|flags
parameter_list|,
name|strict
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|ctype
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|arglist
decl_stmt|,
name|return_type
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
block|{
return|return
name|add_template_candidate_real
argument_list|(
name|candidates
argument_list|,
name|tmpl
argument_list|,
name|ctype
argument_list|,
name|explicit_targs
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_conv_candidate
parameter_list|(
name|candidates
parameter_list|,
name|tmpl
parameter_list|,
name|obj
parameter_list|,
name|arglist
parameter_list|,
name|return_type
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|tree
name|tmpl
decl_stmt|,
name|obj
decl_stmt|,
name|arglist
decl_stmt|,
name|return_type
decl_stmt|;
block|{
return|return
name|add_template_candidate_real
argument_list|(
name|candidates
argument_list|,
name|tmpl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|DEDUCE_CONV
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|any_viable
parameter_list|(
name|cands
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cands
decl_stmt|;
block|{
for|for
control|(
init|;
name|cands
condition|;
name|cands
operator|=
name|cands
operator|->
name|next
control|)
if|if
condition|(
name|pedantic
condition|?
name|cands
operator|->
name|viable
operator|==
literal|1
else|:
name|cands
operator|->
name|viable
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|splice_viable
parameter_list|(
name|cands
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cands
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
modifier|*
name|p
init|=
operator|&
name|cands
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|pedantic
condition|?
operator|(
operator|*
name|p
operator|)
operator|->
name|viable
operator|==
literal|1
else|:
operator|(
operator|*
name|p
operator|)
operator|->
name|viable
condition|)
name|p
operator|=
operator|&
operator|(
operator|(
operator|*
name|p
operator|)
operator|->
name|next
operator|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
name|cands
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_this
parameter_list|(
name|obj
parameter_list|)
name|tree
name|obj
decl_stmt|;
block|{
comment|/* Fix this to work on non-lvalues.  */
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_z_candidates
parameter_list|(
name|candidates
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
for|for
control|(
init|;
name|candidates
condition|;
name|candidates
operator|=
name|candidates
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|candidates
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|candidates
operator|->
name|convs
argument_list|)
operator|==
literal|3
condition|)
name|error
argument_list|(
literal|"%s %D(%T, %T, %T)<built-in>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|candidates
operator|->
name|convs
argument_list|)
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"%s %D(%T, %T)<built-in>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s %D(%T)<built-in>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidates
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|candidates
operator|->
name|fn
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s %T<conversion>"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"%s %+#D%s"
argument_list|,
name|str
argument_list|,
name|candidates
operator|->
name|fn
argument_list|,
name|candidates
operator|->
name|viable
operator|==
operator|-
literal|1
condition|?
literal|"<near match>"
else|:
literal|""
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the best overload candidate to perform the requested    conversion.  This function is used for three the overloading situations    described in [over.match.copy], [over.match.conv], and [over.match.ref].    If TOTYPE is a REFERENCE_TYPE, we're trying to find an lvalue binding as    per [dcl.init.ref], so we ignore temporary bindings.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_user_type_conversion_1
parameter_list|(
name|totype
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|totype
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fromtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|ctors
init|=
name|NULL_TREE
decl_stmt|,
name|convs
init|=
name|NULL_TREE
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We represent conversion within a hierarchy using RVALUE_CONV and      BASE_CONV, as specified by [over.best.ics]; these become plain      constructor calls, as specified in [dcl.init].  */
name|my_friendly_assert
argument_list|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|fromtype
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
operator|||
operator|!
name|DERIVED_FROM_P
argument_list|(
name|totype
argument_list|,
name|fromtype
argument_list|)
argument_list|,
literal|20011226
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
condition|)
name|ctors
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|complete_ctor_identifier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|fromtype
argument_list|)
condition|)
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|fromtype
argument_list|)
expr_stmt|;
name|candidates
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|LOOKUP_NO_CONVERSION
expr_stmt|;
if|if
condition|(
name|ctors
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|ctors
operator|=
name|TREE_VALUE
argument_list|(
name|ctors
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|totype
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* We should never try to call the abstract or base constructor 	 from here.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
argument_list|)
argument_list|,
literal|20011226
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|ctors
condition|;
name|ctors
operator|=
name|OVL_NEXT
argument_list|(
name|ctors
argument_list|)
control|)
block|{
name|tree
name|ctor
init|=
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NONCONVERTING_P
argument_list|(
name|ctor
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ctor
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|ctor
argument_list|,
name|totype
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|ctor
argument_list|,
name|totype
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
block|{
name|candidates
operator|->
name|second_conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|totype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|candidates
operator|->
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|convs
condition|)
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|int
name|convflags
init|=
name|LOOKUP_NO_CONVERSION
decl_stmt|;
name|tree
name|ics
decl_stmt|;
comment|/* If we are called to convert to a reference type, we are trying to 	 find an lvalue binding, so don't even consider temporaries.  If 	 we don't find an lvalue binding, the caller will try again to 	 look for a temporary binding.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|convflags
operator||=
name|LOOKUP_NO_TEMP_BIND
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
name|ics
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|convflags
argument_list|)
expr_stmt|;
else|else
comment|/* We can't compute this yet.  */
name|ics
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|ics
operator|&&
name|ICS_BAD_FLAG
argument_list|(
name|ics
argument_list|)
condition|)
comment|/* ignore the near match.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|ics
condition|)
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|old_candidates
init|=
name|candidates
decl_stmt|;
comment|/* [over.match.funcs] For conversion functions, the function is 	       considered to be a member of the class of the implicit object 	       argument for the purpose of defining the type of the implicit 	       object parameter.  	       So we pass fromtype as CTYPE to add_*_candidate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|fromtype
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|totype
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CONV
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|fromtype
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|!=
name|old_candidates
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|ics
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|convflags
argument_list|)
expr_stmt|;
name|candidates
operator|->
name|second_conv
operator|=
name|ics
expr_stmt|;
name|candidates
operator|->
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|fromtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ics
operator|==
name|NULL_TREE
condition|)
name|candidates
operator|->
name|viable
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|candidates
operator|->
name|viable
operator|==
literal|1
operator|&&
name|ICS_BAD_FLAG
argument_list|(
name|ics
argument_list|)
condition|)
name|candidates
operator|->
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (flags& LOOKUP_COMPLAIN) 	{ 	  if (candidates&& ! candidates->next)
comment|/* say why this one won't work or try to be loose */
block|; 	  else 	    error ("no viable candidates"); 	}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error
argument_list|(
literal|"conversion from `%T' to `%T' is ambiguous"
argument_list|,
name|fromtype
argument_list|,
name|totype
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
name|cand
operator|=
name|candidates
expr_stmt|;
comment|/* any one will do */
name|cand
operator|->
name|second_conv
operator|=
name|build1
argument_list|(
name|AMBIG_CONV
argument_list|,
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cand
return|;
block|}
for|for
control|(
name|p
operator|=
operator|&
operator|(
name|cand
operator|->
name|second_conv
operator|)
init|;
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|;
control|)
name|p
operator|=
operator|&
operator|(
name|TREE_OPERAND
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
operator|*
name|p
operator|=
name|build
argument_list|(
name|USER_CONV
argument_list|,
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
condition|?
name|totype
else|:
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|,
name|expr
argument_list|,
name|build_ptr_wrapper
argument_list|(
name|cand
argument_list|)
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
name|ICS_USER_FLAG
argument_list|(
operator|*
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|viable
operator|==
operator|-
literal|1
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
operator|*
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_function
name|tree
name|build_user_type_conversion
parameter_list|(
name|totype
parameter_list|,
name|expr
parameter_list|,
name|flags
parameter_list|)
name|tree
name|totype
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|build_user_type_conversion_1
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
name|error_mark_node
return|;
return|return
name|convert_from_reference
argument_list|(
name|convert_like
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Do any initial processing on the arguments to a function call.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|args
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg
operator|=
name|resolve_offset_ref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_from_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_function
name|tree
name|build_new_function_call
parameter_list|(
name|fn
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|template_only
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
for|for
control|(
name|t1
operator|=
name|fn
init|;
name|t1
condition|;
name|t1
operator|=
name|OVL_CHAIN
argument_list|(
name|t1
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|OVL_FUNCTION
argument_list|(
name|t1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|explicit_targs
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|template_only
condition|)
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
if|if
condition|(
name|candidates
operator|&&
operator|!
name|candidates
operator|->
name|next
condition|)
return|return
name|build_function_call
argument_list|(
name|candidates
operator|->
name|fn
argument_list|,
name|args
argument_list|)
return|;
name|error
argument_list|(
literal|"no matching function for call to `%D(%A)'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"call of overloaded `%D(%A)' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* This is not really overloaded. */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_object_call
parameter_list|(
name|obj
parameter_list|,
name|args
parameter_list|)
name|tree
name|obj
decl_stmt|,
name|args
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|convs
decl_stmt|,
name|mem_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* It's no good looking for an overloaded operator() on a 	 pointer-to-member-function.  */
name|error
argument_list|(
literal|"pointer-to-member function %E cannot be called without an object; consider using .* or ->*"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|ansi_opname
argument_list|(
name|CALL_EXPR
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|base
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
argument_list|)
decl_stmt|;
name|mem_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|base
argument_list|,
name|NULL_TREE
argument_list|,
name|mem_args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|base
argument_list|,
name|mem_args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|candidates
operator|=
name|add_template_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|totype
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no match for call to `(%T) (%A)'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"call of `(%T) (%A)' is ambiguous"
argument_list|,
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Since cand->fn will be a type, not a function, for a conversion      function, we must be careful not to unconditionally look at      DECL_NAME here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|mem_args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
name|obj
operator|=
name|convert_like_with_context
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|,
name|cand
operator|->
name|fn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME */
return|return
name|build_function_call
argument_list|(
name|obj
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|op_error
parameter_list|(
name|code
parameter_list|,
name|code2
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|problem
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|,
name|code2
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
specifier|const
name|char
modifier|*
name|problem
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
name|opname
operator|=
name|assignment_operator_name_info
index|[
name|code2
index|]
operator|.
name|name
expr_stmt|;
else|else
name|opname
operator|=
name|operator_name_info
index|[
name|code
index|]
operator|.
name|name
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|error
argument_list|(
literal|"%s for `%T ? %T : %T' operator"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|error_type
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|error_type
argument_list|(
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|error
argument_list|(
literal|"%s for `%T %s' operator"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|opname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|error
argument_list|(
literal|"%s for `%T [%T]' operator"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|error_type
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arg2
condition|)
name|error
argument_list|(
literal|"%s for `%T %s %T' operator"
argument_list|,
name|problem
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|opname
argument_list|,
name|error_type
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s for `%s %T' operator"
argument_list|,
name|problem
argument_list|,
name|opname
argument_list|,
name|error_type
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the implicit conversion sequence that could be used to    convert E1 to E2 in [expr.cond].  */
end_comment

begin_function
specifier|static
name|tree
name|conditional_conversion
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
name|tree
name|e1
decl_stmt|;
name|tree
name|e2
decl_stmt|;
block|{
name|tree
name|t1
init|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|conv
decl_stmt|;
comment|/* [expr.cond]       If E2 is an lvalue: E1 can be converted to match E2 if E1 can be      implicitly converted (clause _conv_) to the type "reference to      T2", subject to the constraint that in the conversion the      reference must bind directly (_dcl.init.ref_) to E1.  */
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|e2
argument_list|)
condition|)
block|{
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|build_reference_type
argument_list|(
name|t2
argument_list|)
argument_list|,
name|t1
argument_list|,
name|e1
argument_list|,
name|LOOKUP_NO_TEMP_BIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
return|return
name|conv
return|;
block|}
comment|/* [expr.cond]       If E1 and E2 have class type, and the underlying class types are      the same or one is a base class of the other: E1 can be converted      to match E2 if the class of T2 is the same type as, or a base      class of, the class of T1, and the cv-qualification of T2 is the      same cv-qualification as, or a greater cv-qualification than, the      cv-qualification of T1.  If the conversion is applied, E1 is      changed to an rvalue of type T2 that still refers to the original      source class object (or the appropriate subobject thereof).  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|&&
name|same_or_base_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|at_least_as_qualified_p
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|t1
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|t2
argument_list|,
name|conv
argument_list|)
expr_stmt|;
return|return
name|conv
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
comment|/* [expr.cond]       E1 can be converted to match E2 if E1 can be implicitly converted      to the type that expression E2 would have if E2 were converted to      an rvalue (or the type it has, if E2 is an rvalue).  */
return|return
name|implicit_conversion
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|,
name|e1
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three    arguments to the conditional expression.  By the time this function    is called, any suitable candidate functions are included in    CANDIDATES.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|tree
name|arg1
decl_stmt|;
name|tree
name|arg2
decl_stmt|;
name|tree
name|arg3
decl_stmt|;
block|{
name|tree
name|arg2_type
decl_stmt|;
name|tree
name|arg3_type
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|tree
name|result_type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|lvalue_p
init|=
literal|1
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
comment|/* As a G++ extension, the second argument to the conditional can be      omitted.  (So that `a ? : c' is roughly equivalent to `a ? a :      c'.)  If the second operand is omitted, make sure it is      calculated only once.  */
if|if
condition|(
operator|!
name|arg2
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|arg2
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]         The first expr ession is implicitly converted to bool (clause      _conv_).  */
name|arg1
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
comment|/* If something has already gone wrong, just pass that fact up the      tree.  */
if|if
condition|(
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* [expr.cond]       If either the second or the third operand has type (possibly      cv-qualified) void, then the lvalue-to-rvalue (_conv.lval_),      array-to-pointer (_conv.array_), and function-to-pointer      (_conv.func_) standard conversions are performed on the second      and third operands.  */
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
block|{
comment|/* Do the conversions.  We don't these for `void' type arguments 	 since it can't have any effect and since decay_conversion 	 does not handle that case gracefully.  */
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|)
name|arg2
operator|=
name|decay_conversion
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
name|arg3
operator|=
name|decay_conversion
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
comment|/* [expr.cond]  	 One of the following shall hold:  	 --The second or the third operand (but not both) is a 	   throw-expression (_except.throw_); the result is of the 	   type of the other and is an rvalue.  	 --Both the second and the third operands have type void; the 	   result is of type void and is an rvalue.   */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|THROW_EXPR
operator|)
operator|^
operator|(
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|THROW_EXPR
operator|)
condition|)
name|result_type
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|THROW_EXPR
operator|)
condition|?
name|arg3_type
else|:
name|arg2_type
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"`%E' has type `void' and is not a throw-expression"
argument_list|,
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|?
name|arg2
else|:
name|arg3
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|lvalue_p
operator|=
literal|0
expr_stmt|;
goto|goto
name|valid_operands
goto|;
block|}
comment|/* [expr.cond]       Otherwise, if the second and third operand have different types,      and either has (possibly cv-qualified) class type, an attempt is      made to convert each of those operands to the type of the other.  */
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
operator|&&
operator|(
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|CLASS_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|conv2
init|=
name|conditional_conversion
argument_list|(
name|arg2
argument_list|,
name|arg3
argument_list|)
decl_stmt|;
name|tree
name|conv3
init|=
name|conditional_conversion
argument_list|(
name|arg3
argument_list|,
name|arg2
argument_list|)
decl_stmt|;
comment|/* [expr.cond]  	 If both can be converted, or one can be converted but the 	 conversion is ambiguous, the program is ill-formed.  If 	 neither can be converted, the operands are left unchanged and 	 further checking is performed as described below.  If exactly 	 one conversion is possible, that conversion is applied to the 	 chosen operand and the converted operand is used in place of 	 the original operand for the remainder of this section.  */
if|if
condition|(
operator|(
name|conv2
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv2
argument_list|)
operator|&&
name|conv3
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv3
argument_list|)
operator|)
operator|||
operator|(
name|conv2
operator|&&
name|TREE_CODE
argument_list|(
name|conv2
argument_list|)
operator|==
name|AMBIG_CONV
operator|)
operator|||
operator|(
name|conv3
operator|&&
name|TREE_CODE
argument_list|(
name|conv3
argument_list|)
operator|==
name|AMBIG_CONV
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"operands to ?: have different types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|conv2
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv2
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* That may not quite have done the trick.  If the two types 	     are cv-qualified variants of one another, we will have 	     just used an IDENTITY_CONV.  (There's no conversion from 	     an lvalue of one class type to an lvalue of another type, 	     even a cv-qualified variant, and we don't want to lose 	     lvalue-ness here.)  So, we manually add a NOP_EXPR here 	     if necessary.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|arg3_type
argument_list|)
condition|)
name|arg2
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|arg3_type
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conv3
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv3
argument_list|)
condition|)
block|{
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv3
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_from_reference
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|,
name|arg2_type
argument_list|)
condition|)
name|arg3
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|arg2_type
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* [expr.cond]       If the second and third operands are lvalues and have the same      type, the result is of that type and is an lvalue.  */
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|arg2
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|arg3
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|arg2_type
expr_stmt|;
goto|goto
name|valid_operands
goto|;
block|}
comment|/* [expr.cond]       Otherwise, the result is an rvalue.  If the second and third      operand do not have the same type, and either has (possibly      cv-qualified) class type, overload resolution is used to      determine the conversions (if any) to be applied to the operands      (_over.match.oper_, _over.built_).  */
name|lvalue_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
operator|&&
operator|(
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|CLASS_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|args
index|[
literal|3
index|]
decl_stmt|;
name|tree
name|conv
decl_stmt|;
comment|/* Rearrange the arguments so that add_builtin_candidate only has 	 to know about two args.  In build_builtin_candidates, the 	 arguments are unscrambled.  */
name|args
index|[
literal|0
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
name|candidates
operator|=
name|add_builtin_candidates
argument_list|(
name|candidates
argument_list|,
name|COND_EXPR
argument_list|,
name|NOP_EXPR
argument_list|,
name|ansi_opname
argument_list|(
name|COND_EXPR
argument_list|)
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* [expr.cond]  	 If the overload resolution fails, the program is 	 ill-formed.  */
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
name|op_error
argument_list|(
name|COND_EXPR
argument_list|,
name|NOP_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
block|{
name|op_error
argument_list|(
name|COND_EXPR
argument_list|,
name|NOP_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [expr.cond]  	 Otherwise, the conversions thus determined are applied, and 	 the converted operands are used in place of the original 	 operands for the remainder of this section.  */
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]       Lvalue-to-rvalue (_conv.lval_), array-to-pointer (_conv.array_),      and function-to-pointer (_conv.func_) standard conversions are      performed on the second and third operands.       We need to force the lvalue-to-rvalue conversion here for class types,      so we get TARGET_EXPRs; trying to deal with a COND_EXPR of class rvalues      that isn't wrapped with a TARGET_EXPR plays havoc with exception      regions.       We use ocp_convert rather than build_user_type_conversion because the      latter returns NULL_TREE on failure, while the former gives an error.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|arg2
argument_list|)
condition|)
name|arg2
operator|=
name|ocp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|arg2
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|decay_conversion
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|arg3
argument_list|)
condition|)
name|arg3
operator|=
name|ocp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|,
name|arg3
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
name|arg3
operator|=
name|decay_conversion
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* [expr.cond]            After those conversions, one of the following shall hold:       --The second and third operands have the same type; the result  is  of        that type.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
condition|)
name|result_type
operator|=
name|arg2_type
expr_stmt|;
comment|/* [expr.cond]       --The second and third operands have arithmetic or enumeration        type; the usual arithmetic conversions are performed to bring        them to a common type, and the result is of that type.  */
elseif|else
if|if
condition|(
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg2_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg3_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
comment|/* In this case, there is always a common type.  */
name|result_type
operator|=
name|type_after_usual_arithmetic_conversions
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg3_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|warning
argument_list|(
literal|"enumeral mismatch in conditional expression: `%T' vs `%T'"
argument_list|,
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg2_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|same_type_p
argument_list|(
name|arg3_type
argument_list|,
name|type_promotes_to
argument_list|(
name|arg2_type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg3_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|type_promotes_to
argument_list|(
name|arg3_type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]       --The second and third operands have pointer type, or one has        pointer type and the other is a null pointer constant; pointer        conversions (_conv.ptr_) and qualification conversions        (_conv.qual_) are performed to bring them to their composite        pointer type (_expr.rel_).  The result is of the composite        pointer type.       --The second and third operands have pointer to member type, or        one has pointer to member type and the other is a null pointer        constant; pointer to member conversions (_conv.mem_) and        qualification conversions (_conv.qual_) are performed to bring        them to a common type, whose cv-qualification shall match the        cv-qualification of either the second or the third operand.        The result is of the common type.   */
elseif|else
if|if
condition|(
operator|(
name|null_ptr_cst_p
argument_list|(
name|arg2
argument_list|)
operator|&&
operator|(
name|TYPE_PTR_P
argument_list|(
name|arg3_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|arg3_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|null_ptr_cst_p
argument_list|(
name|arg3
argument_list|)
operator|&&
operator|(
name|TYPE_PTR_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg2_type
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
condition|)
block|{
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"conditional expression"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|error
argument_list|(
literal|"operands to ?: have different types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|valid_operands
label|:
name|result
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand both sides into the same slot, hopefully the target of the      ?: expression.  We used to check for TARGET_EXPRs here, but now we      sometimes wrap them in NOP_EXPRs so the test would fail.  */
if|if
condition|(
operator|!
name|lvalue_p
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|result_type
argument_list|)
condition|)
name|result
operator|=
name|build_target_expr_with_type
argument_list|(
name|result
argument_list|,
name|result_type
argument_list|)
expr_stmt|;
comment|/* If this expression is an rvalue, but might be mistaken for an      lvalue, we must add a NON_LVALUE_EXPR.  */
if|if
condition|(
operator|!
name|lvalue_p
operator|&&
name|real_lvalue_p
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|result_type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|build_new_op
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|mem_arglist
init|=
name|NULL_TREE
decl_stmt|,
name|arglist
decl_stmt|,
name|fnname
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|NOP_EXPR
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|error_mark_node
operator|||
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* This can happen if a template takes all non-type parameters, e.g.      undeclared_template<1, 5, 72>a;  */
if|if
condition|(
name|code
operator|==
name|LT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"`%D' must be declared before use"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|NULL_TREE
expr_stmt|;
name|fnname
operator|=
name|ansi_assopname
argument_list|(
name|code2
argument_list|)
expr_stmt|;
block|}
else|else
name|fnname
operator|=
name|ansi_opname
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg1
operator|=
name|resolve_offset_ref
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|convert_from_reference
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
case|case
name|VEC_NEW_EXPR
case|:
case|case
name|VEC_DELETE_EXPR
case|:
case|case
name|DELETE_EXPR
case|:
comment|/* Use build_op_new_call and build_op_delete_call instead. */
name|abort
argument_list|()
expr_stmt|;
case|case
name|CALL_EXPR
case|:
return|return
name|build_object_call
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|arg2
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg2
operator|=
name|resolve_offset_ref
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg3
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg3
operator|=
name|resolve_offset_ref
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_from_reference
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|arg2
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|builtin
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|arg2
operator|||
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|builtin
goto|;
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
condition|)
name|arg2
operator|=
name|integer_zero_node
expr_stmt|;
name|arglist
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fns
operator|=
name|lookup_function_nonclass
argument_list|(
name|fnname
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|&&
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|templates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|fnname
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|fns
return|;
block|}
else|else
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
argument_list|)
decl_stmt|;
name|mem_arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|this_arglist
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|this_arglist
operator|=
name|mem_arglist
expr_stmt|;
else|else
name|this_arglist
operator|=
name|arglist
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* A member template. */
name|templates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|basetype
argument_list|,
name|NULL_TREE
argument_list|,
name|this_arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|fnname
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|basetype
argument_list|,
name|this_arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|tree
name|args
index|[
literal|3
index|]
decl_stmt|;
comment|/* Rearrange the arguments for ?: so that add_builtin_candidate only has        to know about two args; a builtin candidate will always have a first        parameter of type bool.  We'll handle that in        build_builtin_candidate.  */
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|candidates
operator|=
name|add_builtin_candidates
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Look for an `operator++ (int)'.  If they didn't have 	     one, then we fall back to the old way of doing things.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|pedwarn
argument_list|(
literal|"no `%D(int)' declared for postfix `%s', trying prefix operator instead"
argument_list|,
name|fnname
argument_list|,
name|operator_name_info
index|[
name|code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|code
operator|=
name|PREINCREMENT_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|PREDECREMENT_EXPR
expr_stmt|;
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|flags
argument_list|,
name|arg1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* The caller will deal with these.  */
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|NULL_TREE
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|op_error
argument_list|(
name|code
argument_list|,
name|code2
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|op_error
argument_list|(
name|code
argument_list|,
name|code2
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"ambiguous overload"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
specifier|extern
name|int
name|warn_synth
decl_stmt|;
if|if
condition|(
name|warn_synth
operator|&&
name|fnname
operator|==
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|candidates
operator|->
name|next
operator|&&
operator|!
name|candidates
operator|->
name|next
operator|->
name|next
condition|)
block|{
name|warning
argument_list|(
literal|"using synthesized `%#D' for copy assignment"
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  where cfront would use `%#D'"
argument_list|,
name|cand
operator|==
name|candidates
condition|?
name|candidates
operator|->
name|next
operator|->
name|fn
else|:
name|candidates
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|mem_arglist
else|:
name|arglist
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* Check for comparison of different enum types.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison between `%#T' and `%#T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* We need to strip any leading REF_BIND so that bitfields don't cause      errors.  This should not remove any important conversions, because      builtins don't apply to class objects directly.  */
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
block|{
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg3
condition|)
block|{
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
name|builtin
label|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
return|return
name|build_modify_expr
argument_list|(
name|arg1
argument_list|,
name|code2
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
literal|"unary *"
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|cp_build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|candidates
operator|!=
literal|0
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
return|return
name|build_array_ref
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
return|;
case|case
name|MEMBER_REF
case|:
return|return
name|build_m_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|arg2
argument_list|)
return|;
comment|/* The caller will deal with these.  */
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
return|return
name|NULL_TREE
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build a call to operator delete.  This has to be handled very specially,    because the restrictions on what signatures match are different from all    other call instances.  For a normal delete, only a delete taking (void *)    or (void *, size_t) is accepted.  For a placement delete, only an exact    match with the placement new is accepted.     CODE is either DELETE_EXPR or VEC_DELETE_EXPR.    ADDR is the pointer to be deleted.  For placement delete, it is also      used to determine what the corresponding new looked like.    SIZE is the size of the memory block to be deleted.    FLAGS are the usual overloading flags.    PLACEMENT is the corresponding placement new call, or NULL_TREE.  */
end_comment

begin_function
name|tree
name|build_op_delete_call
parameter_list|(
name|code
parameter_list|,
name|addr
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|,
name|placement
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|size
decl_stmt|,
name|placement
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|fnname
decl_stmt|,
name|fntype
decl_stmt|,
name|argtypes
decl_stmt|,
name|args
decl_stmt|,
name|type
decl_stmt|;
name|int
name|pass
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|ansi_opname
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
condition|)
comment|/* In [class.free]         If the result of the lookup is ambiguous or inaccessible, or if        the lookup selects a placement deallocation function, the        program is ill-formed.           Therefore, we ask lookup_fnfields to complain ambout ambiguity.  */
block|{
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
name|fns
operator|=
name|lookup_name_nonclass
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|placement
condition|)
block|{
comment|/* placement is a CALL_EXPR around an ADDR_EXPR around a function.  */
comment|/* Extract the function.  */
name|argtypes
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|placement
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then the second parm type.  */
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtypes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also the second argument.  */
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|placement
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First try it without the size argument.  */
name|argtypes
operator|=
name|void_list_node
expr_stmt|;
name|args
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Strip const and volatile from addr.  */
name|addr
operator|=
name|cp_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* We make two tries at finding a matching `operator delete'.  On      the first pass, we look for an one-operator (or placement)      operator delete.  If we're not doing placement delete, then on      the second pass we look for a two-argument delete.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
operator|(
name|placement
condition|?
literal|1
else|:
literal|2
operator|)
condition|;
operator|++
name|pass
control|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
else|else
comment|/* Normal delete; now try to find a match including the size 	   argument.  */
name|argtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
comment|/* Go through the `operator delete' functions looking for one 	 with a matching type.  */
for|for
control|(
name|fn
operator|=
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|?
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
else|:
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Exception specifications on the `delete' operator do not 	     matter.  */
name|t
operator|=
name|build_exception_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We also don't compare attributes.  We're really just 	     trying to check the types of the first two parameters.  */
if|if
condition|(
name|comptypes
argument_list|(
name|t
argument_list|,
name|fntype
argument_list|,
name|COMPARE_NO_ATTRIBUTES
argument_list|)
condition|)
break|break;
block|}
comment|/* If we found a match, we're done.  */
if|if
condition|(
name|fn
condition|)
break|break;
block|}
comment|/* If we have a matching function, call it.  */
if|if
condition|(
name|fn
condition|)
block|{
comment|/* Make sure we have the actual function, and not an 	 OVERLOAD.  */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If the FN is a member function, make sure that it is 	 accessible.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|enforce_access
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* If we are doing placement delete we do nothing if we don't find a      matching op delete.  */
if|if
condition|(
name|placement
condition|)
return|return
name|NULL_TREE
return|;
name|error
argument_list|(
literal|"no suitable `operator delete' for `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* If the current scope isn't allowed to access DECL along    BASETYPE_PATH, give an error.  The most derived class in    BASETYPE_PATH is the one used to qualify DECL.  */
end_comment

begin_function
name|int
name|enforce_access
parameter_list|(
name|basetype_path
parameter_list|,
name|decl
parameter_list|)
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|accessible
decl_stmt|;
name|accessible
operator|=
name|accessible_p
argument_list|(
name|basetype_path
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|accessible
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%+#D' is private"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%+#D' is protected"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"`%+#D' is inaccessible"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Perform the conversions in CONVS on the expression EXPR.     FN and ARGNUM are used for diagnostics.  ARGNUM is zero based, -1    indicates the `this' argument of a method.  INNER is non-zero when    being called to continue a conversion chain. It is negative when a    reference binding will be applied, positive otherwise. */
end_comment

begin_function
specifier|static
name|tree
name|convert_like_real
parameter_list|(
name|convs
parameter_list|,
name|expr
parameter_list|,
name|fn
parameter_list|,
name|argnum
parameter_list|,
name|inner
parameter_list|)
name|tree
name|convs
decl_stmt|,
name|expr
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|inner
decl_stmt|;
block|{
name|int
name|savew
decl_stmt|,
name|savee
decl_stmt|;
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|convs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|USER_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|AMBIG_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|REF_BIND
condition|)
block|{
name|tree
name|t
init|=
name|convs
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
operator|||
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expr
operator|=
name|convert_like_real
argument_list|(
name|t
argument_list|,
name|expr
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
name|convert_like_real
argument_list|(
name|t
argument_list|,
name|expr
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|,
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
break|break;
block|}
name|pedwarn
argument_list|(
literal|"invalid conversion from `%T' to `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|totype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|pedwarn
argument_list|(
literal|"  initializing argument %P of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|inner
condition|)
name|expr
operator|=
name|dubious_conversion_warnings
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
literal|"argument"
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
condition|)
block|{
case|case
name|USER_CONV
case|:
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|WRAPPER_PTR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|convfn
init|=
name|cand
operator|->
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|convfn
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|convfn
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|convfn
argument_list|)
operator|||
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|convfn
argument_list|)
condition|)
comment|/* We should never try to call the abstract or base constructor 		 from here.  */
name|abort
argument_list|()
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|build_this
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* If this is a constructor or a function returning an aggr type, 	   we need to build up a TARGET_EXPR.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|convfn
argument_list|)
condition|)
name|expr
operator|=
name|build_cplus_new
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* The result of the call is then used to direct-initialize the object 	   that is the destination of the copy-initialization.  [dcl.init]  	   Note that this step is not reflected in the conversion sequence; 	   it affects the semantics when we actually perform the 	   conversion, but is not considered during overload resolution.  	   If the target is a class, that means call a ctor.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
operator|&&
operator|(
name|inner
operator|>=
literal|0
operator|||
operator|!
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
block|{
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|expr
operator|=
name|build_new_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
comment|/* Core issue 84, now a DR, says that we don't allow UDCs 		  for these args (which deliberately breaks copy-init of an 		  auto_ptr<Base> from an auto_ptr<Derived>).  */
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
expr_stmt|;
comment|/* Tell the user where this failing constructor call came from.  */
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|warning
argument_list|(
literal|"  initializing argument %P of `%D' from result of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|,
name|convfn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|error
argument_list|(
literal|"  initializing argument %P of `%D' from result of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|,
name|convfn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|warning
argument_list|(
literal|"  initializing temporary from result of `%D'"
argument_list|,
name|convfn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|error
argument_list|(
literal|"  initializing temporary from result of `%D'"
argument_list|,
name|convfn
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_cplus_new
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
case|case
name|IDENTITY_CONV
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|instantiate_type
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|itf_complain
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
case|case
name|AMBIG_CONV
case|:
comment|/* Call build_user_type_conversion again for the error.  */
return|return
name|build_user_type_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
default|default:
break|break;
block|}
empty_stmt|;
name|expr
operator|=
name|convert_like_real
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|,
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|==
name|REF_BIND
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Convert a non-array constant variable to its underlying value, unless we      are about to bind it to a reference, in which case we need to      leave it as an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|REF_BIND
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
condition|)
block|{
case|case
name|RVALUE_CONV
case|:
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* else fall through */
case|case
name|BASE_CONV
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|==
name|BASE_CONV
operator|&&
operator|!
name|NEED_TEMPORARY_P
argument_list|(
name|convs
argument_list|)
condition|)
block|{
comment|/* We are going to bind a reference directly to a base-class 	     subobject of EXPR.  */
name|tree
name|base_ptr
init|=
name|build_pointer_type
argument_list|(
name|totype
argument_list|)
decl_stmt|;
comment|/* Build an expression for `*((base*)&expr)'.  */
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|perform_implicit_conversion
argument_list|(
name|base_ptr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|"implicit conversion"
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/* Copy-initialization where the cv-unqualified version of the source 	 type is the same class as, or a derived class of, the class of the 	 destination [is treated as direct-initialization].  [dcl.init] */
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|expr
operator|=
name|build_new_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|warning
argument_list|(
literal|"  initializing argument %P of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|error
argument_list|(
literal|"  initializing argument %P of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
name|build_cplus_new
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|REF_BIND
case|:
block|{
name|tree
name|ref_type
init|=
name|totype
decl_stmt|;
comment|/* If necessary, create a temporary.  */
if|if
condition|(
name|NEED_TEMPORARY_P
argument_list|(
name|convs
argument_list|)
operator|||
operator|!
name|lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_target_expr_with_type
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Take the address of the thing to which we will bind the 	   reference.  */
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Convert it to a pointer to the type referred to by the 	   reference.  This will adjust the pointer if a derived to 	   base conversion is being performed.  */
name|expr
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref_type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Convert the pointer to the desired reference type.  */
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|ref_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
case|case
name|LVALUE_CONV
case|:
return|return
name|decay_conversion
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|QUAL_CONV
case|:
comment|/* Warn about deprecated conversion if appropriate.  */
name|string_conv_p
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ocp_convert
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARG is being passed to a varargs function.  Perform any conversions    required.  Array/function to pointer decay must have already happened.    Return the converted value.  */
end_comment

begin_function
name|tree
name|convert_arg_to_ellipsis
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|arg
operator|=
name|cp_convert
argument_list|(
name|double_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|require_complete_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|error_mark_node
operator|&&
operator|!
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Undefined behaviour [expr.call] 5.2.2/7.  */
name|warning
argument_list|(
literal|"cannot pass objects of non-POD type `%#T' through `...'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* va_arg (EXPR, TYPE) is a builtin. Make sure it is not abused.  */
end_comment

begin_function
name|tree
name|build_x_va_arg
parameter_list|(
name|expr
parameter_list|,
name|type
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|VA_ARG_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|||
operator|!
name|type
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|pod_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Undefined behaviour [expr.call] 5.2.2/7.  */
name|warning
argument_list|(
literal|"cannot receive objects of non-POD type `%#T' through `...'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|build_va_arg
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* TYPE has been given to va_arg. Apply the default conversions which would    have happened when passed via ellipsis. Return the promoted type, or    NULL_TREE, if there is no change.  */
end_comment

begin_function
name|tree
name|convert_type_from_ellipsis
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|promote
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|promote
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|promote
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|promote
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|same_type_p
argument_list|(
name|type
argument_list|,
name|promote
argument_list|)
condition|?
name|NULL_TREE
else|:
name|promote
return|;
block|}
end_function

begin_comment
comment|/* ARG is a default argument expression being passed to a parameter of    the indicated TYPE, which is a parameter to FN.  Do any required    conversions.  Return the converted value.  */
end_comment

begin_function
name|tree
name|convert_default_arg
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|,
name|fn
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
comment|/* When processing the default args for a class, we can find that          there is an ordering constraint, and we call a function who's          default args have not yet been converted. For instance,           class A {               A (int = 0);               void Foo (A const& = A ());           };          We must process A::A before A::Foo's default arg can be converted.          Remember the dependent function, so do_pending_defargs can retry,          and check loops.  */
name|unprocessed_defarg_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Don't return error_mark node, as we won't be able to distinguish          genuine errors from this case, and that would lead to repeated          diagnostics.  Just make something of the right type.  */
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
if|if
condition|(
name|fn
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
name|arg
operator|=
name|tsubst_default_argument
argument_list|(
name|fn
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|break_out_target_exprs
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|arg
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"default argument"
argument_list|,
name|fn
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This could get clobbered by the following call.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|arg
argument_list|)
condition|)
name|arg
operator|=
name|copy_node
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"default argument"
argument_list|,
name|fn
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of the various build_*_call functions.  Overload resolution    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a    bitmask of various LOOKUP_* flags which apply to the call itself.  */
end_comment

begin_function
specifier|static
name|tree
name|build_over_call
parameter_list|(
name|cand
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fn
init|=
name|cand
operator|->
name|fn
decl_stmt|;
name|tree
name|convs
init|=
name|cand
operator|->
name|convs
decl_stmt|;
name|tree
name|converted_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parm
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|conv
decl_stmt|,
name|arg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|is_method
init|=
literal|0
decl_stmt|;
comment|/* Give any warnings we noticed during overload resolution.  */
if|if
condition|(
name|cand
operator|->
name|warnings
condition|)
for|for
control|(
name|val
operator|=
name|cand
operator|->
name|warnings
init|;
name|val
condition|;
name|val
operator|=
name|TREE_CHAIN
argument_list|(
name|val
argument_list|)
control|)
name|joust
argument_list|(
name|cand
argument_list|,
name|WRAPPER_PTR
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
name|enforce_access
argument_list|(
name|cand
operator|->
name|basetype_path
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|args
expr_stmt|;
comment|/* The implicit parameters to a constructor are not considered by overload      resolution, and must be of the proper type.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* We should never try to call the abstract constructor.  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bypass access control for 'this' parameter.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"passing `%T' as `this' argument of `%#D' discards qualifiers"
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* [class.mfct.nonstatic]: If a nonstatic member function of a class 	 X is called for an object that is not of type X, or of a type 	 derived from X, the behavior is undefined.           So we can assume that anything passed as 'this' is non-null, and 	 optimize accordingly.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|,
literal|19990811
argument_list|)
expr_stmt|;
name|t
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|ba_ignore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|is_method
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|arg
operator|&&
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_like_with_context
argument_list|(
name|conv
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|fn
argument_list|,
name|i
operator|-
name|is_method
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
block|}
comment|/* Default arguments */
for|for
control|(
init|;
name|parm
operator|&&
name|parm
operator|!=
name|void_list_node
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|i
operator|++
control|)
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|i
operator|-
name|is_method
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* Ellipsis */
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert_arg_to_ellipsis
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|nreverse
argument_list|(
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format
condition|)
name|check_function_format
argument_list|(
name|NULL
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* Avoid actually calling copy constructors and copy assignment operators,      if possible.  */
if|if
condition|(
operator|!
name|flag_elide_constructors
condition|)
comment|/* Do things the hard way.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|convs
argument_list|)
operator|==
literal|1
operator|&&
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|targ
decl_stmt|;
name|arg
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Pull out the real argument, disregarding const-correctness.  */
name|targ
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
condition|)
name|targ
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|targ
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|targ
condition|)
name|arg
operator|=
name|targ
expr_stmt|;
else|else
name|arg
operator|=
name|build_indirect_ref
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* [class.copy]: the copy constructor is implicitly defined even if 	 the implementation elided its use.  */
if|if
condition|(
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If we're creating a temp and we already have one, don't create a          new one.  If we're not creating a temp but we get one, use          INIT_EXPR to collapse the temp into our target.  Otherwise, if the          ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a          temp or an INIT_EXPR otherwise.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
name|build_target_expr_with_type
argument_list|(
name|arg
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|real_lvalue_p
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|)
comment|/* Empty classes have padding which can be hidden 	          inside an (empty) base of the class. This must not 	          be touched as it might overlay things. When the 	          gcc core learns about empty classes, we can treat it 	          like other classes. */
operator|&&
operator|!
name|is_empty_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|address
decl_stmt|;
name|tree
name|to
init|=
name|stabilize_reference
argument_list|(
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|val
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|address
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid a warning about this expression, if the address is 	     never used.  */
name|TREE_USED
argument_list|(
name|address
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|address
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|fn
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|copy_fn_p
argument_list|(
name|fn
argument_list|)
operator|&&
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|to
init|=
name|stabilize_reference
argument_list|(
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|converted_args
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_empty_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_USED
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|arg
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* Even though the assignment may not actually result in any 	     code being generated, we do not want to warn about the 	     assignment having no effect.  That would be confusing to 	     users who may be performing the assignment as part of a 	     generic algorithm, for example. 	      	     Ideally, the notions of having side-effects and of being 	     useless would be orthogonal.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|t
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
argument_list|,
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|ba_any
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|binfo
operator|&&
name|binfo
operator|!=
name|error_mark_node
argument_list|,
literal|20010730
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|p
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|save_expr
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|&&
name|TYPE_JAVA_INTERFACE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|build_java_interface_fn_ref
argument_list|(
name|fn
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|fn
operator|=
name|build_vfn_ref
argument_list|(
name|build_indirect_ref
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|inline_conversion
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
name|fn
operator|=
name|build_addr_func
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|exp
decl_stmt|;
name|exp
operator|=
name|expand_tree_builtin
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
return|return
name|exp
return|;
block|}
comment|/* Some built-in function calls will be evaluated at      compile-time in fold ().  */
name|fn
operator|=
name|fold
argument_list|(
name|build_call
argument_list|(
name|fn
argument_list|,
name|converted_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
name|fn
return|;
name|fn
operator|=
name|require_complete_type
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|fn
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|java_iface_lookup_fn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make an expression which yields the address of the Java interface    method FN.  This is achieved by generating a call to libjava's    _Jv_LookupInterfaceMethodIdx().  */
end_comment

begin_function
specifier|static
name|tree
name|build_java_interface_fn_ref
parameter_list|(
name|fn
parameter_list|,
name|instance
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|instance
decl_stmt|;
block|{
name|tree
name|lookup_args
decl_stmt|,
name|lookup_fn
decl_stmt|,
name|method
decl_stmt|,
name|idx
decl_stmt|;
name|tree
name|klass_ref
decl_stmt|,
name|iface
decl_stmt|,
name|iface_ref
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|java_iface_lookup_fn
condition|)
block|{
name|tree
name|endlink
init|=
name|build_void_list_node
argument_list|()
decl_stmt|;
name|tree
name|t
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|java_int_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|java_iface_lookup_fn
operator|=
name|builtin_function
argument_list|(
literal|"_Jv_LookupInterfaceMethodIdx"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|java_iface_lookup_fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Look up the pointer to the runtime java.lang.Class object for `instance'.       This is the first entry in the vtable. */
name|klass_ref
operator|=
name|build_vtbl_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
comment|/* Get the java.lang.Class pointer for the interface being called. */
name|iface
operator|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|iface_ref
operator|=
name|lookup_field
argument_list|(
name|iface
argument_list|,
name|get_identifier
argument_list|(
literal|"class$"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iface_ref
operator|||
name|TREE_CODE
argument_list|(
name|iface_ref
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|DECL_CONTEXT
argument_list|(
name|iface_ref
argument_list|)
operator|!=
name|iface
condition|)
block|{
name|error
argument_list|(
literal|"could not find class$ field in java interface type `%T'"
argument_list|,
name|iface
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|iface_ref
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|iface
argument_list|)
argument_list|,
name|iface_ref
argument_list|)
expr_stmt|;
comment|/* Determine the itable index of FN. */
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|method
operator|=
name|TYPE_METHODS
argument_list|(
name|iface
argument_list|)
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|method
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fn
operator|==
name|method
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
name|idx
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lookup_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|klass_ref
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|iface_ref
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lookup_fn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|java_iface_lookup_fn
argument_list|)
argument_list|)
argument_list|,
name|java_iface_lookup_fn
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|lookup_fn
argument_list|,
name|lookup_args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the value to use for the in-charge parameter when making a    call to a function with the indicated NAME.  */
end_comment

begin_function
name|tree
name|in_charge_arg_for_name
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
name|base_ctor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
condition|)
return|return
name|integer_zero_node
return|;
elseif|else
if|if
condition|(
name|name
operator|==
name|complete_ctor_identifier
condition|)
return|return
name|integer_one_node
return|;
elseif|else
if|if
condition|(
name|name
operator|==
name|complete_dtor_identifier
condition|)
return|return
name|integer_two_node
return|;
elseif|else
if|if
condition|(
name|name
operator|==
name|deleting_dtor_identifier
condition|)
return|return
name|integer_three_node
return|;
comment|/* This function should only be called with one of the names listed      above.  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_new_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|args
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|mem_args
init|=
name|NULL_TREE
decl_stmt|,
name|fns
decl_stmt|,
name|instance_ptr
decl_stmt|;
name|tree
name|pretty_name
decl_stmt|;
name|tree
name|user_args
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|call
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|template_only
operator|=
literal|1
expr_stmt|;
block|}
name|user_args
operator|=
name|args
expr_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
condition|)
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype_path
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|instance
operator|=
name|resolve_offset_ref
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|instance
operator|=
name|convert_from_reference
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX this should be handled before we get here.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
operator|&&
name|basetype
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|name
argument_list|,
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
condition|)
block|{
name|instance_ptr
operator|=
name|build_this
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template_only
condition|)
block|{
comment|/* XXX this should be handled before we get here.  */
name|fns
operator|=
name|build_field_call
argument_list|(
name|basetype_path
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
condition|)
return|return
name|fns
return|;
block|}
block|}
else|else
block|{
name|instance_ptr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* Callers should explicitly indicate whether they want to construct      the complete object or just the part without virtual bases.  */
name|my_friendly_assert
argument_list|(
name|name
operator|!=
name|ctor_identifier
argument_list|,
literal|20000408
argument_list|)
expr_stmt|;
comment|/* Similarly for destructors.  */
name|my_friendly_assert
argument_list|(
name|name
operator|!=
name|dtor_identifier
argument_list|,
literal|20000408
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|int
name|constructor_p
decl_stmt|;
name|constructor_p
operator|=
operator|(
name|name
operator|==
name|complete_ctor_identifier
operator|||
name|name
operator|==
name|base_ctor_identifier
operator|)
expr_stmt|;
name|pretty_name
operator|=
operator|(
name|constructor_p
condition|?
name|constructor_name
argument_list|(
name|basetype
argument_list|)
else|:
name|dtor_identifier
operator|)
expr_stmt|;
comment|/* If we're a call to a constructor or destructor for a 	 subobject that uses virtual base classes, then we need to 	 pass down a pointer to a VTT for the subobject.  */
if|if
condition|(
operator|(
name|name
operator|==
name|base_ctor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|vtt
decl_stmt|;
name|tree
name|sub_vtt
decl_stmt|;
name|tree
name|basebinfo
init|=
name|basetype_path
decl_stmt|;
comment|/* If the current function is a complete object constructor 	     or destructor, then we fetch the VTT directly. 	     Otherwise, we look it up using the VTT we were given.  */
name|vtt
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_vtt_name
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|vtt
operator|=
name|decay_conversion
argument_list|(
name|vtt
argument_list|)
expr_stmt|;
name|vtt
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|current_vtt_parm
argument_list|,
name|vtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basebinfo
argument_list|)
condition|)
name|basebinfo
operator|=
name|binfo_for_vbase
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_SUBVTT_INDEX
argument_list|(
name|basebinfo
argument_list|)
argument_list|,
literal|20010110
argument_list|)
expr_stmt|;
name|sub_vtt
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|vtt
argument_list|,
name|BINFO_SUBVTT_INDEX
argument_list|(
name|basebinfo
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sub_vtt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pretty_name
operator|=
name|name
expr_stmt|;
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|base
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fns
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|mem_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|args
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|this_arglist
decl_stmt|;
comment|/* We can end up here for copy-init of same or base class.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
operator|&&
name|DECL_NONCONVERTING_P
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
name|this_arglist
operator|=
name|mem_args
expr_stmt|;
else|else
name|this_arglist
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* A member template. */
name|templates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|base
argument_list|,
name|explicit_targs
argument_list|,
name|this_arglist
argument_list|,
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|template_only
condition|)
name|candidates
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|t
argument_list|,
name|base
argument_list|,
name|this_arglist
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|candidates
operator|->
name|basetype_path
operator|=
name|basetype_path
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|any_viable
argument_list|(
name|candidates
argument_list|)
condition|)
block|{
comment|/* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|incomplete_type_error
argument_list|(
name|instance_ptr
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no matching function for call to `%T::%D(%A)%#V'"
argument_list|,
name|basetype
argument_list|,
name|pretty_name
argument_list|,
name|user_args
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"call of overloaded `%D(%A)' is ambiguous"
argument_list|,
name|pretty_name
argument_list|,
name|user_args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|instance
operator|==
name|current_class_ref
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|value_member
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|?
literal|"abstract virtual `%#D' called from constructor"
else|:
literal|"abstract virtual `%#D' called from destructor"
operator|)
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|is_dummy_object
argument_list|(
name|instance_ptr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot call member function `%D' without object"
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|resolves_to_fixed_type_p
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|call
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|mem_args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|call
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Do evaluate the object parameter in a call to a static member 	 function.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance
argument_list|)
condition|)
name|call
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|call
argument_list|)
argument_list|,
name|instance
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
return|return
name|call
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff standard conversion sequence ICS1 is a proper    subsequence of ICS2.  */
end_comment

begin_function
specifier|static
name|int
name|is_subseq
parameter_list|(
name|ics1
parameter_list|,
name|ics2
parameter_list|)
name|tree
name|ics1
decl_stmt|,
name|ics2
decl_stmt|;
block|{
comment|/* We can assume that a conversion of the same code      between the same types indicates a subsequence since we only get      here if the types we are converting from are the same.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|RVALUE_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|LVALUE_CONV
condition|)
name|ics1
operator|=
name|TREE_OPERAND
argument_list|(
name|ics1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|RVALUE_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|LVALUE_CONV
condition|)
name|ics2
operator|=
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|AMBIG_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
comment|/* At this point, ICS1 cannot be a proper subsequence of 	   ICS2.  We can get a USER_CONV when we are comparing the 	   second standard conversion sequence of two user conversion 	   sequences.  */
return|return
literal|0
return|;
name|ics2
operator|=
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|ics2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ics1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ics1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero iff DERIVED is derived from BASE.  The inputs may    be any _TYPE nodes.  */
end_comment

begin_function
name|int
name|is_properly_derived_from
parameter_list|(
name|derived
parameter_list|,
name|base
parameter_list|)
name|tree
name|derived
decl_stmt|;
name|tree
name|base
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|derived
argument_list|)
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We only allow proper derivation here.  The DERIVED_FROM_P macro      considers every class derived from itself.  */
return|return
operator|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|derived
argument_list|,
name|base
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|base
argument_list|,
name|derived
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We build the ICS for an implicit object parameter as a pointer    conversion sequence.  However, such a sequence should be compared    as if it were a reference conversion sequence.  If ICS is the    implicit conversion sequence for an implicit object parameter,    modify it accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_handle_implicit_object
parameter_list|(
name|ics
parameter_list|)
name|tree
modifier|*
name|ics
decl_stmt|;
block|{
if|if
condition|(
name|ICS_THIS_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
condition|)
block|{
comment|/* [over.match.funcs] 	  	 For non-static member functions, the type of the 	 implicit object parameter is "reference to cv X" 	 where X is the class of which the function is a 	 member and cv is the cv-qualification on the member 	 function declaration.  */
name|tree
name|t
init|=
operator|*
name|ics
decl_stmt|;
name|tree
name|reference_type
decl_stmt|;
comment|/* The `this' parameter is a pointer to a class type.  Make the 	 implict conversion talk about a reference to that same class 	 type.  */
name|reference_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|ics
argument_list|)
argument_list|)
expr_stmt|;
name|reference_type
operator|=
name|build_reference_type
argument_list|(
name|reference_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|QUAL_CONV
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTR_CONV
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|direct_reference_binding
argument_list|(
name|reference_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|ics
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If *ICS is a REF_BIND set *ICS to the remainder of the conversion,    and return the type to which the reference refers.  Otherwise,    leave *ICS unchanged and return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_handle_ref_bind
parameter_list|(
name|ics
parameter_list|)
name|tree
modifier|*
name|ics
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|ics
argument_list|)
operator|==
name|REF_BIND
condition|)
block|{
name|tree
name|old_ics
init|=
operator|*
name|ics
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_ics
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|ics
operator|=
name|TREE_OPERAND
argument_list|(
name|old_ics
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
operator|=
name|ICS_USER_FLAG
argument_list|(
name|old_ics
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
name|old_ics
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Compare two implicit conversion sequences according to the rules set out in    [over.ics.rank].  Return values:        1: ics1 is better than ics2      -1: ics2 is better than ics1       0: ics1 and ics2 are indistinguishable */
end_comment

begin_function
specifier|static
name|int
name|compare_ics
parameter_list|(
name|ics1
parameter_list|,
name|ics2
parameter_list|)
name|tree
name|ics1
decl_stmt|,
name|ics2
decl_stmt|;
block|{
name|tree
name|from_type1
decl_stmt|;
name|tree
name|from_type2
decl_stmt|;
name|tree
name|to_type1
decl_stmt|;
name|tree
name|to_type2
decl_stmt|;
name|tree
name|deref_from_type1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_from_type2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_to_type1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_to_type2
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|rank1
decl_stmt|,
name|rank2
decl_stmt|;
comment|/* REF_BINDING is non-zero if the result of the conversion sequence      is a reference type.   In that case TARGET_TYPE is the      type referred to by the reference.  */
name|tree
name|target_type1
decl_stmt|;
name|tree
name|target_type2
decl_stmt|;
comment|/* Handle implicit object parameters.  */
name|maybe_handle_implicit_object
argument_list|(
operator|&
name|ics1
argument_list|)
expr_stmt|;
name|maybe_handle_implicit_object
argument_list|(
operator|&
name|ics2
argument_list|)
expr_stmt|;
comment|/* Handle reference parameters.  */
name|target_type1
operator|=
name|maybe_handle_ref_bind
argument_list|(
operator|&
name|ics1
argument_list|)
expr_stmt|;
name|target_type2
operator|=
name|maybe_handle_ref_bind
argument_list|(
operator|&
name|ics2
argument_list|)
expr_stmt|;
comment|/* [over.ics.rank]       When  comparing  the  basic forms of implicit conversion sequences (as      defined in _over.best.ics_)       --a standard conversion sequence (_over.ics.scs_) is a better        conversion sequence than a user-defined conversion sequence        or an ellipsis conversion sequence, and            --a user-defined conversion sequence (_over.ics.user_) is a        better conversion sequence than an ellipsis conversion sequence        (_over.ics.ellipsis_).  */
name|rank1
operator|=
name|ICS_RANK
argument_list|(
name|ics1
argument_list|)
expr_stmt|;
name|rank2
operator|=
name|ICS_RANK
argument_list|(
name|ics2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rank1
operator|>
name|rank2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|rank1
operator|<
name|rank2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|rank1
operator|==
name|BAD_RANK
condition|)
block|{
comment|/* XXX Isn't this an extension? */
comment|/* Both ICS are bad.  We try to make a decision based on what 	 would have happenned if they'd been good.  */
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_USER_FLAG
argument_list|(
name|ics2
argument_list|)
operator|||
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_USER_FLAG
argument_list|(
name|ics2
argument_list|)
operator|||
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We couldn't make up our minds; try to figure it out below.  */
block|}
if|if
condition|(
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|ics1
argument_list|)
condition|)
comment|/* Both conversions are ellipsis conversions.  */
return|return
literal|0
return|;
comment|/* User-defined  conversion sequence U1 is a better conversion sequence      than another user-defined conversion sequence U2 if they contain the      same user-defined conversion operator or constructor and if the sec-      ond standard conversion sequence of U1 is  better  than  the  second      standard conversion sequence of U2.  */
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|ics1
init|;
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|USER_CONV
condition|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t2
operator|=
name|ics2
init|;
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|USER_CONV
condition|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USER_CONV_FN
argument_list|(
name|t1
argument_list|)
operator|!=
name|USER_CONV_FN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We can just fall through here, after setting up 	 FROM_TYPE1 and FROM_TYPE2.  */
name|from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're dealing with two standard conversion sequences.   	 [over.ics.rank] 	  	 Standard conversion sequence S1 is a better conversion 	 sequence than standard conversion sequence S2 if       	 --S1 is a proper subsequence of S2 (comparing the conversion 	   sequences in the canonical form defined by _over.ics.scs_, 	   excluding any Lvalue Transformation; the identity 	   conversion sequence is considered to be a subsequence of 	   any non-identity conversion sequence */
name|from_type1
operator|=
name|ics1
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|from_type1
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|from_type1
operator|=
name|TREE_OPERAND
argument_list|(
name|from_type1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|ics2
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|from_type2
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|from_type2
operator|=
name|TREE_OPERAND
argument_list|(
name|from_type2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_subseq
argument_list|(
name|ics1
argument_list|,
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_subseq
argument_list|(
name|ics2
argument_list|,
name|ics1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Otherwise, one sequence cannot be a subsequence of the other; they      don't start with the same type.  This can happen when comparing the      second standard conversion sequence in two user-defined conversion      sequences.  */
comment|/* [over.ics.rank]       Or, if not that,       --the rank of S1 is better than the rank of S2 (by the rules        defined below):      Standard conversion sequences are ordered by their ranks: an Exact     Match is a better conversion than a Promotion, which is a better     conversion than a Conversion.      Two conversion sequences with the same rank are indistinguishable     unless one of the following rules applies:      --A conversion that is not a conversion of a pointer, or pointer       to member, to bool is better than another conversion that is such       a conversion.        The ICS_STD_RANK automatically handles the pointer-to-bool rule,     so that we do not have to check it explicitly.  */
if|if
condition|(
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|to_type1
operator|=
name|TREE_TYPE
argument_list|(
name|ics1
argument_list|)
expr_stmt|;
name|to_type2
operator|=
name|TREE_TYPE
argument_list|(
name|ics2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
name|deref_to_type1
operator|=
name|TREE_TYPE
argument_list|(
name|to_type1
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TREE_TYPE
argument_list|(
name|to_type2
argument_list|)
expr_stmt|;
block|}
comment|/* The rules for pointers to members A::* are just like the rules      for pointers A*, except opposite: if B is derived from A then      A::* converts to B::*, not vice versa.  For that reason, we      switch the from_ and to_ variables here.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_to_type1
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
argument_list|)
expr_stmt|;
name|deref_from_type1
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to_type1
argument_list|)
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to_type2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_to_type1
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
name|deref_from_type1
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|to_type1
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|to_type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deref_from_type1
operator|!=
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_from_type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_from_type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This was one of the pointer or pointer-like conversions.    	 [over.ics.rank] 	  	 --If class B is derived directly or indirectly from class A, 	   conversion of B* to A* is better than conversion of B* to 	   void*, and conversion of A* to void* is better than 	   conversion of B* to void*.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type2
argument_list|,
name|deref_from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_to_type1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* We know that DEREF_TO_TYPE1 is `void' here.  */
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* [over.ics.rank]  	     --If class B is derived directly or indirectly from class A 	       and class C is derived directly or indirectly from B, 	      	     --conversion of C* to B* is better than conversion of C* to 	       A*,  	      	     --conversion of B* to A* is better than conversion of C* to 	       A*  */
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_to_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_to_type2
argument_list|,
name|deref_to_type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_to_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type2
argument_list|,
name|deref_from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|non_reference
argument_list|(
name|from_type1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
block|{
name|tree
name|from
init|=
name|non_reference
argument_list|(
name|from_type1
argument_list|)
decl_stmt|;
comment|/* [over.ics.rank] 	  	 --binding of an expression of type C to a reference of type 	   B& is better than binding an expression of type C to a 	   reference of type A&  	 --conversion of C to B is better than conversion of C to A,  */
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from
argument_list|,
name|to_type1
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from
argument_list|,
name|to_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|to_type2
argument_list|,
name|to_type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|non_reference
argument_list|(
name|to_type1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
block|{
name|tree
name|to
init|=
name|non_reference
argument_list|(
name|to_type1
argument_list|)
decl_stmt|;
comment|/* [over.ics.rank]  	 --binding of an expression of type B to a reference of type 	   A& is better than binding an expression of type C to a 	   reference of type A&,   	 --onversion of B to A is better than conversion of C to A  */
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|to
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from_type2
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type2
argument_list|,
name|from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* [over.ics.rank]       --S1 and S2 differ only in their qualification conversion and  yield        similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-        qualification signature of type T1 is a proper subset of  the  cv-        qualification signature of type T2  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|QUAL_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|QUAL_CONV
operator|&&
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
return|return
name|comp_cv_qual_signature
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
return|;
comment|/* [over.ics.rank]            --S1 and S2 are reference bindings (_dcl.init.ref_), and the      types to which the references refer are the same type except for      top-level cv-qualifiers, and the type to which the reference      initialized by S2 refers is more cv-qualified than the type to      which the reference initialized by S1 refers */
if|if
condition|(
name|target_type1
operator|&&
name|target_type2
operator|&&
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
return|return
name|comp_cv_qualification
argument_list|(
name|target_type2
argument_list|,
name|target_type1
argument_list|)
return|;
comment|/* Neither conversion sequence is better than the other.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The source type for this standard conversion sequence.  */
end_comment

begin_function
specifier|static
name|tree
name|source_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note a warning about preferring WINNER to LOSER.  We do this by storing    a pointer to LOSER and re-running joust to produce the warning if WINNER    is actually used.  */
end_comment

begin_function
specifier|static
name|void
name|add_warning
parameter_list|(
name|winner
parameter_list|,
name|loser
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|winner
decl_stmt|,
decl|*
name|loser
decl_stmt|;
end_function

begin_block
block|{
name|winner
operator|->
name|warnings
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_ptr_wrapper
argument_list|(
name|loser
argument_list|)
argument_list|,
name|winner
operator|->
name|warnings
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Returns true iff functions are equivalent. Equivalent functions are    not '==' only if one is a function-local extern function or if    both are extern "C".  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|equal_functions
parameter_list|(
name|fn1
parameter_list|,
name|fn2
parameter_list|)
name|tree
name|fn1
decl_stmt|;
name|tree
name|fn2
decl_stmt|;
block|{
if|if
condition|(
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|fn1
argument_list|)
operator|||
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|fn2
argument_list|)
operator|||
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|fn1
argument_list|)
condition|)
return|return
name|decls_match
argument_list|(
name|fn1
argument_list|,
name|fn2
argument_list|)
return|;
return|return
name|fn1
operator|==
name|fn2
return|;
block|}
end_function

begin_comment
comment|/* Compare two candidates for overloading as described in    [over.match.best].  Return values:        1: cand1 is better than cand2      -1: cand2 is better than cand1       0: cand1 and cand2 are indistinguishable */
end_comment

begin_function
specifier|static
name|int
name|joust
parameter_list|(
name|cand1
parameter_list|,
name|cand2
parameter_list|,
name|warn
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|cand1
decl_stmt|,
decl|*
name|cand2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|warn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off1
init|=
literal|0
decl_stmt|,
name|off2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
comment|/* Candidates that involve bad conversions are always worse than those      that don't.  */
if|if
condition|(
name|cand1
operator|->
name|viable
operator|>
name|cand2
operator|->
name|viable
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cand1
operator|->
name|viable
operator|<
name|cand2
operator|->
name|viable
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we have two pseudo-candidates for conversions to the same type,      or two candidates for the same function, arbitrarily pick one.  */
if|if
condition|(
name|cand1
operator|->
name|fn
operator|==
name|cand2
operator|->
name|fn
operator|&&
operator|(
name|TYPE_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* a viable function F1      is defined to be a better function than another viable function F2  if      for  all arguments i, ICSi(F1) is not a worse conversion sequence than      ICSi(F2), and then */
comment|/* for some argument j, ICSj(F1) is a better conversion  sequence  than      ICSj(F2) */
comment|/* For comparing static and non-static member functions, we ignore      the implicit object parameter of the non-static function.  The      standard says to pretend that the static function has an object      parm, but that won't work with operator overloading.  */
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|cand2
operator|->
name|convs
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
condition|)
name|off2
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
condition|)
block|{
name|off1
operator|=
literal|1
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
decl_stmt|;
name|int
name|comp
init|=
name|compare_ics
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|warn_sign_promo
operator|&&
name|ICS_RANK
argument_list|(
name|t1
argument_list|)
operator|+
name|ICS_RANK
argument_list|(
name|t2
argument_list|)
operator|==
name|STD_RANK
operator|+
name|PROMO_RANK
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|STD_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|STD_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|w
decl_stmt|,
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|comp
operator|>
literal|0
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|,
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|,
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
else|else
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|,
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|,
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|warning
argument_list|(
literal|"passing `%T' chooses `%T' over `%T'"
argument_list|,
name|type
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  in call to `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|winner
operator|&&
name|comp
operator|!=
name|winner
condition|)
block|{
name|winner
operator|=
literal|0
expr_stmt|;
goto|goto
name|tweak
goto|;
block|}
name|winner
operator|=
name|comp
expr_stmt|;
block|}
block|}
comment|/* warn about confusing overload resolution for user-defined conversions,      either between a constructor and a conversion op, or between two      conversion ops.  */
if|if
condition|(
name|winner
operator|&&
name|cand1
operator|->
name|second_conv
operator|&&
operator|(
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|!=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|)
comment|/* Don't warn if the two conv ops convert to the same type...  */
operator|||
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|comp
init|=
name|compare_ics
argument_list|(
name|cand1
operator|->
name|second_conv
argument_list|,
name|cand2
operator|->
name|second_conv
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
name|winner
condition|)
block|{
name|struct
name|z_candidate
modifier|*
name|w
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|tree
name|convn
decl_stmt|;
if|if
condition|(
name|winner
operator|==
literal|1
condition|)
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
else|else
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|&&
operator|(
name|convn
operator|=
name|standard_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|l
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|w
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|convn
argument_list|)
operator|==
name|QUAL_CONV
condition|)
comment|/* Don't complain about `operator char *()' beating 	       `operator const char *() const'.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|warn
condition|)
block|{
name|tree
name|source
init|=
name|source_type
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|w
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|w
operator|->
name|fn
argument_list|)
condition|)
name|source
operator|=
name|TREE_TYPE
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"choosing `%D' over `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|,
name|l
operator|->
name|fn
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  for conversion from `%T' to `%T'"
argument_list|,
name|source
argument_list|,
name|TREE_TYPE
argument_list|(
name|w
operator|->
name|second_conv
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  because conversion sequence for the argument is better"
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
comment|/* or, if not that,      F1 is a non-template function and F2 is a template function      specialization.  */
if|if
condition|(
operator|!
name|cand1
operator|->
name|template
operator|&&
name|cand2
operator|->
name|template
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cand1
operator|->
name|template
operator|&&
operator|!
name|cand2
operator|->
name|template
condition|)
return|return
operator|-
literal|1
return|;
comment|/* or, if not that,      F1 and F2 are template functions and the function template for F1 is      more specialized than the template for F2 according to the partial      ordering rules.  */
if|if
condition|(
name|cand1
operator|->
name|template
operator|&&
name|cand2
operator|->
name|template
condition|)
block|{
name|winner
operator|=
name|more_specialized
argument_list|(
name|TI_TEMPLATE
argument_list|(
name|cand1
operator|->
name|template
argument_list|)
argument_list|,
name|TI_TEMPLATE
argument_list|(
name|cand2
operator|->
name|template
argument_list|)
argument_list|,
name|DEDUCE_ORDER
argument_list|,
comment|/* Tell the deduction code how many real function arguments 	    we saw, not counting the implicit 'this' argument.  But, 	    add_function_candidate() suppresses the "this" argument 	    for constructors.  	    [temp.func.order]: The presence of unused ellipsis and default 	    arguments has no effect on the partial ordering of function 	    templates.  */
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
operator|-
operator|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|-
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* HERE */
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
block|}
comment|/* or, if not that,      the  context  is  an  initialization by user-defined conversion (see      _dcl.init_  and  _over.match.user_)  and  the  standard   conversion      sequence  from  the return type of F1 to the destination type (i.e.,      the type of the entity being initialized)  is  a  better  conversion      sequence  than the standard conversion sequence from the return type      of F2 to the destination type.  */
if|if
condition|(
name|cand1
operator|->
name|second_conv
condition|)
block|{
name|winner
operator|=
name|compare_ics
argument_list|(
name|cand1
operator|->
name|second_conv
argument_list|,
name|cand2
operator|->
name|second_conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
block|}
comment|/* Check whether we can discard a builtin candidate, either because we      have two identical ones or matching builtin and non-builtin candidates.       (Pedantically in the latter case the builtin which matched the user      function should not be added to the overload set, but we spot it here.            [over.match.oper]      ... the builtin candidates include ...      - do not have the same parameter type list as any non-template        non-member candidate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
condition|)
block|{
if|if
condition|(
name|cand1
operator|->
name|fn
operator|==
name|cand2
operator|->
name|fn
condition|)
comment|/* Two built-in candidates; arbitrarily pick one.  */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* cand1 is built-in; prefer cand2.  */
return|return
operator|-
literal|1
return|;
else|else
comment|/* cand2 is built-in; prefer cand1.  */
return|return
literal|1
return|;
block|}
block|}
comment|/* If the two functions are the same (this can happen with declarations      in multiple scopes and arg-dependent lookup), arbitrarily choose one.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|&&
name|equal_functions
argument_list|(
name|cand1
operator|->
name|fn
argument_list|,
name|cand2
operator|->
name|fn
argument_list|)
condition|)
return|return
literal|1
return|;
name|tweak
label|:
comment|/* Extension: If the worst conversion for one candidate is worse than the      worst conversion for the other, take the first.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
block|{
name|int
name|rank1
init|=
name|IDENTITY_RANK
decl_stmt|,
name|rank2
init|=
name|IDENTITY_RANK
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|w
init|=
literal|0
decl_stmt|,
modifier|*
name|l
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
argument_list|)
operator|>
name|rank1
condition|)
name|rank1
operator|=
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
argument_list|)
operator|>
name|rank2
condition|)
name|rank2
operator|=
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rank1
operator|<
name|rank2
condition|)
name|winner
operator|=
literal|1
operator|,
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
if|if
condition|(
name|rank1
operator|>
name|rank2
condition|)
name|winner
operator|=
operator|-
literal|1
operator|,
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|winner
condition|)
block|{
if|if
condition|(
name|warn
condition|)
block|{
name|pedwarn
argument_list|(
literal|"choosing `%D' over `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|,
name|l
operator|->
name|fn
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  because worst conversion for the former is better than worst conversion for the latter"
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|winner
return|;
block|}
block|}
name|my_friendly_assert
argument_list|(
operator|!
name|winner
argument_list|,
literal|20010121
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given a list of candidates for overloading, find the best one, if any.    This algorithm has a worst case of O(2n) (winner is last), and a best    case of O(n/2) (totally ambiguous); much better than a sorting    algorithm.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|tourney
parameter_list|(
name|candidates
parameter_list|)
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
block|{
name|struct
name|z_candidate
modifier|*
name|champ
init|=
name|candidates
decl_stmt|,
modifier|*
name|challenger
decl_stmt|;
name|int
name|fate
decl_stmt|;
name|int
name|champ_compared_to_predecessor
init|=
literal|0
decl_stmt|;
comment|/* Walk through the list once, comparing each current champ to the next      candidate, knocking out a candidate or two with each comparison.  */
for|for
control|(
name|challenger
operator|=
name|champ
operator|->
name|next
init|;
name|challenger
condition|;
control|)
block|{
name|fate
operator|=
name|joust
argument_list|(
name|champ
argument_list|,
name|challenger
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
name|challenger
operator|=
name|challenger
operator|->
name|next
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|champ
operator|=
name|challenger
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|champ
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|champ_compared_to_predecessor
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|champ
operator|=
name|challenger
expr_stmt|;
name|champ_compared_to_predecessor
operator|=
literal|1
expr_stmt|;
block|}
name|challenger
operator|=
name|champ
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Make sure the champ is better than all the candidates it hasn't yet      been compared to.  */
for|for
control|(
name|challenger
operator|=
name|candidates
init|;
name|challenger
operator|!=
name|champ
operator|&&
operator|!
operator|(
name|champ_compared_to_predecessor
operator|&&
name|challenger
operator|->
name|next
operator|==
name|champ
operator|)
condition|;
name|challenger
operator|=
name|challenger
operator|->
name|next
control|)
block|{
name|fate
operator|=
name|joust
argument_list|(
name|champ
argument_list|,
name|challenger
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if things of type FROM can be converted to TO.  */
end_comment

begin_function
name|int
name|can_convert
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
return|return
name|can_convert_arg
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if ARG (of type FROM) can be converted to TO.  */
end_comment

begin_function
name|int
name|can_convert_arg
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|arg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|arg
decl_stmt|;
block|{
name|tree
name|t
init|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
return|return
operator|(
name|t
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like can_convert_arg, but allows dubious conversions as well.  */
end_comment

begin_function
name|int
name|can_convert_arg_bad
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|arg
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|,
name|arg
decl_stmt|;
block|{
name|tree
name|t
init|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
return|return
operator|!
operator|!
name|t
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE.  Return the converted expression.     Note that we allow bad conversions here because by the time we get to    this point we are committed to doing the conversion.  If we end up    doing a bad conversion, convert_like will complain.  */
end_comment

begin_function
name|tree
name|perform_implicit_conversion
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
condition|)
block|{
name|error
argument_list|(
literal|"could not convert `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|convert_like
argument_list|(
name|conv
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to the indicated reference TYPE, in a way suitable for    initializing a variable of that TYPE.  Return the converted    expression.  */
end_comment

begin_function
name|tree
name|initialize_reference
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|conv
decl_stmt|;
name|conv
operator|=
name|reference_binding
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
operator|||
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"could not convert `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|convert_like
argument_list|(
name|conv
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

end_unit

