begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to invoking methods and overloaded functions.    Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,     1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) and    modified by Brendan Kehoe (brendan@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|tourney
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|equal_functions
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|joust
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|,
name|struct
name|z_candidate
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_ics
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_over_call
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_java_interface_fn_ref
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|convert_like
parameter_list|(
name|CONV
parameter_list|,
name|EXPR
parameter_list|)
define|\
value|convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0, 		\
comment|/*issue_conversion_warnings=*/
value|true)
end_define

begin_define
define|#
directive|define
name|convert_like_with_context
parameter_list|(
name|CONV
parameter_list|,
name|EXPR
parameter_list|,
name|FN
parameter_list|,
name|ARGNO
parameter_list|)
define|\
value|convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0, 		\
comment|/*issue_conversion_warnings=*/
value|true)
end_define

begin_function_decl
specifier|static
name|tree
name|convert_like_real
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|op_error
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_object_call
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|resolve_args
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_user_type_conversion_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_z_candidate
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|z_candidate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_z_candidates
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_this
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|splice_viable
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|any_strictly_viable
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|unification_kind_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate_real
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|unification_kind_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_conv_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_builtin_candidates
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_builtin_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_complete
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_builtin_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_conv_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_function_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|implicit_conversion
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|standard_conversion
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|reference_binding
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_conv
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_subseq
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|maybe_handle_ref_bind
parameter_list|(
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_handle_implicit_object
parameter_list|(
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|source_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_warning
parameter_list|(
name|struct
name|z_candidate
modifier|*
parameter_list|,
name|struct
name|z_candidate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|reference_related_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|reference_compatible_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_class_to_reference
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|direct_reference_binding
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|promoted_arithmetic_type_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|conditional_conversion
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|name_as_c_string
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|call_builtin_trap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|prep_operand
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_candidates
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|struct
name|z_candidate
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|merge_conversion_sequences
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|magic_varargs_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_temp
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_constructor_callable
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|tree
name|build_vfield_ref
parameter_list|(
name|tree
name|datum
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
name|datum
operator|=
name|convert_to_base
argument_list|(
name|datum
argument_list|,
name|type
argument_list|,
comment|/*check_access=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff the destructor name specified in NAME    (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many    forms...  */
end_comment

begin_function
name|bool
name|check_dtor_name
parameter_list|(
name|tree
name|basetype
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Just accept something we've already complained about.  */
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|name
operator|==
name|constructor_name
argument_list|(
name|basetype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
name|name
operator|=
name|basetype
expr_stmt|;
else|else
name|name
operator|=
name|get_type_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* In the case of:               template<class T> struct S { ~S(); };        int i;        i.~S();       NAME will be a class template.  */
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|false
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* We want the address of a function or method.  We avoid creating a    pointer-to-member function.  */
end_comment

begin_function
name|tree
name|build_addr_func
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
comment|/* We have to do these by hand to avoid real pointer to member      functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|tree
name|object
init|=
name|build_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|object
argument_list|,
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|function
operator|=
name|build_address
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
else|else
name|function
operator|=
name|decay_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
end_function

begin_comment
comment|/* Build a CALL_EXPR, we can handle FUNCTION_TYPEs, METHOD_TYPEs, or    POINTER_TYPE to those.  Note, pointer to member function types    (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */
end_comment

begin_function
name|tree
name|build_call
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|parms
parameter_list|)
block|{
name|int
name|is_constructor
init|=
literal|0
decl_stmt|;
name|int
name|nothrow
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|result_type
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"unable to call pointer to member function here"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We check both the decl and the type; a function may be known not to      throw without being declared throw().  */
name|nothrow
operator|=
operator|(
operator|(
name|decl
operator|&&
name|TREE_NOTHROW
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|cfun
condition|)
name|current_function_returns_abnormally
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|require_complete_eh_spec_types
argument_list|(
name|fntype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|is_constructor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We invoke build_call directly for several library functions. 	 These may have been declared normally if we're building libgcc, 	 so we can't just check DECL_ARTIFICIAL.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
condition|)
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Don't pass empty class objects by value.  This is useful      for tags in STL, which are used to control overload resolution.      We don't need to handle other cases of copying empty classes.  */
if|if
condition|(
operator|!
name|decl
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
for|for
control|(
name|tmp
operator|=
name|parms
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|is_empty_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build
argument_list|(
name|EMPTY_CLASS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|function
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|result_type
argument_list|,
name|function
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|function
argument_list|)
operator|=
name|is_constructor
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|function
argument_list|)
operator|=
name|nothrow
expr_stmt|;
return|return
name|function
return|;
block|}
end_function

begin_comment
comment|/* Build something of the form ptr->method (args)    or object.method (args).  This can also build    calls to constructors, and find friends.     Member functions always take their class variable    as a pointer.     INSTANCE is a class instance.     NAME is the name of the method desired, usually an IDENTIFIER_NODE.     PARMS help to figure out what that NAME really refers to.     BASETYPE_PATH, if non-NULL, contains a chain from the type of INSTANCE    down to the real instance type to use for access checking.  We need this    information to get protected accesses correct.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     If this is all OK, calls build_function_call with the resolved    member function.     This function must also handle being called to perform    initialization, promotion/coercion of arguments, and    instantiation of default parameters.     Note that NAME may refer to an instance variable name.  If    `operator()()' is defined for the type of that field, then we return    that result.  */
end_comment

begin_comment
comment|/* New overloading code.  */
end_comment

begin_decl_stmt
name|struct
name|z_candidate
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The FUNCTION_DECL that will be called if this candidate is      selected by overload resolution.  */
name|tree
name|fn
decl_stmt|;
comment|/* The arguments to use when calling this function.  */
name|tree
name|args
decl_stmt|;
comment|/* The implicit conversion sequences for each of the arguments to      FN.  */
name|tree
name|convs
decl_stmt|;
comment|/* If FN is a user-defined conversion, the standard conversion      sequence from the type returned by FN to the desired destination      type.  */
name|tree
name|second_conv
decl_stmt|;
name|int
name|viable
decl_stmt|;
comment|/* If FN is a member function, the binfo indicating the path used to      qualify the name of FN at the call site.  This path is used to      determine whether or not FN is accessible if it is selected by      overload resolution.  The DECL_CONTEXT of FN will always be a      (possibly improper) base of this binfo.  */
name|tree
name|access_path
decl_stmt|;
comment|/* If FN is a non-static member function, the binfo indicating the      subobject to which the `this' pointer should be converted if FN      is selected by overload resolution.  The type pointed to the by      the `this' pointer must correspond to the most derived class      indicated by the CONVERSION_PATH.  */
name|tree
name|conversion_path
decl_stmt|;
name|tree
name|template
decl_stmt|;
name|tree
name|warnings
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|next
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|IDENTITY_RANK
value|0
end_define

begin_define
define|#
directive|define
name|EXACT_RANK
value|1
end_define

begin_define
define|#
directive|define
name|PROMO_RANK
value|2
end_define

begin_define
define|#
directive|define
name|STD_RANK
value|3
end_define

begin_define
define|#
directive|define
name|PBOOL_RANK
value|4
end_define

begin_define
define|#
directive|define
name|USER_RANK
value|5
end_define

begin_define
define|#
directive|define
name|ELLIPSIS_RANK
value|6
end_define

begin_define
define|#
directive|define
name|BAD_RANK
value|7
end_define

begin_define
define|#
directive|define
name|ICS_RANK
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(ICS_BAD_FLAG (NODE) ? BAD_RANK   		\    : ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK	\    : ICS_USER_FLAG (NODE) ? USER_RANK		\    : ICS_STD_RANK (NODE))
end_define

begin_define
define|#
directive|define
name|ICS_STD_RANK
parameter_list|(
name|NODE
parameter_list|)
value|TREE_COMPLEXITY (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_USER_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_0 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_ELLIPSIS_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_1 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_THIS_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_2 (NODE)
end_define

begin_define
define|#
directive|define
name|ICS_BAD_FLAG
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_3 (NODE)
end_define

begin_comment
comment|/* In a REF_BIND or a BASE_CONV, this indicates that a temporary    should be created to hold the result of the conversion.  */
end_comment

begin_define
define|#
directive|define
name|NEED_TEMPORARY_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_4 (NODE)
end_define

begin_comment
comment|/* TRUE in an IDENTITY_CONV or BASE_CONV if the copy constructor must    be accessible, even though it is not being used.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_COPY_CONSTRUCTOR_P
parameter_list|(
name|NODE
parameter_list|)
value|TREE_LANG_FLAG_5 (NODE)
end_define

begin_define
define|#
directive|define
name|USER_CONV_CAND
parameter_list|(
name|NODE
parameter_list|)
value|WRAPPER_ZC (TREE_OPERAND (NODE, 1))
end_define

begin_define
define|#
directive|define
name|USER_CONV_FN
parameter_list|(
name|NODE
parameter_list|)
value|(USER_CONV_CAND (NODE)->fn)
end_define

begin_comment
comment|/* Returns true iff T is a null pointer constant in the sense of    [conv.ptr].  */
end_comment

begin_function
name|bool
name|null_ptr_cst_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* [conv.ptr]       A null pointer constant is an integral constant expression      (_expr.const_) rvalue of integer type that evaluates to zero.  */
if|if
condition|(
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|decl_constant_value
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|null_node
operator|||
operator|(
name|CP_INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if PARMLIST consists of only default parms and/or    ellipsis.  */
end_comment

begin_function
name|bool
name|sufficient_parms_p
parameter_list|(
name|tree
name|parmlist
parameter_list|)
block|{
for|for
control|(
init|;
name|parmlist
operator|&&
name|parmlist
operator|!=
name|void_list_node
condition|;
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|parmlist
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_conv
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|rank
init|=
name|ICS_STD_RANK
argument_list|(
name|from
argument_list|)
decl_stmt|;
comment|/* We can't use buildl1 here because CODE could be USER_CONV, which      takes two arguments.  In that case, the caller is responsible for      filling in the second argument.  */
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|from
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PTR_CONV
case|:
case|case
name|PMEM_CONV
case|:
case|case
name|BASE_CONV
case|:
case|case
name|STD_CONV
case|:
if|if
condition|(
name|rank
operator|<
name|STD_RANK
condition|)
name|rank
operator|=
name|STD_RANK
expr_stmt|;
break|break;
case|case
name|QUAL_CONV
case|:
if|if
condition|(
name|rank
operator|<
name|EXACT_RANK
condition|)
name|rank
operator|=
name|EXACT_RANK
expr_stmt|;
default|default:
break|break;
block|}
name|ICS_STD_RANK
argument_list|(
name|t
argument_list|)
operator|=
name|rank
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|code
operator|==
name|USER_CONV
operator|||
name|ICS_USER_FLAG
argument_list|(
name|from
argument_list|)
operator|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|strip_top_quals
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|t
return|;
return|return
name|cp_build_qualified_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the standard conversion path (see [conv]) from type FROM to type    TO, if any.  For proper handling of null pointer constants, you must    also pass the expression EXPR to convert from.  */
end_comment

begin_function
specifier|static
name|tree
name|standard_conversion
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|enum
name|tree_code
name|fcode
decl_stmt|,
name|tcode
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|bool
name|fromref
init|=
name|false
decl_stmt|;
name|to
operator|=
name|non_reference
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|fromref
operator|=
name|true
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|strip_top_quals
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|=
name|strip_top_quals
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|to
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|tf_conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|tcode
operator|=
name|TREE_CODE
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|LVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcode
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fcode
operator|=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|LVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fromref
operator|||
operator|(
name|expr
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|RVALUE_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* Allow conversion between `__complex__' data types.  */
if|if
condition|(
name|tcode
operator|==
name|COMPLEX_TYPE
operator|&&
name|fcode
operator|==
name|COMPLEX_TYPE
condition|)
block|{
comment|/* The standard conversion sequence to convert FROM to TO is          the standard conversion sequence to perform componentwise          conversion.  */
name|tree
name|part_conv
init|=
name|standard_conversion
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|part_conv
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|TREE_CODE
argument_list|(
name|part_conv
argument_list|)
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|ICS_STD_RANK
argument_list|(
name|part_conv
argument_list|)
expr_stmt|;
block|}
else|else
name|conv
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|conv
return|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
name|conv
return|;
if|if
condition|(
operator|(
name|tcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
name|expr
operator|&&
name|null_ptr_cst_p
argument_list|(
name|expr
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|fcode
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
call|(
modifier|*
name|targetm
operator|.
name|vector_opaque_p
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|||
call|(
modifier|*
name|targetm
operator|.
name|vector_opaque_p
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tcode
operator|==
name|INTEGER_TYPE
operator|&&
name|fcode
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|fcode
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
comment|/* For backwards brain damage compatibility, allow interconversion of 	 pointers and integers with a pedwarn.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|ENUMERAL_TYPE
operator|&&
name|fcode
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* For backwards brain damage compatibility, allow interconversion of 	 enums and integers with a pedwarn.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|fcode
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|to
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|from
argument_list|)
operator|)
condition|)
block|{
name|tree
name|to_pointee
decl_stmt|;
name|tree
name|from_pointee
decl_stmt|;
if|if
condition|(
name|tcode
operator|==
name|POINTER_TYPE
operator|&&
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
name|from
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|from
operator|=
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|tree
name|fbase
init|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|tree
name|tbase
init|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|fbase
argument_list|,
name|tbase
argument_list|)
operator|&&
operator|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|from
operator|=
name|build_ptrmem_type
argument_list|(
name|tbase
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PMEM_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|fbase
argument_list|,
name|tbase
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
comment|/* [conv.ptr] 		   	          An rvalue of type "pointer to cv D," where D is a 		  class type, can be converted to an rvalue of type 		  "pointer to cv B," where B is a base class (clause 		  _class.derived_) of D.  If B is an inaccessible 		  (clause _class.access_) or ambiguous 		  (_class.member.lookup_) base class of D, a program 		  that necessitates this conversion is ill-formed.  */
comment|/* Therefore, we use DERIVED_FROM_P, and not 		  ACESSIBLY_UNIQUELY_DERIVED_FROM_P, in this test.  */
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|from
operator|=
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_pointer_type
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcode
operator|==
name|POINTER_TYPE
condition|)
block|{
name|to_pointee
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from_pointee
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_pointee
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from_pointee
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|to_pointee
argument_list|,
name|from_pointee
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|QUAL_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|&&
name|string_conv_p
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* converting from string constant to char *.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|QUAL_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptr_reasonably_similar
argument_list|(
name|to_pointee
argument_list|,
name|from_pointee
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|PTR_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|from
operator|=
name|to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|tree
name|fromfn
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|from
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tofn
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|to
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fbase
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tbase
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|tofn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|fbase
argument_list|,
name|tbase
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fromfn
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|tofn
argument_list|)
argument_list|)
operator|||
operator|!
name|compparms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|tofn
argument_list|)
argument_list|)
argument_list|)
operator|||
name|cp_type_quals
argument_list|(
name|fbase
argument_list|)
operator|!=
name|cp_type_quals
argument_list|(
name|tbase
argument_list|)
condition|)
return|return
literal|0
return|;
name|from
operator|=
name|cp_build_qualified_type
argument_list|(
name|tbase
argument_list|,
name|cp_type_quals
argument_list|(
name|fbase
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_method_type_directly
argument_list|(
name|from
argument_list|,
name|TREE_TYPE
argument_list|(
name|fromfn
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fromfn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|PMEM_CONV
argument_list|,
name|from
argument_list|,
name|conv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcode
operator|==
name|BOOLEAN_TYPE
condition|)
block|{
comment|/* [conv.bool]            An rvalue of arithmetic, enumeration, pointer, or pointer to 	  member type can be converted to an rvalue of type bool.  */
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|from
argument_list|)
operator|||
name|fcode
operator|==
name|ENUMERAL_TYPE
operator|||
name|fcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|from
argument_list|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from
argument_list|)
operator|&&
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|<
name|PBOOL_RANK
operator|)
condition|)
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|PBOOL_RANK
expr_stmt|;
return|return
name|conv
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* We don't check for ENUMERAL_TYPE here because there are no standard      conversions to enum type.  */
elseif|else
if|if
condition|(
name|tcode
operator|==
name|INTEGER_TYPE
operator|||
name|tcode
operator|==
name|BOOLEAN_TYPE
operator|||
name|tcode
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|fcode
argument_list|)
operator|||
name|fcode
operator|==
name|REAL_TYPE
operator|)
condition|)
return|return
literal|0
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* Give this a better rank if it's a promotion.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|to
argument_list|,
name|type_promotes_to
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|ICS_STD_RANK
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|PROMO_RANK
condition|)
name|ICS_STD_RANK
argument_list|(
name|conv
argument_list|)
operator|=
name|PROMO_RANK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fcode
operator|==
name|VECTOR_TYPE
operator|&&
name|tcode
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
call|(
modifier|*
name|targetm
operator|.
name|vector_opaque_p
call|)
argument_list|(
name|from
argument_list|)
operator|||
call|(
modifier|*
name|targetm
operator|.
name|vector_opaque_p
call|)
argument_list|(
name|to
argument_list|)
operator|)
condition|)
return|return
name|build_conv
argument_list|(
name|STD_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_CONSTRUCTOR_CALLABLE
operator|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|to
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|from
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|RVALUE_CONV
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|to
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* The derived-to-base conversion indicates the initialization 	 of a parameter with base type from an object of a derived 	 type.  A temporary object is created to hold the result of 	 the conversion.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if T1 is reference-related to T2.  */
end_comment

begin_function
specifier|static
name|bool
name|reference_related_p
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|t1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* [dcl.init.ref]       Given types "cv1 T1" and "cv2 T2," "cv1 T1" is reference-related      to "cv2 T2" if T1 is the same type as T2, or T1 is a base class      of T2.  */
return|return
operator|(
name|same_type_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if T1 is reference-compatible with T2.  */
end_comment

begin_function
specifier|static
name|bool
name|reference_compatible_p
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
comment|/* [dcl.init.ref]       "cv1 T1" is reference compatible with "cv2 T2" if T1 is      reference-related to T2 and cv1 is the same cv-qualification as,      or greater cv-qualification than, cv2.  */
return|return
operator|(
name|reference_related_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether or not the EXPR (of class type S) can be    converted to T as in [over.match.ref].  */
end_comment

begin_function
specifier|static
name|tree
name|convert_class_to_reference
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|s
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|conversions
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|tree
name|reference_type
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
name|conversions
operator|=
name|lookup_conversions
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conversions
condition|)
return|return
name|NULL_TREE
return|;
comment|/* [over.match.ref]       Assuming that "cv1 T" is the underlying type of the reference      being initialized, and "cv S" is the type of the initializer      expression, with S a class type, the candidate functions are      selected as follows:       --The conversion functions of S and its base classes are        considered.  Those that are not hidden within S and yield type        "reference to cv2 T2", where "cv1 T" is reference-compatible        (_dcl.init.ref_) with "cv2 T2", are candidate functions.       The argument list has one argument, which is the initializer      expression.  */
name|candidates
operator|=
literal|0
expr_stmt|;
comment|/* Conceptually, we should take the address of EXPR and put it in      the argument list.  Unfortunately, however, that can result in      error messages, which we should not issue now because we are just      trying to find a conversion operator.  Therefore, we use NULL,      cast to the appropriate type.  */
name|arglist
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|reference_type
operator|=
name|build_reference_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|conversions
condition|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|conversions
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|f
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|cand
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a template function, try to get an exact              match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|cand
operator|=
name|add_template_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|f
argument_list|,
name|s
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|reference_type
argument_list|,
name|TYPE_BINFO
argument_list|(
name|s
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|conversions
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CONV
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
comment|/* Now, see if the conversion function really returns 		     an lvalue of the appropriate type.  From the 		     point of view of unification, simply returning an 		     rvalue of the right type is good enough.  */
name|f
operator|=
name|cand
operator|->
name|fn
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|!
name|reference_compatible_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|candidates
operator|=
name|candidates
operator|->
name|next
expr_stmt|;
name|cand
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|reference_compatible_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|cand
operator|=
name|add_function_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|f
argument_list|,
name|s
argument_list|,
name|arglist
argument_list|,
name|TYPE_BINFO
argument_list|(
name|s
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|conversions
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
comment|/* Build a standard conversion sequence indicating the 		 binding from the reference type returned by the 		 function to the desired REFERENCE_TYPE.  */
name|cand
operator|->
name|second_conv
operator|=
operator|(
name|direct_reference_binding
argument_list|(
name|reference_type
argument_list|,
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator||=
name|ICS_BAD_FLAG
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|conversions
operator|=
name|TREE_CHAIN
argument_list|(
name|conversions
argument_list|)
expr_stmt|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|,
name|pedantic
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
comment|/* If none of the conversion functions worked out, let our caller      know.  */
if|if
condition|(
operator|!
name|any_viable_p
condition|)
return|return
name|NULL_TREE
return|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Now that we know that this is the function we're going to use fix      the dummy first argument.  */
name|cand
operator|->
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|cand
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build a user-defined conversion sequence representing the      conversion.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|USER_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|1
argument_list|)
operator|=
name|build_zc_wrapper
argument_list|(
name|cand
argument_list|)
expr_stmt|;
comment|/* Merge it with the standard conversion sequence from the      conversion function's return type to the desired type.  */
name|cand
operator|->
name|second_conv
operator|=
name|merge_conversion_sequences
argument_list|(
name|conv
argument_list|,
name|cand
operator|->
name|second_conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|viable
operator|==
operator|-
literal|1
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cand
operator|->
name|second_conv
return|;
block|}
end_function

begin_comment
comment|/* A reference of the indicated TYPE is being bound directly to the    expression represented by the implicit conversion sequence CONV.    Return a conversion sequence for this binding.  */
end_comment

begin_function
specifier|static
name|tree
name|direct_reference_binding
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|conv
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
argument_list|,
literal|20030306
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|conv
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|20030306
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* [over.ics.rank]             When a parameter of reference type binds directly      (_dcl.init.ref_) to an argument expression, the implicit      conversion sequence is the identity conversion, unless the      argument expression has a type that is a derived class of the      parameter type, in which case the implicit conversion sequence is      a derived-to-base Conversion. 	       If the parameter binds directly to the result of applying a      conversion function to the argument expression, the implicit      conversion sequence is a user-defined conversion sequence      (_over.ics.user_), with the second standard conversion sequence      either an identity conversion or, if the conversion function      returns an entity of a type that is a derived class of the      parameter type, a derived-to-base conversion.  */
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|conv
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Represent the derived-to-base conversion.  */
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|t
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* We will actually be binding to the base-class subobject in 	 the derived class, so we mark this conversion appropriately. 	 That way, convert_like knows not to generate a temporary.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|type
argument_list|,
name|conv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the conversion path from type FROM to reference type TO for    purposes of reference binding.  For lvalue binding, either pass a    reference type to FROM or an lvalue expression to EXPR.  If the    reference will be bound to a temporary, NEED_TEMPORARY_P is set for    the conversion returned.  */
end_comment

begin_function
specifier|static
name|tree
name|reference_binding
parameter_list|(
name|tree
name|rto
parameter_list|,
name|tree
name|rfrom
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|conv
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|to
init|=
name|TREE_TYPE
argument_list|(
name|rto
argument_list|)
decl_stmt|;
name|tree
name|from
init|=
name|rfrom
decl_stmt|;
name|bool
name|related_p
decl_stmt|;
name|bool
name|compatible_p
decl_stmt|;
name|cp_lvalue_kind
name|lvalue_p
init|=
name|clk_none
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Anything with reference type is an lvalue.  */
name|lvalue_p
operator|=
name|clk_ordinary
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
condition|)
name|lvalue_p
operator|=
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not the types are reference-related and      reference compatible.  We have do do this after stripping      references from FROM.  */
name|related_p
operator|=
name|reference_related_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|compatible_p
operator|=
name|reference_compatible_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvalue_p
operator|&&
name|compatible_p
condition|)
block|{
comment|/* [dcl.init.ref]  	 If the initializer expression  	  	 -- is an lvalue (but not an lvalue for a bit-field), and "cv1 T1" 	    is reference-compatible with "cv2 T2," 	  	 the reference is bound directly to the initializer expression 	 lvalue.  */
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|conv
operator|=
name|direct_reference_binding
argument_list|(
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lvalue_p
operator|&
name|clk_bitfield
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|lvalue_p
operator|&
name|clk_packed
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|TYPE_PACKED
argument_list|(
name|to
argument_list|)
operator|)
condition|)
comment|/* For the purposes of overload resolution, we ignore the fact 	   this expression is a bitfield or packed field. (In particular, 	   [over.ics.ref] says specifically that a function with a 	   non-const reference parameter is viable even if the 	   argument is a bitfield.)  	   However, when we actually call the function we must create 	   a temporary to which to bind the reference.  If the 	   reference is volatile, or isn't const, then we cannot make 	   a temporary, so we just issue an error when the conversion 	   actually occurs.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|conv
return|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
condition|)
block|{
comment|/* [dcl.init.ref]  	 If the initializer expression  	 -- has a class type (i.e., T2 is a class type) can be 	    implicitly converted to an lvalue of type "cv3 T3," where 	    "cv1 T1" is reference-compatible with "cv3 T3".  (this 	    conversion is selected by enumerating the applicable 	    conversion functions (_over.match.ref_) and choosing the 	    best one through overload resolution.  (_over.match_).           the reference is bound to the lvalue result of the conversion 	in the second case.  */
name|conv
operator|=
name|convert_class_to_reference
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
return|return
name|conv
return|;
block|}
comment|/* From this point on, we conceptually need temporaries, even if we      elide them.  Only the cases above are "direct bindings".  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NO_TEMP_BIND
condition|)
return|return
name|NULL_TREE
return|;
comment|/* [over.ics.rank]            When a parameter of reference type is not bound directly to an      argument expression, the conversion sequence is the one required      to convert the argument expression to the underlying type of the      reference according to _over.best.ics_.  Conceptually, this      conversion sequence corresponds to copy-initializing a temporary      of the underlying type with the argument expression.  Any      difference in top-level cv-qualification is subsumed by the      initialization itself and does not constitute a conversion.  */
comment|/* [dcl.init.ref]       Otherwise, the reference shall be to a non-volatile const type.  */
if|if
condition|(
operator|!
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* [dcl.init.ref]            If the initializer expression is an rvalue, with T2 a class type,      and "cv1 T1" is reference-compatible with "cv2 T2", the reference      is bound in one of the following ways:            -- The reference is bound to the object represented by the rvalue         or to a sub-object within that object.         -- ... 	      We use the first alternative.  The implicit conversion sequence      is supposed to be same as we would obtain by generating a      temporary.  Fortunately, if the types are reference compatible,      then this is either an identity conversion or the derived-to-base      conversion, just as for direct binding.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|compatible_p
condition|)
block|{
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|from
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|conv
operator|=
name|direct_reference_binding
argument_list|(
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_CONSTRUCTOR_CALLABLE
operator|)
condition|)
name|CHECK_COPY_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|conv
return|;
block|}
comment|/* [dcl.init.ref]       Otherwise, a temporary of type "cv1 T1" is created and      initialized from the initializer expression using the rules for a      non-reference copy initialization.  If T1 is reference-related to      T2, cv1 must be the same cv-qualification as, or greater      cv-qualification than, cv2; otherwise, the program is ill-formed.  */
if|if
condition|(
name|related_p
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
condition|)
return|return
name|NULL_TREE
return|;
name|conv
operator|=
name|build_conv
argument_list|(
name|REF_BIND
argument_list|,
name|rto
argument_list|,
name|conv
argument_list|)
expr_stmt|;
comment|/* This reference binding, unlike those above, requires the      creation of a temporary.  */
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|conv
return|;
block|}
end_function

begin_comment
comment|/* Returns the implicit conversion sequence (see [over.ics]) from type FROM    to type TO.  The optional expression EXPR may affect the conversion.    FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is    significant.  */
end_comment

begin_function
specifier|static
name|tree
name|implicit_conversion
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|error_mark_node
operator|||
name|to
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|conv
operator|=
name|reference_binding
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|conv
operator|=
name|standard_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
return|return
name|conv
return|;
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|from
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|to
argument_list|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|cand
operator|=
name|build_user_type_conversion_1
argument_list|(
name|to
argument_list|,
name|expr
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
name|conv
operator|=
name|cand
operator|->
name|second_conv
expr_stmt|;
comment|/* We used to try to bind a reference to a temporary here, but that 	 is now handled by the recursive call to this function at the end 	 of reference_binding.  */
return|return
name|conv
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to the list of candidates.  Used by the add_*_candidate    functions.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|convs
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|tree
name|conversion_path
parameter_list|,
name|int
name|viable
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|z_candidate
argument_list|)
argument_list|)
decl_stmt|;
name|cand
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|cand
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|cand
operator|->
name|convs
operator|=
name|convs
expr_stmt|;
name|cand
operator|->
name|access_path
operator|=
name|access_path
expr_stmt|;
name|cand
operator|->
name|conversion_path
operator|=
name|conversion_path
expr_stmt|;
name|cand
operator|->
name|viable
operator|=
name|viable
expr_stmt|;
name|cand
operator|->
name|next
operator|=
operator|*
name|candidates
expr_stmt|;
operator|*
name|candidates
operator|=
name|cand
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_comment
comment|/* Create an overload candidate for the function or method FN called with    the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on    to implicit_conversion.     CTYPE, if non-NULL, is the type we want to pretend this function    comes from for purposes of overload resolution.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_function_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|fn
parameter_list|,
name|tree
name|ctype
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|tree
name|conversion_path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|parmlist
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|tree
name|convs
decl_stmt|;
name|tree
name|parmnode
decl_stmt|,
name|argnode
decl_stmt|;
name|tree
name|orig_arglist
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|;
comment|/* Built-in functions that haven't been declared don't really      exist.  */
if|if
condition|(
name|DECL_ANTICIPATED
argument_list|(
name|fn
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* The `this', `in_chrg' and VTT arguments to constructors are not      considered in overload resolution.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|parmlist
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
name|orig_arglist
operator|=
name|arglist
expr_stmt|;
name|arglist
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
else|else
name|orig_arglist
operator|=
name|arglist
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|convs
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 13.3.2 - Viable functions [over.match.viable]      First, to be a viable function, a candidate function shall have enough      parameters to agree in number with the arguments in the list.       We need to check this first; otherwise, checking the ICSes might cause      us to produce an ill-formed template instantiation.  */
name|parmnode
operator|=
name|parmlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|parmnode
operator|==
name|NULL_TREE
operator|||
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
operator|&&
name|parmnode
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
comment|/* Make sure there are default args for the rest of the parms.  */
elseif|else
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|parmnode
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|viable
condition|)
goto|goto
name|out
goto|;
comment|/* Second, for F to be a viable function, there shall exist for each      argument an implicit conversion sequence that converts that argument      to the corresponding parameter of F.  */
name|parmnode
operator|=
name|parmlist
expr_stmt|;
name|argnode
operator|=
name|arglist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|argnode
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|is_this
decl_stmt|;
if|if
condition|(
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
name|is_this
operator|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|parmnode
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parmnode
argument_list|)
decl_stmt|;
comment|/* The type of the implicit object parameter ('this') for 	     overload resolution is not always the same as for the 	     function itself; conversion functions are considered to 	     be members of the class being converted, and functions 	     introduced by a using-declaration are considered to be 	     members of the class that uses them.  	     Since build_over_call ignores the ICS for the `this' 	     parameter, we can just change the parm type.  */
if|if
condition|(
name|ctype
operator|&&
name|is_this
condition|)
block|{
name|parmtype
operator|=
name|build_qualified_type
argument_list|(
name|ctype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|build_pointer_type
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|implicit_conversion
argument_list|(
name|parmtype
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|is_this
condition|)
name|ICS_THIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|parmnode
condition|)
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
name|argnode
operator|=
name|TREE_CHAIN
argument_list|(
name|argnode
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|orig_arglist
argument_list|,
name|convs
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an overload candidate for the conversion function FN which will    be invoked for expression OBJ, producing a pointer-to-function which    will in turn be called with the argument list ARGLIST, and add it to    CANDIDATES.  FLAGS is passed on to implicit_conversion.     Actually, we don't really care about FN; we care about the type it    converts to.  There may be multiple conversion functions that will    convert to that type, and we rely on build_user_type_conversion_1 to    choose the best one; so when we create our candidate, we record the type    instead of the function.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_conv_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|fn
parameter_list|,
name|tree
name|obj
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|tree
name|conversion_path
parameter_list|)
block|{
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|viable
decl_stmt|,
name|flags
decl_stmt|;
name|tree
name|parmlist
decl_stmt|,
name|convs
decl_stmt|,
name|parmnode
decl_stmt|,
name|argnode
decl_stmt|;
for|for
control|(
name|parmlist
operator|=
name|totype
init|;
name|TREE_CODE
argument_list|(
name|parmlist
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|;
control|)
name|parmlist
operator|=
name|TREE_TYPE
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
operator|+
literal|1
expr_stmt|;
name|convs
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|parmnode
operator|=
name|parmlist
expr_stmt|;
name|argnode
operator|=
name|arglist
expr_stmt|;
name|viable
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|LOOKUP_NORMAL
expr_stmt|;
comment|/* Don't bother looking up the same type twice.  */
if|if
condition|(
operator|*
name|candidates
operator|&&
operator|(
operator|*
name|candidates
operator|)
operator|->
name|fn
operator|==
name|totype
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|i
operator|==
literal|0
condition|?
name|obj
else|:
name|TREE_VALUE
argument_list|(
name|argnode
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|t
operator|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmnode
operator|==
name|void_list_node
condition|)
break|break;
elseif|else
if|if
condition|(
name|parmnode
condition|)
name|t
operator|=
name|implicit_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmnode
argument_list|)
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
break|break;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|parmnode
condition|)
name|parmnode
operator|=
name|TREE_CHAIN
argument_list|(
name|parmnode
argument_list|)
expr_stmt|;
name|argnode
operator|=
name|TREE_CHAIN
argument_list|(
name|argnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|parmnode
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
return|return
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|totype
argument_list|,
name|arglist
argument_list|,
name|convs
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|viable
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_builtin_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|fnname
parameter_list|,
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|,
name|tree
modifier|*
name|args
parameter_list|,
name|tree
modifier|*
name|argtypes
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|convs
decl_stmt|;
name|int
name|viable
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|;
name|types
index|[
literal|0
index|]
operator|=
name|type1
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
name|type2
expr_stmt|;
name|convs
operator|=
name|make_tree_vec
argument_list|(
name|args
index|[
literal|2
index|]
condition|?
literal|3
else|:
operator|(
name|args
index|[
literal|1
index|]
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
break|break;
name|t
operator|=
name|implicit_conversion
argument_list|(
name|types
index|[
name|i
index|]
argument_list|,
name|argtypes
index|[
name|i
index|]
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|viable
operator|=
literal|0
expr_stmt|;
comment|/* We need something for printing the candidate.  */
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|types
index|[
name|i
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
name|viable
operator|=
literal|0
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* For COND_EXPR we rearranged the arguments; undo that now.  */
if|if
condition|(
name|args
index|[
literal|2
index|]
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|2
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|argtypes
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
else|else
name|viable
operator|=
literal|0
expr_stmt|;
block|}
name|add_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
comment|/*args=*/
name|NULL_TREE
argument_list|,
name|convs
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*conversion_path=*/
name|NULL_TREE
argument_list|,
name|viable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_complete
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if TYPE is a promoted arithmetic type.  */
end_comment

begin_function
specifier|static
name|bool
name|promoted_arithmetic_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* [over.built]       In this section, the term promoted integral type is used to refer      to those integral types which are preserved by integral promotion      (including e.g.  int and long but excluding e.g.  char).      Similarly, the term promoted arithmetic type refers to promoted      integral types plus floating types.  */
return|return
operator|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type_promotes_to
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create any builtin operator overload candidates for the operator in    question given the converted operand types TYPE1 and TYPE2.  The other    args are passed through from add_builtin_candidates to    build_builtin_candidate.          TYPE1 and TYPE2 may not be permissible, and we must filter them.     If CODE is requires candidates operands of the same type of the kind    of which TYPE1 and TYPE2 are, we add both candidates    CODE (TYPE1, TYPE1) and CODE (TYPE2, TYPE2).  */
end_comment

begin_function
specifier|static
name|void
name|add_builtin_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|enum
name|tree_code
name|code2
parameter_list|,
name|tree
name|fnname
parameter_list|,
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|,
name|tree
modifier|*
name|args
parameter_list|,
name|tree
modifier|*
name|argtypes
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|args
index|[
literal|1
index|]
operator|=
name|integer_zero_node
expr_stmt|;
name|type2
operator|=
name|integer_type_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,      and  VQ  is  either  volatile or empty, there exist candidate operator      functions of the form 	     VQ T&   operator++(VQ T&); 	     T       operator++(VQ T&, int);    5 For every pair T, VQ), where T is an enumeration type or an arithmetic      type  other than bool, and VQ is either volatile or empty, there exist      candidate operator functions of the form 	     VQ T&   operator--(VQ T&); 	     T       operator--(VQ T&, int);    6 For every pair T, VQ), where T is  a  cv-qualified  or  cv-unqualified      complete  object type, and VQ is either volatile or empty, there exist      candidate operator functions of the form 	     T*VQ&   operator++(T*VQ&); 	     T*VQ&   operator--(T*VQ&); 	     T*      operator++(T*VQ&, int); 	     T*      operator--(T*VQ&, int);  */
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
comment|/* 7 For every cv-qualified or cv-unqualified complete object type T, there      exist candidate operator functions of the form  	     T&      operator*(T*);     8 For every function type T, there exist candidate operator functions of      the form 	     T&      operator*(T*);  */
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
break|break;
return|return;
comment|/* 9 For every type T, there exist candidate operator functions of the form 	     T*      operator+(T*);     10For  every  promoted arithmetic type T, there exist candidate operator      functions of the form 	     T       operator+(T); 	     T       operator-(T);  */
case|case
name|CONVERT_EXPR
case|:
comment|/* unary + */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
condition|)
break|break;
return|return;
comment|/* 11For every promoted integral type T,  there  exist  candidate  operator      functions of the form 	     T       operator~(T);  */
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
condition|)
break|break;
return|return;
comment|/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1      is the same type as C2 or is a derived class of C2, T  is  a  complete      object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,      there exist candidate operator functions of the form 	     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);      where CV12 is the union of CV1 and CV2.  */
case|case
name|MEMBER_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|tree
name|c1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|tree
name|c2
init|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|c1
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|&&
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|||
name|is_complete
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
return|return;
comment|/* 13For every pair of promoted arithmetic types L and R, there exist  can-      didate operator functions of the form 	     LR      operator*(L, R); 	     LR      operator/(L, R); 	     LR      operator+(L, R); 	     LR      operator-(L, R); 	     bool    operator<(L, R); 	     bool    operator>(L, R); 	     bool    operator<=(L, R); 	     bool    operator>=(L, R); 	     bool    operator==(L, R); 	     bool    operator!=(L, R);      where  LR  is  the  result of the usual arithmetic conversions between      types L and R.     14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-      unqualified  complete  object  type and I is a promoted integral type,      there exist candidate operator functions of the form 	     T*      operator+(T*, I); 	     T&      operator[](T*, I); 	     T*      operator-(T*, I); 	     T*      operator+(I, T*); 	     T&      operator[](I, T*);     15For every T, where T is a pointer to complete object type, there exist      candidate operator functions of the form112) 	     ptrdiff_t operator-(T, T);     16For every pointer or enumeration type T, there exist candidate operator      functions of the form 	     bool    operator<(T, T); 	     bool    operator>(T, T); 	     bool    operator<=(T, T); 	     bool    operator>=(T, T); 	     bool    operator==(T, T); 	     bool    operator!=(T, T);     17For every pointer to member type T,  there  exist  candidate  operator      functions of the form 	     bool    operator==(T, T); 	     bool    operator!=(T, T);  */
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type2
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
break|break;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|type2
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type1
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
return|return;
comment|/* 18For  every pair of promoted integral types L and R, there exist candi-      date operator functions of the form 	     LR      operator%(L, R); 	     LR      operator&(L, R); 	     LR      operator^(L, R); 	     LR      operator|(L, R); 	     L       operator<<(L, R); 	     L       operator>>(L, R);      where LR is the result of the  usual  arithmetic  conversions  between      types L and R.  */
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return;
comment|/* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration      type, VQ is either volatile or empty, and R is a  promoted  arithmetic      type, there exist candidate operator functions of the form 	     VQ L&   operator=(VQ L&, R); 	     VQ L&   operator*=(VQ L&, R); 	     VQ L&   operator/=(VQ L&, R); 	     VQ L&   operator+=(VQ L&, R); 	     VQ L&   operator-=(VQ L&, R);     20For  every  pair T, VQ), where T is any type and VQ is either volatile      or empty, there exist candidate operator functions of the form 	     T*VQ&   operator=(T*VQ&, T*);     21For every pair T, VQ), where T is a pointer to member type and  VQ  is      either  volatile or empty, there exist candidate operator functions of      the form 	     VQ T&   operator=(VQ T&, T);     22For every triple  T,  VQ,  I),  where  T  is  a  cv-qualified  or  cv-      unqualified  complete object type, VQ is either volatile or empty, and      I is a promoted integral type, there exist  candidate  operator  func-      tions of the form 	     T*VQ&   operator+=(T*VQ&, I); 	     T*VQ&   operator-=(T*VQ&, I);     23For  every  triple  L,  VQ,  R), where L is an integral or enumeration      type, VQ is either volatile or empty, and R  is  a  promoted  integral      type, there exist candidate operator functions of the form  	     VQ L&   operator%=(VQ L&, R); 	     VQ L&   operator<<=(VQ L&, R); 	     VQ L&   operator>>=(VQ L&, R); 	     VQ L&   operator&=(VQ L&, R); 	     VQ L&   operator^=(VQ L&, R); 	     VQ L&   operator|=(VQ L&, R);  */
case|case
name|MODIFY_EXPR
case|:
switch|switch
condition|(
name|code2
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|type2
operator|=
name|ptrdiff_type_node
expr_stmt|;
break|break;
block|}
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
return|return;
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|ARITHMETIC_TYPE_P
argument_list|(
name|type2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|type2
operator|=
name|type1
expr_stmt|;
break|break;
block|}
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
comment|/* [over.built]  	 For every pair of promoted arithmetic types L and R, there 	 exist candidate operator functions of the form   	 LR operator?(bool, L, R);   	 where LR is the result of the usual arithmetic conversions 	 between types L and R.  	 For every type T, where T is a pointer or pointer-to-member 	 type, there exist candidate operator functions of the form T 	 operator?(bool, T, T);  */
if|if
condition|(
name|promoted_arithmetic_type_p
argument_list|(
name|type1
argument_list|)
operator|&&
name|promoted_arithmetic_type_p
argument_list|(
name|type2
argument_list|)
condition|)
comment|/* That's OK.  */
break|break;
comment|/* Otherwise, the types should be pointers.  */
if|if
condition|(
operator|!
operator|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type1
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type2
argument_list|)
operator|)
condition|)
return|return;
comment|/* We don't check that the two types are the same; the logic 	 below will actually create two candidates; one in which both 	 parameter types are TYPE1, and one in which both parameter 	 types are TYPE2.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we're dealing with two pointer types or two enumeral types,      we need candidates for both of them.  */
if|if
condition|(
name|type2
operator|&&
operator|!
name|same_type_p
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type2
argument_list|)
operator|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type1
argument_list|,
name|type1
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type2
argument_list|,
name|type2
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|type_decays_to
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|type
argument_list|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* There are three conditions of builtin candidates:     1) bool-taking candidates.  These are the same regardless of the input.    2) pointer-pair taking candidates.  These are generated for each type       one of the input types converts to.    3) arithmetic candidates.  According to the standard, we should generate       all of these, but I'm trying not to...        Here we generate a superset of the possible candidates for this particular    case.  That is a subset of the full set the standard defines, plus some    other cases which the standard disallows. add_builtin_candidate will    filter out the invalid set.  */
end_comment

begin_function
specifier|static
name|void
name|add_builtin_candidates
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|enum
name|tree_code
name|code2
parameter_list|,
name|tree
name|fnname
parameter_list|,
name|tree
modifier|*
name|args
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ref1
decl_stmt|,
name|i
decl_stmt|;
name|int
name|enum_p
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|argtypes
index|[
literal|3
index|]
decl_stmt|;
comment|/* TYPES[i] is the set of possible builtin-operator parameter types      we will consider for the Ith argument.  These are represented as      a TREE_LIST; the TREE_VALUE of each node is the potential      parameter type.  */
name|tree
name|types
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|argtypes
index|[
name|i
index|]
operator|=
name|lvalue_type
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|argtypes
index|[
name|i
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,      and  VQ  is  either  volatile or empty, there exist candidate operator      functions of the form 		 VQ T&   operator++(VQ T&);  */
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
name|ref1
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 24There also exist candidate operator functions of the form 	     bool    operator!(bool); 	     bool    operator&&(bool, bool); 	     bool    operator||(bool, bool);  */
case|case
name|TRUTH_NOT_EXPR
case|:
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|boolean_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|build_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|fnname
argument_list|,
name|boolean_type_node
argument_list|,
name|boolean_type_node
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return;
case|case
name|COND_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|enum_p
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
default|default:
name|ref1
operator|=
literal|0
expr_stmt|;
block|}
name|types
index|[
literal|0
index|]
operator|=
name|types
index|[
literal|1
index|]
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|tree
name|convs
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|code
operator|==
name|MODIFY_EXPR
operator|&&
name|code2
operator|==
name|NOP_EXPR
condition|)
return|return;
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|convs
condition|)
return|return;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ref1
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
name|ref1
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enum_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|value_member
argument_list|(
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|COND_EXPR
operator|&&
name|real_lvalue_p
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|argtypes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
name|ref1
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enum_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|types
index|[
name|i
index|]
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Run through the possible parameter types of both arguments,      creating candidates with those parameter types.  */
for|for
control|(
init|;
name|types
index|[
literal|0
index|]
condition|;
name|types
index|[
literal|0
index|]
operator|=
name|TREE_CHAIN
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
control|)
block|{
if|if
condition|(
name|types
index|[
literal|1
index|]
condition|)
for|for
control|(
name|type
operator|=
name|types
index|[
literal|1
index|]
init|;
name|type
condition|;
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
name|add_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|TREE_VALUE
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|add_builtin_candidate
argument_list|(
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|TREE_VALUE
argument_list|(
name|types
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|argtypes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* If TMPL can be successfully instantiated as indicated by    EXPLICIT_TARGS and ARGLIST, adds the instantiation to CANDIDATES.     TMPL is the template.  EXPLICIT_TARGS are any explicit template    arguments.  ARGLIST is the arguments provided at the call-site.    The RETURN_TYPE is the desired type for conversion operators.  If    OBJ is NULL_TREE, FLAGS and CTYPE are as for add_function_candidate.    If an OBJ is supplied, FLAGS and CTYPE are ignored, and OBJ is as for    add_conv_candidate.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate_real
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|tmpl
parameter_list|,
name|tree
name|ctype
parameter_list|,
name|tree
name|explicit_targs
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|return_type
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|tree
name|conversion_path
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|obj
parameter_list|,
name|unification_kind_t
name|strict
parameter_list|)
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_tree_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|tree
name|args_without_in_chrg
init|=
name|arglist
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* We don't do deduction on the in-charge parameter, the VTT      parameter or 'this'.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
condition|)
name|args_without_in_chrg
operator|=
name|TREE_CHAIN
argument_list|(
name|args_without_in_chrg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|||
name|DECL_BASE_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
condition|)
name|args_without_in_chrg
operator|=
name|TREE_CHAIN
argument_list|(
name|args_without_in_chrg
argument_list|)
expr_stmt|;
name|i
operator|=
name|fn_type_unification
argument_list|(
name|tmpl
argument_list|,
name|explicit_targs
argument_list|,
name|targs
argument_list|,
name|args_without_in_chrg
argument_list|,
name|return_type
argument_list|,
name|strict
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|fn
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|NULL
return|;
comment|/* In [class.copy]:         A member function template is never instantiated to perform the        copy of a class object to an object of its class type.         It's a little unclear what this means; the standard explicitly      does allow a template to be used to copy a class.  For example,      in:         struct A {          A(A&); 	 template<class T> A(const T&);        };        const A f ();        void g () { A a (f ()); }              the member template will be used to make the copy.  The section      quoted above appears in the paragraph that forbids constructors      whose only parameter is (a possibly cv-qualified variant of) the      class type, and a logical interpretation is that the intent was      to forbid the instantiation of member templates which would then      have that form.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|list_length
argument_list|(
name|arglist
argument_list|)
operator|==
literal|2
condition|)
block|{
name|tree
name|arg_types
init|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_types
operator|&&
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
argument_list|,
name|ctype
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|obj
operator|!=
name|NULL_TREE
condition|)
comment|/* Aha, this is a conversion function.  */
name|cand
operator|=
name|add_conv_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
else|else
name|cand
operator|=
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|ctype
argument_list|,
name|arglist
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
operator|!=
name|tmpl
condition|)
comment|/* This situation can occur if a member template of a template        class is specialized.  Then, instantiate_template might return        an instantiation of the specialization, in which case the        DECL_TI_TEMPLATE field will point at the original        specialization.  For example:  	 template<class T> struct S { template<class U> void f(U); 				       template<> void f(int) {}; }; 	 S<double> sd; 	 sd.f(3);         Here, TMPL will be template<class U> S<double>::f(U).        And, instantiate template will give us the specialization        template<> S<double>::f(int).  But, the DECL_TI_TEMPLATE field        for this will point at template<class T> template<> S<T>::f(int),        so that we can find the definition.  For the purposes of        overload resolution, however, we want the original TMPL.  */
name|cand
operator|->
name|template
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|cand
operator|->
name|template
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|tmpl
parameter_list|,
name|tree
name|ctype
parameter_list|,
name|tree
name|explicit_targs
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|return_type
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|tree
name|conversion_path
parameter_list|,
name|int
name|flags
parameter_list|,
name|unification_kind_t
name|strict
parameter_list|)
block|{
return|return
name|add_template_candidate_real
argument_list|(
name|candidates
argument_list|,
name|tmpl
argument_list|,
name|ctype
argument_list|,
name|explicit_targs
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|,
name|strict
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|add_template_conv_candidate
parameter_list|(
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|tree
name|tmpl
parameter_list|,
name|tree
name|obj
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|return_type
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|tree
name|conversion_path
parameter_list|)
block|{
return|return
name|add_template_candidate_real
argument_list|(
name|candidates
argument_list|,
name|tmpl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|arglist
argument_list|,
name|return_type
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|DEDUCE_CONV
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The CANDS are the set of candidates that were considered for    overload resolution.  Return the set of viable candidates.  If none    of the candidates were viable, set *ANY_VIABLE_P to true.  STRICT_P    is true if a candidate should be considered viable only if it is    strictly viable.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|splice_viable
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|cands
parameter_list|,
name|bool
name|strict_p
parameter_list|,
name|bool
modifier|*
name|any_viable_p
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|viable
decl_stmt|;
name|struct
name|z_candidate
modifier|*
modifier|*
name|last_viable
decl_stmt|;
name|struct
name|z_candidate
modifier|*
modifier|*
name|cand
decl_stmt|;
name|viable
operator|=
name|NULL
expr_stmt|;
name|last_viable
operator|=
operator|&
name|viable
expr_stmt|;
operator|*
name|any_viable_p
operator|=
name|false
expr_stmt|;
name|cand
operator|=
operator|&
name|cands
expr_stmt|;
while|while
condition|(
operator|*
name|cand
condition|)
block|{
name|struct
name|z_candidate
modifier|*
name|c
init|=
operator|*
name|cand
decl_stmt|;
if|if
condition|(
name|strict_p
condition|?
name|c
operator|->
name|viable
operator|==
literal|1
else|:
name|c
operator|->
name|viable
condition|)
block|{
operator|*
name|last_viable
operator|=
name|c
expr_stmt|;
operator|*
name|cand
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|last_viable
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
operator|*
name|any_viable_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|cand
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
block|}
return|return
name|viable
condition|?
name|viable
else|:
name|cands
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|any_strictly_viable
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|cands
parameter_list|)
block|{
for|for
control|(
init|;
name|cands
condition|;
name|cands
operator|=
name|cands
operator|->
name|next
control|)
if|if
condition|(
name|cands
operator|->
name|viable
operator|==
literal|1
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* OBJ is being used in an expression like "OBJ.f (...)".  In other    words, it is about to become the "this" pointer for a member    function call.  Take the address of the object.  */
end_comment

begin_function
specifier|static
name|tree
name|build_this
parameter_list|(
name|tree
name|obj
parameter_list|)
block|{
comment|/* In a template, we are only concerned about the type of the      expression, so we can take a shortcut.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_address
argument_list|(
name|obj
argument_list|)
return|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff functions are equivalent. Equivalent functions are    not '==' only if one is a function-local extern function or if    both are extern "C".  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|equal_functions
parameter_list|(
name|tree
name|fn1
parameter_list|,
name|tree
name|fn2
parameter_list|)
block|{
if|if
condition|(
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|fn1
argument_list|)
operator|||
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|fn2
argument_list|)
operator|||
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|fn1
argument_list|)
condition|)
return|return
name|decls_match
argument_list|(
name|fn1
argument_list|,
name|fn2
argument_list|)
return|;
return|return
name|fn1
operator|==
name|fn2
return|;
block|}
end_function

begin_comment
comment|/* Print information about one overload candidate CANDIDATE.  MSGSTR    is the text to print before the candidate itself.     NOTE: Unlike most diagnostic functions in GCC, MSGSTR is expected    to have been run through gettext by the caller.  This wart makes    life simpler in print_z_candidates and for the translators.  */
end_comment

begin_function
specifier|static
name|void
name|print_z_candidate
parameter_list|(
specifier|const
name|char
modifier|*
name|msgstr
parameter_list|,
name|struct
name|z_candidate
modifier|*
name|candidate
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|candidate
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|candidate
operator|->
name|convs
argument_list|)
operator|==
literal|3
condition|)
name|inform
argument_list|(
literal|"%s %D(%T, %T, %T)<built-in>"
argument_list|,
name|msgstr
argument_list|,
name|candidate
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidate
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidate
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidate
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|candidate
operator|->
name|convs
argument_list|)
operator|==
literal|2
condition|)
name|inform
argument_list|(
literal|"%s %D(%T, %T)<built-in>"
argument_list|,
name|msgstr
argument_list|,
name|candidate
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidate
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidate
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|inform
argument_list|(
literal|"%s %D(%T)<built-in>"
argument_list|,
name|msgstr
argument_list|,
name|candidate
operator|->
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|candidate
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|candidate
operator|->
name|fn
argument_list|)
condition|)
name|inform
argument_list|(
literal|"%s %T<conversion>"
argument_list|,
name|msgstr
argument_list|,
name|candidate
operator|->
name|fn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|candidate
operator|->
name|viable
operator|==
operator|-
literal|1
condition|)
name|inform
argument_list|(
literal|"%J%s %+#D<near match>"
argument_list|,
name|candidate
operator|->
name|fn
argument_list|,
name|msgstr
argument_list|,
name|candidate
operator|->
name|fn
argument_list|)
expr_stmt|;
else|else
name|inform
argument_list|(
literal|"%J%s %+#D"
argument_list|,
name|candidate
operator|->
name|fn
argument_list|,
name|msgstr
argument_list|,
name|candidate
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_z_candidates
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|candidates
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand1
decl_stmt|;
name|struct
name|z_candidate
modifier|*
modifier|*
name|cand2
decl_stmt|;
comment|/* There may be duplicates in the set of candidates.  We put off      checking this condition as long as possible, since we have no way      to eliminate duplicates from a set of functions in less than n^2      time.  Now we are about to emit an error message, so it is more      permissible to go slowly.  */
for|for
control|(
name|cand1
operator|=
name|candidates
init|;
name|cand1
condition|;
name|cand1
operator|=
name|cand1
operator|->
name|next
control|)
block|{
name|tree
name|fn
init|=
name|cand1
operator|->
name|fn
decl_stmt|;
comment|/* Skip builtin candidates and conversion functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
continue|continue;
name|cand2
operator|=
operator|&
name|cand1
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|*
name|cand2
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|(
operator|*
name|cand2
operator|)
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|equal_functions
argument_list|(
name|fn
argument_list|,
operator|(
operator|*
name|cand2
operator|)
operator|->
name|fn
argument_list|)
condition|)
operator|*
name|cand2
operator|=
operator|(
operator|*
name|cand2
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|cand2
operator|=
operator|&
operator|(
operator|*
name|cand2
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|candidates
condition|)
return|return;
name|str
operator|=
name|_
argument_list|(
literal|"candidates are:"
argument_list|)
expr_stmt|;
name|print_z_candidate
argument_list|(
name|str
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|->
name|next
condition|)
block|{
comment|/* Indent successive candidates by the width of the translation 	 of the above string.  */
name|size_t
name|len
init|=
name|gcc_gettext_width
argument_list|(
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|spaces
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|spaces
argument_list|,
literal|' '
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|spaces
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|candidates
operator|=
name|candidates
operator|->
name|next
expr_stmt|;
do|do
block|{
name|print_z_candidate
argument_list|(
name|spaces
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|candidates
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|candidates
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* USER_SEQ is a user-defined conversion sequence, beginning with a    USER_CONV.  STD_SEQ is the standard conversion sequence applied to    the result of the conversion function to convert it to the final    desired type.  Merge the the two sequences into a single sequence,    and return the merged sequence.  */
end_comment

begin_function
specifier|static
name|tree
name|merge_conversion_sequences
parameter_list|(
name|tree
name|user_seq
parameter_list|,
name|tree
name|std_seq
parameter_list|)
block|{
name|tree
modifier|*
name|t
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|user_seq
argument_list|)
operator|==
name|USER_CONV
argument_list|,
literal|20030306
argument_list|)
expr_stmt|;
comment|/* Find the end of the second conversion sequence.  */
name|t
operator|=
operator|&
operator|(
name|std_seq
operator|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|t
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|t
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Replace the identity conversion with the user conversion      sequence.  */
operator|*
name|t
operator|=
name|user_seq
expr_stmt|;
comment|/* The entire sequence is a user-conversion sequence.  */
name|ICS_USER_FLAG
argument_list|(
name|std_seq
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|std_seq
return|;
block|}
end_function

begin_comment
comment|/* Returns the best overload candidate to perform the requested    conversion.  This function is used for three the overloading situations    described in [over.match.copy], [over.match.conv], and [over.match.ref].    If TOTYPE is a REFERENCE_TYPE, we're trying to find an lvalue binding as    per [dcl.init.ref], so we ignore temporary bindings.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|build_user_type_conversion_1
parameter_list|(
name|tree
name|totype
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fromtype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|ctors
init|=
name|NULL_TREE
decl_stmt|,
name|convs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
comment|/* We represent conversion within a hierarchy using RVALUE_CONV and      BASE_CONV, as specified by [over.best.ics]; these become plain      constructor calls, as specified in [dcl.init].  */
name|my_friendly_assert
argument_list|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|fromtype
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
operator|||
operator|!
name|DERIVED_FROM_P
argument_list|(
name|totype
argument_list|,
name|fromtype
argument_list|)
argument_list|,
literal|20011226
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
condition|)
name|ctors
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|complete_ctor_identifier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|fromtype
argument_list|)
condition|)
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|fromtype
argument_list|)
expr_stmt|;
name|candidates
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|LOOKUP_NO_CONVERSION
expr_stmt|;
if|if
condition|(
name|ctors
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|ctors
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|ctors
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|totype
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* We should never try to call the abstract or base constructor 	 from here.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
argument_list|)
argument_list|,
literal|20011226
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|ctors
condition|;
name|ctors
operator|=
name|OVL_NEXT
argument_list|(
name|ctors
argument_list|)
control|)
block|{
name|tree
name|ctor
init|=
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NONCONVERTING_P
argument_list|(
name|ctor
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|cand
operator|=
name|add_template_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|ctor
argument_list|,
name|totype
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
else|else
name|cand
operator|=
name|add_function_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|ctor
argument_list|,
name|totype
argument_list|,
name|args
argument_list|,
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|totype
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
name|cand
operator|->
name|second_conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|totype
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|convs
condition|)
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|fns
decl_stmt|;
name|tree
name|conversion_path
init|=
name|TREE_PURPOSE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|int
name|convflags
init|=
name|LOOKUP_NO_CONVERSION
decl_stmt|;
comment|/* If we are called to convert to a reference type, we are trying to 	 find an lvalue binding, so don't even consider temporaries.  If 	 we don't find an lvalue binding, the caller will try again to 	 look for a temporary binding.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|convflags
operator||=
name|LOOKUP_NO_TEMP_BIND
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
comment|/* [over.match.funcs] For conversion functions, the function 	     is considered to be a member of the class of the implicit 	     object argument for the purpose of defining the type of 	     the implicit object parameter.  	     So we pass fromtype as CTYPE to add_*_candidate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|cand
operator|=
name|add_template_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|fn
argument_list|,
name|fromtype
argument_list|,
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|totype
argument_list|,
name|TYPE_BINFO
argument_list|(
name|fromtype
argument_list|)
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CONV
argument_list|)
expr_stmt|;
else|else
name|cand
operator|=
name|add_function_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|fn
argument_list|,
name|fromtype
argument_list|,
name|args
argument_list|,
name|TYPE_BINFO
argument_list|(
name|fromtype
argument_list|)
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
name|tree
name|ics
init|=
name|implicit_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|convflags
argument_list|)
decl_stmt|;
name|cand
operator|->
name|second_conv
operator|=
name|ics
expr_stmt|;
if|if
condition|(
name|ics
operator|==
name|NULL_TREE
condition|)
name|cand
operator|->
name|viable
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|candidates
operator|->
name|viable
operator|==
literal|1
operator|&&
name|ICS_BAD_FLAG
argument_list|(
name|ics
argument_list|)
condition|)
name|cand
operator|->
name|viable
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|,
name|pedantic
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_viable_p
condition|)
return|return
literal|0
return|;
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error
argument_list|(
literal|"conversion from `%T' to `%T' is ambiguous"
argument_list|,
name|fromtype
argument_list|,
name|totype
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
name|cand
operator|=
name|candidates
expr_stmt|;
comment|/* any one will do */
name|cand
operator|->
name|second_conv
operator|=
name|build1
argument_list|(
name|AMBIG_CONV
argument_list|,
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|any_strictly_viable
argument_list|(
name|candidates
argument_list|)
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If there are viable candidates, don't set ICS_BAD_FLAG; an 	 ambiguous conversion is no worse than another user-defined 	 conversion.  */
return|return
name|cand
return|;
block|}
comment|/* Build the user conversion sequence.  */
name|convs
operator|=
name|build_conv
argument_list|(
name|USER_CONV
argument_list|,
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
condition|?
name|totype
else|:
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|,
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|1
argument_list|)
operator|=
name|build_zc_wrapper
argument_list|(
name|cand
argument_list|)
expr_stmt|;
comment|/* Combine it with the second conversion sequence.  */
name|cand
operator|->
name|second_conv
operator|=
name|merge_conversion_sequences
argument_list|(
name|convs
argument_list|,
name|cand
operator|->
name|second_conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|viable
operator|==
operator|-
literal|1
condition|)
name|ICS_BAD_FLAG
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_function
name|tree
name|build_user_type_conversion
parameter_list|(
name|tree
name|totype
parameter_list|,
name|tree
name|expr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|build_user_type_conversion_1
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|cand
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
name|error_mark_node
return|;
return|return
name|convert_from_reference
argument_list|(
name|convert_like
argument_list|(
name|cand
operator|->
name|second_conv
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Do any initial processing on the arguments to a function call.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_args
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|args
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg
operator|=
name|convert_from_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Perform overload resolution on FN, which is called with the ARGS.     Return the candidate function selected by overload resolution, or    NULL if the event that overload resolution failed.  In the case    that overload resolution fails, *CANDIDATES will be the set of    candidates considered, and ANY_VIABLE_P will be set to true or    false to indicate whether or not any of the candidates were    viable.       The ARGS should already have gone through RESOLVE_ARGS before this    function is called.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|perform_overload_resolution
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|,
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|,
name|bool
modifier|*
name|any_viable_p
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
operator|*
name|candidates
operator|=
name|NULL
expr_stmt|;
operator|*
name|any_viable_p
operator|=
name|true
expr_stmt|;
comment|/* Check FN and ARGS.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|args
operator|||
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|template_only
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Add the various candidate functions.  */
name|add_candidates
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|explicit_targs
argument_list|,
name|template_only
argument_list|,
comment|/*conversion_path=*/
name|NULL_TREE
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
operator|*
name|candidates
operator|=
name|splice_viable
argument_list|(
operator|*
name|candidates
argument_list|,
name|pedantic
argument_list|,
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|any_viable_p
condition|)
return|return
name|NULL
return|;
name|cand
operator|=
name|tourney
argument_list|(
operator|*
name|candidates
argument_list|)
expr_stmt|;
return|return
name|cand
return|;
block|}
end_function

begin_comment
comment|/* Return an expression for a call to FN (a namespace-scope function,    or a static member function) with the ARGS.  */
end_comment

begin_function
name|tree
name|build_new_function_call
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|cand
operator|=
name|perform_overload_resolution
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
operator|&
name|candidates
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
block|{
if|if
condition|(
operator|!
name|any_viable_p
operator|&&
name|candidates
operator|&&
operator|!
name|candidates
operator|->
name|next
condition|)
return|return
name|build_function_call
argument_list|(
name|candidates
operator|->
name|fn
argument_list|,
name|args
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_viable_p
condition|)
name|error
argument_list|(
literal|"no matching function for call to `%D(%A)'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"call of overloaded `%D(%A)' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a global operator new.  FNNAME is the name of the    operator (either "operator new" or "operator new[]") and ARGS are    the arguments provided.  *SIZE points to the total number of bytes    required by the allocation, and is updated if that is changed here.    *COOKIE_SIZE is non-NULL if a cookie should be used.  If this    function determines that no cookie should be used, after all,    *COOKIE_SIZE is set to NULL_TREE.  */
end_comment

begin_function
name|tree
name|build_operator_new_call
parameter_list|(
name|tree
name|fnname
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
modifier|*
name|size
parameter_list|,
name|tree
modifier|*
name|cookie_size
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|candidates
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
operator|*
name|size
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|args
return|;
name|fns
operator|=
name|lookup_function_nonclass
argument_list|(
name|fnname
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Figure out what function is being called.  */
name|cand
operator|=
name|perform_overload_resolution
argument_list|(
name|fns
argument_list|,
name|args
argument_list|,
operator|&
name|candidates
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
comment|/* If no suitable function could be found, issue an error message      and give up.  */
if|if
condition|(
operator|!
name|cand
condition|)
block|{
if|if
condition|(
operator|!
name|any_viable_p
condition|)
name|error
argument_list|(
literal|"no matching function for call to `%D(%A)'"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"call of overloaded `%D(%A)' is ambiguous"
argument_list|,
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
condition|)
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If a cookie is required, add some extra space.  Whether       or not a cookie is required cannot be determined until       after we know which function was called.  */
if|if
condition|(
operator|*
name|cookie_size
condition|)
block|{
name|bool
name|use_cookie
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|tree
name|placement
init|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
decl_stmt|;
comment|/* In G++ 3.2, the check was implemented incorrectly; it 	      looked at the placement expression, rather than the 	      type of the function.  */
if|if
condition|(
name|placement
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|placement
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|placement
argument_list|)
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
name|use_cookie
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|tree
name|arg_types
decl_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the size_t parameter.  */
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
comment|/* Check the remaining parameters (if any).  */
if|if
condition|(
name|arg_types
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|==
name|void_list_node
operator|&&
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
name|use_cookie
operator|=
name|false
expr_stmt|;
block|}
comment|/* If we need a cookie, adjust the number of bytes allocated.  */
if|if
condition|(
name|use_cookie
condition|)
block|{
comment|/* Update the total size.  */
operator|*
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|cookie_size
argument_list|)
expr_stmt|;
comment|/* Update the argument list to reflect the adjusted size.  */
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|=
operator|*
name|size
expr_stmt|;
block|}
else|else
operator|*
name|cookie_size
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Build the CALL_EXPR.  */
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_object_call
parameter_list|(
name|tree
name|obj
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|convs
decl_stmt|,
name|mem_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* It's no good looking for an overloaded operator() on a 	 pointer-to-member-function.  */
name|error
argument_list|(
literal|"pointer-to-member function %E cannot be called without an object; consider using .* or ->*"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|ansi_opname
argument_list|(
name|CALL_EXPR
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fns
condition|)
block|{
name|tree
name|base
init|=
name|BINFO_TYPE
argument_list|(
name|BASELINK_BINFO
argument_list|(
name|fns
argument_list|)
argument_list|)
decl_stmt|;
name|mem_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|add_template_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|fn
argument_list|,
name|base
argument_list|,
name|NULL_TREE
argument_list|,
name|mem_args
argument_list|,
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
else|else
name|add_function_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|fn
argument_list|,
name|base
argument_list|,
name|mem_args
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
name|convs
operator|=
name|lookup_conversions
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|convs
condition|;
name|convs
operator|=
name|TREE_CHAIN
argument_list|(
name|convs
argument_list|)
control|)
block|{
name|tree
name|fns
init|=
name|TREE_VALUE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|add_template_conv_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
name|totype
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*conversion_path=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|add_conv_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|fn
argument_list|,
name|obj
argument_list|,
name|args
argument_list|,
comment|/*conversion_path=*/
name|NULL_TREE
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|,
name|pedantic
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_viable_p
condition|)
block|{
name|error
argument_list|(
literal|"no match for call to `(%T) (%A)'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"call of `(%T) (%A)' is ambiguous"
argument_list|,
name|TREE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Since cand->fn will be a type, not a function, for a conversion      function, we must be careful not to unconditionally look at      DECL_NAME here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
name|obj
operator|=
name|convert_like_with_context
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|obj
argument_list|,
name|cand
operator|->
name|fn
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME */
return|return
name|build_function_call
argument_list|(
name|obj
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|op_error
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|enum
name|tree_code
name|code2
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|tree
name|arg3
parameter_list|,
specifier|const
name|char
modifier|*
name|problem
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
name|opname
operator|=
name|assignment_operator_name_info
index|[
name|code2
index|]
operator|.
name|name
expr_stmt|;
else|else
name|opname
operator|=
name|operator_name_info
index|[
name|code
index|]
operator|.
name|name
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COND_EXPR
case|:
name|error
argument_list|(
literal|"%s for ternary 'operator?:' in '%E ? %E : %E'"
argument_list|,
name|problem
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|error
argument_list|(
literal|"%s for 'operator%s' in '%E%s'"
argument_list|,
name|problem
argument_list|,
name|opname
argument_list|,
name|arg1
argument_list|,
name|opname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|error
argument_list|(
literal|"%s for 'operator[]' in '%E[%E]'"
argument_list|,
name|problem
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|error
argument_list|(
literal|"%s for '%s' in '%s %E'"
argument_list|,
name|problem
argument_list|,
name|opname
argument_list|,
name|opname
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arg2
condition|)
name|error
argument_list|(
literal|"%s for 'operator%s' in '%E %s %E'"
argument_list|,
name|problem
argument_list|,
name|opname
argument_list|,
name|arg1
argument_list|,
name|opname
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s for 'operator%s' in '%s%E'"
argument_list|,
name|problem
argument_list|,
name|opname
argument_list|,
name|opname
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return the implicit conversion sequence that could be used to    convert E1 to E2 in [expr.cond].  */
end_comment

begin_function
specifier|static
name|tree
name|conditional_conversion
parameter_list|(
name|tree
name|e1
parameter_list|,
name|tree
name|e2
parameter_list|)
block|{
name|tree
name|t1
init|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|bool
name|good_base
decl_stmt|;
comment|/* [expr.cond]       If E2 is an lvalue: E1 can be converted to match E2 if E1 can be      implicitly converted (clause _conv_) to the type "reference to      T2", subject to the constraint that in the conversion the      reference must bind directly (_dcl.init.ref_) to E1.  */
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|e2
argument_list|)
condition|)
block|{
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|build_reference_type
argument_list|(
name|t2
argument_list|)
argument_list|,
name|t1
argument_list|,
name|e1
argument_list|,
name|LOOKUP_NO_TEMP_BIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
return|return
name|conv
return|;
block|}
comment|/* [expr.cond]       If E1 and E2 have class type, and the underlying class types are      the same or one is a base class of the other: E1 can be converted      to match E2 if the class of T2 is the same type as, or a base      class of, the class of T1, and the cv-qualification of T2 is the      same cv-qualification as, or a greater cv-qualification than, the      cv-qualification of T1.  If the conversion is applied, E1 is      changed to an rvalue of type T2 that still refers to the original      source class object (or the appropriate subobject thereof).  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
operator|(
name|good_base
operator|=
name|DERIVED_FROM_P
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
operator|)
operator|||
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|good_base
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
block|{
name|conv
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|t1
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|conv
operator|=
name|build_conv
argument_list|(
name|BASE_CONV
argument_list|,
name|t2
argument_list|,
name|conv
argument_list|)
expr_stmt|;
else|else
name|conv
operator|=
name|build_conv
argument_list|(
name|RVALUE_CONV
argument_list|,
name|t2
argument_list|,
name|conv
argument_list|)
expr_stmt|;
return|return
name|conv
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
else|else
comment|/* [expr.cond]         Otherwise: E1 can be converted to match E2 if E1 can be implicitly        converted to the type that expression E2 would have if E2 were        converted to an rvalue (or the type it has, if E2 is an rvalue).  */
return|return
name|implicit_conversion
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|,
name|e1
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three    arguments to the conditional expression.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|tree
name|arg3
parameter_list|)
block|{
name|tree
name|arg2_type
decl_stmt|;
name|tree
name|arg3_type
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|tree
name|result_type
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|lvalue_p
init|=
name|true
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|cand
decl_stmt|;
comment|/* As a G++ extension, the second argument to the conditional can be      omitted.  (So that `a ? : c' is roughly equivalent to `a ? a :      c'.)  If the second operand is omitted, make sure it is      calculated only once.  */
if|if
condition|(
operator|!
name|arg2
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
comment|/* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|arg1
argument_list|)
condition|)
name|arg2
operator|=
name|arg1
operator|=
name|stabilize_reference
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
else|else
name|arg2
operator|=
name|arg1
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]         The first expr ession is implicitly converted to bool (clause      _conv_).  */
name|arg1
operator|=
name|perform_implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
comment|/* If something has already gone wrong, just pass that fact up the      tree.  */
if|if
condition|(
name|error_operand_p
argument_list|(
name|arg1
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|arg2
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|arg3
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* [expr.cond]       If either the second or the third operand has type (possibly      cv-qualified) void, then the lvalue-to-rvalue (_conv.lval_),      array-to-pointer (_conv.array_), and function-to-pointer      (_conv.func_) standard conversions are performed on the second      and third operands.  */
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
block|{
comment|/* Do the conversions.  We don't these for `void' type arguments 	 since it can't have any effect and since decay_conversion 	 does not handle that case gracefully.  */
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|)
name|arg2
operator|=
name|decay_conversion
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
name|arg3
operator|=
name|decay_conversion
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
comment|/* [expr.cond]  	 One of the following shall hold:  	 --The second or the third operand (but not both) is a 	   throw-expression (_except.throw_); the result is of the 	   type of the other and is an rvalue.  	 --Both the second and the third operands have type void; the 	   result is of type void and is an rvalue.             We must avoid calling force_rvalue for expressions of type 	 "void" because it will complain that their value is being 	 used.   */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|THROW_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|!=
name|THROW_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
name|arg3
operator|=
name|force_rvalue
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|arg3_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|!=
name|THROW_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|THROW_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|)
name|arg2
operator|=
name|force_rvalue
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|arg2_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|VOID_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"`%E' has type `void' and is not a throw-expression"
argument_list|,
name|VOID_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|?
name|arg2
else|:
name|arg3
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|lvalue_p
operator|=
name|false
expr_stmt|;
goto|goto
name|valid_operands
goto|;
block|}
comment|/* [expr.cond]       Otherwise, if the second and third operand have different types,      and either has (possibly cv-qualified) class type, an attempt is      made to convert each of those operands to the type of the other.  */
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
operator|&&
operator|(
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|CLASS_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|conv2
init|=
name|conditional_conversion
argument_list|(
name|arg2
argument_list|,
name|arg3
argument_list|)
decl_stmt|;
name|tree
name|conv3
init|=
name|conditional_conversion
argument_list|(
name|arg3
argument_list|,
name|arg2
argument_list|)
decl_stmt|;
comment|/* [expr.cond]  	 If both can be converted, or one can be converted but the 	 conversion is ambiguous, the program is ill-formed.  If 	 neither can be converted, the operands are left unchanged and 	 further checking is performed as described below.  If exactly 	 one conversion is possible, that conversion is applied to the 	 chosen operand and the converted operand is used in place of 	 the original operand for the remainder of this section.  */
if|if
condition|(
operator|(
name|conv2
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv2
argument_list|)
operator|&&
name|conv3
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv3
argument_list|)
operator|)
operator|||
operator|(
name|conv2
operator|&&
name|TREE_CODE
argument_list|(
name|conv2
argument_list|)
operator|==
name|AMBIG_CONV
operator|)
operator|||
operator|(
name|conv3
operator|&&
name|TREE_CODE
argument_list|(
name|conv3
argument_list|)
operator|==
name|AMBIG_CONV
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"operands to ?: have different types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|conv2
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv2
argument_list|)
condition|)
block|{
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv2
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conv3
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|conv3
argument_list|)
condition|)
block|{
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv3
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_from_reference
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
block|}
comment|/* If, after the conversion, both operands have class type, 	 treat the cv-qualification of both operands as if it were the 	 union of the cv-qualification of the operands.    	 The standard is not clear about what to do in this 	 circumstance.  For example, if the first operand has type 	 "const X" and the second operand has a user-defined 	 conversion to "volatile X", what is the type of the second 	 operand after this step?  Making it be "const X" (matching 	 the first operand) seems wrong, as that discards the 	 qualification without actuall performing a copy.  Leaving it 	 as "volatile X" seems wrong as that will result in the 	 conditional expression failing altogether, even though, 	 according to this step, the one operand could be converted to 	 the type of the other.  */
if|if
condition|(
operator|(
name|conv2
operator|||
name|conv3
operator|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_QUALS
argument_list|(
name|arg2_type
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|arg3_type
argument_list|)
condition|)
name|arg2_type
operator|=
name|arg3_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|arg2_type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|arg2_type
argument_list|)
operator||
name|TYPE_QUALS
argument_list|(
name|arg3_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]       If the second and third operands are lvalues and have the same      type, the result is of that type and is an lvalue.  */
if|if
condition|(
name|real_lvalue_p
argument_list|(
name|arg2
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|arg3
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|arg2_type
expr_stmt|;
goto|goto
name|valid_operands
goto|;
block|}
comment|/* [expr.cond]       Otherwise, the result is an rvalue.  If the second and third      operand do not have the same type, and either has (possibly      cv-qualified) class type, overload resolution is used to      determine the conversions (if any) to be applied to the operands      (_over.match.oper_, _over.built_).  */
name|lvalue_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
operator|&&
operator|(
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|CLASS_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
condition|)
block|{
name|tree
name|args
index|[
literal|3
index|]
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
comment|/* Rearrange the arguments so that add_builtin_candidate only has 	 to know about two args.  In build_builtin_candidates, the 	 arguments are unscrambled.  */
name|args
index|[
literal|0
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
name|add_builtin_candidates
argument_list|(
operator|&
name|candidates
argument_list|,
name|COND_EXPR
argument_list|,
name|NOP_EXPR
argument_list|,
name|ansi_opname
argument_list|(
name|COND_EXPR
argument_list|)
argument_list|,
name|args
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* [expr.cond]  	 If the overload resolution fails, the program is 	 ill-formed.  */
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|,
name|pedantic
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_viable_p
condition|)
block|{
name|op_error
argument_list|(
name|COND_EXPR
argument_list|,
name|NOP_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
block|{
name|op_error
argument_list|(
name|COND_EXPR
argument_list|,
name|NOP_EXPR
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [expr.cond]  	 Otherwise, the conversions thus determined are applied, and 	 the converted operands are used in place of the original 	 operands for the remainder of this section.  */
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]       Lvalue-to-rvalue (_conv.lval_), array-to-pointer (_conv.array_),      and function-to-pointer (_conv.func_) standard conversions are      performed on the second and third operands.       We need to force the lvalue-to-rvalue conversion here for class types,      so we get TARGET_EXPRs; trying to deal with a COND_EXPR of class rvalues      that isn't wrapped with a TARGET_EXPR plays havoc with exception      regions.  */
name|arg2
operator|=
name|force_rvalue
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|)
name|arg2_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|force_rvalue
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
condition|)
name|arg3_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
operator|==
name|error_mark_node
operator|||
name|arg3
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* [expr.cond]            After those conversions, one of the following shall hold:       --The second and third operands have the same type; the result  is  of        that type.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
condition|)
name|result_type
operator|=
name|arg2_type
expr_stmt|;
comment|/* [expr.cond]       --The second and third operands have arithmetic or enumeration        type; the usual arithmetic conversions are performed to bring        them to a common type, and the result is of that type.  */
elseif|else
if|if
condition|(
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg2_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|arg3_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg3_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
comment|/* In this case, there is always a common type.  */
name|result_type
operator|=
name|type_after_usual_arithmetic_conversions
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg3_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|warning
argument_list|(
literal|"enumeral mismatch in conditional expression: `%T' vs `%T'"
argument_list|,
name|arg2_type
argument_list|,
name|arg3_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg2_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|same_type_p
argument_list|(
name|arg3_type
argument_list|,
name|type_promotes_to
argument_list|(
name|arg2_type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg3_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|same_type_p
argument_list|(
name|arg2_type
argument_list|,
name|type_promotes_to
argument_list|(
name|arg3_type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.cond]       --The second and third operands have pointer type, or one has        pointer type and the other is a null pointer constant; pointer        conversions (_conv.ptr_) and qualification conversions        (_conv.qual_) are performed to bring them to their composite        pointer type (_expr.rel_).  The result is of the composite        pointer type.       --The second and third operands have pointer to member type, or        one has pointer to member type and the other is a null pointer        constant; pointer to member conversions (_conv.mem_) and        qualification conversions (_conv.qual_) are performed to bring        them to a common type, whose cv-qualification shall match the        cv-qualification of either the second or the third operand.        The result is of the common type.  */
elseif|else
if|if
condition|(
operator|(
name|null_ptr_cst_p
argument_list|(
name|arg2
argument_list|)
operator|&&
operator|(
name|TYPE_PTR_P
argument_list|(
name|arg3_type
argument_list|)
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|null_ptr_cst_p
argument_list|(
name|arg3
argument_list|)
operator|&&
operator|(
name|TYPE_PTR_P
argument_list|(
name|arg2_type
argument_list|)
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|arg2_type
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TYPE_PTR_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg2_type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg3_type
argument_list|)
operator|)
condition|)
block|{
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|arg2_type
argument_list|,
name|arg3_type
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"conditional expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|arg2
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|perform_implicit_conversion
argument_list|(
name|result_type
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|error
argument_list|(
literal|"operands to ?: have different types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|valid_operands
label|:
name|result
operator|=
name|fold_if_not_in_template
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't use result_type below, as fold might have returned a      throw_expr.  */
comment|/* Expand both sides into the same slot, hopefully the target of the      ?: expression.  We used to check for TARGET_EXPRs here, but now we      sometimes wrap them in NOP_EXPRs so the test would fail.  */
if|if
condition|(
operator|!
name|lvalue_p
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|get_target_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* If this expression is an rvalue, but might be mistaken for an      lvalue, we must add a NON_LVALUE_EXPR.  */
if|if
condition|(
operator|!
name|lvalue_p
operator|&&
name|real_lvalue_p
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* OPERAND is an operand to an expression.  Perform necessary steps    required before using it.  If OPERAND is NULL_TREE, NULL_TREE is    returned.  */
end_comment

begin_function
specifier|static
name|tree
name|prep_operand
parameter_list|(
name|tree
name|operand
parameter_list|)
block|{
if|if
condition|(
name|operand
condition|)
block|{
name|operand
operator|=
name|convert_from_reference
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
condition|)
comment|/* Make sure the template type is instantiated now.  */
name|instantiate_class_template
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|operand
return|;
block|}
end_function

begin_comment
comment|/* Add each of the viable functions in FNS (a FUNCTION_DECL or    OVERLOAD) to the CANDIDATES, returning an updated list of    CANDIDATES.  The ARGS are the arguments provided to the call,    without any implicit object parameter.  The EXPLICIT_TARGS are    explicit template arguments provided.  TEMPLATE_ONLY is true if    only template functions should be considered.  CONVERSION_PATH,    ACCESS_PATH, and FLAGS are as for add_function_candidate.  */
end_comment

begin_function
specifier|static
name|void
name|add_candidates
parameter_list|(
name|tree
name|fns
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|explicit_targs
parameter_list|,
name|bool
name|template_only
parameter_list|,
name|tree
name|conversion_path
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|z_candidate
modifier|*
modifier|*
name|candidates
parameter_list|)
block|{
name|tree
name|ctype
decl_stmt|;
name|tree
name|non_static_args
decl_stmt|;
name|ctype
operator|=
name|conversion_path
condition|?
name|BINFO_TYPE
argument_list|(
name|conversion_path
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
comment|/* Delay creating the implicit this parameter until it is needed.  */
name|non_static_args
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|fns
condition|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|fn_args
decl_stmt|;
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* Figure out which set of arguments to use.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If this function is a non-static member, prepend the implicit 	     object parameter.  */
if|if
condition|(
operator|!
name|non_static_args
condition|)
name|non_static_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_this
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|fn_args
operator|=
name|non_static_args
expr_stmt|;
block|}
else|else
comment|/* Otherwise, just use the list of arguments provided.  */
name|fn_args
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|add_template_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|ctype
argument_list|,
name|explicit_targs
argument_list|,
name|fn_args
argument_list|,
name|NULL_TREE
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|template_only
condition|)
name|add_function_candidate
argument_list|(
name|candidates
argument_list|,
name|fn
argument_list|,
name|ctype
argument_list|,
name|fn_args
argument_list|,
name|access_path
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|build_new_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|tree
name|arg3
parameter_list|,
name|bool
modifier|*
name|overloaded_p
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|arglist
decl_stmt|,
name|fnname
decl_stmt|;
name|tree
name|args
index|[
literal|3
index|]
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|NOP_EXPR
decl_stmt|;
name|tree
name|conv
decl_stmt|;
name|bool
name|strict_p
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|arg1
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|arg2
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|arg3
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|NULL_TREE
expr_stmt|;
name|fnname
operator|=
name|ansi_assopname
argument_list|(
name|code2
argument_list|)
expr_stmt|;
block|}
else|else
name|fnname
operator|=
name|ansi_opname
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|prep_operand
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
case|case
name|VEC_NEW_EXPR
case|:
case|case
name|VEC_DELETE_EXPR
case|:
case|case
name|DELETE_EXPR
case|:
comment|/* Use build_op_new_call and build_op_delete_call instead.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|CALL_EXPR
case|:
return|return
name|build_object_call
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
default|default:
break|break;
block|}
name|arg2
operator|=
name|prep_operand
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|prep_operand
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|arg2
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg3
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|builtin
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|arg2
operator|||
operator|!
name|IS_OVERLOAD_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|builtin
goto|;
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
condition|)
name|arg2
operator|=
name|integer_zero_node
expr_stmt|;
name|arglist
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg2
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Add namespace-scope operators to the list of functions to      consider.  */
name|add_candidates
argument_list|(
name|lookup_function_nonclass
argument_list|(
name|fnname
argument_list|,
name|arglist
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|,
operator|&
name|candidates
argument_list|)
expr_stmt|;
comment|/* Add class-member operators to the candidate set.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fns
decl_stmt|;
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|fns
return|;
if|if
condition|(
name|fns
condition|)
name|add_candidates
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|,
name|BASELINK_BINFO
argument_list|(
name|fns
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|candidates
argument_list|)
expr_stmt|;
block|}
comment|/* Rearrange the arguments for ?: so that add_builtin_candidate only has      to know about two args; a builtin candidate will always have a first      parameter of type bool.  We'll handle that in      build_builtin_candidate.  */
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|add_builtin_candidates
argument_list|(
operator|&
name|candidates
argument_list|,
name|code
argument_list|,
name|code2
argument_list|,
name|fnname
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
comment|/* For these, the built-in candidates set is empty 	 [over.match.oper]/3.  We don't want non-strict matches 	 because exact matches are always possible with built-in 	 operators.  The built-in candidate set for COMPONENT_REF 	 would be empty too, but since there are no such built-in 	 operators, we accept non-strict matches for them.  */
name|strict_p
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|strict_p
operator|=
name|pedantic
expr_stmt|;
break|break;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|,
name|strict_p
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_viable_p
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Look for an `operator++ (int)'.  If they didn't have 	     one, then we fall back to the old way of doing things.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|pedwarn
argument_list|(
literal|"no `%D(int)' declared for postfix `%s', trying prefix operator instead"
argument_list|,
name|fnname
argument_list|,
name|operator_name_info
index|[
name|code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|code
operator|=
name|PREINCREMENT_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|PREDECREMENT_EXPR
expr_stmt|;
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|flags
argument_list|,
name|arg1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|overloaded_p
argument_list|)
return|;
comment|/* The caller will deal with these.  */
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
return|return
name|NULL_TREE
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|op_error
argument_list|(
name|code
argument_list|,
name|code2
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|op_error
argument_list|(
name|code
argument_list|,
name|code2
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
literal|"ambiguous overload"
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|overloaded_p
condition|)
operator|*
name|overloaded_p
operator|=
name|true
expr_stmt|;
return|return
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* Check for comparison of different enum types.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison between `%#T' and `%#T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* We need to strip any leading REF_BIND so that bitfields don't cause      errors.  This should not remove any important conversions, because      builtins don't apply to class objects directly.  */
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
block|{
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg3
condition|)
block|{
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|cand
operator|->
name|convs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
condition|)
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg3
operator|=
name|convert_like
argument_list|(
name|conv
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
name|builtin
label|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
return|return
name|build_modify_expr
argument_list|(
name|arg1
argument_list|,
name|code2
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
literal|"unary *"
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|cp_build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|candidates
operator|!=
literal|0
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
return|return
name|build_array_ref
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
return|;
case|case
name|MEMBER_REF
case|:
return|return
name|build_m_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|arg1
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|arg2
argument_list|)
return|;
comment|/* The caller will deal with these.  */
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
return|return
name|NULL_TREE
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build a call to operator delete.  This has to be handled very specially,    because the restrictions on what signatures match are different from all    other call instances.  For a normal delete, only a delete taking (void *)    or (void *, size_t) is accepted.  For a placement delete, only an exact    match with the placement new is accepted.     CODE is either DELETE_EXPR or VEC_DELETE_EXPR.    ADDR is the pointer to be deleted.    SIZE is the size of the memory block to be deleted.    FLAGS are the usual overloading flags.    PLACEMENT is the corresponding placement new call, or NULL_TREE.  */
end_comment

begin_function
name|tree
name|build_op_delete_call
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|addr
parameter_list|,
name|tree
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|tree
name|placement
parameter_list|)
block|{
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fns
decl_stmt|,
name|fnname
decl_stmt|,
name|argtypes
decl_stmt|,
name|args
decl_stmt|,
name|type
decl_stmt|;
name|int
name|pass
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|ansi_opname
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
condition|)
comment|/* In [class.free]         If the result of the lookup is ambiguous or inaccessible, or if        the lookup selects a placement deallocation function, the        program is ill-formed.           Therefore, we ask lookup_fnfields to complain about ambiguity.  */
block|{
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
else|else
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
name|fns
operator|=
name|lookup_name_nonclass
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|placement
condition|)
block|{
name|tree
name|alloc_fn
decl_stmt|;
name|tree
name|call_expr
decl_stmt|;
comment|/* Find the allocation function that is being called.  */
name|call_expr
operator|=
name|placement
expr_stmt|;
comment|/* Extract the function.  */
name|alloc_fn
operator|=
name|get_callee_fndecl
argument_list|(
name|call_expr
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|alloc_fn
operator|!=
name|NULL_TREE
argument_list|,
literal|20020327
argument_list|)
expr_stmt|;
comment|/* Then the second parm type.  */
name|argtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|alloc_fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also the second argument.  */
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First try it without the size argument.  */
name|argtypes
operator|=
name|void_list_node
expr_stmt|;
name|args
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Strip const and volatile from addr.  */
name|addr
operator|=
name|cp_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* We make two tries at finding a matching `operator delete'.  On      the first pass, we look for a one-operator (or placement)      operator delete.  If we're not doing placement delete, then on      the second pass we look for a two-argument delete.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
operator|(
name|placement
condition|?
literal|1
else|:
literal|2
operator|)
condition|;
operator|++
name|pass
control|)
block|{
comment|/* Go through the `operator delete' functions looking for one 	 with a matching type.  */
for|for
control|(
name|fn
operator|=
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|?
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
else|:
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* The first argument must be "void *".  */
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
continue|continue;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* On the first pass, check the rest of the arguments.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|tree
name|a
init|=
name|argtypes
decl_stmt|;
while|while
condition|(
name|a
operator|&&
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
break|break;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|a
operator|&&
operator|!
name|t
condition|)
break|break;
block|}
comment|/* On the second pass, the second argument must be 	     "size_t".  */
elseif|else
if|if
condition|(
name|pass
operator|==
literal|1
operator|&&
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|sizetype
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|void_list_node
condition|)
break|break;
block|}
comment|/* If we found a match, we're done.  */
if|if
condition|(
name|fn
condition|)
break|break;
block|}
comment|/* If we have a matching function, call it.  */
if|if
condition|(
name|fn
condition|)
block|{
comment|/* Make sure we have the actual function, and not an 	 OVERLOAD.  */
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If the FN is a member function, make sure that it is 	 accessible.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|placement
condition|)
block|{
comment|/* The placement args might not be suitable for overload 	     resolution at this point, so build the call directly.  */
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_cxx_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|args
argument_list|)
return|;
block|}
else|else
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/* If we are doing placement delete we do nothing if we don't find a      matching op delete.  */
if|if
condition|(
name|placement
condition|)
return|return
name|NULL_TREE
return|;
name|error
argument_list|(
literal|"no suitable `operator %s' for `%T'"
argument_list|,
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* If the current scope isn't allowed to access DECL along    BASETYPE_PATH, give an error.  The most derived class in    BASETYPE_PATH is the one used to qualify DECL.  */
end_comment

begin_function
name|bool
name|enforce_access
parameter_list|(
name|tree
name|basetype_path
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|basetype_path
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|20030624
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|accessible_p
argument_list|(
name|basetype_path
argument_list|,
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%+#D' is private"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"`%+#D' is protected"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"`%+#D' is inaccessible"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check that a callable constructor to initialize a temporary of    TYPE from an EXPR exists.  */
end_comment

begin_function
specifier|static
name|void
name|check_constructor_callable
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
operator||
name|LOOKUP_NO_CONVERSION
operator||
name|LOOKUP_CONSTRUCTOR_CALLABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a temporary of type TYPE with EXPR.  The FLAGS are a    bitwise or of LOOKUP_* values.  If any errors are warnings are    generated, set *DIAGNOSTIC_FN to "error" or "warning",    respectively.  If no diagnostics are generated, set *DIAGNOSTIC_FN    to NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|build_temp
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
modifier|*
name|diagnostic_fn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|int
name|savew
decl_stmt|,
name|savee
decl_stmt|;
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|expr
operator|=
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
operator|*
name|diagnostic_fn
operator|=
name|warning
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
operator|*
name|diagnostic_fn
operator|=
name|error
expr_stmt|;
else|else
operator|*
name|diagnostic_fn
operator|=
name|NULL
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Perform the conversions in CONVS on the expression EXPR.  FN and    ARGNUM are used for diagnostics.  ARGNUM is zero based, -1    indicates the `this' argument of a method.  INNER is nonzero when    being called to continue a conversion chain. It is negative when a    reference binding will be applied, positive otherwise.  If    ISSUE_CONVERSION_WARNINGS is true, warnings about suspicious    conversions will be emitted if appropriate.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_like_real
parameter_list|(
name|tree
name|convs
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|fn
parameter_list|,
name|int
name|argnum
parameter_list|,
name|int
name|inner
parameter_list|,
name|bool
name|issue_conversion_warnings
parameter_list|)
block|{
name|tree
name|totype
init|=
name|TREE_TYPE
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|diagnostic_fn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|convs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|USER_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|AMBIG_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|!=
name|REF_BIND
condition|)
block|{
name|tree
name|t
init|=
name|convs
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
operator|||
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expr
operator|=
name|convert_like_real
argument_list|(
name|t
argument_list|,
name|expr
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|,
literal|1
argument_list|,
comment|/*issue_conversion_warnings=*/
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
name|convert_like_real
argument_list|(
name|t
argument_list|,
name|expr
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|,
literal|1
argument_list|,
comment|/*issue_conversion_warnings=*/
name|false
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
break|break;
block|}
name|pedwarn
argument_list|(
literal|"invalid conversion from `%T' to `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|totype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|pedwarn
argument_list|(
literal|"  initializing argument %P of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
name|issue_conversion_warnings
condition|)
name|expr
operator|=
name|dubious_conversion_warnings
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
literal|"converting"
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
condition|)
block|{
case|case
name|USER_CONV
case|:
block|{
name|struct
name|z_candidate
modifier|*
name|cand
init|=
name|USER_CONV_CAND
argument_list|(
name|convs
argument_list|)
decl_stmt|;
name|tree
name|convfn
init|=
name|cand
operator|->
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|convfn
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|convfn
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|convfn
argument_list|)
operator|||
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|convfn
argument_list|)
condition|)
comment|/* We should never try to call the abstract or base constructor 		 from here.  */
name|abort
argument_list|()
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|build_this
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* If this is a constructor or a function returning an aggr type, 	   we need to build up a TARGET_EXPR.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|convfn
argument_list|)
condition|)
name|expr
operator|=
name|build_cplus_new
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* The result of the call is then used to direct-initialize the object 	   that is the destination of the copy-initialization.  [dcl.init]  	   Note that this step is not reflected in the conversion sequence; 	   it affects the semantics when we actually perform the 	   conversion, but is not considered during overload resolution.  	   If the target is a class, that means call a ctor.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
operator|&&
operator|(
name|inner
operator|>=
literal|0
operator|||
operator|!
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
block|{
name|expr
operator|=
operator|(
name|build_temp
argument_list|(
name|expr
argument_list|,
name|totype
argument_list|,
comment|/* Core issue 84, now a DR, says that we don't 			allow UDCs for these args (which deliberately 			breaks copy-init of an auto_ptr<Base> from an 			auto_ptr<Derived>).  */
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
operator||
name|LOOKUP_NO_CONVERSION
argument_list|,
operator|&
name|diagnostic_fn
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|diagnostic_fn
condition|)
block|{
if|if
condition|(
name|fn
condition|)
name|diagnostic_fn
argument_list|(
literal|"  initializing argument %P of `%D' from result of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|,
name|convfn
argument_list|)
expr_stmt|;
else|else
name|diagnostic_fn
argument_list|(
literal|"  initializing temporary from result of `%D'"
argument_list|,
name|convfn
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_cplus_new
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
case|case
name|IDENTITY_CONV
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|instantiate_type
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|tf_error
operator||
name|tf_warning
argument_list|)
expr_stmt|;
comment|/* Convert a non-array constant variable to its underlying 	 value, unless we are about to bind it to a reference, in 	 which case we need to leave it as an lvalue.  */
if|if
condition|(
name|inner
operator|>=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_COPY_CONSTRUCTOR_P
argument_list|(
name|convs
argument_list|)
condition|)
name|check_constructor_callable
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
case|case
name|AMBIG_CONV
case|:
comment|/* Call build_user_type_conversion again for the error.  */
return|return
name|build_user_type_conversion
argument_list|(
name|totype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
default|default:
break|break;
block|}
empty_stmt|;
name|expr
operator|=
name|convert_like_real
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|,
name|fn
argument_list|,
name|argnum
argument_list|,
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|==
name|REF_BIND
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|,
comment|/*issue_conversion_warnings=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
condition|)
block|{
case|case
name|RVALUE_CONV
case|:
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|totype
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* Else fall through.  */
case|case
name|BASE_CONV
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|convs
argument_list|)
operator|==
name|BASE_CONV
operator|&&
operator|!
name|NEED_TEMPORARY_P
argument_list|(
name|convs
argument_list|)
condition|)
block|{
comment|/* We are going to bind a reference directly to a base-class 	     subobject of EXPR.  */
if|if
condition|(
name|CHECK_COPY_CONSTRUCTOR_P
argument_list|(
name|convs
argument_list|)
condition|)
name|check_constructor_callable
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Build an expression for `*((base*)&expr)'.  */
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|perform_implicit_conversion
argument_list|(
name|build_pointer_type
argument_list|(
name|totype
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|"implicit conversion"
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/* Copy-initialization where the cv-unqualified version of the source 	 type is the same class as, or a derived class of, the class of the 	 destination [is treated as direct-initialization].  [dcl.init] */
name|expr
operator|=
name|build_temp
argument_list|(
name|expr
argument_list|,
name|totype
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|,
operator|&
name|diagnostic_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnostic_fn
operator|&&
name|fn
condition|)
name|diagnostic_fn
argument_list|(
literal|"  initializing argument %P of `%D'"
argument_list|,
name|argnum
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_cplus_new
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|REF_BIND
case|:
block|{
name|tree
name|ref_type
init|=
name|totype
decl_stmt|;
comment|/* If necessary, create a temporary.  */
if|if
condition|(
name|NEED_TEMPORARY_P
argument_list|(
name|convs
argument_list|)
operator|||
operator|!
name|lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|cp_lvalue_kind
name|lvalue
init|=
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref_type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If the reference is volatile or non-const, we 		   cannot create a temporary.  */
if|if
condition|(
name|lvalue
operator|&
name|clk_bitfield
condition|)
name|error
argument_list|(
literal|"cannot bind bitfield `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|ref_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lvalue
operator|&
name|clk_packed
condition|)
name|error
argument_list|(
literal|"cannot bind packed field `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|ref_type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot bind rvalue `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|ref_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the source is a packed field, and we must use a copy 	       constructor, then building the target expr will require 	       binding the field to the reference parameter to the 	       copy constructor, and we'll end up with an infinite 	       loop.  If we can use a bitwise copy, then we'll be 	       OK.  */
if|if
condition|(
operator|(
name|lvalue
operator|&
name|clk_packed
operator|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot bind packed field `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|ref_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|expr
operator|=
name|build_target_expr_with_type
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Take the address of the thing to which we will bind the 	   reference.  */
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Convert it to a pointer to the type referred to by the 	   reference.  This will adjust the pointer if a derived to 	   base conversion is being performed.  */
name|expr
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref_type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Convert the pointer to the desired reference type.  */
return|return
name|build_nop
argument_list|(
name|ref_type
argument_list|,
name|expr
argument_list|)
return|;
block|}
case|case
name|LVALUE_CONV
case|:
return|return
name|decay_conversion
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|QUAL_CONV
case|:
comment|/* Warn about deprecated conversion if appropriate.  */
name|string_conv_p
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ocp_convert
argument_list|(
name|totype
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a call to __builtin_trap.  */
end_comment

begin_function
specifier|static
name|tree
name|call_builtin_trap
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fn
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
literal|"__builtin_trap"
argument_list|)
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|fn
operator|!=
name|NULL
argument_list|,
literal|20030927
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* ARG is being passed to a varargs function.  Perform any conversions    required.  Return the converted value.  */
end_comment

begin_function
name|tree
name|convert_arg_to_ellipsis
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
comment|/* [expr.call]       The lvalue-to-rvalue, array-to-pointer, and function-to-pointer      standard conversions are performed.  */
name|arg
operator|=
name|decay_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* [expr.call]       If the argument has integral or enumeration type that is subject      to the integral promotions (_conv.prom_), or a floating point      type that is subject to the floating point promotion      (_conv.fpprom_), the value of the argument is converted to the      promoted type before the call.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|convert_to_real
argument_list|(
name|double_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|arg
operator|=
name|perform_integral_promotions
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|require_complete_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|error_mark_node
operator|&&
operator|!
name|pod_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Undefined behavior [expr.call] 5.2.2/7.  We used to just warn 	 here and do a bitwise copy, but now cp_expr_size will abort if we 	 try to do that.  	 If the call appears in the context of a sizeof expression,  	 there is no need to emit a warning, since the expression won't be  	 evaluated. We keep the builtin_trap just as a safety check.  */
if|if
condition|(
operator|!
name|skip_evaluation
condition|)
name|warning
argument_list|(
literal|"cannot pass objects of non-POD type `%#T' through `...'; "
literal|"call will abort at runtime"
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|call_builtin_trap
argument_list|()
expr_stmt|;
name|arg
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* va_arg (EXPR, TYPE) is a builtin. Make sure it is not abused.  */
end_comment

begin_function
name|tree
name|build_x_va_arg
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|VA_ARG_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|||
operator|!
name|type
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|pod_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Undefined behavior [expr.call] 5.2.2/7.  */
name|warning
argument_list|(
literal|"cannot receive objects of non-POD type `%#T' through `...'; \ call will abort at runtime"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|null_node
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|call_builtin_trap
argument_list|()
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
return|return
name|build_va_arg
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* TYPE has been given to va_arg.  Apply the default conversions which    would have happened when passed via ellipsis.  Return the promoted    type, or the passed type if there is no change.  */
end_comment

begin_function
name|tree
name|cxx_type_promotes_to
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|promote
decl_stmt|;
comment|/* Perform the array-to-pointer and function-to-pointer      conversions.  */
name|type
operator|=
name|type_decays_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|promote
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|promote
argument_list|)
condition|)
name|promote
operator|=
name|type
expr_stmt|;
return|return
name|promote
return|;
block|}
end_function

begin_comment
comment|/* ARG is a default argument expression being passed to a parameter of    the indicated TYPE, which is a parameter to FN.  Do any required    conversions.  Return the converted value.  */
end_comment

begin_function
name|tree
name|convert_default_arg
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arg
parameter_list|,
name|tree
name|fn
parameter_list|,
name|int
name|parmnum
parameter_list|)
block|{
comment|/* If the ARG is an unparsed default argument expression, the      conversion cannot be performed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|error
argument_list|(
literal|"the default argument for parameter %d of `%D' has "
literal|"not yet been parsed"
argument_list|,
name|parmnum
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|fn
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
name|arg
operator|=
name|tsubst_default_argument
argument_list|(
name|fn
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|break_out_target_exprs
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|arg
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"default argument"
argument_list|,
name|fn
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This could get clobbered by the following call.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|arg
argument_list|)
condition|)
name|arg
operator|=
name|copy_node
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"default argument"
argument_list|,
name|fn
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
name|arg
operator|=
name|convert_for_arg_passing
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Returns the type which will really be used for passing an argument of    type TYPE.  */
end_comment

begin_function
name|tree
name|type_passed_as
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Pass classes with copy ctors by invisible reference.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INT_CST_LT_UNSIGNED
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Actually perform the appropriate conversion.  */
end_comment

begin_function
name|tree
name|convert_for_arg_passing
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* Pass classes with copy ctors by invisible reference.  */
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|val
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INT_CST_LT_UNSIGNED
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|perform_integral_promotions
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff FN is a function with magic varargs, i.e. ones for    which no conversions at all should be done.  This is true for some    builtins which don't act like normal functions.  */
end_comment

begin_function
specifier|static
name|bool
name|magic_varargs_p
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|fn
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|fn
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_CLASSIFY_TYPE
case|:
case|case
name|BUILT_IN_CONSTANT_P
case|:
case|case
name|BUILT_IN_NEXT_ARG
case|:
case|case
name|BUILT_IN_STDARG_START
case|:
case|case
name|BUILT_IN_VA_START
case|:
return|return
name|true
return|;
default|default:
empty_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of the various build_*_call functions.  Overload resolution    has chosen a winning candidate CAND; build up a CALL_EXPR accordingly.    ARGS is a TREE_LIST of the unconverted arguments to the call.  FLAGS is a    bitmask of various LOOKUP_* flags which apply to the call itself.  */
end_comment

begin_function
specifier|static
name|tree
name|build_over_call
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|cand
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|fn
init|=
name|cand
operator|->
name|fn
decl_stmt|;
name|tree
name|args
init|=
name|cand
operator|->
name|args
decl_stmt|;
name|tree
name|convs
init|=
name|cand
operator|->
name|convs
decl_stmt|;
name|tree
name|converted_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parm
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|conv
decl_stmt|,
name|arg
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|is_method
init|=
literal|0
decl_stmt|;
comment|/* In a template, there is no need to perform all of the work that      is normally done.  We are only interested in the type of the call      expression, i.e., the return type of the function.  Any semantic      errors will be deferred until the template is instantiated.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|return_type
decl_stmt|;
name|return_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|return_type
argument_list|,
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fn
argument_list|)
operator|&&
name|cfun
condition|)
name|current_function_returns_abnormally
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|return_type
argument_list|)
condition|)
name|require_complete_type
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
comment|/* Give any warnings we noticed during overload resolution.  */
if|if
condition|(
name|cand
operator|->
name|warnings
condition|)
for|for
control|(
name|val
operator|=
name|cand
operator|->
name|warnings
init|;
name|val
condition|;
name|val
operator|=
name|TREE_CHAIN
argument_list|(
name|val
argument_list|)
control|)
name|joust
argument_list|(
name|cand
argument_list|,
name|WRAPPER_ZC
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If FN is a template function, two cases must be considered. 	 For example:  	   struct A { 	     protected: 	       template<class T> void f(); 	   }; 	   template<class T> struct B { 	     protected: 	       void g(); 	   }; 	   struct C : A, B<int> { 	     using A::f;	// #1 	     using B<int>::g;	// #2 	   };  	 In case #1 where `A::f' is a member template, DECL_ACCESS is 	 recorded in the primary template but not in its specialization. 	 We check access of FN using its primary template.  	 In case #2, where `B<int>::g' has a DECL_TEMPLATE_INFO simply 	 because it is a member of class template B, DECL_ACCESS is 	 recorded in the specialization `B<int>::g'.  We cannot use its 	 primary template because `B<T>::g' and `B<int>::g' may have 	 different access.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
operator|&&
name|is_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|cand
operator|->
name|access_path
argument_list|,
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|perform_or_defer_access_check
argument_list|(
name|cand
operator|->
name|access_path
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|&&
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|args
expr_stmt|;
comment|/* The implicit parameters to a constructor are not considered by overload      resolution, and must be of the proper type.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* We should never try to call the abstract constructor.  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bypass access control for 'this' parameter.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|converted_arg
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
if|if
condition|(
name|ICS_BAD_FLAG
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"passing `%T' as `this' argument of `%#D' discards qualifiers"
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* [class.mfct.nonstatic]: If a nonstatic member function of a class 	 X is called for an object that is not of type X, or of a type 	 derived from X, the behavior is undefined.           So we can assume that anything passed as 'this' is non-null, and 	 optimize accordingly.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|,
literal|19990811
argument_list|)
expr_stmt|;
comment|/* Convert to the base in which the function was declared.  */
name|my_friendly_assert
argument_list|(
name|cand
operator|->
name|conversion_path
operator|!=
name|NULL_TREE
argument_list|,
literal|20020730
argument_list|)
expr_stmt|;
name|converted_arg
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|cand
operator|->
name|conversion_path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check that the base class is accessible.  */
if|if
condition|(
operator|!
name|accessible_base_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|cand
operator|->
name|conversion_path
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%T' is not an accessible base of `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|cand
operator|->
name|conversion_path
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If fn was found by a using declaration, the conversion path          will be to the derived class, not the base declaring fn. We          must convert from derived to base.  */
name|base_binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|converted_arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|ba_ignore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|converted_arg
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|converted_arg
argument_list|,
name|base_binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|converted_arg
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|is_method
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|arg
operator|&&
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|conv
operator|=
name|TREE_VEC_ELT
argument_list|(
name|convs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_like_with_context
argument_list|(
name|conv
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|fn
argument_list|,
name|i
operator|-
name|is_method
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_for_arg_passing
argument_list|(
name|type
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
block|}
comment|/* Default arguments */
for|for
control|(
init|;
name|parm
operator|&&
name|parm
operator|!=
name|void_list_node
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|i
operator|++
control|)
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|i
operator|-
name|is_method
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* Ellipsis */
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic_varargs_p
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Do no conversions for magic varargs.  */
empty_stmt|;
else|else
name|a
operator|=
name|convert_arg_to_ellipsis
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|converted_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|a
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
block|}
name|converted_args
operator|=
name|nreverse
argument_list|(
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format
condition|)
name|check_function_format
argument_list|(
name|NULL
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* Avoid actually calling copy constructors and copy assignment operators,      if possible.  */
if|if
condition|(
operator|!
name|flag_elide_constructors
condition|)
comment|/* Do things the hard way.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|convs
argument_list|)
operator|==
literal|1
operator|&&
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|targ
decl_stmt|;
name|arg
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Pull out the real argument, disregarding const-correctness.  */
name|targ
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
condition|)
name|targ
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|targ
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|targ
condition|)
name|arg
operator|=
name|targ
expr_stmt|;
else|else
name|arg
operator|=
name|build_indirect_ref
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* [class.copy]: the copy constructor is implicitly defined even if 	 the implementation elided its use.  */
if|if
condition|(
name|TYPE_HAS_COMPLEX_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If we're creating a temp and we already have one, don't create a          new one.  If we're not creating a temp but we get one, use          INIT_EXPR to collapse the temp into our target.  Otherwise, if the          ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a          temp or an INIT_EXPR otherwise.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
return|return
name|arg
return|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
name|build_target_expr_with_type
argument_list|(
name|arg
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TARGET_EXPR
operator|||
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|to
init|=
name|stabilize_reference
argument_list|(
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|val
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|fn
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|copy_fn_p
argument_list|(
name|fn
argument_list|)
operator|&&
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|to
init|=
name|stabilize_reference
argument_list|(
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|tree
name|as_base
init|=
name|CLASSTYPE_AS_BASE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build_indirect_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|converted_args
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|as_base
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We must only copy the non-tail padding parts. Use 	     CLASSTYPE_AS_BASE for the bitwise copy.  */
name|tree
name|to_ptr
decl_stmt|,
name|arg_ptr
decl_stmt|,
name|to_as_base
decl_stmt|,
name|arg_as_base
decl_stmt|,
name|base_ptr_type
decl_stmt|;
name|tree
name|save_to
decl_stmt|;
name|to_ptr
operator|=
name|save_expr
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arg_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|as_base
argument_list|)
expr_stmt|;
name|to_as_base
operator|=
name|build_nop
argument_list|(
name|base_ptr_type
argument_list|,
name|to_ptr
argument_list|)
expr_stmt|;
name|to_as_base
operator|=
name|build_indirect_ref
argument_list|(
name|to_as_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_as_base
operator|=
name|build_nop
argument_list|(
name|base_ptr_type
argument_list|,
name|arg_ptr
argument_list|)
expr_stmt|;
name|arg_as_base
operator|=
name|build_indirect_ref
argument_list|(
name|arg_as_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save_to
operator|=
name|build_indirect_ref
argument_list|(
name|to_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|as_base
argument_list|,
name|to_as_base
argument_list|,
name|arg_as_base
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert_to_void
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|save_to
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|t
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|TREE_VALUE
argument_list|(
name|converted_args
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|ba_any
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|binfo
operator|&&
name|binfo
operator|!=
name|error_mark_node
argument_list|,
literal|20010730
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|p
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|save_expr
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|&&
name|TYPE_JAVA_INTERFACE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|build_java_interface_fn_ref
argument_list|(
name|fn
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|fn
operator|=
name|build_vfn_ref
argument_list|(
name|build_indirect_ref
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|inline_conversion
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
name|fn
operator|=
name|build_addr_func
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_cxx_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|converted_args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build and return a call to FN, using the the CONVERTED_ARGS.  ARGS    gives the original form of the arguments.  This function performs    no overload resolution, conversion, or other high-level    operations.  */
end_comment

begin_function
name|tree
name|build_cxx_call
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|converted_args
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|exp
decl_stmt|;
name|exp
operator|=
name|expand_tree_builtin
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
return|return
name|exp
return|;
block|}
name|fn
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|converted_args
argument_list|)
expr_stmt|;
comment|/* If this call might throw an exception, note that fact.  */
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|fndecl
operator|||
operator|!
name|TREE_NOTHROW
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|&&
name|at_function_scope_p
argument_list|()
operator|&&
name|cfun
condition|)
name|cp_function_chain
operator|->
name|can_throw
operator|=
literal|1
expr_stmt|;
comment|/* Some built-in function calls will be evaluated at compile-time in      fold ().  */
name|fn
operator|=
name|fold
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return
name|fn
return|;
name|fn
operator|=
name|require_complete_type
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fn
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|fn
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|java_iface_lookup_fn
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Make an expression which yields the address of the Java interface    method FN.  This is achieved by generating a call to libjava's    _Jv_LookupInterfaceMethodIdx().  */
end_comment

begin_function
specifier|static
name|tree
name|build_java_interface_fn_ref
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|instance
parameter_list|)
block|{
name|tree
name|lookup_args
decl_stmt|,
name|lookup_fn
decl_stmt|,
name|method
decl_stmt|,
name|idx
decl_stmt|;
name|tree
name|klass_ref
decl_stmt|,
name|iface
decl_stmt|,
name|iface_ref
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|java_iface_lookup_fn
condition|)
block|{
name|tree
name|endlink
init|=
name|build_void_list_node
argument_list|()
decl_stmt|;
name|tree
name|t
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|java_int_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|java_iface_lookup_fn
operator|=
name|builtin_function
argument_list|(
literal|"_Jv_LookupInterfaceMethodIdx"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Look up the pointer to the runtime java.lang.Class object for `instance'.       This is the first entry in the vtable.  */
name|klass_ref
operator|=
name|build_vtbl_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
comment|/* Get the java.lang.Class pointer for the interface being called.  */
name|iface
operator|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|iface_ref
operator|=
name|lookup_field
argument_list|(
name|iface
argument_list|,
name|get_identifier
argument_list|(
literal|"class$"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iface_ref
operator|||
name|TREE_CODE
argument_list|(
name|iface_ref
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|DECL_CONTEXT
argument_list|(
name|iface_ref
argument_list|)
operator|!=
name|iface
condition|)
block|{
name|error
argument_list|(
literal|"could not find class$ field in java interface type `%T'"
argument_list|,
name|iface
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|iface_ref
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|iface
argument_list|)
argument_list|,
name|iface_ref
argument_list|)
expr_stmt|;
comment|/* Determine the itable index of FN.  */
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|method
operator|=
name|TYPE_METHODS
argument_list|(
name|iface
argument_list|)
init|;
name|method
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|method
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fn
operator|==
name|method
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
name|idx
operator|=
name|build_int_2
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lookup_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|klass_ref
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|iface_ref
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lookup_fn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|java_iface_lookup_fn
argument_list|)
argument_list|)
argument_list|,
name|java_iface_lookup_fn
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|lookup_fn
argument_list|,
name|lookup_args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the value to use for the in-charge parameter when making a    call to a function with the indicated NAME.  */
end_comment

begin_function
name|tree
name|in_charge_arg_for_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|base_ctor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
condition|)
return|return
name|integer_zero_node
return|;
elseif|else
if|if
condition|(
name|name
operator|==
name|complete_ctor_identifier
condition|)
return|return
name|integer_one_node
return|;
elseif|else
if|if
condition|(
name|name
operator|==
name|complete_dtor_identifier
condition|)
return|return
name|integer_two_node
return|;
elseif|else
if|if
condition|(
name|name
operator|==
name|deleting_dtor_identifier
condition|)
return|return
name|integer_three_node
return|;
comment|/* This function should only be called with one of the names listed      above.  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a constructor, destructor, or an assignment    operator for INSTANCE, an expression with class type.  NAME    indicates the special member function to call; ARGS are the    arguments.  BINFO indicates the base of INSTANCE that is to be    passed as the `this' parameter to the member function called.     FLAGS are the LOOKUP_* flags to use when processing the call.     If NAME indicates a complete object constructor, INSTANCE may be    NULL_TREE.  In this case, the caller will call build_cplus_new to    store the newly constructed object into a VAR_DECL.  */
end_comment

begin_function
name|tree
name|build_special_member_call
parameter_list|(
name|tree
name|instance
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|binfo
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
comment|/* The type of the subobject to be constructed or destroyed.  */
name|tree
name|class_type
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|name
operator|==
name|complete_ctor_identifier
operator|||
name|name
operator|==
name|base_ctor_identifier
operator|||
name|name
operator|==
name|complete_dtor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|||
name|name
operator|==
name|deleting_dtor_identifier
operator|||
name|name
operator|==
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|binfo
operator|!=
name|NULL_TREE
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
name|class_type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* Handle the special case where INSTANCE is NULL_TREE.  */
if|if
condition|(
name|name
operator|==
name|complete_ctor_identifier
operator|&&
operator|!
name|instance
condition|)
block|{
name|instance
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|class_type
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
operator|==
name|complete_dtor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|||
name|name
operator|==
name|deleting_dtor_identifier
condition|)
name|my_friendly_assert
argument_list|(
name|args
operator|==
name|NULL_TREE
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
comment|/* Convert to the base class, if necessary.  */
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|!=
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
condition|)
comment|/* For constructors and destructors, either the base is 	       non-virtual, or it is virtual but we are doing the 	       conversion from a constructor or destructor for the 	       complete object.  In either case, we can convert 	       statically.  */
name|instance
operator|=
name|convert_to_base_statically
argument_list|(
name|instance
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
else|else
comment|/* However, for assignment operators, we must convert 	       dynamically if the base is virtual.  */
name|instance
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|instance
argument_list|,
name|binfo
argument_list|,
comment|/*nonnull=*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|my_friendly_assert
argument_list|(
name|instance
operator|!=
name|NULL_TREE
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
comment|/* Resolve the name.  */
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|binfo
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* When making a call to a constructor or destructor for a subobject      that uses virtual base classes, pass down a pointer to a VTT for      the subobject.  */
if|if
condition|(
operator|(
name|name
operator|==
name|base_ctor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|class_type
argument_list|)
condition|)
block|{
name|tree
name|vtt
decl_stmt|;
name|tree
name|sub_vtt
decl_stmt|;
comment|/* If the current function is a complete object constructor 	 or destructor, then we fetch the VTT directly. 	 Otherwise, we look it up using the VTT we were given.  */
name|vtt
operator|=
name|TREE_CHAIN
argument_list|(
name|CLASSTYPE_VTABLES
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|vtt
operator|=
name|decay_conversion
argument_list|(
name|vtt
argument_list|)
expr_stmt|;
name|vtt
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|current_vtt_parm
argument_list|,
name|vtt
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|20010110
argument_list|)
expr_stmt|;
name|sub_vtt
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|vtt
argument_list|,
name|BINFO_SUBVTT_INDEX
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sub_vtt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
return|return
name|build_new_method_call
argument_list|(
name|instance
argument_list|,
name|fns
argument_list|,
name|args
argument_list|,
name|TYPE_BINFO
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the NAME, as a C string.  The NAME indicates a function that    is a member of TYPE.  *FREE_P is set to true if the caller must    free the memory returned.       Rather than go through all of this, we should simply set the names    of constructors and destructors appropriately, and dispense with    ctor_identifier, dtor_identifier, etc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|name_as_c_string
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
modifier|*
name|free_p
parameter_list|)
block|{
name|char
modifier|*
name|pretty_name
decl_stmt|;
comment|/* Assume that we will not allocate memory.  */
operator|*
name|free_p
operator|=
name|false
expr_stmt|;
comment|/* Constructors and destructors are special.  */
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|pretty_name
operator|=
operator|(
name|char
operator|*
operator|)
name|IDENTIFIER_POINTER
argument_list|(
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a destructor, add the '~'.  */
if|if
condition|(
name|name
operator|==
name|complete_dtor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|||
name|name
operator|==
name|deleting_dtor_identifier
condition|)
block|{
name|pretty_name
operator|=
name|concat
argument_list|(
literal|"~"
argument_list|,
name|pretty_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Remember that we need to free the memory allocated.  */
operator|*
name|free_p
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|pretty_name
operator|=
name|concat
argument_list|(
literal|"operator "
argument_list|,
name|type_as_string
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Remember that we need to free the memory allocated.  */
operator|*
name|free_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|pretty_name
operator|=
operator|(
name|char
operator|*
operator|)
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|pretty_name
return|;
block|}
end_function

begin_comment
comment|/* Build a call to "INSTANCE.FN (ARGS)".  */
end_comment

begin_function
name|tree
name|build_new_method_call
parameter_list|(
name|tree
name|instance
parameter_list|,
name|tree
name|fns
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|conversion_path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|candidates
init|=
literal|0
decl_stmt|,
modifier|*
name|cand
decl_stmt|;
name|tree
name|explicit_targs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|access_binfo
decl_stmt|;
name|tree
name|optype
decl_stmt|;
name|tree
name|mem_args
init|=
name|NULL_TREE
decl_stmt|,
name|instance_ptr
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|user_args
decl_stmt|;
name|tree
name|call
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|class_type
decl_stmt|;
name|int
name|template_only
init|=
literal|0
decl_stmt|;
name|bool
name|any_viable_p
decl_stmt|;
name|tree
name|orig_instance
decl_stmt|;
name|tree
name|orig_fns
decl_stmt|;
name|tree
name|orig_args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|instance
operator|!=
name|NULL_TREE
argument_list|,
literal|20020729
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|instance
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|fns
argument_list|)
operator|||
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|orig_instance
operator|=
name|instance
expr_stmt|;
name|orig_fns
operator|=
name|fns
expr_stmt|;
name|orig_args
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|instance
operator|=
name|build_non_dependent_expr
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|!=
name|PSEUDO_DTOR_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|fns
argument_list|)
operator|!=
name|unknown_type_node
condition|)
name|fns
operator|=
name|build_non_dependent_expr
argument_list|(
name|fns
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_non_dependent_args
argument_list|(
name|orig_args
argument_list|)
expr_stmt|;
block|}
comment|/* Process the argument list.  */
name|user_args
operator|=
name|args
expr_stmt|;
name|args
operator|=
name|resolve_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|instance
operator|=
name|convert_from_reference
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|build_this
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"call to non-function `%D'"
argument_list|,
name|fns
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|conversion_path
condition|)
name|conversion_path
operator|=
name|BASELINK_BINFO
argument_list|(
name|fns
argument_list|)
expr_stmt|;
name|access_binfo
operator|=
name|BASELINK_ACCESS_BINFO
argument_list|(
name|fns
argument_list|)
expr_stmt|;
name|optype
operator|=
name|BASELINK_OPTYPE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|template_only
operator|=
literal|1
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
comment|/* XXX this should be handled before we get here.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
operator|&&
name|basetype
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|fns
argument_list|,
name|instance
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fn
operator|=
name|get_first_fn
argument_list|(
name|fns
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_CTOR_OR_DTOR_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* Callers should explicitly indicate whether they want to construct 	 the complete object or just the part without virtual bases.  */
name|my_friendly_assert
argument_list|(
name|name
operator|!=
name|ctor_identifier
argument_list|,
literal|20000408
argument_list|)
expr_stmt|;
comment|/* Similarly for destructors.  */
name|my_friendly_assert
argument_list|(
name|name
operator|!=
name|dtor_identifier
argument_list|,
literal|20000408
argument_list|)
expr_stmt|;
block|}
comment|/* It's OK to call destructors on cv-qualified objects.  Therefore,      convert the INSTANCE_PTR to the unqualified type, if necessary.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
condition|)
name|instance_ptr
operator|=
name|build_nop
argument_list|(
name|type
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
block|}
name|class_type
operator|=
operator|(
name|conversion_path
condition|?
name|BINFO_TYPE
argument_list|(
name|conversion_path
argument_list|)
else|:
name|NULL_TREE
operator|)
expr_stmt|;
name|mem_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|this_arglist
decl_stmt|;
comment|/* We can end up here for copy-init of same or base class.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
operator|&&
name|DECL_NONCONVERTING_P
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
name|this_arglist
operator|=
name|mem_args
expr_stmt|;
else|else
name|this_arglist
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* A member template.  */
name|add_template_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|t
argument_list|,
name|class_type
argument_list|,
name|explicit_targs
argument_list|,
name|this_arglist
argument_list|,
name|optype
argument_list|,
name|access_binfo
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|,
name|DEDUCE_CALL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|template_only
condition|)
name|add_function_candidate
argument_list|(
operator|&
name|candidates
argument_list|,
name|t
argument_list|,
name|class_type
argument_list|,
name|this_arglist
argument_list|,
name|access_binfo
argument_list|,
name|conversion_path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|candidates
operator|=
name|splice_viable
argument_list|(
name|candidates
argument_list|,
name|pedantic
argument_list|,
operator|&
name|any_viable_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_viable_p
condition|)
block|{
comment|/* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|cxx_incomplete_type_error
argument_list|(
name|instance_ptr
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|pretty_name
decl_stmt|;
name|bool
name|free_p
decl_stmt|;
name|pretty_name
operator|=
name|name_as_c_string
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|,
operator|&
name|free_p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"no matching function for call to `%T::%s(%A)%#V'"
argument_list|,
name|basetype
argument_list|,
name|pretty_name
argument_list|,
name|user_args
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_p
condition|)
name|free
argument_list|(
name|pretty_name
argument_list|)
expr_stmt|;
block|}
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|cand
operator|=
name|tourney
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|pretty_name
decl_stmt|;
name|bool
name|free_p
decl_stmt|;
name|pretty_name
operator|=
name|name_as_c_string
argument_list|(
name|name
argument_list|,
name|basetype
argument_list|,
operator|&
name|free_p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"call of overloaded `%s(%A)' is ambiguous"
argument_list|,
name|pretty_name
argument_list|,
name|user_args
argument_list|)
expr_stmt|;
name|print_z_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_p
condition|)
name|free
argument_list|(
name|pretty_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
name|instance
operator|==
name|current_class_ref
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|value_member
argument_list|(
name|cand
operator|->
name|fn
argument_list|,
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|?
literal|"abstract virtual `%#D' called from constructor"
else|:
literal|"abstract virtual `%#D' called from destructor"
operator|)
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|is_dummy_object
argument_list|(
name|instance_ptr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot call member function `%D' without object"
argument_list|,
name|cand
operator|->
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|resolves_to_fixed_type_p
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
condition|)
name|flags
operator||=
name|LOOKUP_NONVIRTUAL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|fn
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|call
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|call
operator|=
name|build_over_call
argument_list|(
name|cand
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* In an expression of the form `a->f()' where `f' turns out to 	 be a static member function, `a' is none-the-less evaluated.  */
if|if
condition|(
operator|!
name|is_dummy_object
argument_list|(
name|instance_ptr
argument_list|)
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance
argument_list|)
condition|)
name|call
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|call
argument_list|)
argument_list|,
name|instance
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
operator|&&
name|call
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|CALL_EXPR
argument_list|,
name|call
argument_list|,
name|build_min_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|orig_instance
argument_list|,
name|orig_fns
argument_list|)
argument_list|,
name|orig_args
argument_list|)
return|;
return|return
name|call
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff standard conversion sequence ICS1 is a proper    subsequence of ICS2.  */
end_comment

begin_function
specifier|static
name|bool
name|is_subseq
parameter_list|(
name|tree
name|ics1
parameter_list|,
name|tree
name|ics2
parameter_list|)
block|{
comment|/* We can assume that a conversion of the same code      between the same types indicates a subsequence since we only get      here if the types we are converting from are the same.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|RVALUE_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|LVALUE_CONV
condition|)
name|ics1
operator|=
name|TREE_OPERAND
argument_list|(
name|ics1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|RVALUE_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|LVALUE_CONV
condition|)
name|ics2
operator|=
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|AMBIG_CONV
operator|||
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
comment|/* At this point, ICS1 cannot be a proper subsequence of 	   ICS2.  We can get a USER_CONV when we are comparing the 	   second standard conversion sequence of two user conversion 	   sequences.  */
return|return
name|false
return|;
name|ics2
operator|=
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|ics2
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ics1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ics2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ics1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns nonzero iff DERIVED is derived from BASE.  The inputs may    be any _TYPE nodes.  */
end_comment

begin_function
name|bool
name|is_properly_derived_from
parameter_list|(
name|tree
name|derived
parameter_list|,
name|tree
name|base
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|derived
argument_list|)
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We only allow proper derivation here.  The DERIVED_FROM_P macro      considers every class derived from itself.  */
return|return
operator|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|derived
argument_list|,
name|base
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|base
argument_list|,
name|derived
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We build the ICS for an implicit object parameter as a pointer    conversion sequence.  However, such a sequence should be compared    as if it were a reference conversion sequence.  If ICS is the    implicit conversion sequence for an implicit object parameter,    modify it accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_handle_implicit_object
parameter_list|(
name|tree
modifier|*
name|ics
parameter_list|)
block|{
if|if
condition|(
name|ICS_THIS_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
condition|)
block|{
comment|/* [over.match.funcs] 	  	 For non-static member functions, the type of the 	 implicit object parameter is "reference to cv X" 	 where X is the class of which the function is a 	 member and cv is the cv-qualification on the member 	 function declaration.  */
name|tree
name|t
init|=
operator|*
name|ics
decl_stmt|;
name|tree
name|reference_type
decl_stmt|;
comment|/* The `this' parameter is a pointer to a class type.  Make the 	 implicit conversion talk about a reference to that same class 	 type.  */
name|reference_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|ics
argument_list|)
argument_list|)
expr_stmt|;
name|reference_type
operator|=
name|build_reference_type
argument_list|(
name|reference_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|QUAL_CONV
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTR_CONV
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|IDENTITY_CONV
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|direct_reference_binding
argument_list|(
name|reference_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|ics
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If *ICS is a REF_BIND set *ICS to the remainder of the conversion,    and return the type to which the reference refers.  Otherwise,    leave *ICS unchanged and return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_handle_ref_bind
parameter_list|(
name|tree
modifier|*
name|ics
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|ics
argument_list|)
operator|==
name|REF_BIND
condition|)
block|{
name|tree
name|old_ics
init|=
operator|*
name|ics
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_ics
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|ics
operator|=
name|TREE_OPERAND
argument_list|(
name|old_ics
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ICS_USER_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
operator|=
name|ICS_USER_FLAG
argument_list|(
name|old_ics
argument_list|)
expr_stmt|;
name|ICS_BAD_FLAG
argument_list|(
operator|*
name|ics
argument_list|)
operator|=
name|ICS_BAD_FLAG
argument_list|(
name|old_ics
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Compare two implicit conversion sequences according to the rules set out in    [over.ics.rank].  Return values:        1: ics1 is better than ics2      -1: ics2 is better than ics1       0: ics1 and ics2 are indistinguishable */
end_comment

begin_function
specifier|static
name|int
name|compare_ics
parameter_list|(
name|tree
name|ics1
parameter_list|,
name|tree
name|ics2
parameter_list|)
block|{
name|tree
name|from_type1
decl_stmt|;
name|tree
name|from_type2
decl_stmt|;
name|tree
name|to_type1
decl_stmt|;
name|tree
name|to_type2
decl_stmt|;
name|tree
name|deref_from_type1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_from_type2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_to_type1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|deref_to_type2
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|rank1
decl_stmt|,
name|rank2
decl_stmt|;
comment|/* REF_BINDING is nonzero if the result of the conversion sequence      is a reference type.   In that case TARGET_TYPE is the      type referred to by the reference.  */
name|tree
name|target_type1
decl_stmt|;
name|tree
name|target_type2
decl_stmt|;
comment|/* Handle implicit object parameters.  */
name|maybe_handle_implicit_object
argument_list|(
operator|&
name|ics1
argument_list|)
expr_stmt|;
name|maybe_handle_implicit_object
argument_list|(
operator|&
name|ics2
argument_list|)
expr_stmt|;
comment|/* Handle reference parameters.  */
name|target_type1
operator|=
name|maybe_handle_ref_bind
argument_list|(
operator|&
name|ics1
argument_list|)
expr_stmt|;
name|target_type2
operator|=
name|maybe_handle_ref_bind
argument_list|(
operator|&
name|ics2
argument_list|)
expr_stmt|;
comment|/* [over.ics.rank]       When  comparing  the  basic forms of implicit conversion sequences (as      defined in _over.best.ics_)       --a standard conversion sequence (_over.ics.scs_) is a better        conversion sequence than a user-defined conversion sequence        or an ellipsis conversion sequence, and            --a user-defined conversion sequence (_over.ics.user_) is a        better conversion sequence than an ellipsis conversion sequence        (_over.ics.ellipsis_).  */
name|rank1
operator|=
name|ICS_RANK
argument_list|(
name|ics1
argument_list|)
expr_stmt|;
name|rank2
operator|=
name|ICS_RANK
argument_list|(
name|ics2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rank1
operator|>
name|rank2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|rank1
operator|<
name|rank2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|rank1
operator|==
name|BAD_RANK
condition|)
block|{
comment|/* XXX Isn't this an extension? */
comment|/* Both ICS are bad.  We try to make a decision based on what 	 would have happened if they'd been good.  */
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_USER_FLAG
argument_list|(
name|ics2
argument_list|)
operator|||
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|>
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_USER_FLAG
argument_list|(
name|ics2
argument_list|)
operator|||
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We couldn't make up our minds; try to figure it out below.  */
block|}
if|if
condition|(
name|ICS_ELLIPSIS_FLAG
argument_list|(
name|ics1
argument_list|)
condition|)
comment|/* Both conversions are ellipsis conversions.  */
return|return
literal|0
return|;
comment|/* User-defined  conversion sequence U1 is a better conversion sequence      than another user-defined conversion sequence U2 if they contain the      same user-defined conversion operator or constructor and if the sec-      ond standard conversion sequence of U1 is  better  than  the  second      standard conversion sequence of U2.  */
if|if
condition|(
name|ICS_USER_FLAG
argument_list|(
name|ics1
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|ics1
init|;
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|USER_CONV
condition|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t2
operator|=
name|ics2
init|;
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|USER_CONV
condition|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|AMBIG_CONV
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|USER_CONV_FN
argument_list|(
name|t1
argument_list|)
operator|!=
name|USER_CONV_FN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We can just fall through here, after setting up 	 FROM_TYPE1 and FROM_TYPE2.  */
name|from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're dealing with two standard conversion sequences.   	 [over.ics.rank] 	  	 Standard conversion sequence S1 is a better conversion 	 sequence than standard conversion sequence S2 if       	 --S1 is a proper subsequence of S2 (comparing the conversion 	   sequences in the canonical form defined by _over.ics.scs_, 	   excluding any Lvalue Transformation; the identity 	   conversion sequence is considered to be a subsequence of 	   any non-identity conversion sequence */
name|from_type1
operator|=
name|ics1
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|from_type1
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|from_type1
operator|=
name|TREE_OPERAND
argument_list|(
name|from_type1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|ics2
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|from_type2
argument_list|)
operator|!=
name|IDENTITY_CONV
condition|)
name|from_type2
operator|=
name|TREE_OPERAND
argument_list|(
name|from_type2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_subseq
argument_list|(
name|ics1
argument_list|,
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_subseq
argument_list|(
name|ics2
argument_list|,
name|ics1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Otherwise, one sequence cannot be a subsequence of the other; they      don't start with the same type.  This can happen when comparing the      second standard conversion sequence in two user-defined conversion      sequences.  */
comment|/* [over.ics.rank]       Or, if not that,       --the rank of S1 is better than the rank of S2 (by the rules        defined below):      Standard conversion sequences are ordered by their ranks: an Exact     Match is a better conversion than a Promotion, which is a better     conversion than a Conversion.      Two conversion sequences with the same rank are indistinguishable     unless one of the following rules applies:      --A conversion that is not a conversion of a pointer, or pointer       to member, to bool is better than another conversion that is such       a conversion.        The ICS_STD_RANK automatically handles the pointer-to-bool rule,     so that we do not have to check it explicitly.  */
if|if
condition|(
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ICS_STD_RANK
argument_list|(
name|ics2
argument_list|)
operator|<
name|ICS_STD_RANK
argument_list|(
name|ics1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|to_type1
operator|=
name|TREE_TYPE
argument_list|(
name|ics1
argument_list|)
expr_stmt|;
name|to_type2
operator|=
name|TREE_TYPE
argument_list|(
name|ics2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|to_type2
argument_list|)
condition|)
block|{
name|deref_from_type1
operator|=
name|TREE_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TREE_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
name|deref_to_type1
operator|=
name|TREE_TYPE
argument_list|(
name|to_type1
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TREE_TYPE
argument_list|(
name|to_type2
argument_list|)
expr_stmt|;
block|}
comment|/* The rules for pointers to members A::* are just like the rules      for pointers A*, except opposite: if B is derived from A then      A::* converts to B::*, not vice versa.  For that reason, we      switch the from_ and to_ variables here.  */
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|to_type2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from_type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|from_type2
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to_type1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|to_type2
argument_list|)
operator|)
condition|)
block|{
name|deref_to_type1
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|from_type1
argument_list|)
expr_stmt|;
name|deref_to_type2
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|from_type2
argument_list|)
expr_stmt|;
name|deref_from_type1
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|to_type1
argument_list|)
expr_stmt|;
name|deref_from_type2
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|to_type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deref_from_type1
operator|!=
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_from_type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_from_type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This was one of the pointer or pointer-like conversions.    	 [over.ics.rank] 	  	 --If class B is derived directly or indirectly from class A, 	   conversion of B* to A* is better than conversion of B* to 	   void*, and conversion of A* to void* is better than 	   conversion of B* to void*.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type2
argument_list|,
name|deref_from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_to_type1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* We know that DEREF_TO_TYPE1 is `void' here.  */
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_to_type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|deref_to_type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* [over.ics.rank]  	     --If class B is derived directly or indirectly from class A 	       and class C is derived directly or indirectly from B, 	      	     --conversion of C* to B* is better than conversion of C* to 	       A*,  	      	     --conversion of B* to A* is better than conversion of C* to 	       A*  */
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_to_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_to_type2
argument_list|,
name|deref_to_type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|deref_to_type1
argument_list|,
name|deref_to_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type2
argument_list|,
name|deref_from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|deref_from_type1
argument_list|,
name|deref_from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|non_reference
argument_list|(
name|from_type1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
block|{
name|tree
name|from
init|=
name|non_reference
argument_list|(
name|from_type1
argument_list|)
decl_stmt|;
comment|/* [over.ics.rank] 	  	 --binding of an expression of type C to a reference of type 	   B& is better than binding an expression of type C to a 	   reference of type A&  	 --conversion of C to B is better than conversion of C to A,  */
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from
argument_list|,
name|to_type1
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from
argument_list|,
name|to_type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|to_type2
argument_list|,
name|to_type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|non_reference
argument_list|(
name|to_type1
argument_list|)
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
block|{
name|tree
name|to
init|=
name|non_reference
argument_list|(
name|to_type1
argument_list|)
decl_stmt|;
comment|/* [over.ics.rank]  	 --binding of an expression of type B to a reference of type 	   A& is better than binding an expression of type C to a 	   reference of type A&,   	 --onversion of B to A is better than conversion of C to A  */
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|to
argument_list|)
operator|&&
name|is_properly_derived_from
argument_list|(
name|from_type2
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type2
argument_list|,
name|from_type1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* [over.ics.rank]       --S1 and S2 differ only in their qualification conversion and  yield        similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-        qualification signature of type T1 is a proper subset of  the  cv-        qualification signature of type T2  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ics1
argument_list|)
operator|==
name|QUAL_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|ics2
argument_list|)
operator|==
name|QUAL_CONV
operator|&&
name|same_type_p
argument_list|(
name|from_type1
argument_list|,
name|from_type2
argument_list|)
condition|)
return|return
name|comp_cv_qual_signature
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
return|;
comment|/* [over.ics.rank]            --S1 and S2 are reference bindings (_dcl.init.ref_), and the      types to which the references refer are the same type except for      top-level cv-qualifiers, and the type to which the reference      initialized by S2 refers is more cv-qualified than the type to      which the reference initialized by S1 refers */
if|if
condition|(
name|target_type1
operator|&&
name|target_type2
operator|&&
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|to_type1
argument_list|,
name|to_type2
argument_list|)
condition|)
return|return
name|comp_cv_qualification
argument_list|(
name|target_type2
argument_list|,
name|target_type1
argument_list|)
return|;
comment|/* Neither conversion sequence is better than the other.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The source type for this standard conversion sequence.  */
end_comment

begin_function
specifier|static
name|tree
name|source_type
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|USER_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|AMBIG_CONV
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTITY_CONV
condition|)
return|return
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note a warning about preferring WINNER to LOSER.  We do this by storing    a pointer to LOSER and re-running joust to produce the warning if WINNER    is actually used.  */
end_comment

begin_function
specifier|static
name|void
name|add_warning
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|winner
parameter_list|,
name|struct
name|z_candidate
modifier|*
name|loser
parameter_list|)
block|{
name|winner
operator|->
name|warnings
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_zc_wrapper
argument_list|(
name|loser
argument_list|)
argument_list|,
name|winner
operator|->
name|warnings
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare two candidates for overloading as described in    [over.match.best].  Return values:        1: cand1 is better than cand2      -1: cand2 is better than cand1       0: cand1 and cand2 are indistinguishable */
end_comment

begin_function
specifier|static
name|int
name|joust
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|cand1
parameter_list|,
name|struct
name|z_candidate
modifier|*
name|cand2
parameter_list|,
name|bool
name|warn
parameter_list|)
block|{
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off1
init|=
literal|0
decl_stmt|,
name|off2
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
comment|/* Candidates that involve bad conversions are always worse than those      that don't.  */
if|if
condition|(
name|cand1
operator|->
name|viable
operator|>
name|cand2
operator|->
name|viable
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cand1
operator|->
name|viable
operator|<
name|cand2
operator|->
name|viable
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we have two pseudo-candidates for conversions to the same type,      or two candidates for the same function, arbitrarily pick one.  */
if|if
condition|(
name|cand1
operator|->
name|fn
operator|==
name|cand2
operator|->
name|fn
operator|&&
operator|(
name|TYPE_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* a viable function F1      is defined to be a better function than another viable function F2  if      for  all arguments i, ICSi(F1) is not a worse conversion sequence than      ICSi(F2), and then */
comment|/* for some argument j, ICSj(F1) is a better conversion  sequence  than      ICSj(F2) */
comment|/* For comparing static and non-static member functions, we ignore      the implicit object parameter of the non-static function.  The      standard says to pretend that the static function has an object      parm, but that won't work with operator overloading.  */
name|len
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|cand2
operator|->
name|convs
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
condition|)
name|off2
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
condition|)
block|{
name|off1
operator|=
literal|1
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
decl_stmt|;
name|int
name|comp
init|=
name|compare_ics
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|warn_sign_promo
operator|&&
name|ICS_RANK
argument_list|(
name|t1
argument_list|)
operator|+
name|ICS_RANK
argument_list|(
name|t2
argument_list|)
operator|==
name|STD_RANK
operator|+
name|PROMO_RANK
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|STD_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|STD_CONV
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|w
decl_stmt|,
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|comp
operator|>
literal|0
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|,
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|,
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
else|else
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|,
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|,
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|warning
argument_list|(
literal|"passing `%T' chooses `%T' over `%T'"
argument_list|,
name|type
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  in call to `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|winner
operator|&&
name|comp
operator|!=
name|winner
condition|)
block|{
name|winner
operator|=
literal|0
expr_stmt|;
goto|goto
name|tweak
goto|;
block|}
name|winner
operator|=
name|comp
expr_stmt|;
block|}
block|}
comment|/* warn about confusing overload resolution for user-defined conversions,      either between a constructor and a conversion op, or between two      conversion ops.  */
if|if
condition|(
name|winner
operator|&&
name|warn_conversion
operator|&&
name|cand1
operator|->
name|second_conv
operator|&&
operator|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|||
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|)
operator|&&
name|winner
operator|!=
name|compare_ics
argument_list|(
name|cand1
operator|->
name|second_conv
argument_list|,
name|cand2
operator|->
name|second_conv
argument_list|)
condition|)
block|{
name|struct
name|z_candidate
modifier|*
name|w
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|bool
name|give_warning
init|=
name|false
decl_stmt|;
if|if
condition|(
name|winner
operator|==
literal|1
condition|)
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
else|else
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
comment|/* We don't want to complain about `X::operator T1 ()' 	 beating `X::operator T2 () const', when T2 is a no less 	 cv-qualified version of T1.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|w
operator|->
name|fn
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|l
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|w
operator|->
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|l
operator|->
name|fn
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|l
operator|->
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|f
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|w
operator|->
name|fn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|f
operator|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|comp_ptr_ttypes
argument_list|(
name|t
argument_list|,
name|f
argument_list|)
condition|)
name|give_warning
operator|=
name|true
expr_stmt|;
block|}
else|else
name|give_warning
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|give_warning
condition|)
comment|/*NOP*/
empty_stmt|;
elseif|else
if|if
condition|(
name|warn
condition|)
block|{
name|tree
name|source
init|=
name|source_type
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|w
operator|->
name|convs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|w
operator|->
name|fn
argument_list|)
condition|)
name|source
operator|=
name|TREE_TYPE
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"choosing `%D' over `%D'"
argument_list|,
name|w
operator|->
name|fn
argument_list|,
name|l
operator|->
name|fn
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  for conversion from `%T' to `%T'"
argument_list|,
name|source
argument_list|,
name|TREE_TYPE
argument_list|(
name|w
operator|->
name|second_conv
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  because conversion sequence for the argument is better"
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
comment|/* or, if not that,      F1 is a non-template function and F2 is a template function      specialization.  */
if|if
condition|(
operator|!
name|cand1
operator|->
name|template
operator|&&
name|cand2
operator|->
name|template
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cand1
operator|->
name|template
operator|&&
operator|!
name|cand2
operator|->
name|template
condition|)
return|return
operator|-
literal|1
return|;
comment|/* or, if not that,      F1 and F2 are template functions and the function template for F1 is      more specialized than the template for F2 according to the partial      ordering rules.  */
if|if
condition|(
name|cand1
operator|->
name|template
operator|&&
name|cand2
operator|->
name|template
condition|)
block|{
name|winner
operator|=
name|more_specialized
argument_list|(
name|TI_TEMPLATE
argument_list|(
name|cand1
operator|->
name|template
argument_list|)
argument_list|,
name|TI_TEMPLATE
argument_list|(
name|cand2
operator|->
name|template
argument_list|)
argument_list|,
name|DEDUCE_ORDER
argument_list|,
comment|/* Tell the deduction code how many real function arguments 	    we saw, not counting the implicit 'this' argument.  But, 	    add_function_candidate() suppresses the "this" argument 	    for constructors.  	    [temp.func.order]: The presence of unused ellipsis and default 	    arguments has no effect on the partial ordering of function 	    templates.  */
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
operator|-
operator|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|-
name|DECL_CONSTRUCTOR_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
block|}
comment|/* or, if not that,      the  context  is  an  initialization by user-defined conversion (see      _dcl.init_  and  _over.match.user_)  and  the  standard   conversion      sequence  from  the return type of F1 to the destination type (i.e.,      the type of the entity being initialized)  is  a  better  conversion      sequence  than the standard conversion sequence from the return type      of F2 to the destination type.  */
if|if
condition|(
name|cand1
operator|->
name|second_conv
condition|)
block|{
name|winner
operator|=
name|compare_ics
argument_list|(
name|cand1
operator|->
name|second_conv
argument_list|,
name|cand2
operator|->
name|second_conv
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
condition|)
return|return
name|winner
return|;
block|}
comment|/* Check whether we can discard a builtin candidate, either because we      have two identical ones or matching builtin and non-builtin candidates.       (Pedantically in the latter case the builtin which matched the user      function should not be added to the overload set, but we spot it here.            [over.match.oper]      ... the builtin candidates include ...      - do not have the same parameter type list as any non-template        non-member candidate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|cand1
operator|->
name|convs
argument_list|)
condition|)
block|{
if|if
condition|(
name|cand1
operator|->
name|fn
operator|==
name|cand2
operator|->
name|fn
condition|)
comment|/* Two built-in candidates; arbitrarily pick one.  */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* cand1 is built-in; prefer cand2.  */
return|return
operator|-
literal|1
return|;
else|else
comment|/* cand2 is built-in; prefer cand1.  */
return|return
literal|1
return|;
block|}
block|}
comment|/* If the two functions are the same (this can happen with declarations      in multiple scopes and arg-dependent lookup), arbitrarily choose one.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|cand1
operator|->
name|fn
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|cand2
operator|->
name|fn
argument_list|)
operator|&&
name|equal_functions
argument_list|(
name|cand1
operator|->
name|fn
argument_list|,
name|cand2
operator|->
name|fn
argument_list|)
condition|)
return|return
literal|1
return|;
name|tweak
label|:
comment|/* Extension: If the worst conversion for one candidate is worse than the      worst conversion for the other, take the first.  */
if|if
condition|(
operator|!
name|pedantic
condition|)
block|{
name|int
name|rank1
init|=
name|IDENTITY_RANK
decl_stmt|,
name|rank2
init|=
name|IDENTITY_RANK
decl_stmt|;
name|struct
name|z_candidate
modifier|*
name|w
init|=
literal|0
decl_stmt|,
modifier|*
name|l
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
argument_list|)
operator|>
name|rank1
condition|)
name|rank1
operator|=
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand1
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
argument_list|)
operator|>
name|rank2
condition|)
name|rank2
operator|=
name|ICS_RANK
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|cand2
operator|->
name|convs
argument_list|,
name|i
operator|+
name|off2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rank1
operator|<
name|rank2
condition|)
name|winner
operator|=
literal|1
operator|,
name|w
operator|=
name|cand1
operator|,
name|l
operator|=
name|cand2
expr_stmt|;
if|if
condition|(
name|rank1
operator|>
name|rank2
condition|)
name|winner
operator|=
operator|-
literal|1
operator|,
name|w
operator|=
name|cand2
operator|,
name|l
operator|=
name|cand1
expr_stmt|;
if|if
condition|(
name|winner
condition|)
block|{
if|if
condition|(
name|warn
condition|)
block|{
name|pedwarn
argument_list|(
literal|"\ ISO C++ says that these are ambiguous, even \ though the worst conversion for the first is better than \ the worst conversion for the second:"
argument_list|)
expr_stmt|;
name|print_z_candidate
argument_list|(
name|_
argument_list|(
literal|"candidate 1:"
argument_list|)
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|print_z_candidate
argument_list|(
name|_
argument_list|(
literal|"candidate 2:"
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|add_warning
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|winner
return|;
block|}
block|}
name|my_friendly_assert
argument_list|(
operator|!
name|winner
argument_list|,
literal|20010121
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a list of candidates for overloading, find the best one, if any.    This algorithm has a worst case of O(2n) (winner is last), and a best    case of O(n/2) (totally ambiguous); much better than a sorting    algorithm.  */
end_comment

begin_function
specifier|static
name|struct
name|z_candidate
modifier|*
name|tourney
parameter_list|(
name|struct
name|z_candidate
modifier|*
name|candidates
parameter_list|)
block|{
name|struct
name|z_candidate
modifier|*
name|champ
init|=
name|candidates
decl_stmt|,
modifier|*
name|challenger
decl_stmt|;
name|int
name|fate
decl_stmt|;
name|int
name|champ_compared_to_predecessor
init|=
literal|0
decl_stmt|;
comment|/* Walk through the list once, comparing each current champ to the next      candidate, knocking out a candidate or two with each comparison.  */
for|for
control|(
name|challenger
operator|=
name|champ
operator|->
name|next
init|;
name|challenger
condition|;
control|)
block|{
name|fate
operator|=
name|joust
argument_list|(
name|champ
argument_list|,
name|challenger
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
name|challenger
operator|=
name|challenger
operator|->
name|next
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|champ
operator|=
name|challenger
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|champ
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|champ_compared_to_predecessor
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|champ
operator|=
name|challenger
expr_stmt|;
name|champ_compared_to_predecessor
operator|=
literal|1
expr_stmt|;
block|}
name|challenger
operator|=
name|champ
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Make sure the champ is better than all the candidates it hasn't yet      been compared to.  */
for|for
control|(
name|challenger
operator|=
name|candidates
init|;
name|challenger
operator|!=
name|champ
operator|&&
operator|!
operator|(
name|champ_compared_to_predecessor
operator|&&
name|challenger
operator|->
name|next
operator|==
name|champ
operator|)
condition|;
name|challenger
operator|=
name|challenger
operator|->
name|next
control|)
block|{
name|fate
operator|=
name|joust
argument_list|(
name|champ
argument_list|,
name|challenger
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if things of type FROM can be converted to TO.  */
end_comment

begin_function
name|bool
name|can_convert
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
return|return
name|can_convert_arg
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if ARG (of type FROM) can be converted to TO.  */
end_comment

begin_function
name|bool
name|can_convert_arg
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|t
init|=
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
return|return
operator|(
name|t
operator|&&
operator|!
name|ICS_BAD_FLAG
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like can_convert_arg, but allows dubious conversions as well.  */
end_comment

begin_function
name|bool
name|can_convert_arg_bad
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
return|return
name|implicit_conversion
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|arg
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE.  Return the converted expression.     Note that we allow bad conversions here because by the time we get to    this point we are committed to doing the conversion.  If we end up    doing a bad conversion, convert_like will complain.  */
end_comment

begin_function
name|tree
name|perform_implicit_conversion
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
condition|)
block|{
name|error
argument_list|(
literal|"could not convert `%E' to `%T'"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|convert_like
argument_list|(
name|conv
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE (as a direct-initialization) if that is    permitted.  If the conversion is valid, the converted expression is    returned.  Otherwise, NULL_TREE is returned, except in the case    that TYPE is a class type; in that case, an error is issued.  */
end_comment

begin_function
name|tree
name|perform_direct_initialization_if_possible
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* [dcl.init]       If the destination type is a (possibly cv-qualified) class type:       -- If the initialization is direct-initialization ...,      constructors are considered. ... If no constructor applies, or      the overload resolution is ambiguous, the initialization is      ill-formed.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|expr
operator|=
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
return|return
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
name|conv
operator|=
name|implicit_conversion
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
operator|||
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|convert_like_real
argument_list|(
name|conv
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/*issue_conversion_warnings=*/
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference    is being bound to a temporary.  Create and return a new VAR_DECL    with the indicated TYPE; this variable will store the value to    which the reference is bound.  */
end_comment

begin_function
name|tree
name|make_temporary_var_for_ref_to_temp
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
comment|/* Create the variable.  */
name|var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Register the variable.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Namespace-scope or local static; give it a mangled name.  */
name|tree
name|name
decl_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|mangle_ref_init_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|var
argument_list|)
operator|=
name|name
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|var
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|var
operator|=
name|pushdecl_top_level
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new cleanup level if necessary.  */
name|maybe_push_cleanup_level
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't push unnamed temps.  Do set DECL_CONTEXT, though.  */
name|DECL_CONTEXT
argument_list|(
name|var
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to the indicated reference TYPE, in a way suitable for    initializing a variable of that TYPE.  If DECL is non-NULL, it is    the VAR_DECL being initialized with the EXPR.  (In that case, the    type of DECL will be TYPE.)  If DECL is non-NULL, then CLEANUP must    also be non-NULL, and with *CLEANUP initialized to NULL.  Upon    return, if *CLEANUP is no longer NULL, it will be a CLEANUP_STMT    that should be inserted after the returned expression is used to    initialize DECL.     Return the converted expression.  */
end_comment

begin_function
name|tree
name|initialize_reference
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
modifier|*
name|cleanup
parameter_list|)
block|{
name|tree
name|conv
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|conv
operator|=
name|reference_binding
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conv
operator|||
name|ICS_BAD_FLAG
argument_list|(
name|conv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|&&
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid initialization of non-const reference of "
literal|"type '%T' from a temporary of type '%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid initialization of reference of type "
literal|"'%T' from expression of type '%T'"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If DECL is non-NULL, then this special rule applies:         [class.temporary]         The temporary to which the reference is bound or the temporary        that is the complete object to which the reference is bound        persists for the lifetime of the reference.         The temporaries created during the evaluation of the expression        initializing the reference, except the temporary to which the        reference is bound, are destroyed at the end of the        full-expression in which they are created.       In that case, we store the converted expression into a new      VAR_DECL in a new scope.         However, we want to be careful not to create temporaries when      they are not required.  For example, given:         struct B {};         struct D : public B {};        D f();        const B& b = f();       there is no need to copy the return value from "f"; we can just      extend its lifetime.  Similarly, given:         struct S {};        struct T { operator S(); };        T t;        const S& s = t;      we can extend the lifetime of the return value of the conversion     operator.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|REF_BIND
argument_list|,
literal|20030302
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|base_conv_type
decl_stmt|;
comment|/* Skip over the REF_BIND.  */
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the next conversion is a BASE_CONV, skip that too -- but 	 remember that the conversion was required.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|conv
argument_list|)
operator|==
name|BASE_CONV
operator|&&
operator|!
name|NEED_TEMPORARY_P
argument_list|(
name|conv
argument_list|)
condition|)
block|{
if|if
condition|(
name|CHECK_COPY_CONSTRUCTOR_P
argument_list|(
name|conv
argument_list|)
condition|)
name|check_constructor_callable
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|base_conv_type
operator|=
name|TREE_TYPE
argument_list|(
name|conv
argument_list|)
expr_stmt|;
name|conv
operator|=
name|TREE_OPERAND
argument_list|(
name|conv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|base_conv_type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Perform the remainder of the conversion.  */
name|expr
operator|=
name|convert_like_real
argument_list|(
name|conv
argument_list|,
name|expr
argument_list|,
comment|/*fn=*/
name|NULL_TREE
argument_list|,
comment|/*argnum=*/
literal|0
argument_list|,
comment|/*inner=*/
operator|-
literal|1
argument_list|,
comment|/*issue_conversion_warnings=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|init
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Create the temporary variable.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|var
operator|=
name|make_temporary_var_for_ref_to_temp
argument_list|(
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the rvalue is the result of a function call it will be 	     a TARGET_EXPR.  If it is some other construct (such as a 	     member access expression where the underlying object is 	     itself the result of a function call), turn it into a 	     TARGET_EXPR here.  It is important that EXPR be a 	     TARGET_EXPR below since otherwise the INIT_EXPR will 	     attempt to make a bitwise copy of EXPR to intialize 	     VAR. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|TARGET_EXPR
condition|)
name|expr
operator|=
name|get_target_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Create the INIT_EXPR that will initialize the temporary 	     variable.  */
name|init
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|var
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
block|{
name|add_decl_stmt
argument_list|(
name|var
argument_list|)
expr_stmt|;
operator|*
name|cleanup
operator|=
name|cxx_maybe_build_cleanup
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cleanup
condition|)
comment|/* We must be careful to destroy the temporary only 		   after its initialization has taken place.  If the 		   initialization throws an exception, then the 		   destructor should not be run.  We cannot simply 		   transform INIT into something like: 	      		     (INIT, ({ CLEANUP_STMT; }))  		   because emit_local_var always treats the 		   initializer as a full-expression.  Thus, the 		   destructor would run too early; it would run at the 		   end of initializing the reference variable, rather 		   than at the end of the block enclosing the 		   reference variable.  		   The solution is to pass back a CLEANUP_STMT which 		   the caller is responsible for attaching to the 		   statement tree.  */
operator|*
name|cleanup
operator|=
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|var
argument_list|,
operator|*
name|cleanup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rest_of_decl_compilation
argument_list|(
name|var
argument_list|,
name|NULL
argument_list|,
comment|/*toplev=*/
literal|1
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|static_aggregates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
comment|/* Use its address to initialize the reference variable.  */
name|expr
operator|=
name|build_address
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|init
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Take the address of EXPR.  */
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If a BASE_CONV was required, perform it now.  */
if|if
condition|(
name|base_conv_type
condition|)
name|expr
operator|=
operator|(
name|perform_implicit_conversion
argument_list|(
name|build_pointer_type
argument_list|(
name|base_conv_type
argument_list|)
argument_list|,
name|expr
argument_list|)
operator|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/* Perform the conversion.  */
return|return
name|convert_like
argument_list|(
name|conv
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-call.h"
end_include

end_unit

