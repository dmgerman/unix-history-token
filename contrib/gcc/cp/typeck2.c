begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Report error messages, build initializers, and perform    some front-end optimizations for C++ compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C++ front end.    It contains routines to build C++ expressions given their operands,    including computing the types of the result, C and C++ specific error    checks, and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_decl_stmt
specifier|static
name|tree
name|process_init_constructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print an error message stemming from an attempt to use    BASETYPE as a base class for TYPE.  */
end_comment

begin_function
name|tree
name|error_not_base_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"type `%T' is not a base type for type `%T'"
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|binfo_or_else
parameter_list|(
name|base
parameter_list|,
name|type
parameter_list|)
name|tree
name|base
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|type
argument_list|,
name|base
argument_list|,
name|ba_ignore
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|binfo
condition|)
name|error_not_base_type
argument_list|(
name|base
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* According to ARM $7.1.6, "A `const' object may be initialized, but its    value may not be changed thereafter.  Thus, we emit hard errors for these,    rather than just pedwarns.  If `SOFT' is 1, then we just pedwarn.  (For    example, conversions to references.)  */
end_comment

begin_function
name|void
name|readonly_error
parameter_list|(
name|arg
parameter_list|,
name|string
parameter_list|,
name|soft
parameter_list|)
name|tree
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|soft
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|void
argument_list|(
argument|*fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|soft
condition|)
name|fn
operator|=
name|pedwarn
expr_stmt|;
else|else
name|fn
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|fmt
operator|=
literal|"%s of data-member `%D' in read-only structure"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"%s of read-only data-member `%D'"
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|fmt
argument_list|,
name|string
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|arg
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
condition|)
name|fmt
operator|=
literal|"%s of constant field `%D'"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"%s of read-only variable `%D'"
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|fmt
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PARM_DECL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only parameter `%D'"
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only reference `%D'"
argument_list|,
name|string
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RESULT_DECL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only named return value `%D'"
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of function `%D'"
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE has abstract virtual functions, issue an error about trying    to create an object of that type.  DECL is the object declared, or    NULL_TREE if the declaration is unavailable.  Returns 1 if an error    occurred; zero if all was well.  */
end_comment

begin_function
name|int
name|abstract_virtuals_error
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|u
decl_stmt|;
name|tree
name|tu
decl_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* TYPE is being defined, and during that time        CLASSTYPE_PURE_VIRTUALS holds the inline friends.  */
return|return
literal|0
return|;
name|u
operator|=
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"cannot declare variable `%D' to be of type `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|error
argument_list|(
literal|"cannot declare parameter `%D' to be of type `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error
argument_list|(
literal|"cannot declare field `%D' to be of type `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|error
argument_list|(
literal|"invalid return type for member function `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|error
argument_list|(
literal|"invalid return type for function `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"cannot allocate an object of type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Only go through this once.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|u
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|u
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|error
argument_list|(
literal|"  because the following virtual functions are abstract:"
argument_list|)
expr_stmt|;
for|for
control|(
name|tu
operator|=
name|u
init|;
name|tu
condition|;
name|tu
operator|=
name|TREE_CHAIN
argument_list|(
name|tu
argument_list|)
control|)
name|cp_error_at
argument_list|(
literal|"\t%#D"
argument_list|,
name|TREE_VALUE
argument_list|(
name|tu
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"  since type `%T' has abstract virtual functions"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|decl
init|=
literal|0
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"`%D' has incomplete type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|1
expr_stmt|;
block|}
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
operator|!
name|decl
condition|)
name|error
argument_list|(
literal|"invalid use of undefined type `%#T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"forward declaration of `%#T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|bad_member
label|:
name|error
argument_list|(
literal|"invalid use of member (did you forget the `&' ?)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|error
argument_list|(
literal|"invalid use of template type parameter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
goto|goto
name|bad_member
goto|;
elseif|else
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|error
argument_list|(
literal|"address of overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|error
argument_list|(
literal|"overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"insufficient contextual information to determine type"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.     C++: Note that INIT might be a TREE_LIST, which would mean that it is    a base class initializer for some aggregate type, hopefully compatible    with DECL.  If INIT is a single element, and DECL is an aggregate    type, we silently convert INIT into a TREE_LIST, allowing a constructor    to be called.     If INIT is a TREE_LIST and there is no constructor, turn INIT    into a CONSTRUCTOR and use standard initialization techniques.    Perhaps a warning should be generated?     Returns value of initializer if initialization could not be    performed for static variable.  In that case, caller must do    the storing.  */
end_comment

begin_function
name|tree
name|store_init_value
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|NULL_TREE
return|;
if|#
directive|if
literal|0
comment|/* This breaks arrays, and should not have any effect for other decls.  */
comment|/* Take care of C++ business up here.  */
block|type = TYPE_MAIN_VARIANT (type);
endif|#
directive|endif
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"constructor syntax used, but no constructor declared for type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (TREE_CODE (init) == CONSTRUCTOR) 	{ 	  tree field;
comment|/* Check that we're really an aggregate as ARM 8.4.1 defines it.  */
block|if (CLASSTYPE_N_BASECLASSES (type)) 	    cp_error_at ("initializer list construction invalid for derived class object `%D'", decl); 	  if (CLASSTYPE_VTBL_PTR (type)) 	    cp_error_at ("initializer list construction invalid for polymorphic class object `%D'", decl); 	  if (TYPE_NEEDS_CONSTRUCTING (type)) 	    { 	      cp_error_at ("initializer list construction invalid for `%D'", decl); 	      error ("due to the presence of a constructor"); 	    } 	  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field)) 	    if (TREE_PRIVATE (field) || TREE_PROTECTED (field)) 	      { 		cp_error_at ("initializer list construction invalid for `%D'", decl); 		cp_error_at ("due to non-public access of member `%D'", field); 	      } 	  for (field = TYPE_METHODS (type); field; field = TREE_CHAIN (field)) 	    if (TREE_PRIVATE (field) || TREE_PROTECTED (field)) 	      { 		cp_error_at ("initializer list construction invalid for `%D'", decl); 		cp_error_at ("due to non-public access of member `%D'", field); 	      } 	}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comma expression used to initialize return value"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize arrays using this syntax"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
comment|/* We get here with code like `int a (2);' */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* End of special C++ code.  */
comment|/* We might have already run this bracketed initializer through      digest_init.  Don't do so again.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|value
operator|=
name|init
expr_stmt|;
else|else
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
empty_stmt|;
comment|/* Other code expects that initializers for objects of types that need      constructing never make it into DECL_INITIAL, and passes 'init' to      build_aggr_init without checking DECL_INITIAL.  So just return.  */
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value
return|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|||
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
if|#
directive|if
literal|0
comment|/* A STATIC PUBLIC int variable doesn't have to be 		  run time inited when doing pic.  (mrs) */
comment|/* Since ctors and dtors are the only things that can 		  reference vtables, and they are always written down 		  the vtable definition, we can leave the 		  vtables in initialized data space. 		  However, other initialized data cannot be initialized 		  this way.  Instead a global file-level initializer 		  must do the job.  */
expr||| (flag_pic&& !DECL_VIRTUAL_P (decl)&& TREE_PUBLIC (decl))
endif|#
directive|endif
operator|)
condition|)
return|return
name|value
return|;
if|#
directive|if
literal|0
comment|/* No, that's C.  jason 9/19/94 */
block|else     {       if (pedantic&& TREE_CODE (value) == CONSTRUCTOR) 	{ 	  if (! TREE_CONSTANT (value) || ! TREE_STATIC (value)) 	    pedwarn ("ISO C++ forbids non-constant aggregate initializer expressions"); 	}     }
endif|#
directive|endif
comment|/* Store the VALUE in DECL_INITIAL.  If we're building a      statement-tree we will actually expand the initialization later      when we output this function.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     If TAIL is nonzero, it points to a variable holding a list of elements    of which INIT is the first.  We update the list stored there by    removing from the head all the elements that we use.    Normally this is only one; we use more than one element only if    TYPE is an aggregate and INIT is not a constructor.  */
end_comment

begin_function
name|tree
name|digest_init
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|tail
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|element
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|old_tail_contents
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR      tree node which has no TREE_TYPE.  */
name|int
name|raw_constructor
decl_stmt|;
comment|/* By default, assume we use one element from a list.      We correct this later in the sole case where it is not true.  */
if|if
condition|(
name|tail
condition|)
block|{
name|old_tail_contents
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ERROR_MARK
condition|)
comment|/* __PRETTY_FUNCTION__'s initializer is a bogus expression inside        a template function. This gets substituted during instantiation. */
return|return
name|init
return|;
comment|/* We must strip the outermost array type when completing the type,      because the its bounds might be incomplete at the moment.  */
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|type
condition|)
return|return
name|init
return|;
name|raw_constructor
operator|=
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|raw_constructor
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|element
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|element
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|element
operator|=
name|TREE_OPERAND
argument_list|(
name|element
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|error_mark_node
condition|)
return|return
name|element
return|;
block|}
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"initializing array with parameter list"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|typ1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_type_p
argument_list|(
name|typ1
argument_list|)
operator|&&
operator|(
operator|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|||
operator|(
name|element
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
block|{
name|tree
name|string
init|=
name|element
condition|?
name|element
else|:
name|init
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|BITS_PER_UNIT
condition|)
block|{
name|error
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|BITS_PER_UNIT
condition|)
block|{
name|error
argument_list|(
literal|"int-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* In C it is ok to subtract 1 from the length of the string 		 because it's ok to ignore the terminating null char that is 		 counted in the length of the constant, but in C++ this would 		 be invalid.  */
if|if
condition|(
name|size
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
block|}
comment|/* Handle scalar types, including conversions,      and signature pointers and references.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
operator|||
name|code
operator|==
name|BOOLEAN_TYPE
operator|||
name|code
operator|==
name|COMPLEX_TYPE
operator|||
name|code
operator|==
name|VECTOR_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
block|{
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"initializer for scalar variable requires one element"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|init
operator|=
name|element
expr_stmt|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"braces around scalar initializer for `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|init
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ignoring extra initializers for `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
return|return
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"initialization"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Come here only for records and arrays (and unions with constructors).  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object of type `%T' may not be initialized"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|||
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|raw_constructor
operator|&&
name|TYPE_NON_AGGREGATE_CLASS
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"subobject of type `%T' must be initialized by constructor, not by `%E'"
argument_list|,
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|raw_constructor
condition|)
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|can_convert_arg
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|)
operator|||
name|TYPE_NON_AGGREGATE_CLASS
argument_list|(
name|type
argument_list|)
condition|)
comment|/* These are never initialized from multiple constructor elements.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
operator|*
name|tail
operator|=
name|old_tail_contents
expr_stmt|;
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|tail
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|int
name|flags
init|=
name|LOOKUP_NORMAL
decl_stmt|;
comment|/* Initialization from { } is copy-initialization.  */
if|if
condition|(
name|tail
condition|)
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
return|return
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|flags
argument_list|,
literal|"initialization"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"invalid initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Process a constructor for a variable of type TYPE.    The constructor elements may be specified either with INIT or with ELTS,    only one of which should be non-null.     If INIT is specified, it is a CONSTRUCTOR node which is specifically    and solely for initializing this datum.     If ELTS is specified, it is the address of a variable containing    a list of expressions.  We take as many elements as we need    from the head of the list and update the list.     In the resulting constructor, TREE_CONSTANT is set if all elts are    constant, and TREE_STATIC is set if, in addition, all elts are simple enough    constants that the assembler and linker can compute them.  */
end_comment

begin_function
specifier|static
name|tree
name|process_init_constructor
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|elts
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|elts
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* List of the elements of the result constructor,      in reverse order.  */
specifier|register
name|tree
name|members
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|next1
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|allconstant
init|=
literal|1
decl_stmt|;
name|int
name|allsimple
init|=
literal|1
decl_stmt|;
name|int
name|erroneous
init|=
literal|0
decl_stmt|;
comment|/* Make TAIL be the list of elements to use for the initialization,      no matter how the data was given to us.  */
if|if
condition|(
name|elts
condition|)
block|{
if|if
condition|(
name|warn_missing_braces
condition|)
name|warning
argument_list|(
literal|"aggregate has a partly bracketed initializer"
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|*
name|elts
expr_stmt|;
block|}
else|else
name|tail
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Gobble as many elements as needed, and make a constructor or initial value      for each element of this aggregate.  Chain them together in result.      If there are too few, use 0 for each scalar ultimate component.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|long
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|domain
condition|)
name|len
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|len
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Take as many as there are */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|<
literal|0
operator|||
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|compare_tree_int
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|sorry
argument_list|(
literal|"non-trivial labeled initializers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
return|return
name|next1
return|;
name|my_friendly_assert
argument_list|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
argument_list|,
literal|981123
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|tail1
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|319
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|tail1
operator|&&
name|len
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"non-empty initializer for array of empty elements"
argument_list|)
expr_stmt|;
comment|/* Just ignore what we were supposed to use.  */
name|tail1
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
comment|/* We're done.  */
break|break;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this type needs constructors run for 		 default-initialization, we can't rely on the backend to do it 		 for us, so build up TARGET_EXPRs.  If the type in question is 		 a class, just build one up; if it's an array, recurse.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|next1
operator|=
name|build_functional_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|next1
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|next1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The default zero-initialization is fine for us; don't 	       add anything to the CONSTRUCTOR.  */
break|break;
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|i
argument_list|)
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
specifier|register
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"initializer list for object of class with virtual base classes"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"initializer list for object of class with base classes"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sorry
argument_list|(
literal|"initializer list for object using virtual functions"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|integer_zero_node
argument_list|,
name|members
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|field
operator|&&
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"non-trivial labeled initializers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|tail1
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|320
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this type needs constructors run for 		 default-initialization, we can't rely on the backend to do it 		 for us, so build up TARGET_EXPRs.  If the type in question is 		 a class, just build one up; if it's an array, recurse.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|next1
operator|=
name|build_functional_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
name|next1
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|next1
argument_list|)
operator|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|next1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Warn when some struct elements are implicitly initialized.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|(
operator|!
name|init
operator|||
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"missing initializer for member `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|error
argument_list|(
literal|"uninitialized const member `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"member `%D' with uninitialized const fields"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|error
argument_list|(
literal|"member `%D' is uninitialized reference"
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* Warn when some struct elements are implicitly initialized 		 to zero.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|(
operator|!
name|init
operator|||
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"missing initializer for member `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* The default zero-initialization is fine for us; don't 		 add anything to the CONSTRUCTOR.  */
continue|continue;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
comment|/* If the initializer was empty, use default zero initialization.  */
operator|&&
name|tail
condition|)
block|{
specifier|register
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Find the first named field.  ANSI decided in September 1990 	 that only named fields count here.  */
while|while
condition|(
name|field
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* If this element specifies a field, initialize via that field.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
comment|/* Handle the case of a call by build_c_cast.  */
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|,
name|win
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"index value instead of field name in union initializer"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|temp
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|temp
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
if|if
condition|(
name|temp
condition|)
name|field
operator|=
name|temp
operator|,
name|win
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no field `%D' in union being initialized"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"union `%T' with no named members cannot be initialized"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
name|next1
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|&
name|tail1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
comment|/* If arguments were specified as a list, just remove the ones we used.  */
if|if
condition|(
name|elts
condition|)
operator|*
name|elts
operator|=
name|tail
expr_stmt|;
comment|/* If arguments were specified as a constructor,      complain unless we used all the elements of the constructor.  */
elseif|else
if|if
condition|(
name|tail
condition|)
name|pedwarn
argument_list|(
literal|"excess elements in aggregate initializer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|erroneous
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|members
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|allconstant
condition|)
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allconstant
operator|&&
name|allsimple
condition|)
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a structure or union value DATUM, construct and return    the structure or union component which results from narrowing    that value by the type specified in BASETYPE.  For example, given the    hierarchy     class L { int ii; };    class A : L { ... };    class B : L { ... };    class C : A, B { ... };     and the declaration     C x;     then the expression     x.A::ii refers to the ii member of the L part of    the A part of the C object named by X.  In this case,    DATUM would be x, and BASETYPE would be A.     I used to think that this was nonconformant, that the standard specified    that first we look up ii in A, then convert x to an L& and pull out the    ii part.  But in fact, it does say that we convert x to an A&; A here    is known as the "naming class".  (jason 2000-12-19) */
end_comment

begin_function
name|tree
name|build_scoped_ref
parameter_list|(
name|datum
parameter_list|,
name|basetype
parameter_list|)
name|tree
name|datum
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
block|{
name|tree
name|ref
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|binfo
condition|)
return|return
name|error_not_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|,
name|basetype
argument_list|)
return|;
name|ref
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ref
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|ref
argument_list|,
literal|"(compiler error in build_scoped_ref)"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a reference to an object specified by the C++ `->' operator.    Usually this just involves dereferencing the object, but if the    `->' operator is overloaded, then such overloads must be    performed until an object which does not have the `->' operator    overloaded is found.  An error is reported when circular pointer    delegation is detected.  */
end_comment

begin_function
name|tree
name|build_x_arrow
parameter_list|(
name|datum
parameter_list|)
name|tree
name|datum
decl_stmt|;
block|{
name|tree
name|types_memoized
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|rval
init|=
name|datum
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
decl_stmt|;
name|tree
name|last_rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|ARROW_EXPR
argument_list|,
name|rval
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|rval
operator|=
name|resolve_offset_ref
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|rval
operator|=
name|convert_from_reference
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|rval
operator|=
name|build_opfncall
argument_list|(
name|COMPONENT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|value_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|types_memoized
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"circular pointer delegation detected"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|types_memoized
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|types_memoized
argument_list|)
expr_stmt|;
block|}
name|last_rval
operator|=
name|rval
expr_stmt|;
block|}
if|if
condition|(
name|last_rval
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"base operand of `->' has non-pointer type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|last_rval
operator|=
name|convert_from_reference
argument_list|(
name|last_rval
argument_list|)
expr_stmt|;
block|}
else|else
name|last_rval
operator|=
name|default_conversion
argument_list|(
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|build_indirect_ref
argument_list|(
name|last_rval
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|types_memoized
condition|)
name|error
argument_list|(
literal|"result of `operator->()' yields non-pointer result"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"base operand of `->' is not a pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an arbitrary    expression.  DATUM has not already been checked out to be of    aggregate type.     For C++, COMPONENT may be a TREE_LIST.  This happens when we must    return an object of member type to a method of the current class,    but there is not yet enough typing information to know which one.    As a special case, if there is only one method by that name,    it is returned.  Otherwise we return an expression which other    routines will have to know how to deal with later.  */
end_comment

begin_function
name|tree
name|build_m_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|objtype
decl_stmt|;
name|tree
name|field_type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|DOTSTAR_EXPR
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
name|datum
operator|=
name|decay_conversion
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
operator|||
name|component
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|objtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the type of the field, as described in [expr.ref].  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* The standard says that the type of the result should be the        	   type referred to by the reference.  But for now, at least,        	   we do the conversion from reference type later.  */
empty_stmt|;
else|else
block|{
name|type_quals
operator|=
operator|(
name|cp_type_quals
argument_list|(
name|field_type
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* There's no such thing as a mutable pointer-to-member, so 	     we don't need to deal with that here like we do in 	     build_component_ref.  */
name|field_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|field_type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"`%E' cannot be used as a member pointer, since it is of type `%T'"
argument_list|,
name|component
argument_list|,
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|objtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot apply member pointer `%E' to `%E', which is of non-aggregate type `%T'"
argument_list|,
name|component
argument_list|,
name|datum
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|binfo
operator|=
name|lookup_base
argument_list|(
name|objtype
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|error
argument_list|(
literal|"member type `%T::' incompatible with object type `%T'"
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|component
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|field_type
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|component
operator|=
name|resolve_offset_ref
argument_list|(
name|component
argument_list|)
expr_stmt|;
return|return
name|component
return|;
block|}
end_function

begin_comment
comment|/* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */
end_comment

begin_function
name|tree
name|build_functional_cast
parameter_list|(
name|exp
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
comment|/* This is either a call to a constructor,      or a C cast in C++'s `functional' notation.  */
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* Either an enum or an aggregate type.  */
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|lookup_name
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"`%T' fails to be a typedef or built-in type"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|CAST_EXPR
argument_list|,
name|type
argument_list|,
name|parms
argument_list|)
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* this must build a C cast */
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
name|parms
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
name|parms
operator|=
name|build_compound_expr
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|parms
argument_list|)
return|;
block|}
comment|/* Prepare to evaluate as a call to a constructor.  If this expression      is actually used, for example, 	       return X (arg1, arg2, ...); 	       then the slot being initialized will be filled in.  */
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|parms
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
return|;
comment|/* We need to zero-initialize POD types.  Let's do that for everything      that doesn't need a constructor.  */
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|get_target_expr
argument_list|(
name|exp
argument_list|)
return|;
block|}
name|exp
operator|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|parms
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Complain about defining new types in inappropriate places.  We give an    exception for C-style casts, to accommodate GNU C stylings.  */
end_comment

begin_function
name|void
name|check_for_new_type
parameter_list|(
name|string
parameter_list|,
name|inptree
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|flagged_type_tree
name|inptree
decl_stmt|;
block|{
if|if
condition|(
name|inptree
operator|.
name|new_type_flag
operator|&&
operator|(
name|pedantic
operator|||
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"cast"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids defining types within %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add new exception specifier SPEC, to the LIST we currently have.    If it's already in LIST then do nothing.    Moan if it's bad and we're allowed to. COMPLAIN< 0 means we    know what we're doing.  */
end_comment

begin_function
name|tree
name|add_exception_specifier
parameter_list|(
name|list
parameter_list|,
name|spec
parameter_list|,
name|complain
parameter_list|)
name|tree
name|list
decl_stmt|,
name|spec
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|tree
name|core
init|=
name|spec
decl_stmt|;
name|int
name|is_ptr
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|error_mark_node
condition|)
return|return
name|list
return|;
name|my_friendly_assert
argument_list|(
name|spec
operator|&&
operator|(
operator|!
name|list
operator|||
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|)
argument_list|,
literal|19990317
argument_list|)
expr_stmt|;
comment|/* [except.spec] 1, type in an exception specifier shall not be      incomplete, or pointer or ref to incomplete other than pointer      to cv void.  */
name|is_ptr
operator|=
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|POINTER_TYPE
expr_stmt|;
if|if
condition|(
name|is_ptr
operator|||
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|core
operator|=
name|TREE_TYPE
argument_list|(
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|complain
operator|<
literal|0
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|core
argument_list|)
condition|)
name|ok
operator|=
name|is_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|processing_template_decl
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
else|else
name|ok
operator|=
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|list
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|spec
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|probe
condition|)
block|{
name|spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|spec
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|complain
condition|)
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|core
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Combine the two exceptions specifier lists LIST and ADD, and return    their union. */
end_comment

begin_function
name|tree
name|merge_exception_specifiers
parameter_list|(
name|list
parameter_list|,
name|add
parameter_list|)
name|tree
name|list
decl_stmt|,
name|add
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|add
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|add
return|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|add
argument_list|)
condition|)
return|return
name|list
return|;
else|else
block|{
name|tree
name|orig_list
init|=
name|list
decl_stmt|;
for|for
control|(
init|;
name|add
condition|;
name|add
operator|=
name|TREE_CHAIN
argument_list|(
name|add
argument_list|)
control|)
block|{
name|tree
name|spec
init|=
name|TREE_VALUE
argument_list|(
name|add
argument_list|)
decl_stmt|;
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|orig_list
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|spec
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|probe
condition|)
block|{
name|spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|spec
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function

end_unit

