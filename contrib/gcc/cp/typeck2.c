begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Report error messages, build initializers, and perform    some front-end optimizations for C++ compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2004, 2005, 2006    Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C++ front end.    It contains routines to build C++ expressions given their operands,    including computing the types of the result, C and C++ specific error    checks, and some optimization.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_function_decl
specifier|static
name|tree
name|process_init_constructor
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print an error message stemming from an attempt to use    BASETYPE as a base class for TYPE.  */
end_comment

begin_function
name|tree
name|error_not_base_type
parameter_list|(
name|tree
name|basetype
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"type %qT is not a base type for type %qT"
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|binfo_or_else
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|type
argument_list|,
name|base
argument_list|,
name|ba_unique
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|binfo
condition|)
name|error_not_base_type
argument_list|(
name|base
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|binfo
return|;
block|}
end_function

begin_comment
comment|/* According to ARM $7.1.6, "A `const' object may be initialized, but its    value may not be changed thereafter.  Thus, we emit hard errors for these,    rather than just pedwarns.  If `SOFT' is 1, then we just pedwarn.  (For    example, conversions to references.)  */
end_comment

begin_function
name|void
name|readonly_error
parameter_list|(
name|tree
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|soft
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTRIBUTE_GCC_CXXDIAG
parameter_list|(
function_decl|1
operator|,
function_decl|2
block|)
function|;
end_function

begin_if
if|if
condition|(
name|soft
condition|)
name|fn
operator|=
name|pedwarn
expr_stmt|;
else|else
name|fn
operator|=
name|error
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|fmt
operator|=
literal|"%s of data-member %qD in read-only structure"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"%s of read-only data-member %qD"
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|fmt
argument_list|,
name|string
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|arg
argument_list|)
operator|&&
name|DECL_IN_AGGR_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
condition|)
name|fmt
operator|=
literal|"%s of constant field %qD"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"%s of read-only variable %qD"
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|fmt
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PARM_DECL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only parameter %qD"
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only reference %qD"
argument_list|,
name|string
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RESULT_DECL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only named return value %qD"
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of function %qD"
argument_list|,
name|string
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|fn
call|)
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|string
argument_list|)
expr_stmt|;
end_if

begin_escape
unit|}
end_escape

begin_comment
comment|/* Structure that holds information about declarations whose type was    incomplete and we could not check whether it was abstract or not.  */
end_comment

begin_decl_stmt
unit|struct
name|pending_abstract_type
name|GTY
argument_list|(
operator|(
name|chain_next
argument_list|(
literal|"%h.next"
argument_list|)
operator|)
argument_list|)
block|{
comment|/* Declaration which we are checking for abstractness. It is either      a DECL node, or an IDENTIFIER_NODE if we do not have a full      declaration available.  */
name|tree
name|decl
decl_stmt|;
comment|/* Type which will be checked for abstractness.  */
name|tree
name|type
decl_stmt|;
comment|/* Position of the declaration. This is only needed for IDENTIFIER_NODEs,      because DECLs already carry locus information.  */
name|location_t
name|locus
decl_stmt|;
comment|/* Link to the next element in list.  */
name|struct
name|pending_abstract_type
modifier|*
name|next
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Compute the hash value of the node VAL. This function is used by the    hash table abstract_pending_vars.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|pat_calc_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|val
parameter_list|)
block|{
specifier|const
name|struct
name|pending_abstract_type
modifier|*
name|pat
init|=
operator|(
specifier|const
expr|struct
name|pending_abstract_type
operator|*
operator|)
name|val
decl_stmt|;
return|return
operator|(
name|hashval_t
operator|)
name|TYPE_UID
argument_list|(
name|pat
operator|->
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare node VAL1 with the type VAL2. This function is used by the    hash table abstract_pending_vars.  */
end_comment

begin_function
specifier|static
name|int
name|pat_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|val1
parameter_list|,
specifier|const
name|void
modifier|*
name|val2
parameter_list|)
block|{
specifier|const
name|struct
name|pending_abstract_type
modifier|*
name|pat1
init|=
operator|(
specifier|const
expr|struct
name|pending_abstract_type
operator|*
operator|)
name|val1
decl_stmt|;
name|tree
name|type2
init|=
operator|(
name|tree
operator|)
name|val2
decl_stmt|;
return|return
operator|(
name|pat1
operator|->
name|type
operator|==
name|type2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hash table that maintains pending_abstract_type nodes, for which we still    need to check for type abstractness.  The key of the table is the type    of the declaration.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct pending_abstract_type))
argument_list|)
name|htab_t
name|abstract_pending_vars
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This function is called after TYPE is completed, and will check if there    are pending declarations for which we still need to verify the abstractness    of TYPE, and emit a diagnostic (through abstract_virtuals_error) if TYPE    turned out to be incomplete.  */
end_comment

begin_function
name|void
name|complete_type_check_abstract
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|pending_abstract_type
modifier|*
name|pat
decl_stmt|;
name|location_t
name|cur_loc
init|=
name|input_location
decl_stmt|;
name|gcc_assert
argument_list|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abstract_pending_vars
condition|)
return|return;
comment|/* Retrieve the list of pending declarations for this type.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|abstract_pending_vars
argument_list|,
name|type
argument_list|,
operator|(
name|hashval_t
operator|)
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return;
name|pat
operator|=
operator|(
expr|struct
name|pending_abstract_type
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|gcc_assert
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* If the type is not abstract, do not do anything.  */
if|if
condition|(
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|pending_abstract_type
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Reverse the list to emit the errors in top-down order.  */
for|for
control|(
init|;
name|pat
condition|;
name|pat
operator|=
name|next
control|)
block|{
name|next
operator|=
name|pat
operator|->
name|next
expr_stmt|;
name|pat
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|pat
expr_stmt|;
block|}
name|pat
operator|=
name|prev
expr_stmt|;
comment|/* Go through the list, and call abstract_virtuals_error for each 	element: it will issue a diagnostic if the type is abstract.  */
while|while
condition|(
name|pat
condition|)
block|{
name|gcc_assert
argument_list|(
name|type
operator|==
name|pat
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Tweak input_location so that the diagnostic appears at the correct 	    location. Notice that this is only needed if the decl is an 	    IDENTIFIER_NODE.  */
name|input_location
operator|=
name|pat
operator|->
name|locus
expr_stmt|;
name|abstract_virtuals_error
argument_list|(
name|pat
operator|->
name|decl
argument_list|,
name|pat
operator|->
name|type
argument_list|)
expr_stmt|;
name|pat
operator|=
name|pat
operator|->
name|next
expr_stmt|;
block|}
block|}
name|htab_clear_slot
argument_list|(
name|abstract_pending_vars
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|cur_loc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TYPE has abstract virtual functions, issue an error about trying    to create an object of that type.  DECL is the object declared, or    NULL_TREE if the declaration is unavailable.  Returns 1 if an error    occurred; zero if all was well.  */
end_comment

begin_function
name|int
name|abstract_virtuals_error
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|pure
expr_stmt|;
comment|/* This function applies only to classes. Any other entity can never      be abstract.  */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the type is incomplete, we register it within a hash table,      so that we can check again once it is completed. This makes sense      only for objects for which we have a declaration or at least a      name.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|pending_abstract_type
modifier|*
name|pat
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|decl
operator|||
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abstract_pending_vars
condition|)
name|abstract_pending_vars
operator|=
name|htab_create_ggc
argument_list|(
literal|31
argument_list|,
operator|&
name|pat_calc_hash
argument_list|,
operator|&
name|pat_compare
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|abstract_pending_vars
argument_list|,
name|type
argument_list|,
operator|(
name|hashval_t
operator|)
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|pending_abstract_type
argument_list|)
expr_stmt|;
name|pat
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|pat
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|pat
operator|->
name|locus
operator|=
operator|(
operator|(
name|decl
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|?
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
else|:
name|input_location
operator|)
expr_stmt|;
name|pat
operator|->
name|next
operator|=
operator|(
expr|struct
name|pending_abstract_type
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
operator|*
name|slot
operator|=
name|pat
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* TYPE is being defined, and during that time        CLASSTYPE_PURE_VIRTUALS holds the inline friends.  */
return|return
literal|0
return|;
name|pure
operator|=
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pure
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"cannot declare variable %q+D to be of abstract "
literal|"type %qT"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|error
argument_list|(
literal|"cannot declare parameter %q+D to be of abstract type %qT"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error
argument_list|(
literal|"cannot declare field %q+D to be of abstract type %qT"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|error
argument_list|(
literal|"invalid abstract return type for member function %q+#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|error
argument_list|(
literal|"invalid abstract return type for function %q+#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* Here we do not have location information.  */
name|error
argument_list|(
literal|"invalid abstract type %qT for %qE"
argument_list|,
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid abstract type for %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"cannot allocate an object of abstract type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Only go through this once.  */
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|pure
argument_list|)
condition|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|inform
argument_list|(
literal|"%J  because the following virtual functions are pure "
literal|"within %qT:"
argument_list|,
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|pure
argument_list|,
name|ix
argument_list|,
name|fn
argument_list|)
condition|;
name|ix
operator|++
control|)
name|inform
argument_list|(
literal|"\t%+#D"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Now truncate the vector.  This leaves it non-null, so we know 	 there are pure virtuals, but empty so we don't list them out 	 again.  */
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|pure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|inform
argument_list|(
literal|"%J  since type %qT has pure virtual functions"
argument_list|,
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  DIAG_TYPE indicates the    type of diagnostic:  0 for an error, 1 for a warning, 2 for a    pedwarn.  */
end_comment

begin_function
name|void
name|cxx_incomplete_type_diagnostic
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|diag_type
parameter_list|)
block|{
name|int
name|decl
init|=
literal|0
decl_stmt|;
name|void
function_decl|(
modifier|*
name|p_msg
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTRIBUTE_GCC_CXXDIAG
parameter_list|(
function_decl|1
operator|,
function_decl|2
block|)
function|;
end_function

begin_if
if|if
condition|(
name|diag_type
operator|==
literal|1
condition|)
name|p_msg
operator|=
name|warning0
expr_stmt|;
elseif|else
if|if
condition|(
name|diag_type
operator|==
literal|2
condition|)
name|p_msg
operator|=
name|pedwarn
expr_stmt|;
else|else
name|p_msg
operator|=
name|error
expr_stmt|;
end_if

begin_comment
comment|/* Avoid duplicate error message.  */
end_comment

begin_if
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
end_if

begin_if
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
operator|)
condition|)
block|{
name|p_msg
argument_list|(
literal|"%q+D has incomplete type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_label
name|retry
label|:
end_label

begin_comment
comment|/* We must print an error message.  Be clever about what it says.  */
end_comment

begin_switch
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
operator|!
name|decl
condition|)
name|p_msg
argument_list|(
literal|"invalid use of incomplete type %q#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
name|p_msg
argument_list|(
literal|"forward declaration of %q+#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|p_msg
argument_list|(
literal|"declaration of %q+#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|p_msg
argument_list|(
literal|"invalid use of %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|p_msg
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|bad_member
label|:
name|p_msg
argument_list|(
literal|"invalid use of member (did you forget the %<&%> ?)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|p_msg
argument_list|(
literal|"invalid use of template type parameter %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|p_msg
argument_list|(
literal|"invalid use of template template parameter %qT"
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
name|p_msg
argument_list|(
literal|"invalid use of dependent type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
goto|goto
name|bad_member
goto|;
elseif|else
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|p_msg
argument_list|(
literal|"address of overloaded function with no contextual "
literal|"type information"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|p_msg
argument_list|(
literal|"overloaded function with no contextual type information"
argument_list|)
expr_stmt|;
else|else
name|p_msg
argument_list|(
literal|"insufficient contextual information to determine type"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_switch

begin_comment
unit|}
comment|/* Backward-compatibility interface to incomplete_type_diagnostic;    required by ../tree.c.  */
end_comment

begin_undef
undef|#
directive|undef
name|cxx_incomplete_type_error
end_undef

begin_macro
unit|void
name|cxx_incomplete_type_error
argument_list|(
argument|tree value
argument_list|,
argument|tree type
argument_list|)
end_macro

begin_block
block|{
name|cxx_incomplete_type_diagnostic
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The recursive part of split_nonconstant_init.  DEST is an lvalue    expression to which INIT should be assigned.  INIT is a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|void
name|split_nonconstant_init_1
parameter_list|(
name|tree
name|dest
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|field_index
decl_stmt|,
name|value
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|tree
name|inner_type
init|=
name|NULL
decl_stmt|;
name|bool
name|array_type_p
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|array_type_p
operator|=
name|true
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (init)
argument_list|,
argument|idx
argument_list|,
argument|field_index
argument_list|,
argument|value
argument_list|)
block|{
comment|/* The current implementation of this algorithm assumes that 	     the field was set for all the elements. This is usually done 	     by process_init_constructor.  */
name|gcc_assert
argument_list|(
name|field_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|array_type_p
condition|)
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|field_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|sub
decl_stmt|;
if|if
condition|(
name|array_type_p
condition|)
name|sub
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|inner_type
argument_list|,
name|dest
argument_list|,
name|field_index
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|sub
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|inner_type
argument_list|,
name|dest
argument_list|,
name|field_index
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|split_nonconstant_init_1
argument_list|(
name|sub
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|inner_type
argument_list|)
condition|)
block|{
name|tree
name|code
decl_stmt|;
name|tree
name|sub
decl_stmt|;
comment|/* FIXME: Ordered removal is O(1) so the whole function is 		 worst-case quadratic. This could be fixed using an aside 		 bitmap to record which elements must be removed and remove 		 them all at the same time. Or by merging 		 split_non_constant_init into process_init_constructor_array, 		 that is separating constants from non-constants while building 		 the vector.  */
name|VEC_ordered_remove
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
operator|--
name|idx
expr_stmt|;
if|if
condition|(
name|array_type_p
condition|)
name|sub
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|inner_type
argument_list|,
name|dest
argument_list|,
name|field_index
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|sub
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|inner_type
argument_list|,
name|dest
argument_list|,
name|field_index
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|code
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|inner_type
argument_list|,
name|sub
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|code
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|code
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|init
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|tree
name|code
decl_stmt|;
name|tree
name|cons
init|=
name|copy_node
argument_list|(
name|init
argument_list|)
decl_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|code
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|dest
argument_list|,
name|cons
argument_list|)
expr_stmt|;
name|code
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* The rest of the initializer is now a constant. */
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of store_init_value.  Splits non-constant static    initializer INIT into a constant part and generates code to    perform the non-constant part of the initialization to DEST.    Returns the code for the runtime init.  */
end_comment

begin_function
specifier|static
name|tree
name|split_nonconstant_init
parameter_list|(
name|tree
name|dest
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|code
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|code
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|split_nonconstant_init_1
argument_list|(
name|dest
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|code
operator|=
name|pop_stmt_list
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|dest
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|dest
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|code
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.     C++: Note that INIT might be a TREE_LIST, which would mean that it is    a base class initializer for some aggregate type, hopefully compatible    with DECL.  If INIT is a single element, and DECL is an aggregate    type, we silently convert INIT into a TREE_LIST, allowing a constructor    to be called.     If INIT is a TREE_LIST and there is no constructor, turn INIT    into a CONSTRUCTOR and use standard initialization techniques.    Perhaps a warning should be generated?     Returns code to be executed if initialization could not be performed    for static variable.  In that case, caller must emit the code.  */
end_comment

begin_function
name|tree
name|store_init_value
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"constructor syntax used, but no constructor declared "
literal|"for type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_constructor_from_list
argument_list|(
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|init
operator|=
name|build_x_compound_expr_from_list
argument_list|(
name|init
argument_list|,
literal|"return value initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize arrays using this syntax"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
comment|/* We get here with code like `int a (2);' */
name|init
operator|=
name|build_x_compound_expr_from_list
argument_list|(
name|init
argument_list|,
literal|"initializer"
argument_list|)
expr_stmt|;
block|}
comment|/* End of special C++ code.  */
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
comment|/* If the initializer is not a constant, fill in DECL_INITIAL with      the bits that are constant, and then return an expression that      will perform the dynamic initialization.  */
if|if
condition|(
name|value
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
operator|||
operator|!
name|initializer_constant_valid_p
argument_list|(
name|value
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|split_nonconstant_init
argument_list|(
name|decl
argument_list|,
name|value
argument_list|)
return|;
comment|/* If the value is a constant, just put it in DECL_INITIAL.  If DECL      is an automatic variable, the middle end will turn this into a      dynamic initialization later.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the initializer INIT for a variable of type TYPE, emitting    diagnostics for invalid initializers and converting the initializer as    appropriate.     For aggregate types, it assumes that reshape_init has already run, thus the    initializer will have the right shape (brace elision has been undone).  */
end_comment

begin_function
name|tree
name|digest_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* We must strip the outermost array type when completing the type,      because the its bounds might be incomplete at the moment.  */
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue      (g++.old-deja/g++.law/casts2.C).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialization of an array of chars from a string constant. The initializer      can be optionally enclosed in braces, but reshape_init has already removed      them if they were present.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|char_type_p
argument_list|(
name|typ1
argument_list|)
comment|/*&& init */
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|tree
name|char_type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|char_type
operator|!=
name|char_type_node
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|BITS_PER_UNIT
condition|)
block|{
name|error
argument_list|(
literal|"char-array initialized from wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|char_type
operator|==
name|char_type_node
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|BITS_PER_UNIT
condition|)
block|{
name|error
argument_list|(
literal|"int-array initialized from non-wide string"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* In C it is ok to subtract 1 from the length of the string 		 because it's ok to ignore the terminating null char that is 		 counted in the length of the constant, but in C++ this would 		 be invalid.  */
if|if
condition|(
name|size
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"initializer-string for array of chars is too long"
argument_list|)
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
block|}
comment|/* Handle scalar types (including conversions) and references.  */
if|if
condition|(
name|SCALAR_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|convert_for_initialization
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"initialization"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Come here only for aggregates: records, arrays, unions, complex numbers      and vectors.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
condition|)
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|COMPOUND_LITERAL_P
argument_list|(
name|init
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize aggregate of type %qT with "
literal|"a compound literal"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
block|{
name|error
argument_list|(
literal|"array must be initialized with a brace-enclosed"
literal|" initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|,
literal|"initialization"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set of flags used within process_init_constructor to describe the    initializers.  */
end_comment

begin_define
define|#
directive|define
name|PICFLAG_ERRONEOUS
value|1
end_define

begin_define
define|#
directive|define
name|PICFLAG_NOT_ALL_CONSTANT
value|2
end_define

begin_define
define|#
directive|define
name|PICFLAG_NOT_ALL_SIMPLE
value|4
end_define

begin_comment
comment|/* Given an initializer INIT, return the flag (PICFLAG_*) which better    describe it.  */
end_comment

begin_function
specifier|static
name|int
name|picflag_from_initializer
parameter_list|(
name|tree
name|init
parameter_list|)
block|{
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|PICFLAG_ERRONEOUS
return|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
condition|)
return|return
name|PICFLAG_NOT_ALL_CONSTANT
return|;
elseif|else
if|if
condition|(
operator|!
name|initializer_constant_valid_p
argument_list|(
name|init
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
return|return
name|PICFLAG_NOT_ALL_SIMPLE
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of process_init_constructor, which will process an initializer    INIT for a array or vector of type TYPE. Returns the flags (PICFLAG_*) which    describe the initializers.  */
end_comment

begin_function
specifier|static
name|int
name|process_init_constructor_array
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|bool
name|unbounded
init|=
name|false
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
condition|)
name|len
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|unbounded
operator|=
name|true
expr_stmt|;
comment|/* Take as many as there are.  */
block|}
else|else
comment|/* Vectors are like simple fixed-size arrays.  */
name|len
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* There cannot be more initializers than needed as otherwise      reshape_init would have already rejected the initializer.  */
if|if
condition|(
operator|!
name|unbounded
condition|)
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
operator|<=
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|i
argument_list|,
name|ce
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|index
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|ce
operator|->
name|index
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ce
operator|->
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|sorry
argument_list|(
literal|"non-trivial designated initializers not supported"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ce
operator|->
name|index
operator|=
name|size_int
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|value
operator|!=
name|error_mark_node
condition|)
name|gcc_assert
argument_list|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ce
operator|->
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|picflag_from_initializer
argument_list|(
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* No more initializers. If the array is unbounded, we are done. Otherwise,      we must add initializers ourselves.  */
if|if
condition|(
operator|!
name|unbounded
condition|)
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|next
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this type needs constructors run for default-initialization, 	      we can't rely on the backend to do it for us, so build up 	      TARGET_EXPRs.  If the type in question is a class, just build 	      one up; if it's an array, recurse.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|next
operator|=
name|build_functional_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zero_init_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|next
operator|=
name|build_zero_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*nelts=*/
name|NULL_TREE
argument_list|,
comment|/*static_storage_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
comment|/* The default zero-initialization is fine for us; don't 	     add anything to the CONSTRUCTOR.  */
break|break;
name|flags
operator||=
name|picflag_from_initializer
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|size_int
argument_list|(
name|i
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|=
name|v
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of process_init_constructor, which will process an initializer    INIT for a class of type TYPE. Returns the flags (PICFLAG_*) which describe    the initializers.  */
end_comment

begin_function
specifier|static
name|int
name|process_init_constructor_record
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generally, we will always have an index for each initializer (which is      a FIELD_DECL, put by reshape_init), but compound literals don't go trough      reshape_init. So we need to handle both cases.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|flags
operator||=
name|picflag_from_initializer
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|field
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|<
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
name|constructor_elt
modifier|*
name|ce
init|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|index
condition|)
block|{
comment|/* We can have either a FIELD_DECL or an IDENTIFIER_NODE. The 		 latter case can happen in templates where lookup has to be 		 deferred.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|index
operator|!=
name|field
operator|&&
name|ce
operator|->
name|index
operator|!=
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|ce
operator|->
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|sorry
argument_list|(
literal|"non-trivial designated initializers not supported"
argument_list|)
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
name|next
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this type needs constructors run for 	     default-initialization, we can't rely on the backend to do it 	     for us, so build up TARGET_EXPRs.  If the type in question is 	     a class, just build one up; if it's an array, recurse.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|next
operator|=
name|build_functional_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Warn when some struct elements are implicitly initialized.  */
name|warning
argument_list|(
name|OPT_Wmissing_field_initializers
argument_list|,
literal|"missing initializer for member %qD"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|error
argument_list|(
literal|"uninitialized const member %qD"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %qD with uninitialized const fields"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|error
argument_list|(
literal|"member %qD is uninitialized reference"
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* Warn when some struct elements are implicitly initialized 	     to zero.  */
name|warning
argument_list|(
name|OPT_Wmissing_field_initializers
argument_list|,
literal|"missing initializer for member %qD"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero_init_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|next
operator|=
name|build_zero_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
comment|/*nelts=*/
name|NULL_TREE
argument_list|,
comment|/*static_storage_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
comment|/* The default zero-initialization is fine for us; don't 	    add anything to the CONSTRUCTOR.  */
continue|continue;
block|}
name|flags
operator||=
name|picflag_from_initializer
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|field
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|=
name|v
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of process_init_constructor, which will process a single    initializer INIT for a union of type TYPE. Returns the flags (PICFLAG_*)    which describe the initializer.  */
end_comment

begin_function
specifier|static
name|int
name|process_init_constructor_union
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
comment|/* If the initializer was empty, use default zero initialization.  */
if|if
condition|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ce
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this element specifies a field, initialize via that field.  */
if|if
condition|(
name|ce
operator|->
name|index
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|FIELD_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* This can happen within a cast, see g++.dg/opt/cse2.C.  */
name|tree
name|name
init|=
name|ce
operator|->
name|index
decl_stmt|;
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|name
condition|)
break|break;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
literal|"no field %qD found in union being initialized"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|ce
operator|->
name|index
operator|=
name|field
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
operator|==
name|RANGE_EXPR
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"index value instead of field name in union initializer"
argument_list|)
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Find the first named field.  ANSI decided in September 1990 	 that only named fields count here.  */
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|field
operator|&&
operator|(
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ce
operator|->
name|index
operator|=
name|field
expr_stmt|;
block|}
if|if
condition|(
name|ce
operator|->
name|value
operator|&&
name|ce
operator|->
name|value
operator|!=
name|error_mark_node
condition|)
name|ce
operator|->
name|value
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|ce
operator|->
name|index
argument_list|)
argument_list|,
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|picflag_from_initializer
argument_list|(
name|ce
operator|->
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process INIT, a constructor for a variable of aggregate type TYPE. The    constructor is a brace-enclosed initializer, and will be modified in-place.     Each element is converted to the right type through digest_init, and    missing initializers are added following the language rules (zero-padding,    etc.).     After the execution, the initializer will have TREE_CONSTANT if all elts are    constant, and TREE_STATIC set if, in addition, all elts are simple enough    constants that the assembler and linker can compute them.     The function returns the initializer itself, or error_mark_node in case    of error.  */
end_comment

begin_function
specifier|static
name|tree
name|process_init_constructor
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|gcc_assert
argument_list|(
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|flags
operator|=
name|process_init_constructor_array
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|flags
operator|=
name|process_init_constructor_record
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|flags
operator|=
name|process_init_constructor_union
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PICFLAG_ERRONEOUS
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|cp_complete_array_type
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|,
comment|/*do_default=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PICFLAG_NOT_ALL_CONSTANT
operator|)
condition|)
block|{
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PICFLAG_NOT_ALL_SIMPLE
operator|)
condition|)
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a structure or union value DATUM, construct and return    the structure or union component which results from narrowing    that value to the base specified in BASETYPE.  For example, given the    hierarchy     class L { int ii; };    class A : L { ... };    class B : L { ... };    class C : A, B { ... };     and the declaration     C x;     then the expression     x.A::ii refers to the ii member of the L part of    the A part of the C object named by X.  In this case,    DATUM would be x, and BASETYPE would be A.     I used to think that this was nonconformant, that the standard specified    that first we look up ii in A, then convert x to an L& and pull out the    ii part.  But in fact, it does say that we convert x to an A&; A here    is known as the "naming class".  (jason 2000-12-19)     BINFO_P points to a variable initialized either to NULL_TREE or to the    binfo for the specific base subobject we want to convert to.  */
end_comment

begin_function
name|tree
name|build_scoped_ref
parameter_list|(
name|tree
name|datum
parameter_list|,
name|tree
name|basetype
parameter_list|,
name|tree
modifier|*
name|binfo_p
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|*
name|binfo_p
condition|)
name|binfo
operator|=
operator|*
name|binfo_p
expr_stmt|;
else|else
name|binfo
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
operator|||
name|binfo
operator|==
name|error_mark_node
condition|)
block|{
operator|*
name|binfo_p
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
name|error_not_base_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
operator|*
name|binfo_p
operator|=
name|binfo
expr_stmt|;
return|return
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|datum
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a reference to an object specified by the C++ `->' operator.    Usually this just involves dereferencing the object, but if the    `->' operator is overloaded, then such overloads must be    performed until an object which does not have the `->' operator    overloaded is found.  An error is reported when circular pointer    delegation is detected.  */
end_comment

begin_function
name|tree
name|build_x_arrow
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|orig_expr
init|=
name|expr
decl_stmt|;
name|tree
name|types_memoized
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|last_rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|ARROW_EXPR
argument_list|,
name|expr
argument_list|)
return|;
name|expr
operator|=
name|build_non_dependent_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|expr
operator|=
name|build_new_op
argument_list|(
name|COMPONENT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|value_member
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|types_memoized
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"circular pointer delegation detected"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|types_memoized
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|types_memoized
argument_list|)
expr_stmt|;
block|}
name|last_rval
operator|=
name|expr
expr_stmt|;
block|}
if|if
condition|(
name|last_rval
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"base operand of %<->%> has non-pointer type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|last_rval
operator|=
name|convert_from_reference
argument_list|(
name|last_rval
argument_list|)
expr_stmt|;
block|}
else|else
name|last_rval
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|expr
operator|=
name|build_min_non_dep
argument_list|(
name|ARROW_EXPR
argument_list|,
name|last_rval
argument_list|,
name|orig_expr
argument_list|)
expr_stmt|;
comment|/* It will be dereferenced.  */
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|last_rval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|last_rval
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|types_memoized
condition|)
name|error
argument_list|(
literal|"result of %<operator->()%> yields non-pointer result"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"base operand of %<->%> is not a pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return an expression for "DATUM .* COMPONENT".  DATUM has not    already been checked out to be of aggregate type.  */
end_comment

begin_function
name|tree
name|build_m_component_ref
parameter_list|(
name|tree
name|datum
parameter_list|,
name|tree
name|component
parameter_list|)
block|{
name|tree
name|ptrmem_type
decl_stmt|;
name|tree
name|objtype
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|datum
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|component
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|ptrmem_type
operator|=
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|ptrmem_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE cannot be used as a member pointer, since it is of "
literal|"type %qT"
argument_list|,
name|component
argument_list|,
name|ptrmem_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|objtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|objtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot apply member pointer %qE to %qE, which is of "
literal|"non-class type %qT"
argument_list|,
name|component
argument_list|,
name|datum
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|ptrmem_type
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|complete_type
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|ptrmem_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|ctype
argument_list|,
name|objtype
argument_list|)
condition|)
goto|goto
name|mismatch
goto|;
name|binfo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|binfo
operator|=
name|lookup_base
argument_list|(
name|objtype
argument_list|,
name|ctype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
name|mismatch
label|:
name|error
argument_list|(
literal|"pointer to member type %qT incompatible with object "
literal|"type %qT"
argument_list|,
name|type
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|ptrmem_type
argument_list|)
condition|)
block|{
comment|/* Compute the type of the field, as described in [expr.ref]. 	 There's no such thing as a mutable pointer-to-member, so 	 things are not as complex as they are for references to 	 non-static data members.  */
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|datum
operator|=
name|build_address
argument_list|(
name|datum
argument_list|)
expr_stmt|;
comment|/* Convert object to the correct base.  */
if|if
condition|(
name|binfo
condition|)
name|datum
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|datum
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Build an expression for "object + offset" where offset is the 	 value stored in the pointer-to-data-member.  */
name|datum
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|datum
argument_list|,
name|build_nop
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
return|return
name|build2
argument_list|(
name|OFFSET_REF
argument_list|,
name|type
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */
end_comment

begin_function
name|tree
name|build_functional_cast
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|parms
parameter_list|)
block|{
comment|/* This is either a call to a constructor,      or a C cast in C++'s `functional' notation.  */
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CAST_EXPR
argument_list|,
name|type
argument_list|,
name|parms
argument_list|)
decl_stmt|;
comment|/* We don't know if it will or will not have side effects.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
comment|/* This must build a C cast.  */
name|parms
operator|=
name|build_x_compound_expr_from_list
argument_list|(
name|parms
argument_list|,
literal|"functional cast"
argument_list|)
expr_stmt|;
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|parms
argument_list|)
return|;
block|}
comment|/* Prepare to evaluate as a call to a constructor.  If this expression      is actually used, for example,       return X (arg1, arg2, ...);       then the slot being initialized will be filled in.  */
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|parms
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
return|;
comment|/* We need to zero-initialize POD types.  */
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
operator|&&
operator|!
name|CLASSTYPE_NON_POD_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|get_target_expr
argument_list|(
name|exp
argument_list|)
return|;
block|}
name|exp
operator|=
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|parms
argument_list|,
name|type
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add new exception specifier SPEC, to the LIST we currently have.    If it's already in LIST then do nothing.    Moan if it's bad and we're allowed to. COMPLAIN< 0 means we    know what we're doing.  */
end_comment

begin_function
name|tree
name|add_exception_specifier
parameter_list|(
name|tree
name|list
parameter_list|,
name|tree
name|spec
parameter_list|,
name|int
name|complain
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|tree
name|core
init|=
name|spec
decl_stmt|;
name|bool
name|is_ptr
decl_stmt|;
name|int
name|diag_type
init|=
operator|-
literal|1
decl_stmt|;
comment|/* none */
if|if
condition|(
name|spec
operator|==
name|error_mark_node
condition|)
return|return
name|list
return|;
name|gcc_assert
argument_list|(
name|spec
operator|&&
operator|(
operator|!
name|list
operator|||
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* [except.spec] 1, type in an exception specifier shall not be      incomplete, or pointer or ref to incomplete other than pointer      to cv void.  */
name|is_ptr
operator|=
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|POINTER_TYPE
expr_stmt|;
if|if
condition|(
name|is_ptr
operator|||
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|core
operator|=
name|TREE_TYPE
argument_list|(
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|complain
operator|<
literal|0
condition|)
name|ok
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|core
argument_list|)
condition|)
name|ok
operator|=
name|is_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|ok
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|processing_template_decl
condition|)
name|ok
operator|=
name|true
expr_stmt|;
else|else
block|{
name|ok
operator|=
name|true
expr_stmt|;
comment|/* 15.4/1 says that types in an exception specifier must be complete, 	 but it seems more reasonable to only require this on definitions 	 and calls.  So just give a pedwarn at this point; we will give an 	 error later if we hit one of those two cases.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|core
argument_list|)
argument_list|)
condition|)
name|diag_type
operator|=
literal|2
expr_stmt|;
comment|/* pedwarn */
block|}
if|if
condition|(
name|ok
condition|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|list
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|spec
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|probe
condition|)
name|list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|spec
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
name|diag_type
operator|=
literal|0
expr_stmt|;
comment|/* error */
if|if
condition|(
name|diag_type
operator|>=
literal|0
operator|&&
name|complain
condition|)
name|cxx_incomplete_type_diagnostic
argument_list|(
name|NULL_TREE
argument_list|,
name|core
argument_list|,
name|diag_type
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Combine the two exceptions specifier lists LIST and ADD, and return    their union.  */
end_comment

begin_function
name|tree
name|merge_exception_specifiers
parameter_list|(
name|tree
name|list
parameter_list|,
name|tree
name|add
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|add
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|add
return|;
elseif|else
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|add
argument_list|)
condition|)
return|return
name|list
return|;
else|else
block|{
name|tree
name|orig_list
init|=
name|list
decl_stmt|;
for|for
control|(
init|;
name|add
condition|;
name|add
operator|=
name|TREE_CHAIN
argument_list|(
name|add
argument_list|)
control|)
block|{
name|tree
name|spec
init|=
name|TREE_VALUE
argument_list|(
name|add
argument_list|)
decl_stmt|;
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|orig_list
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|probe
argument_list|)
argument_list|,
name|spec
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|probe
condition|)
block|{
name|spec
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|spec
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of build_call.  Ensure that each of the types in the    exception specification is complete.  Technically, 15.4/1 says that    they need to be complete when we see a declaration of the function,    but we should be able to get away with only requiring this when the    function is defined or called.  See also add_exception_specifier.  */
end_comment

begin_function
name|void
name|require_complete_eh_spec_types
parameter_list|(
name|tree
name|fntype
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|raises
decl_stmt|;
comment|/* Don't complain about calls to op new.  */
if|if
condition|(
name|decl
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
for|for
control|(
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
init|;
name|raises
condition|;
name|raises
operator|=
name|TREE_CHAIN
argument_list|(
name|raises
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|raises
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|error
argument_list|(
literal|"call to function %qD which throws incomplete type %q#T"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"call to function which throws incomplete type %q#T"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_include
include|#
directive|include
file|"gt-cp-typeck2.h"
end_include

end_unit

