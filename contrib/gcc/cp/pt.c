begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle parameterized types (templates) for GNU C++.    Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.    Rewritten by Jason Merrill (jason@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Known bugs or deficiencies include:       all methods must be provided in header files; can't use a source      file that contains only the method templates and "just win".  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* The type of functions taking a tree, and some additional data, and    returning an int.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*tree_fn_t
argument_list|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_template_expansions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_template_parms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|processing_template_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|template_tail
init|=
operator|&
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|maybe_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|maybe_template_tail
init|=
operator|&
name|maybe_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minimal_parse_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_specialization
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_explicit_instantiation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_parmlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_header_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|saved_trees
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_NONE
value|0
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_MORE_CV_QUAL
value|1
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_LESS_CV_QUAL
value|2
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_DERIVED
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|unify
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pending_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|push_tinst_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|classtype_mangled_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_expr_values
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list_eq
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_bindings
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|coerce_template_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_enum
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_to_template_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_adjust_types_for_deduction
name|PROTO
argument_list|(
operator|(
name|unification_kind_t
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_unification_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|unification_kind_t
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|complete_template_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_template_header
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_fold_nontype_arg
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_nontype_argument
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_bindings_overload
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|for_each_template_parm
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree_fn_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_template_parm_index
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|original_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inline_needs_template_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_inline_template_parms_recursive
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|retrieve_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|register_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_candidates
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|reduce_template_parm_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_template_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_template_parm
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_friend_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_friend_class
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_bindings_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_decl_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_get_template_decl_from_type_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_cv_quals_for_unify
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_template_arg_vector
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regenerate_decl_from_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_member_template_class
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if ARGVEC contains multiple levels of template arguments.  */
end_comment

begin_define
define|#
directive|define
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(NODE != NULL_TREE 					\&& TREE_CODE (NODE) == TREE_VEC 			\&& TREE_VEC_LENGTH (NODE)> 0 			\&& TREE_VEC_ELT (NODE, 0) != NULL_TREE               \&& TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)
end_define

begin_comment
comment|/* Do any processing required when DECL (a member template declaration    using TEMPLATE_PARAMETERS as its innermost parameter list) is    finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless    it is a specialization, in which case the DECL itself is returned.  */
end_comment

begin_function
name|tree
name|finish_member_template_decl
parameter_list|(
name|template_parameters
parameter_list|,
name|decl
parameter_list|)
name|tree
name|template_parameters
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|template_parameters
condition|)
name|end_template_decl
argument_list|()
expr_stmt|;
else|else
name|end_specialization
argument_list|()
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Assume that the class is the only declspec.  */
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|check_member_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|check_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
return|;
block|}
else|else
return|return
name|decl
return|;
block|}
else|else
name|cp_error
argument_list|(
literal|"invalid member template declaration `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the template nesting level of the indicated class TYPE.        For example, in:      template<class T>      struct A      {        template<class U>        struct B {};      };     A<T>::B<U> has depth two, while A<T> has depth one.  Also,    both A<T>::B<int> and A<int>::B<U> have depth one.  */
end_comment

begin_function
name|int
name|template_class_depth
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
control|)
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
operator|++
name|depth
expr_stmt|;
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Return the original template for this decl, disregarding any    specializations.  */
end_comment

begin_function
specifier|static
name|tree
name|original_template
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if processing DECL as part of do_pending_inlines    needs us to push template parms.  */
end_comment

begin_function
specifier|static
name|int
name|inline_needs_template_parms
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|original_template
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|>
operator|(
name|processing_template_decl
operator|+
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of maybe_begin_member_template_processing.    Push the template parms in PARMS, starting from LEVELS steps into the    chain, and ending at the beginning, since template parms are listed    innermost first.  */
end_comment

begin_function
specifier|static
name|void
name|push_inline_template_parms_recursive
parameter_list|(
name|parmlist
parameter_list|,
name|levels
parameter_list|)
name|tree
name|parmlist
decl_stmt|;
name|int
name|levels
decl_stmt|;
block|{
name|tree
name|parms
init|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|levels
operator|>
literal|1
condition|)
name|push_inline_template_parms_recursive
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|levels
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|build_int_2
argument_list|(
literal|0
argument_list|,
name|processing_template_decl
argument_list|)
argument_list|,
name|parms
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
block|{
comment|/* Make a CONST_DECL as is done in process_template_parm. */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Restore the template parameter context for a member template or    a friend template defined in a class definition.  */
end_comment

begin_function
name|void
name|maybe_begin_member_template_processing
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|levels
decl_stmt|;
if|if
condition|(
operator|!
name|inline_needs_template_parms
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|original_template
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|levels
operator|=
name|list_length
argument_list|(
name|parms
argument_list|)
operator|-
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|--
name|levels
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|push_inline_template_parms_recursive
argument_list|(
name|parms
argument_list|,
name|levels
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the effects of begin_member_template_processing. */
end_comment

begin_function
name|void
name|maybe_end_member_template_processing
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return;
while|while
condition|(
name|current_template_parms
operator|&&
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
condition|)
block|{
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero iff T is a member template function.  We must be    careful as in       template<class T> class C { void f(); }     Here, f is a template function, and a member, but not a member    template.  This function does not concern itself with the origin of    T, only its present state.  So if we have        template<class T> class C { template<class U> void f(U); }     then neither C<int>::f<char> nor C<T>::f<double> is considered    to be a member template.  */
end_comment

begin_function
name|int
name|is_member_template
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Anything that isn't a function or a template function is        certainly not a member template.  */
return|return
literal|0
return|;
comment|/* A local class can't have member templates.  */
if|if
condition|(
name|hack_decl_function_context
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
name|tmpl
operator|=
name|t
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|tmpl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|tmpl
comment|/* If there are more levels of template parameters than 	     there are template classes surrounding the declaration, 	     then we have a member template.  */
operator|&&
operator|(
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|>
name|template_class_depth
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff T is a member template class.  See    is_member_template for a description of what precisely constitutes    a member template.  */
end_comment

begin_function
name|int
name|is_member_template_class
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Anything that isn't a class template, is certainly not a member        template.  */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Anything whose context isn't a class type is surely not a        member template.  */
return|return
literal|0
return|;
comment|/* If there are more levels of template parameters than there are      template classes surrounding the declaration, then we have a      member template.  */
return|return
operator|(
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|>
name|template_class_depth
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new template argument vector which contains all of ARGS    for all outer templates TMPL is contained in, but has as its     innermost set of arguments the EXTRA_ARGS.  If UNBOUND_ONLY, we    are only interested in unbound template arguments, not arguments from    enclosing templates that have been instantiated already.  */
end_comment

begin_function
specifier|static
name|tree
name|complete_template_args
parameter_list|(
name|tmpl
parameter_list|,
name|extra_args
parameter_list|,
name|unbound_only
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
name|extra_args
decl_stmt|;
name|int
name|unbound_only
decl_stmt|;
block|{
comment|/* depth is the number of levels of enclosing args we're adding.  */
name|int
name|depth
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|args
decl_stmt|,
name|new_args
decl_stmt|,
name|spec_args
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|extra_arg_depth
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|extra_args
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|extra_args
argument_list|)
condition|)
name|extra_arg_depth
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
else|else
name|extra_arg_depth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|&&
operator|!
name|unbound_only
condition|)
block|{
comment|/* A specialization of a member template of a template class shows up 	 as a TEMPLATE_DECL with DECL_TEMPLATE_SPECIALIZATION set. 	 DECL_TI_ARGS is the specialization args, and DECL_TI_TEMPLATE 	 is the template being specialized.  */
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|spec_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* A partial instantiation of a member template shows up as a 	     TEMPLATE_DECL with DECL_TEMPLATE_INFO.  DECL_TI_ARGS is 	     all the bound template arguments.  */
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
name|depth
operator|=
literal|1
expr_stmt|;
else|else
name|depth
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If we are a specialization, we might have no previously bound 	   template args.  */
name|depth
operator|=
literal|0
expr_stmt|;
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|depth
operator|+
name|extra_arg_depth
operator|+
operator|(
operator|!
operator|!
name|spec_args
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
literal|0
argument_list|)
operator|=
name|args
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
decl_stmt|;
name|int
name|skip
decl_stmt|;
comment|/* For unbound args, we have to do more work.  We are getting bindings 	 for the innermost args from extra_args, so we start from our 	 context and work out until we've seen all the args.  We need to 	 do it this way to handle partial specialization.  */
name|depth
operator|=
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
return|return
name|extra_args
return|;
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|depth
operator|+
name|extra_arg_depth
argument_list|)
expr_stmt|;
comment|/* If this isn't a member template, extra_args is for the innermost 	 template class, so skip over it.  */
name|skip
operator|=
operator|(
operator|!
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|skip
condition|)
block|{
name|type
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|depth
init|;
name|i
condition|;
name|type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
control|)
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|skip
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|--
name|i
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|)
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|extra_arg_depth
operator|==
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|depth
operator|++
argument_list|)
operator|=
name|extra_args
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_arg_depth
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|depth
operator|++
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|extra_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_args
condition|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|depth
argument_list|)
operator|=
name|spec_args
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* Return a new template argument vector which contains all of ARGS,    but has as its innermost set of arguments the EXTRA_ARGS.  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_template_args
parameter_list|(
name|args
parameter_list|,
name|extra_args
parameter_list|)
name|tree
name|args
decl_stmt|;
name|tree
name|extra_args
decl_stmt|;
block|{
name|tree
name|new_args
decl_stmt|;
if|if
condition|(
operator|!
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|new_args
operator|=
name|make_tree_vec
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
literal|0
argument_list|)
operator|=
name|args
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|new_args
argument_list|)
operator|-
literal|1
argument_list|)
operator|=
name|extra_args
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* We've got a template header coming up; push to a new level for storing    the parms.  */
end_comment

begin_function
name|void
name|begin_template_parm_list
parameter_list|()
block|{
comment|/* We use a non-tag-transparent scope here, which causes pushtag to      put tags in this scope, rather than in the enclosing class or      namespace scope.  This is the right thing, since we want      TEMPLATE_DECLS, and not TYPE_DECLS for template classes.  For a      global template class, push_template_decl handles putting the      TEMPLATE_DECL into top-level scope.  For a nested template class,      e.g.:         template<class T> struct S1 {          template<class T> struct S2 {};         };       pushtag contains special code to call pushdecl_with_scope on the      TEMPLATE_DECL for S2.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_pseudo_global_level
argument_list|()
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
operator|++
name|processing_template_parmlist
expr_stmt|;
name|note_template_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen template<>. */
end_comment

begin_function
name|void
name|begin_specialization
parameter_list|()
block|{
name|note_template_header
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at then end of processing a declaration preceeded by    template<>.  */
end_comment

begin_function
name|void
name|end_specialization
parameter_list|()
block|{
name|reset_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any template<>'s that we have seen thus far are not referring to a    function specialization. */
end_comment

begin_function
name|void
name|reset_specialization
parameter_list|()
block|{
name|processing_specialization
operator|=
literal|0
expr_stmt|;
name|template_header_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen a template header.  If SPECIALIZATION is non-zero,    it was of the form template<>.  */
end_comment

begin_function
specifier|static
name|void
name|note_template_header
parameter_list|(
name|specialization
parameter_list|)
name|int
name|specialization
decl_stmt|;
block|{
name|processing_specialization
operator|=
name|specialization
expr_stmt|;
name|template_header_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're beginning an explicit instantiation.  */
end_comment

begin_function
name|void
name|begin_explicit_instantiation
parameter_list|()
block|{
operator|++
name|processing_explicit_instantiation
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_explicit_instantiation
parameter_list|()
block|{
name|my_friendly_assert
argument_list|(
name|processing_explicit_instantiation
operator|>
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|processing_explicit_instantiation
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the specialization (in the sense of [temp.spec] - a    specialization is either an instantiation or an explicit    specialization) of TMPL for the given template ARGS.  If there is    no such specialization, return NULL_TREE.  The ARGS are a vector of    arguments, or a vector of vectors of arguments, in the case of    templates with more than one level of parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|retrieve_specialization
parameter_list|(
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|s
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff DECL is a specialization of TMPL.  */
end_comment

begin_function
name|int
name|is_specialization_of
parameter_list|(
name|decl
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
for|for
control|(
name|t
operator|=
name|decl
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|t
operator|==
name|tmpl
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Register the specialization SPEC as a specialization of TMPL with    the indicated ARGS.  */
end_comment

begin_function
specifier|static
name|void
name|register_specialization
parameter_list|(
name|spec
parameter_list|,
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|s
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
comment|/* Avoid registering function declarations as        specializations of member templates, as would otherwise        happen with out-of-class specializations of member        templates.  */
return|return;
for|for
control|(
name|s
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"specialization of %D after instantiation"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* This situation should occur only if the first 		       specialization is an implicit instantiation, 		       the second is an explicit specialization, and 		       the implicit instantiation has not yet been 		       used.  That situation can occur if we have 		       implicitly instantiated a member function of 		       class type, and then specialized it later.  */
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|spec
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"duplicate specialization of %D"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
operator|=
name|spec
expr_stmt|;
return|return;
block|}
block|}
block|}
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|args
argument_list|,
name|spec
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the list of candidate FNS in an error message.  */
end_comment

begin_function
specifier|static
name|void
name|print_candidates
parameter_list|(
name|fns
parameter_list|)
name|tree
name|fns
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
operator|!=
name|NULL_TREE
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|cp_error_at
argument_list|(
literal|"%s %+#D"
argument_list|,
name|str
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the template (one of the functions given by TEMPLATE_ID)    which can be specialized to match the indicated DECL with the    explicit template args given in TEMPLATE_ID.  If    NEED_MEMBER_TEMPLATE is true the function is a specialization of a    member template.  The template args (those explicitly specified and    those deduced) are output in a newly created vector *TARGS_OUT.  If    it is impossible to determine the result, an error message is    issued, unless COMPLAIN is 0.  The DECL may be NULL_TREE if none is    available.  */
end_comment

begin_function
name|tree
name|determine_specialization
parameter_list|(
name|template_id
parameter_list|,
name|decl
parameter_list|,
name|targs_out
parameter_list|,
name|need_member_template
parameter_list|,
name|complain
parameter_list|)
name|tree
name|template_id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|targs_out
decl_stmt|;
name|int
name|need_member_template
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|fns
decl_stmt|,
name|targs_in
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|targs_out
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|template_id
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|targs_in
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check for baselinks. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_member_template
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* We can get here when processing something like: 	     template<class T> class X { void f(); } 	     template<> void X<int>::f() {} 	   We're specializing a member function, but not a member 	   template.  */
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|||
operator|(
name|need_member_template
operator|&&
operator|!
name|is_member_template
argument_list|(
name|fn
argument_list|)
operator|)
condition|)
continue|continue;
else|else
name|tmpl
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|list_length
argument_list|(
name|targs_in
argument_list|)
operator|>
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|targs
init|=
name|make_scratch_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We allow incomplete unification here, because we are going to 	     check all the functions. */
name|i
operator|=
name|type_unification
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|targs_in
argument_list|,
name|DEDUCE_EXACT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* Unification was successful.  */
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|targs
argument_list|,
name|tmpl
argument_list|,
name|templates
argument_list|)
expr_stmt|;
block|}
else|else
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmpl
argument_list|,
name|templates
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|tmpl
init|=
name|most_specialized
argument_list|(
name|templates
argument_list|,
name|decl
argument_list|,
name|targs_in
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
goto|goto
name|ambiguous
goto|;
elseif|else
if|if
condition|(
name|tmpl
operator|==
name|NULL_TREE
condition|)
goto|goto
name|no_match
goto|;
operator|*
name|targs_out
operator|=
name|get_bindings
argument_list|(
name|tmpl
argument_list|,
name|decl
argument_list|,
name|targs_in
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
if|if
condition|(
name|templates
operator|==
name|NULL_TREE
condition|)
block|{
name|no_match
label|:
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"template-id `%D' for `%+D' does not match any template declaration"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|ambiguous
label|:
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"ambiguous template specialization `%D' for `%+D'"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|templates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* We have one, and exactly one, match. */
operator|*
name|targs_out
operator|=
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the function just declared, as indicated in    DECLARATOR, and in DECL, is a specialization of a function    template.  We may also discover that the declaration is an explicit    instantiation at this point.     Returns DECL, or an equivalent declaration that should be used    instead.         FLAGS is a bitmask consisting of the following flags:      1: We are being called by finish_struct.  (We are unable to       determine what template is specialized by an in-class       declaration until the class definition is complete, so       finish_struct_methods calls this function again later to finish       the job.)    2: The function has a definition.    4: The function is a friend.    8: The function is known to be a specialization of a member       template.      The TEMPLATE_COUNT is the number of references to qualifying    template classes that appeared in the name of the function.  For    example, in       template<class T> struct S { void f(); };      void S<int>::f();          the TEMPLATE_COUNT would be 1.  However, explicitly specialized    classes are not counted in the TEMPLATE_COUNT, so that in       template<class T> struct S {};      template<> struct S<int> { void f(); }      template<>      void S<int>::f();     the TEMPLATE_COUNT would be 0.  (Note that this declaration is    illegal; there should be no template<>.)     If the function is a specialization, it is marked as such via    DECL_TEMPLATE_SPECIALIZATION.  Furthermore, its DECL_TEMPLATE_INFO    is set up correctly, and it is added to the list of specializations     for that template.  */
end_comment

begin_function
name|tree
name|check_explicit_specialization
parameter_list|(
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|template_count
parameter_list|,
name|flags
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|template_count
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|finish_member
init|=
name|flags
operator|&
literal|1
decl_stmt|;
name|int
name|have_def
init|=
name|flags
operator|&
literal|2
decl_stmt|;
name|int
name|is_friend
init|=
name|flags
operator|&
literal|4
decl_stmt|;
name|int
name|specialization
init|=
literal|0
decl_stmt|;
name|int
name|explicit_instantiation
init|=
literal|0
decl_stmt|;
name|int
name|member_specialization
init|=
name|flags
operator|&
literal|8
decl_stmt|;
name|tree
name|ctype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|dname
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|finish_member
condition|)
block|{
if|if
condition|(
name|processing_specialization
condition|)
block|{
comment|/* The last template header was of the form template<>.  */
if|if
condition|(
name|template_header_count
operator|>
name|template_count
condition|)
block|{
comment|/* There were more template headers than qualifying template 		 classes.  */
if|if
condition|(
name|template_header_count
operator|-
name|template_count
operator|>
literal|1
condition|)
comment|/* There shouldn't be that many template parameter 		   lists.  There can be at most one parameter list for 		   every qualifying class, plus one for the function 		   itself.  */
name|cp_error
argument_list|(
literal|"too many template parameter lists in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
name|member_specialization
operator|=
literal|1
expr_stmt|;
else|else
name|specialization
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|template_header_count
operator|==
name|template_count
condition|)
block|{
comment|/* The counts are equal.  So, this might be a 		 specialization, but it is not a specialization of a 		 member template.  It might be something like 		  		 template<class T> struct S {  	         void f(int i);  		 }; 		 template<> 		 void S<int>::f(int i) {}  */
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This cannot be an explicit specialization.  There are not 		 enough headers for all of the qualifying classes.  For 		 example, we might have: 	      		 template<> 		 void S<int>::T<char>::f();  		 But, we're missing another template<>.  */
name|cp_error
argument_list|(
literal|"too few template parameter lists in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|processing_explicit_instantiation
condition|)
block|{
if|if
condition|(
name|template_header_count
condition|)
name|cp_error
argument_list|(
literal|"template parameter list used in explicit instantiation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_def
condition|)
name|cp_error
argument_list|(
literal|"definition provided for explicit instantiation"
argument_list|)
expr_stmt|;
name|explicit_instantiation
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* This case catches outdated code that looks like this:  	     template<class T> struct S { void f(); }; 	     void S<int>::f() {} // Missing template<>  	     We disable this check when the type is being defined to 	     avoid complaining about default compiler-generated 	     constructors, destructors, and assignment operators. 	     Since the type is an instantiation, not a specialization, 	     these are the only functions that can be defined before 	     the class is complete.  */
comment|/* If they said 	       template<class T> void S<int>::f() {} 	     that's bogus.  */
if|if
condition|(
name|template_header_count
condition|)
block|{
name|cp_error
argument_list|(
literal|"template parameters specified in specialization"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"explicit specialization not preceded by `template<>'"
argument_list|)
expr_stmt|;
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* This case handles bogus declarations like 	     template<> template<class T> 	     void f<int>();  */
name|cp_error
argument_list|(
literal|"template-id `%D' in declaration of primary template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
condition|)
block|{
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"default argument specified in explicit specialization"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
operator|||
name|explicit_instantiation
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|targs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|fns
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctype
condition|)
name|fns
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
name|fns
operator|=
name|dname
expr_stmt|;
name|declarator
operator|=
name|lookup_template_function
argument_list|(
name|fns
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
block|{
comment|/* A friend declaration.  We can't do much, because we don't 	   know what this resolves to, yet.  */
name|my_friendly_assert
argument_list|(
name|is_friend
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|explicit_instantiation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit_instantiation
condition|)
block|{
comment|/* Since finish_struct_1 has not been called yet, we 		 can't call lookup_fnfields.  We note that this 		 template is a specialization, and proceed, letting 		 finish_struct fix this up later.  */
name|tree
name|ti
init|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TI_PENDING_SPECIALIZATION_FLAG
argument_list|(
name|ti
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|ti
expr_stmt|;
block|}
else|else
comment|/* It's not legal to write an explicit instantiation in 	       class scope, e.g.:  	         class C { template void f(); }  	       This case is caught by the parser.  However, on 	       something like: 	        	         template class C { void f(); };  	       (which is illegal) we can get here.  The error will be 	       issued later.  */
empty_stmt|;
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
comment|/* Find the list of functions in ctype that have the same 	     name as the declared function.  */
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|fns
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|int
name|is_constructor
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_constructor
condition|?
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
else|:
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* From [temp.expl.spec]: 		        		     If such an explicit specialization for the member 		     of a class template names an implicitly-declared 		     special member function (clause _special_), the 		     program is ill-formed.    		     Similar language is found in [temp.explicit].  */
name|cp_error
argument_list|(
literal|"specialization of implicitly-declared special member function"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
name|name
operator|=
name|is_constructor
condition|?
name|ctor_identifier
else|:
name|dtor_identifier
expr_stmt|;
block|}
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"no member function `%s' declared in `%T'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|=
name|fns
expr_stmt|;
block|}
comment|/* Figure out what exactly is being specialized at this point. 	 Note that for an explicit instantiation, even one for a 	 member function, we cannot tell apriori whether the 	 instantiation is for a member template, or just a member 	 function of a template class.  In particular, even in if the 	 instantiation is for a member template, the template 	 arguments could be deduced from the declaration.  */
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|declarator
argument_list|,
name|decl
argument_list|,
operator|&
name|targs
argument_list|,
name|member_specialization
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|&&
name|tmpl
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|explicit_instantiation
condition|)
block|{
name|decl
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* There doesn't seem to be anything in the draft to 		   prevent a specialization from being explicitly 		   instantiated.  We're careful not to destroy the 		   information indicating that this is a 		   specialization here.  */
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
comment|/* Mangle the function name appropriately.  Note that we do 	     not mangle specializations of non-template member 	     functions of template classes, e.g. with 	       template<class T> struct S { void f(); } 	     and given the specialization  	       template<> void S<int>::f() {} 	     we do not mangle S<int>::f() here.  That's because it's 	     just an ordinary member function and doesn't need special 	     treatment.  */
if|if
condition|(
operator|(
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|||
name|ctype
operator|==
name|NULL_TREE
operator|)
operator|&&
name|name_mangling_version
operator|>=
literal|1
condition|)
block|{
name|tree
name|arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_template_decl_overload
argument_list|(
name|decl
argument_list|,
name|arg_types
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targs
argument_list|,
name|ctype
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_friend
operator|&&
operator|!
name|have_def
condition|)
block|{
comment|/* This is not really a declaration of a specialization. 		 It's just the name of an instantiation.  But, it's not 		 a request for an instantiation, either.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* If DECL_TI_TEMPLATE (decl), the decl is an 	     instantiation of a specialization of a member template. 	     (In other words, there was a member template, in a 	     class template.  That member template was specialized. 	     We then instantiated the class, so there is now an 	     instance of that specialization.)    	     According to the CD2,  	     14.7.3.13 [tmpl.expl.spec] 	        	     A specialization  of  a member function template or 	     member class template of a non-specialized class 	     template is itself a template.	          	     So, we just leave the template info alone in this case.  */
if|if
condition|(
operator|!
operator|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|decl
argument_list|,
name|tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff PARMS1 and PARMS2 are identical sets of template    parameters.  These are represented in the same format used for    DECL_TEMPLATE_PARMS.  */
end_comment

begin_function
name|int
name|comp_template_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|;
name|tree
name|parms2
decl_stmt|;
block|{
name|tree
name|p1
decl_stmt|;
name|tree
name|p2
decl_stmt|;
if|if
condition|(
name|parms1
operator|==
name|parms2
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p1
operator|=
name|parms1
operator|,
name|p2
operator|=
name|parms2
init|;
name|p1
operator|!=
name|NULL_TREE
operator|&&
name|p2
operator|!=
name|NULL_TREE
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm2
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|p1
operator|!=
name|NULL_TREE
operator|)
operator|!=
operator|(
name|p2
operator|!=
name|NULL_TREE
operator|)
condition|)
comment|/* One set of parameters has more parameters lists than the        other.  */
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,    ORIG_LEVEL, DECL, and TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_parm_index
parameter_list|(
name|index
parameter_list|,
name|level
parameter_list|,
name|orig_level
parameter_list|,
name|decl
parameter_list|,
name|type
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|orig_level
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TEMPLATE_PARM_INDEX
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
operator|=
name|index
expr_stmt|;
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|level
expr_stmt|;
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|orig_level
expr_stmt|;
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose    TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a    new one is created.  */
end_comment

begin_function
specifier|static
name|tree
name|reduce_template_parm_level
parameter_list|(
name|index
parameter_list|,
name|type
parameter_list|,
name|levels
parameter_list|)
name|tree
name|index
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|levels
decl_stmt|;
block|{
if|if
condition|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
operator|)
condition|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|build_template_parm_index
argument_list|(
name|TEMPLATE_PARM_IDX
argument_list|(
name|index
argument_list|)
argument_list|,
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
argument_list|,
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|index
argument_list|)
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Template template parameters need this.  */
name|DECL_TEMPLATE_PARMS
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process information from new template parameter NEXT and append it to the    LIST being built.  */
end_comment

begin_function
name|tree
name|process_template_parm
parameter_list|(
name|list
parameter_list|,
name|next
parameter_list|)
name|tree
name|list
decl_stmt|,
name|next
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|tree
name|defval
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|idx
decl_stmt|;
name|parm
operator|=
name|next
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|259
argument_list|)
expr_stmt|;
name|defval
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|==
name|class_type_node
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
else|else
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|260
argument_list|)
expr_stmt|;
comment|/* is a const-param */
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* A template parameter is not modifiable.  */
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|TYPENAME_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%#T' is not a valid type for a template constant parameter"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"  a template type parameter must begin with `class' or `typename'"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"`%T' is not a valid type for a template constant parameter"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parm
operator|=
name|copy_node
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|&&
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|TEMPLATE_TEMPLATE_PARM
argument_list|)
expr_stmt|;
comment|/* This is for distinguishing between real templates and template  	     template parameters */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
name|t
expr_stmt|;
name|decl
operator|=
name|parm
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|TEMPLATE_TYPE_PARM
argument_list|)
expr_stmt|;
comment|/* parm is either IDENTIFIER_NODE or NULL_TREE */
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|parm
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|parm
operator|=
name|decl
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_tree_list
argument_list|(
name|defval
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The end of a template parameter list has been reached.  Process the    tree list into a parameter vector, converting each parameter into a more    useful form.	 Type parameters are saved as IDENTIFIER_NODEs, and others    as PARM_DECLs.  */
end_comment

begin_function
name|tree
name|end_template_parm_list
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|saved_parmlist
init|=
name|make_tree_vec
argument_list|(
name|list_length
argument_list|(
name|parms
argument_list|)
argument_list|)
decl_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|build_int_2
argument_list|(
literal|0
argument_list|,
name|processing_template_decl
argument_list|)
argument_list|,
name|saved_parmlist
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
operator|,
name|nparms
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|nparms
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
operator|=
name|parm
expr_stmt|;
operator|--
name|processing_template_parmlist
expr_stmt|;
return|return
name|saved_parmlist
return|;
block|}
end_function

begin_comment
comment|/* end_template_decl is called after a template declaration is seen.  */
end_comment

begin_function
name|void
name|end_template_decl
parameter_list|()
block|{
name|reset_specialization
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return;
comment|/* This matches the pushlevel in begin_template_parm_list.  */
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
comment|/* Why? */
block|}
end_function

begin_comment
comment|/* Generate a valid set of template args from current_template_parms.  */
end_comment

begin_function
name|tree
name|current_template_args
parameter_list|()
block|{
name|tree
name|header
init|=
name|current_template_parms
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|make_tree_vec
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|length
decl_stmt|;
while|while
condition|(
name|header
condition|)
block|{
name|tree
name|a
init|=
name|copy_node
argument_list|(
name|TREE_VALUE
argument_list|(
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* t will be a list if we are called from within a 	     begin/end_template_parm_list pair, but a vector directly 	     if within a begin/end_member_template_processing pair.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
operator|--
name|l
argument_list|)
operator|=
name|a
expr_stmt|;
name|header
operator|=
name|TREE_CHAIN
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_DECL corresponding to DECL, using the indicated    template PARMS.  Used by push_template_decl below.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_decl
parameter_list|(
name|decl
parameter_list|,
name|parms
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|parms
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_CLASS_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|tmpl
return|;
block|}
end_function

begin_struct
struct|struct
name|template_parm_data
block|{
name|int
name|level
decl_stmt|;
name|int
modifier|*
name|parms
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Subroutine of push_template_decl used to see if each template    parameter in a partial specialization is used in the explicit    argument list.  If T is of the LEVEL given in DATA (which is    treated as a template_parm_data*), then DATA->PARMS is marked    appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|mark_template_parm
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|template_parm_data
modifier|*
name|tpd
init|=
operator|(
expr|struct
name|template_parm_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|tpd
operator|->
name|level
condition|)
name|tpd
operator|->
name|parms
index|[
name|idx
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Return zero so that for_each_template_parm will continue the      traversal of the tree; we want to mark *every* template parm.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Creates a TEMPLATE_DECL for the indicated DECL using the template    parameters given by current_template_args, or reuses a    previously existing one, if appropriate.  Returns the DECL, or an    equivalent one, if it is replaced via a call to duplicate_decls.       If IS_FRIEND is non-zero, DECL is a friend declaration.  */
end_comment

begin_function
name|tree
name|push_template_decl_real
parameter_list|(
name|decl
parameter_list|,
name|is_friend
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|is_friend
decl_stmt|;
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|info
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|primary
decl_stmt|;
name|is_friend
operator||=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_friend
condition|)
comment|/* For a friend, we want the context of the friend function, not        the type of which it is a friend.  */
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
comment|/* In the case of a virtual function, we want the class in which        it is defined.  */
name|ctx
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, if we're currently definining some class, the DECL        is assumed to be a member of the class.  */
name|ctx
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* For determining whether this is a primary template or not, we're really      interested in the lexical context, not the true context.  */
if|if
condition|(
name|is_friend
condition|)
comment|/* For a TYPE_DECL, there is no DECL_CLASS_CONTEXT.  */
name|info
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
else|:
name|current_class_type
expr_stmt|;
else|else
name|info
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|info
operator|&&
name|TREE_CODE
argument_list|(
name|info
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|primary
operator|=
literal|0
expr_stmt|;
comment|/* Note that template_class_depth returns 0 if given NULL_TREE, so      this next line works even when we are at global scope.  */
elseif|else
if|if
condition|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|info
argument_list|)
condition|)
name|primary
operator|=
literal|1
expr_stmt|;
else|else
name|primary
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|cp_error
argument_list|(
literal|"template with C linkage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"template class without a name"
argument_list|)
expr_stmt|;
block|}
comment|/* Partial specialization.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|maintmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|mainargs
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|spec
init|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
decl_stmt|;
comment|/* We check that each of the template parameters given in the 	 partial specialization is used in the argument list to the 	 specialization.  For example: 	  	   template<class T> struct S; 	   template<class T> struct S<T*>;  	 The second declaration is OK because `T*' uses the template 	 parameter T, whereas                    template<class T> struct S<int>;  	 is no good.  Even trickier is:  	   template<class T> 	   struct S1 	   { 	      template<class U> 	      struct S2; 	      template<class U> 	      struct S2<T>; 	   }; 	    	 The S2<T> declaration is actually illegal; it is a 	 full-specialization.  Of course,                 template<class U>               struct S2<T (*)(U)>;           or some such would have been OK.  */
name|int
name|i
decl_stmt|;
name|struct
name|template_parm_data
name|tpd
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|current_template_parms
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|did_error_intro
init|=
literal|0
decl_stmt|;
name|tpd
operator|.
name|level
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|current_template_parms
argument_list|)
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|parms
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
name|tpd
operator|.
name|parms
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|mainargs
argument_list|)
condition|;
operator|++
name|i
control|)
name|for_each_template_parm
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|mainargs
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|tpd
operator|.
name|parms
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* One of the template parms was not used in the 	       specialization.  */
if|if
condition|(
operator|!
name|did_error_intro
condition|)
block|{
name|cp_error
argument_list|(
literal|"template parameters not used in partial specialization:"
argument_list|)
expr_stmt|;
name|did_error_intro
operator|=
literal|1
expr_stmt|;
block|}
name|cp_error
argument_list|(
literal|"        `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|current_template_parms
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
comment|/* purpose: args to main template 	     value: spec template */
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|spec
argument_list|)
argument_list|,
name|mainargs
argument_list|)
condition|)
return|return
name|decl
return|;
block|}
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
operator|=
name|CLASSTYPE_TI_SPEC_INFO
argument_list|(
name|type
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|mainargs
argument_list|,
name|TREE_VALUE
argument_list|(
name|current_template_parms
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|decl
return|;
block|}
name|args
operator|=
name|current_template_args
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
operator|||
operator|(
name|is_friend
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* A specialization of a member template of a template 		 class. */
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|a
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctx
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"must specialize `%#T' before defining member `%#D'"
argument_list|,
name|ctx
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|tmpl
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"`%D' does not declare a template type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"template definition of non-template `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|||
name|is_member_template_class
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|new_tmpl
decl_stmt|;
comment|/* The declaration is a specialization of a member 		 template, declared outside the class.  Therefore, the 		 innermost template arguments will be NULL, so we 		 replace them with the arguments determined by the 		 earlier call to check_explicit_specialization.  */
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|new_tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|=
name|new_tmpl
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|new_tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|new_tmpl
argument_list|,
name|tmpl
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
name|a
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"got %d template parameters for `%#D'"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  but %d required"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|1
condition|)
comment|/* Get the template parameters for the enclosing template 	       class.  */
name|a
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|a
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|a
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* When processing an inline member template of a 	     specialized class, there is no CLASSTYPE_TI_SPEC_INFO.  */
if|if
condition|(
name|CLASSTYPE_TI_SPEC_INFO
argument_list|(
name|ctx
argument_list|)
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|CLASSTYPE_TI_SPEC_INFO
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|ctx
argument_list|)
condition|)
name|t
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There should be template arguments if and only if there is a 	 template class.  */
name|my_friendly_assert
argument_list|(
operator|(
name|a
operator|!=
name|NULL_TREE
operator|)
operator|==
operator|(
name|t
operator|!=
name|NULL_TREE
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"got %d template parameters for `%#D'"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  but `%#T' has %d"
argument_list|,
name|ctx
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the innermost set of template arguments.  We don't do this      for a non-template member function of a nested template class      because there we will never get a `partial instantiation' of the      function containing the outer arguments, and so we must save all      of the arguments here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|template_class_depth
argument_list|(
name|ctx
argument_list|)
operator|<=
literal|1
operator|||
name|primary
condition|)
name|args
operator|=
name|innermost_args
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|&&
operator|!
operator|(
name|is_friend
operator|&&
name|template_class_depth
argument_list|(
name|info
argument_list|)
operator|>
literal|0
operator|)
condition|)
comment|/* Note that we do not try to push a global template friend        declared in a template class; such a thing may well depend on        the template parameters of the class.  */
name|tmpl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|info
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
name|info
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"template declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|info
expr_stmt|;
return|return
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|push_template_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when a class template TYPE is redeclared with the indicated    template PARMS, e.g.:       template<class T> struct S;      template<class T> struct S {};  */
end_comment

begin_function
name|void
name|redeclare_class_template
parameter_list|(
name|type
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmpl_parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
comment|/* The type is nested in some template class.  Nothing to worry        about here; there are no new template parameters for the nested        type.  */
return|return;
name|parms
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|tmpl_parms
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"previous declaration `%D'"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"used %d template parameter%s instead of %d"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmpl_parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmpl_default
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm_default
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmpl_parm
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"template parameter `%#D'"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"redeclared here as `%#D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmpl_default
operator|!=
name|NULL_TREE
operator|&&
name|parm_default
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We have in [temp.param]:  	     A template-parameter may not be given default arguments 	     by two different declarations in the same scope.  */
name|cp_error
argument_list|(
literal|"redefinition of default argument for `%#D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  original definition appeared here"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm_default
operator|!=
name|NULL_TREE
condition|)
comment|/* Update the previous template parameters (which are the ones 	   that will really count) with the new default value.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|parm_default
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to convert the non-type template parameter EXPR to the    indicated TYPE.  If the conversion is successful, return the    converted value.  If the conversion is unsuccesful, return    NULL_TREE if we issued an error message, or error_mark_node if we    did not.  We issue error messages for out-and-out bad template    parameters, but not simply because the conversion failed, since we    might be just trying to do argument deduction.  By the time this    function is called, neither TYPE nor EXPR may make use of template    parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nontype_argument
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|expr_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* A template-argument for a non-type, non-template      template-parameter shall be one of:       --an integral constant-expression of integral or enumeration      type; or            --the name of a non-type template-parameter; or            --the name of an object or function with external linkage,      including function templates and function template-ids but      excluding non-static class members, expressed as id-expression;      or            --the address of an object or function with external linkage,      including function templates and function template-ids but      excluding non-static class members, expressed as& id-expression      where the& is optional if the name refers to a function or      array; or            --a pointer to member expressed as described in _expr.unary.op_.  */
comment|/* An integral constant-expression can include const variables      or enumerators.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TREE_READONLY_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* OK for now.  We'll check that it has external linkage later.        Check this first since if expr_type is the unknown_type_node        we would otherwise complain below.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
comment|/* The next two are g++ extensions.  */
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|non_constant
label|:
name|cp_error
argument_list|(
literal|"non-constant `%E' cannot be used as template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|expr_type
argument_list|)
comment|/* If expr is the address of an overloaded function, we 	      will get the unknown_type_node at this point.  */
operator|||
name|expr_type
operator|==
name|unknown_type_node
condition|)
block|{
name|tree
name|referent
decl_stmt|;
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
name|bad_argument
label|:
name|cp_error
argument_list|(
literal|"`%E' is not a valid template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"it must be %s%s with external linkage"
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|?
literal|"a pointer to "
else|:
literal|""
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|?
literal|"a function"
else|:
literal|"an object"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|referent
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|referent
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|referent
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|cp_error
argument_list|(
literal|"string literal %E is not a valid template argument"
argument_list|,
name|referent
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"because it is the address of an object with static linkage"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|referent
argument_list|)
condition|)
comment|/* We'll check that it has external linkage later.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|referent
argument_list|)
operator|!=
name|VAR_DECL
condition|)
goto|goto
name|bad_argument
goto|;
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|referent
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"address of non-extern `%E' cannot be used as template argument"
argument_list|,
name|referent
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|expr
argument_list|)
condition|)
goto|goto
name|bad_argument
goto|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"object `%E' cannot be used as template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* For a non-type template-parameter of integral or enumeration          type, integral promotions (_conv.prom_) and integral          conversions (_conv.integral_) are applied. */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* It's safe to call digest_init in this case; we know we're 	 just converting one integral constant expression to another.  */
name|expr
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* Curiously, some TREE_CONSTNAT integral expressions do not 	   simplify to integer constants.  For example, `3 % 0', 	   remains a TRUNC_MOD_EXPR.  */
goto|goto
name|non_constant
goto|;
return|return
name|expr
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
comment|/* These are g++ extensions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|REAL_CST
condition|)
goto|goto
name|non_constant
goto|;
return|return
name|expr
return|;
case|case
name|POINTER_TYPE
case|:
block|{
name|tree
name|type_pointed_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* For a non-type template-parameter of type pointer to data 	     member, qualification conversions (_conv.qual_) are 	     applied.  */
return|return
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_pointed_to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* For a non-type template-parameter of type pointer to 	       function, only the function-to-pointer conversion 	       (_conv.func_) is applied.  If the template-argument 	       represents a set of overloaded functions (or a pointer to 	       such), the matching function is selected from the set 	       (_over.over_).  */
name|tree
name|fns
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fns
operator|=
name|expr
expr_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type_pointed_to
argument_list|,
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
goto|goto
name|bad_argument
goto|;
block|}
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|comptypes
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
block|{
comment|/* For a non-type template-parameter of type pointer to 	       object, qualification conversions (_conv.qual_) and the 	       array-to-pointer conversion (_conv.array_) are applied. 	       [Note: In particular, neither the null pointer conversion 	       (_conv.ptr_) nor the derived-to-base conversion 	       (_conv.ptr_) are applied.  Although 0 is a valid 	       template-argument for a non-type template-parameter of 	       integral type, it is not a valid template-argument for a 	       non-type template-parameter of pointer type.]   	     	       The call to decay_conversion performs the 	       array-to-pointer conversion, if appropriate.  */
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|type_referred_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_referred_to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* For a non-type template-parameter of type reference to 	      function, no conversions apply.  If the 	      template-argument represents a set of overloaded 	      functions, the matching function is selected from the 	      set (_over.over_).  */
name|tree
name|fns
init|=
name|expr
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type_referred_to
argument_list|,
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
comment|/* Don't issue an error here; we might get a different 		     function if the overloading had worked out 		     differently.  */
return|return
name|error_mark_node
return|;
else|else
goto|goto
name|bad_argument
goto|;
block|}
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|comptypes
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
else|else
block|{
comment|/* For a non-type template-parameter of type reference to 	       object, no conversions apply.  The type referred to by the 	       reference may be more cv-qualified than the (otherwise 	       identical) type of the template-argument.  The 	       template-parameter is bound directly to the 	       template-argument, which must be an lvalue.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|expr_type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|TYPE_READONLY
argument_list|(
name|expr_type
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|type_referred_to
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_VOLATILE
argument_list|(
name|expr_type
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|type_referred_to
argument_list|)
operator|)
operator|||
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|expr
return|;
block|}
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
block|{
name|tree
name|fns
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* This handles templates like 	       template<class T, T t> void f(); 	     when T is substituted with any class.  The second template 	     parameter becomes invalid and the template candidate is 	     rejected.  */
return|return
name|error_mark_node
return|;
comment|/* For a non-type template-parameter of type pointer to member 	   function, no conversions apply.  If the template-argument 	   represents a set of overloaded member functions, the 	   matching member function is selected from the set 	   (_over.over_).  */
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|expr_type
operator|!=
name|unknown_type_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* A ptr-to-member constant.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|type
argument_list|,
name|expr_type
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|error_mark_node
return|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|comptypes
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
break|break;
default|default:
comment|/* All non-type parameters must have one of these types.  */
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARM_PARMS and ARG_PARMS matches using rule for     template template parameters.  Both PARM_PARMS and ARG_PARMS are     vectors of TREE_LIST nodes containing TYPE_DECL, TEMPLATE_DECL     or PARM_DECL.        ARG_PARMS may contain more parameters than PARM_PARMS.  If this is     the case, then extra parameters must have default arguments.     Consider the example:      template<class T, class Allocator = allocator> class vector;      template<template<class U> class TT> class C;     C<vector> is a valid instantiation.  PARM_PARMS for the above code     contains a TYPE_DECL (for U),  ARG_PARMS contains two TYPE_DECLs (for     T and Allocator) and OUTER_ARGS contains the argument that is used to     substitute the TT parameter.  */
end_comment

begin_function
specifier|static
name|int
name|coerce_template_template_parms
parameter_list|(
name|parm_parms
parameter_list|,
name|arg_parms
parameter_list|,
name|in_decl
parameter_list|,
name|outer_args
parameter_list|)
name|tree
name|parm_parms
decl_stmt|,
name|arg_parms
decl_stmt|,
name|in_decl
decl_stmt|,
name|outer_args
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm_parms
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arg_parms
argument_list|)
expr_stmt|;
comment|/* The rule here is opposite of coerce_template_parms.  */
if|if
condition|(
name|nargs
operator|<
name|nparms
operator|||
operator|(
name|nargs
operator|>
name|nparms
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|nparms
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
operator|++
name|i
control|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parm_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
operator|||
name|arg
operator|==
name|error_mark_node
operator|||
name|parm
operator|==
name|NULL_TREE
operator|||
name|parm
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
break|break;
case|case
name|TEMPLATE_DECL
case|:
comment|/* We encounter instantiations of templates like 	       template<template<template<class> class> class TT> 	       class C;  */
name|sorry
argument_list|(
literal|"nested template template parameter"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PARM_DECL
case|:
comment|/* The tsubst call is used to handle cases such as 	       template<class T, template<T> class TT> class D;   	     i.e. the parameter list of TT depends on earlier parameters.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|outer_args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert all template arguments to their appropriate types, and return    a vector containing the resulting values.  If any error occurs, return    error_mark_node, and, if COMPLAIN is non-zero, issue an error message.    Some error messages are issued even if COMPLAIN is zero; for    instance, if a template argument is composed from a local class.      If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be    provided in ARGLIST, or else trailing parameters must have default    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument    deduction for any unspecified trailing arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|parms
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|,
name|complain
parameter_list|,
name|require_all_arguments
parameter_list|)
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|require_all_arguments
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|,
name|lost
init|=
literal|0
decl_stmt|;
name|tree
name|vec
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
name|NULL_TREE
condition|)
name|nargs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|else
name|nargs
operator|=
name|list_length
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|nparms
operator|||
operator|(
name|nargs
operator|<
name|nparms
operator|&&
name|require_all_arguments
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|nargs
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"incorrect number of parameters (%d, should be %d)"
argument_list|,
name|nargs
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"in template expansion for decl `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|arglist
operator|&&
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|nargs
operator|==
name|nparms
condition|)
name|vec
operator|=
name|copy_node
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
else|else
block|{
name|vec
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|arglist
operator|&&
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|arg
operator|=
name|arglist
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
else|else
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|require_all_arguments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|arg
operator|=
name|tsubst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|vec
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|arg
operator|=
name|tsubst_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|vec
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
literal|0
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|requires_type
decl_stmt|,
name|is_tmpl_type
decl_stmt|,
name|requires_tmpl_type
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
condition|)
comment|/* We're out of arguments.  */
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|require_all_arguments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"template argument %d is invalid"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lost
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The template argument was the name of some 	     member function.  That's usually 	     illegal, but static members are OK.  In any 	     case, grab the underlying fields/functions 	     and issue an error later if required.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
name|requires_tmpl_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
expr_stmt|;
name|requires_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|requires_tmpl_type
expr_stmt|;
comment|/* Check if it is a class template.  If REQUIRES_TMPL_TYPE is true, 	 we also accept implicitly created TYPE_DECL as a valid argument.          This is necessary to handle the case where we pass a template name          to a template template parameter in a scope where we've derived from          in instantiation of that template, so the template name refers to that          instantiation.  We really ought to handle this better.  */
name|is_tmpl_type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|requires_tmpl_type
operator|&&
name|current_class_type
comment|/* FIXME what about nested types?  */
operator|&&
name|get_binfo
argument_list|(
name|arg
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|arg
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tmpl_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|arg
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|||
name|is_tmpl_type
expr_stmt|;
if|if
condition|(
name|requires_type
operator|&&
operator|!
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"to refer to a type member of a template parameter,"
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"  use `typename %E'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|make_typename_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|is_type
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_type
operator|!=
name|requires_type
condition|)
block|{
if|if
condition|(
name|in_decl
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
name|cp_error
argument_list|(
literal|"  expected a constant of type `%T', got `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|(
name|is_tmpl_type
condition|?
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
else|:
name|arg
operator|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"  expected a type, got `%E'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_tmpl_type
operator|^
name|requires_tmpl_type
condition|)
block|{
if|if
condition|(
name|in_decl
operator|&&
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
condition|)
name|cp_error
argument_list|(
literal|"  expected a type, got `%T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"  expected a class template, got `%T'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_type
condition|)
block|{
if|if
condition|(
name|requires_tmpl_type
condition|)
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|in_decl
argument_list|,
name|vec
argument_list|)
condition|)
block|{
name|val
operator|=
name|arg
expr_stmt|;
comment|/* TEMPLATE_TEMPLATE_PARM node is preferred over  		     TEMPLATE_DECL.  */
if|if
condition|(
name|val
operator|!=
name|error_mark_node
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in_decl
operator|&&
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  expected a template of type `%D', got `%D'"
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|groktypename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|target_type
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' composed from a local type is not a valid template-argument"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|vec
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|arg
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|t
argument_list|)
condition|)
comment|/* We used to call digest_init here.  However, digest_init 	       will report errors, which we don't want when complain 	       is zero.  More importantly, digest_init will try too 	       hard to convert things: for example, `0' should not be 	       converted to pointer type at this point according to 	       the standard.  Accepting this is not merely an 	       extension, since deciding whether or not these 	       conversions can occur is part of determining which 	       function template to call, or whether a given epxlicit 	       argument specification is legal.  */
name|val
operator|=
name|convert_nontype_argument
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|error_mark_node
operator|&&
name|complain
condition|)
name|cp_error
argument_list|(
literal|"could not convert template argument `%E' to `%T'"
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|lost
condition|)
return|return
name|error_mark_node
return|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Renturns 1 iff the OLDARGS and NEWARGS are in fact identical sets    of template arguments.  Returns 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_template_args
parameter_list|(
name|oldargs
parameter_list|,
name|newargs
parameter_list|)
name|tree
name|oldargs
decl_stmt|,
name|newargs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|newargs
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|nt
init|=
name|TREE_VEC_ELT
argument_list|(
name|newargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|ot
init|=
name|TREE_VEC_ELT
argument_list|(
name|oldargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nt
operator|==
name|ot
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|nt
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|nt
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
comment|/* For member templates */
if|if
condition|(
name|comp_template_args
argument_list|(
name|nt
argument_list|,
name|ot
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cp_tree_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given class template name and parameter list, produce a user-friendly name    for the instantiation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
name|name
parameter_list|,
name|parms
parameter_list|,
name|arglist
parameter_list|,
name|ctx
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
block|{
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
if|if
condition|(
operator|!
name|scratch_firstobj
condition|)
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
else|else
name|obstack_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|scratch_firstobj
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
define|#
directive|define
name|buflen
value|sizeof(buf)
define|#
directive|define
name|check
value|if (bufp>= buf+buflen-1) goto too_long
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|*bufp++=(c); check
define|#
directive|define
name|advance
value|bufp+=strlen(bufp); check
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|strncpy(bufp, s, buf+buflen-bufp-1); advance
else|#
directive|else
define|#
directive|define
name|check
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|obstack_1grow (&scratch_obstack, (c));
define|#
directive|define
name|advance
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|obstack_grow (&scratch_obstack, (s), strlen (s))
endif|#
directive|endif
if|if
condition|(
name|ctx
operator|&&
name|ctx
operator|!=
name|global_namespace
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|s
operator|=
name|fndecl_as_string
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|s
operator|=
name|type_as_string_real
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|s
operator|=
name|decl_as_string
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|cat
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nparms
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|268
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|ccat
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cat
argument_list|(
name|type_as_string_real
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* Already substituted with real template.  Just output  		 the template name here */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|980422
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|decl_as_string
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|cat
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output the parameter declaration */
name|cat
argument_list|(
name|type_as_string_real
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|269
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* New list cell was built because old chain link was in 	     use.  */
name|my_friendly_assert
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|270
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* No need to check arglist against parmlist here; we did that 	 in coerce_template_parms, called from lookup_template_class.  */
name|cat
argument_list|(
name|expr_as_string
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|bufp
init|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|offset
operator|--
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* B<C<char>>, not B<C<char>> */
if|if
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|ccat
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ccat
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
if|#
directive|if
literal|0
block|too_long:
endif|#
directive|endif
name|fatal
argument_list|(
literal|"out of (preallocated) string space creating template instantiation name"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|classtype_mangled_name
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We do not pass in the context here since that is only needed 	 when mangling the name of instantiations, not the primary 	 template declaration.  In reality, it should not be needed 	 then either, but the way lookup_template_class operates 	 requires the context for the moment.  In the long run, 	 lookup_template_class should not be looking for existing 	 instantiations by matching mangled names, but rather by 	 matching the templates, and then scanning the instantiation 	 list.  */
name|char
modifier|*
name|mangled_name
init|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
decl_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|id
return|;
block|}
else|else
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|ti
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|ti
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|ti
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
condition|)
return|return;
operator|*
name|template_tail
operator|=
name|perm_tree_cons
argument_list|(
name|build_srcloc_here
argument_list|()
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|template_tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|template_tail
argument_list|)
expr_stmt|;
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS (which    may be either a _DECL or an overloaded function or an    IDENTIFIER_NODE), and ARGLIST.  */
end_comment

begin_function
name|tree
name|lookup_template_function
parameter_list|(
name|fns
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|fns
decl_stmt|,
name|arglist
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"non-template used as template"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|arglist
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|arglist
argument_list|)
condition|)
name|copy_to_permanent
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|!
name|type
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|build_min
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|type
argument_list|,
name|fns
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class S<T>, the name S gets bound    (in build_self_reference) to a TYPE_DECL for the class, not a    TEMPLATE_DECL.  If DECL is a TYPE_DECL for current_class_type,    or one of its enclosing classes, and that type is a template,    return the associated TEMPLATE_DECL.  Otherwise, the original    DECL is returned.  */
end_comment

begin_function
name|tree
name|maybe_get_template_decl_from_type_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|?
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of    parameters, find the desired type.     D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.    Since ARGLIST is build on the decl_obstack, we must copy it here    to keep it from being reclaimed when the decl storage is reclaimed.     IN_DECL, if non-NULL, is the template declaration we are trying to    instantiate.       If the template class is really a local class in a template    function, then the FUNCTION_CONTEXT is the function in which it is    being instantiated.  */
end_comment

begin_function
name|tree
name|lookup_template_class
parameter_list|(
name|d1
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|,
name|context
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|{
name|tree
name|template
init|=
name|NULL_TREE
decl_stmt|,
name|parmlist
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|tree
name|id
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|d1
argument_list|)
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
name|template
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|context
condition|)
name|push_decl_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
name|template
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|template
operator|==
name|NULL_TREE
condition|)
name|template
operator|=
name|lookup_name_nonclass
argument_list|(
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|template
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|d1
argument_list|)
condition|)
block|{
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|template
operator|=
name|d1
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|272
argument_list|)
expr_stmt|;
comment|/* With something like `template<class T> class X class X { ... };'      we could end up with D1 having nothing but an IDENTIFIER_LOCAL_VALUE.      We don't want to do that, but we have to deal with the situation, so      let's give them some syntax errors to chew on instead of a crash.  */
if|if
condition|(
operator|!
name|template
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"non-template type `%T' used as a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"for template declaration `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
comment|/* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store          template arguments */
name|tree
name|parm
init|=
name|copy_template_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|template2
init|=
name|TYPE_STUB_DECL
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|arglist2
decl_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|parmlist
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|arglist2
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|arglist2
operator|=
name|copy_to_permanent
argument_list|(
name|arglist2
argument_list|)
expr_stmt|;
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|template2
argument_list|,
name|arglist2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|parm
return|;
block|}
elseif|else
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|arglist_for_mangling
decl_stmt|;
name|parmlist
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* ARGLIST can be NULL_TREE if there are default arguments.  */
name|arglist
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|>
literal|1
operator|&&
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* We have multiple levels of arguments to coerce, at once.  */
name|tree
name|new_args
init|=
name|make_tree_vec
argument_list|(
name|list_length
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|-
literal|1
operator|,
name|t
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
init|;
name|i
operator|>=
literal|0
operator|&&
name|t
operator|!=
name|NULL_TREE
condition|;
operator|--
name|i
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|)
operator|=
name|coerce_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
argument_list|,
name|template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|new_args
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|innermost_args
argument_list|(
name|arglist
argument_list|,
literal|0
argument_list|)
argument_list|,
name|template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|tree
name|found
decl_stmt|;
if|if
condition|(
name|comp_template_args
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
name|found
operator|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|found
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
init|;
name|found
condition|;
name|found
operator|=
name|TREE_CHAIN
argument_list|(
name|found
argument_list|)
control|)
block|{
if|if
condition|(
name|TI_USES_TEMPLATE_PARMS
argument_list|(
name|found
argument_list|)
operator|&&
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|found
condition|)
name|found
operator|=
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|can_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|arglist
argument_list|)
condition|)
name|obstack_free
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|arglist_for_mangling
operator|=
name|innermost_args
argument_list|(
name|arglist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|arglist_for_mangling
operator|=
name|arglist
expr_stmt|;
comment|/* FIXME avoid duplication.  */
name|mangled_name
operator|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|d1
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|arglist_for_mangling
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|d1
expr_stmt|;
name|maybe_push_to_top_level
argument_list|(
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|xref_tag_from_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Set up the context for the type_decl correctly.  Note 	     that we must clear DECL_ASSEMBLER_NAME to fool 	     build_overload_name into creating a new name.  */
name|tree
name|type_decl
init|=
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|type_decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type_ctx
init|=
name|TYPE_CONTEXT
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|tsubst
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type_ctx
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|ctx
init|=
name|lookup_template_class
argument_list|(
name|type_ctx
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|id
operator|=
name|d1
expr_stmt|;
name|arglist
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
operator|&&
name|ctx
operator|==
name|current_class_type
condition|)
block|{
name|int
name|save_temp
init|=
name|processing_template_decl
decl_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|xref_tag_from_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|save_temp
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|lookup_nested_type_by_name
argument_list|(
name|ctx
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|t
operator|!=
name|NULL_TREE
argument_list|,
literal|42
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Seems to be wanted.  */
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|arglist
operator|=
name|copy_to_permanent
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|arglist
argument_list|,
name|t
argument_list|,
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|TI_USES_TEMPLATE_PARMS
argument_list|(
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
argument_list|)
operator|=
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* We need to set this again after CLASSTYPE_TEMPLATE_INFO is set up.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
condition|)
name|add_pending_template
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
condition|)
comment|/* If the type makes use of template parameters, the 	   code that generates debugging information will crash.  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Should be defined in parse.h.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, or    TEMPLATE_PARM_INDEX in T, call FN with the parameter and the DATA.    If FN returns non-zero, the iteration is terminated, and    for_each_template_parm returns 1.  Otherwise, the iteration    continues.  If FN never returns a non-zero value, the value    returned by for_each_template_parm is 0.  If FN is NULL, it is    considered to be the function which always returns 1.  */
end_comment

begin_function
name|int
name|for_each_template_parm
parameter_list|(
name|t
parameter_list|,
name|fn
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree_fn_t
name|fn
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* We assume that the object must be instantiated in order to build 	 the COMPONENT_REF, so we test only whether the type of the 	 COMPONENT_REF uses template parms.  */
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
comment|/* aggregates of tree nodes */
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|TREE_LIST
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|||
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|OVERLOAD
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* constructed type nodes */
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|for_each_template_parm
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|UNION_TYPE
case|:
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* decl nodes */
case|case
name|TYPE_DECL
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|TEMPLATE_DECL
case|:
comment|/* A template template parameter is encountered */
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* Already substituted template template parameter */
return|return
literal|0
return|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|check_type_and_context
goto|;
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
comment|/* ??? What about FIELD_DECLs?  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* fall through */
case|case
name|PARM_DECL
case|:
name|check_type_and_context
label|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* template parm nodes */
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
comment|/* Record template parameters such as `T' inside `TT<T>'.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
if|if
condition|(
name|fn
condition|)
return|return
call|(
modifier|*
name|fn
call|)
argument_list|(
name|t
argument_list|,
name|data
argument_list|)
return|;
else|else
return|return
literal|1
return|;
comment|/* simple type nodes */
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|NAMESPACE_DECL
case|:
return|return
literal|0
return|;
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|tree
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
init|;
name|v
operator|!=
name|NULL_TREE
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* constants */
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
literal|0
return|;
case|case
name|ERROR_MARK
case|:
comment|/* Non-error_mark_node ERROR_MARKs are bad things.  */
name|my_friendly_assert
argument_list|(
name|t
operator|==
name|error_mark_node
argument_list|,
literal|274
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
case|case
name|LOOKUP_EXPR
case|:
case|case
name|TYPENAME_TYPE
case|:
return|return
literal|1
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|for_each_template_parm
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|MODOP_EXPR
case|:
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
return|return
literal|1
return|;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
default|default:
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'e'
case|:
case|case
literal|'<'
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|sorry
argument_list|(
literal|"testing %s for template parms"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|82
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|uses_template_parms
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|for_each_template_parm
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|tinst_level
modifier|*
name|current_tinst_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tinst_level
modifier|*
name|free_tinst_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tinst_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_tinst_depth
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|tinst_level_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_template_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print out all the template instantiations that we are currently    working on.  If ERR, we are being called from cp_thing, so do    the right thing for an error message.  */
end_comment

begin_function
specifier|static
name|void
name|print_template_context
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
name|struct
name|tinst_level
modifier|*
name|p
init|=
name|current_tinst_level
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|p
operator|->
name|decl
condition|)
comment|/* Avoid redundancy with the the "In function" line.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: In instantiation of `%s':\n"
argument_list|,
name|file
argument_list|,
name|decl_as_string
argument_list|(
name|p
operator|->
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|980521
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|line
operator|=
name|p
operator|->
name|line
expr_stmt|;
name|file
operator|=
name|p
operator|->
name|file
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
name|next
label|:
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:   instantiated from `%s'\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|decl_as_string
argument_list|(
name|p
operator|->
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|p
operator|->
name|line
expr_stmt|;
name|file
operator|=
name|p
operator|->
name|file
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:   instantiated from here\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from cp_thing to print the template context for an error.  */
end_comment

begin_function
name|void
name|maybe_print_template_context
parameter_list|()
block|{
if|if
condition|(
name|last_template_error_tick
operator|==
name|tinst_level_tick
operator|||
name|current_tinst_level
operator|==
literal|0
condition|)
return|return;
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
name|print_template_context
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|push_tinst_level
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|struct
name|tinst_level
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|tinst_depth
operator|>=
name|max_tinst_depth
condition|)
block|{
comment|/* If the instantiation in question still has unbound template parms, 	 we don't really care if we can't instantiate it, so just return.          This happens with base instantiation for implicit `typename'.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
name|error
argument_list|(
literal|"template instantiation depth exceeds maximum of %d"
argument_list|,
name|max_tinst_depth
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" (use -ftemplate-depth-NN to increase the maximum)"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  instantiating `%D'"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|print_template_context
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|free_tinst_level
condition|)
block|{
name|new
operator|=
name|free_tinst_level
expr_stmt|;
name|free_tinst_level
operator|=
name|new
operator|->
name|next
expr_stmt|;
block|}
else|else
name|new
operator|=
operator|(
expr|struct
name|tinst_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tinst_level
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|decl
operator|=
name|d
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|lineno
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|input_filename
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|current_tinst_level
expr_stmt|;
name|current_tinst_level
operator|=
name|new
expr_stmt|;
operator|++
name|tinst_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|tinst_depth
operator|>
name|depth_reached
condition|)
name|depth_reached
operator|=
name|tinst_depth
expr_stmt|;
endif|#
directive|endif
operator|++
name|tinst_level_tick
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|pop_tinst_level
parameter_list|()
block|{
name|struct
name|tinst_level
modifier|*
name|old
init|=
name|current_tinst_level
decl_stmt|;
name|current_tinst_level
operator|=
name|old
operator|->
name|next
expr_stmt|;
name|old
operator|->
name|next
operator|=
name|free_tinst_level
expr_stmt|;
name|free_tinst_level
operator|=
name|old
expr_stmt|;
operator|--
name|tinst_depth
expr_stmt|;
operator|++
name|tinst_level_tick
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|tinst_level
modifier|*
name|tinst_for_decl
parameter_list|()
block|{
name|struct
name|tinst_level
modifier|*
name|p
init|=
name|current_tinst_level
decl_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the    vector of template arguments, as for tsubst.     Returns an appropriate tsbust'd friend declaration.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_function
parameter_list|(
name|decl
parameter_list|,
name|args
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|new_friend
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* This was a friend declared with an explicit template        argument list, e.g.:                friend void f<>(T);                to indicate that f was a template instantiation, not a new        function declaration.  Now, we have to figure out what        instantiation of what template.  */
block|{
name|tree
name|template_id
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|tinfo
decl_stmt|;
name|template_id
operator|=
name|lookup_template_function
argument_list|(
name|tsubst_expr
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Temporarily remove the DECL_TEMPLATE_INFO so as not to 	 confuse tsubst.  */
name|tinfo
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tinfo
expr_stmt|;
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|template_id
argument_list|,
name|new_friend
argument_list|,
operator|&
name|new_args
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_friend
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|new_args
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The new_friend will look like an instantiation, to the      compiler, but is not an instantiation from the point of view of      the language.  For example, we might have had:            template<class T> struct S {        template<class U> friend void f(T, U);      };            Then, in S<int>, template<class U> void f(int, U) is not an      instantiation of anything.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|DECL_USE_TEMPLATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|new_friend
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* This declaration is a `primary' template.  */
name|TREE_TYPE
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
name|new_friend
expr_stmt|;
name|new_friend
operator|=
name|pushdecl_namespace_level
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check to see that the declaration is really present, and, 	 possibly obtain an improved declaration.  */
name|tree
name|fn
init|=
name|check_classfn
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
argument_list|,
name|new_friend
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|new_friend
operator|=
name|fn
expr_stmt|;
block|}
name|done
label|:
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
return|return
name|new_friend
return|;
block|}
end_function

begin_comment
comment|/* FRIEND_TMPL is a friend TEMPLATE_DECL.  ARGS is the vector of    template arguments, as for tsubst.     Returns an appropriate tsbust'd friend type.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_class
parameter_list|(
name|friend_tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|friend_tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|friend_type
decl_stmt|;
name|tree
name|tmpl
init|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tmpl
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* The friend template has already been declared.  Just 	 check to see that the declarations match.  */
name|redeclare_class_template
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The friend template has not already been declared.  In this 	 case, the instantiation of the template class will cause the 	 injection of this template into the global scope.  */
name|tmpl
operator|=
name|tsubst
argument_list|(
name|friend_tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The new TMPL is not an instantiation of anything, so we  	 forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for 	 the new type because that is supposed to be the corresponding 	 template decl, i.e., TMPL.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Inject this template into the global scope.  */
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|pushdecl_top_level
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|friend_type
return|;
block|}
end_function

begin_function
name|tree
name|instantiate_class_template
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|template_info
decl_stmt|,
name|args
decl_stmt|,
name|pattern
decl_stmt|,
name|t
decl_stmt|,
modifier|*
name|field_chain
decl_stmt|;
name|tree
name|typedecl
decl_stmt|,
name|outer_args
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|template_info
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
name|template
operator|=
name|TI_TEMPLATE
argument_list|(
name|template_info
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|279
argument_list|)
expr_stmt|;
name|args
operator|=
name|TI_ARGS
argument_list|(
name|template_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|template
argument_list|)
condition|)
block|{
name|outer_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|template
argument_list|)
expr_stmt|;
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|template
argument_list|)
condition|)
name|template
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
else|else
name|outer_args
operator|=
name|NULL_TREE
expr_stmt|;
name|t
operator|=
name|most_specialized_class
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|template
argument_list|)
argument_list|,
name|args
argument_list|,
name|outer_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
name|cp_error
argument_list|(
literal|"ambiguous class template instantiation for `%#T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|template
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|outer_args
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"%s %+#T"
argument_list|,
name|str
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|t
condition|)
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|pattern
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|t
condition|)
name|args
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|outer_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|uses_template_parms
argument_list|(
name|args
argument_list|)
condition|)
comment|/* If there are still template parameters amongst the args, then        we can't instantiate the type; there's no telling whether or not one        of the template parameters might eventually be instantiated to some        value that results in a specialization being used.  */
return|return
name|type
return|;
comment|/* We must copy the arguments to the permanent obstack since      during the tsubst'ing below they may wind up in the      DECL_TI_ARGS of some instantiated member template.  */
name|args
operator|=
name|copy_to_permanent
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
name|maybe_push_to_top_level
argument_list|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer_args
condition|)
name|args
operator|=
name|add_to_template_args
argument_list|(
name|outer_args
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
condition|)
block|{
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|type
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
operator|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
operator|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_GETS_NEW
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_GETS_NEW
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_GETS_DELETE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONVERSION
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_PACKED
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* For libjava's JArray<T> */
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* If this is a partial instantiation, don't tsubst anything.  We will      only use this type for implicit typename, so the actual contents don't      matter.  All that matters is whether a particular name is a type.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|pbases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbases
condition|)
block|{
name|tree
name|bases
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|pbases
argument_list|)
decl_stmt|;
name|bases
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|elt
decl_stmt|,
name|basetype
decl_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
operator|=
name|elt
operator|=
name|tsubst
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|pbases
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"base type `%T' of `%T' fails to be a struct or class type"
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|cp_error
argument_list|(
literal|"base class `%T' of `%T' has incomplete type"
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* These are set up in xref_basetypes for normal classes, so 	       we have to handle them here for template bases.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_GETS_NEW
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_GETS_NEW
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_GETS_DELETE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|type
argument_list|)
operator||=
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* Don't initialize this until the vector is filled out, or 	   lookups will crash.  */
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
operator|=
name|bases
expr_stmt|;
block|}
block|}
name|field_chain
operator|=
operator|&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|tag
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* These will add themselves to CLASSTYPE_TAGS for the new type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tag
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
operator|(
name|void
operator|)
name|tsubst_enum
argument_list|(
name|tag
argument_list|,
name|args
argument_list|,
name|field_chain
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|field_chain
condition|)
block|{
name|DECL_FIELD_CONTEXT
argument_list|(
operator|*
name|field_chain
argument_list|)
operator|=
name|type
expr_stmt|;
name|field_chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|field_chain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|tsubst
argument_list|(
name|tag
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Don't replace enum constants here.  */
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
name|tree
name|r
init|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|pending_statics
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|r
argument_list|,
name|pending_statics
argument_list|)
expr_stmt|;
comment|/* Perhaps we should do more of grokfield here.  */
name|start_decl_1
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|r
argument_list|,
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|field_chain
operator|=
name|r
expr_stmt|;
name|field_chain
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|=
name|tsubst_chain
argument_list|(
name|TYPE_METHODS
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Construct the DECL_FRIENDLIST for the new class type.  */
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|pattern
argument_list|)
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|friends
decl_stmt|;
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|friends
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
init|;
name|friends
operator|!=
name|NULL_TREE
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|tsubst_friend_function
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|,
name|args
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_VALUE
argument_list|(
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tsubst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|t
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|pattern
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|friend_type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|new_friend_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* The call to xref_tag_from_type does injection for friend 	   classes.  */
name|new_friend_type
operator|=
name|xref_tag_from_type
argument_list|(
name|tsubst
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|new_friend_type
operator|=
name|tsubst_friend_class
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* Trick make_friend_class into realizing that the friend 	   we're adding is a template, not an ordinary class.  It's 	   important that we use make_friend_class since it will 	   perform some error-checking and output cross-reference 	   information.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|make_friend_class
argument_list|(
name|type
argument_list|,
name|new_friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
block|}
comment|/* This does injection for friend functions. */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|t
operator|=
name|tsubst
argument_list|(
name|DECL_TEMPLATE_INJECT
argument_list|(
name|template
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|d
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Already injected.  */
empty_stmt|;
else|else
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|require_complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|finish_struct_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|repo_template_used
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|end
label|:
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_eq
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Don't care if one declares its arg const and the other doesn't -- the      main variant of the arg type is all that matters.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|list_eq
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_nested_type_by_name
parameter_list|(
name|ctype
parameter_list|,
name|name
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|complete_type
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
comment|/* this catches typedef enum { foo } bar; */
operator|||
name|name
operator|==
name|TYPE_IDENTIFIER
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If arg is a non-type template parameter that does not depend on template    arguments, fold it like we weren't in the body of a template.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_nontype_arg
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Sometimes, one of the args was an expression involving a 	 template constant parameter, like N - 1.  Now that we've 	 tsubst'd, we might have something like 2 - 1.  This will 	 confuse lookup_template_class, so we do constant folding 	 here.  We have to unset processing_template_decl, to 	 fool build_expr_from_tree() into building an actual 	 tree.  */
name|int
name|saved_processing_template_decl
init|=
name|processing_template_decl
decl_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|fold
argument_list|(
name|build_expr_from_tree
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Return the TREE_VEC with the arguments for the innermost template header,    where ARGS is either that or the VEC of VECs for all the arguments.     If is_spec, then we are dealing with a specialization of a member    template, and want the second-innermost args, the innermost ones that    are instantiated.  */
end_comment

begin_function
name|tree
name|innermost_args
parameter_list|(
name|args
parameter_list|,
name|is_spec
parameter_list|)
name|tree
name|args
decl_stmt|;
name|int
name|is_spec
decl_stmt|;
block|{
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-
literal|1
operator|-
name|is_spec
argument_list|)
return|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Substitute ARGS into the vector of template arguments T.  */
end_comment

begin_function
name|tree
name|tsubst_template_arg_vector
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|need_new
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|elts
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elts
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|elts
index|[
name|i
index|]
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|elts
index|[
name|i
index|]
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|tsubst_expr
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|need_new
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_new
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|elts
index|[
name|i
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Take the tree structure T and replace template parameters used therein    with the argument vector ARGS.  IN_DECL is an associated decl for    diagnostics.     tsubst is used for dealing with types, decls and the like; for    expressions, use tsubst_expr or tsubst_copy.  */
end_comment

begin_function
name|tree
name|tsubst
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
operator|||
name|t
operator|==
name|integer_type_node
operator|||
name|t
operator|==
name|void_type_node
operator|||
name|t
operator|==
name|char_type_node
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|unknown_type_node
condition|)
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|r
init|=
name|build_ptrmemfunc_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|r
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/* else fall through */
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|uses_template_parms
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|context
operator|=
name|tsubst
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
comment|/* For a member class template, we need all the 		     template arguments.  */
if|if
condition|(
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|argvec
operator|=
name|add_to_template_args
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|context
argument_list|)
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|context
argument_list|)
condition|)
name|argvec
operator|=
name|complete_template_args
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|context
argument_list|)
argument_list|,
name|argvec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|t
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|r
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/* else fall through */
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|OP_IDENTIFIER
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|NAMESPACE_DECL
case|:
return|return
name|t
return|;
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|t
return|;
elseif|else
if|if
condition|(
name|ctx
operator|==
name|current_function_decl
condition|)
return|return
name|lookup_name
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|lookup_nested_type_by_name
argument_list|(
name|ctx
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|t
operator|==
name|integer_type_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|t
return|;
block|{
name|tree
name|max
init|=
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|max
operator|=
name|tsubst_expr
argument_list|(
name|max
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|max
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
return|return
name|itype
return|;
block|}
name|max
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|max
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_index_2_type
argument_list|(
name|size_zero_node
argument_list|,
name|max
argument_list|)
return|;
block|}
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
block|{
name|int
name|idx
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|levels
decl_stmt|;
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|arg
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|levels
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|levels
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|level
operator|-
literal|1
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|levels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
return|return
name|cp_build_type_variant
argument_list|(
name|arg
argument_list|,
name|TYPE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|arg
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* We are processing a type constructed from 			   a template template parameter */
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|r
decl_stmt|;
comment|/* We can get a TEMPLATE_TEMPLATE_PARM here when  			   we are resolving nested-types in the signature of  			   a member function templates. 			   Otherwise ARG is a TEMPLATE_DECL and is the real  			   template to be instantiated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|arg
operator|=
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|r
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
else|else
comment|/* We are processing a template argument list.  */
return|return
name|arg
return|;
block|}
else|else
return|return
name|arg
return|;
block|}
block|}
if|if
condition|(
name|level
operator|==
literal|1
condition|)
comment|/* This can happen during the attempted tsubst'ing in 	     unify.  This means that we don't yet have any information 	     about the template parameter in question.  */
return|return
name|t
return|;
comment|/* If we get here, we must have been looking at a parm for a 	   more deeply nested template.  Make a new version of this 	   template parameter, but with a lower level.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|r
argument_list|)
operator|=
name|reduce_template_parm_level
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|,
name|r
argument_list|,
name|levels
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|TEMPLATE_TYPE_DECL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|r
operator|=
name|reduce_template_parm_level
argument_list|(
name|t
argument_list|,
name|type
argument_list|,
name|levels
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
case|case
name|TEMPLATE_DECL
case|:
block|{
comment|/* We can get here when processing a member template function 	   of a template class.  */
name|tree
name|tmpl
decl_stmt|;
name|tree
name|decl
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|tree
modifier|*
name|new_parms
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|int
name|is_template_template_parm
init|=
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_template_template_parm
condition|)
block|{
comment|/* We might already have an instance of this template. */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
block|}
comment|/* Make a new template decl.  It will be similar to the 	   original, but will record the current template arguments.  	   We also create a new function declaration, which is just 	   like the old one, but points to this new template, rather 	   than the old one.  */
name|tmpl
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|tmpl
argument_list|)
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_template_template_parm
condition|)
block|{
name|tree
name|new_decl
init|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|new_type
expr_stmt|;
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|new_type
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|new_decl
init|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
block|}
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* The template parameters for this new template are all the 	   template parameters for the old template, except the 	   outermost level of parameters. */
for|for
control|(
name|new_parms
operator|=
operator|&
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|,
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
init|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|!=
name|NULL_TREE
condition|;
name|new_parms
operator|=
operator|&
operator|(
name|TREE_CHAIN
argument_list|(
operator|*
name|new_parms
argument_list|)
operator|)
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|new_vec
init|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|new_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|default_value
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm_decl
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
name|i
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|tsubst
argument_list|(
name|default_value
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|parm_decl
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|build_int_2
argument_list|(
literal|0
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|new_vec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
comment|/* We don't partially instantiate partial specializations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|tmpl
return|;
comment|/* What should we do with the specializations of this member 	   template?  Are they specializations of this new template, 	   or instantiations of the templates they previously were? 	   this new template?  And where should their 	   DECL_TI_TEMPLATES point?  */
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|spec
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
init|;
name|spec
operator|!=
name|NULL_TREE
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
comment|/* It helps to consider example here.  Consider:  	       template<class T> 	       struct S { 	         template<class U> 		 void f(U u);  		 template<> 		 void f(T* t) {} 	       }; 	        	       Now, for example, we are instantiating S<int>::f(U u).   	       We want to make a template:  	       template<class U> 	       void S<int>::f(U);  	       It will have a specialization, for the case U = int*, of 	       the form:  	       template<> 	       void S<int>::f<int*>(int*);  	       This specialization will be an instantiation of 	       the specialization given in the declaration of S, with 	       argument list int*.  */
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|tree
name|spec_args
decl_stmt|;
name|tree
name|new_fn
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Instantiations are on the same list, but they're of 		 no concern to us.  */
continue|continue;
name|spec_args
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|new_fn
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|spec_args
argument_list|,
name|new_fn
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record this partial instantiation.  */
name|register_specialization
argument_list|(
name|tmpl
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|tree
name|argvec
decl_stmt|;
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|member
decl_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|member
operator|=
literal|2
expr_stmt|;
else|else
name|member
operator|=
literal|1
expr_stmt|;
name|ctx
operator|=
name|tsubst
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|member
operator|=
literal|0
expr_stmt|;
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* If we are instantiating a specialization, get the other args.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|spec
decl_stmt|;
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Start by getting the innermost args.  */
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
condition|)
name|argvec
operator|=
name|args
expr_stmt|;
else|else
name|argvec
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
condition|)
name|argvec
operator|=
name|complete_template_args
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do we already have this instantiation?  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
return|return
name|spec
return|;
block|}
comment|/* We do NOT check for matching decls pushed separately at this            point, as they may not represent instantiations of this            template, and in any case are considered separate under the            discrete model.  Instead, see add_maybe_template.  */
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|member
operator|&&
operator|!
name|strncmp
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Type-conversion operator.  Reconstruct the name, in 	       case it's the name of one of the template's parameters.  */
name|DECL_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_typename_overload
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_ARGUMENTS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|maybe_retrofit_in_chrg
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|grok_ctor_properties
argument_list|(
name|ctx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|r
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|r
argument_list|)
argument_list|,
name|DECL_FRIEND_P
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_destructor_name
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Instantiations of template functions must be mangled 	       specially, in order to conform to 14.5.5.1 	       [temp.over.link].  We use in_decl below rather than 	       DECL_TI_TEMPLATE (r) because the latter is set to 	       NULL_TREE in instantiate_decl.  */
name|tree
name|tmpl
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|tmpl
operator|=
name|in_decl
expr_stmt|;
comment|/* tmpl will be NULL if this is a specialization of a 	       member function of a template class.  */
if|if
condition|(
name|name_mangling_version
operator|<
literal|1
operator|||
name|tmpl
operator|==
name|NULL_TREE
operator|||
operator|(
name|member
operator|&&
operator|!
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|)
condition|)
block|{
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|,
name|arg_types
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* We pass the outermost template parameters to 		       build_template_decl_overload, since the innermost 		       template parameters are still just template 		       parameters; there are no corresponding subsitution 		       arguments.  Levels of parms that have been bound 		       before are not represented in DECL_TEMPLATE_PARMS.  */
name|tparms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
while|while
condition|(
name|tparms
operator|&&
name|TREE_CHAIN
argument_list|(
name|tparms
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|tparms
operator|=
name|TREE_CHAIN
argument_list|(
name|tparms
argument_list|)
expr_stmt|;
name|targs
operator|=
name|innermost_args
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the template is a specialization, then it is 		       a member template specialization.  We have 		       something like:  		       template<class T> struct S { 		         template<int i> void f(); 			 template<> void f<7>(); 		       };  		       and now we are forming S<double>::f<7>. 		       Therefore, the template parameters of interest 		       are those that are specialized by the template 		       (i.e., the int), not those we are using to 		       instantiate the template, i.e. the double.  */
name|tparms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|tparms
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tparms
operator|=
name|TREE_VALUE
argument_list|(
name|tparms
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_template_decl_overload
argument_list|(
name|r
argument_list|,
name|arg_types
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
name|tparms
argument_list|,
name|targs
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_RTL
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|r
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If we're not using ANSI overloading, then we might have 	       called duplicate_decls above, and gotten back an 	       preexisting version of this function.  We treat such a 	       function as a specialization.  Otherwise, we cleared 	       both TREE_STATIC and DECL_TEMPLATE_SPECIALIZATION, so 	       this condition will be false.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|||
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|r
argument_list|)
condition|)
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
block|}
comment|/* Like grokfndecl.  If we don't do this, pushdecl will mess up our 	   TREE_CHAIN because it doesn't find a previous decl.  Sigh.  */
if|if
condition|(
name|member
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|FIELD_DECL
case|:
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DECL_FIELD_CONTEXT (r) = tsubst (DECL_FIELD_CONTEXT (t), args, in_decl);
endif|#
directive|endif
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"instantiation of `%D' as type void"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|USING_DECL
case|:
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_copy
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|VAR_DECL
case|:
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|ctx
init|=
name|tsubst_copy
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
comment|/* Do we already have this instantiation?  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|decls
init|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|decls
condition|;
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
control|)
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|)
operator|==
name|ctx
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|decls
argument_list|)
return|;
block|}
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_static_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't try to expand the initializer until someone tries to use 	   this variable; otherwise we run into circular dependencies.  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_RTL
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|declsp
init|=
operator|&
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
operator|*
name|declsp
operator|=
name|perm_tree_cons
argument_list|(
name|argvec
argument_list|,
name|r
argument_list|,
operator|*
name|declsp
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"instantiation of `%D' as type void"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|t
operator|==
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
return|;
block|{
name|tree
name|r
init|=
name|copy_node
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|,
name|result
decl_stmt|;
name|int
name|via_public
decl_stmt|,
name|via_virtual
decl_stmt|,
name|via_protected
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|via_public
operator|=
name|TREE_VIA_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|via_protected
operator|=
name|TREE_VIA_PROTECTED
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|via_virtual
operator|=
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|result
operator|=
name|hash_tree_cons
argument_list|(
name|via_public
argument_list|,
name|via_virtual
argument_list|,
name|via_protected
argument_list|,
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_PARMLIST
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
case|case
name|TREE_VEC
case|:
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* A binfo node.  We always need to make a copy, of the node 	     itself and of its BINFO_BASETYPES.  */
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Make sure type isn't a typedef copy.  */
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* Otherwise, a vector of template arguments.  */
return|return
name|tsubst_template_arg_vector
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|r
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
specifier|static
name|int
name|last_line
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_file
init|=
literal|0
decl_stmt|;
comment|/* We keep track of the last time we issued this error 	       message to avoid spewing a ton of messages during a 	       single bad template instantiation.  */
if|if
condition|(
name|last_line
operator|!=
name|lineno
operator|||
name|last_file
operator|!=
name|input_filename
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot form type %s to reference type %T during template instantiation"
argument_list|,
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|)
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|last_line
operator|=
name|lineno
expr_stmt|;
name|last_file
operator|=
name|input_filename
expr_stmt|;
block|}
comment|/* Use the underlying type in an attempt at error 	       recovery; maybe the user meant vector<int> and wrote 	       vector<int&>, or some such.  */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|r
operator|=
name|type
expr_stmt|;
else|else
name|r
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
name|r
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_type_variant
argument_list|(
name|r
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will this ever be needed for TYPE_..._TO values?  */
name|layout_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
return|return
name|build_offset_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|values
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
comment|/* Don't bother recursing if we know it won't change anything.	*/
if|if
condition|(
name|values
operator|!=
name|void_list_node
condition|)
block|{
comment|/* This should probably be rewritten to use hash_tree_cons for                the memory savings.  */
name|tree
name|first
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
init|;
name|values
operator|&&
name|values
operator|!=
name|void_list_node
condition|;
name|values
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Don't instantiate default args unless they are used. 		   Handle it in build_over_call instead.  */
name|tree
name|purpose
init|=
name|TREE_PURPOSE
argument_list|(
name|values
argument_list|)
decl_stmt|;
name|tree
name|x
init|=
name|build_tree_list
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|x
expr_stmt|;
else|else
name|first
operator|=
name|x
expr_stmt|;
name|last
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|==
name|void_list_node
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|values
operator|=
name|first
expr_stmt|;
block|}
if|if
condition|(
name|context
condition|)
name|context
operator|=
name|tsubst
argument_list|(
name|context
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Could also optimize cases where return value and 	   values have common elements (e.g., T min(const&T, const T&).  */
comment|/* If the above parameters haven't changed, just return the type.  */
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|values
operator|==
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
operator|&&
name|context
operator|==
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* Construct a new type node and return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|context
operator|==
name|NULL_TREE
condition|)
block|{
name|fntype
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|base
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|base
argument_list|,
name|type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fntype
operator|=
name|make_node
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_CONTEXT
argument_list|(
name|fntype
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|fntype
argument_list|)
operator|=
name|values
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|fntype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|fntype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|fntype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
condition|)
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Need to generate hash value.  */
name|my_friendly_abort
argument_list|(
literal|84
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|build_type_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|raises
operator|=
name|tsubst
argument_list|(
name|raises
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|raises
argument_list|)
expr_stmt|;
block|}
return|return
name|fntype
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|domain
init|=
name|tsubst
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|domain
operator|==
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|r
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TYPENAME_TYPE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|f
init|=
name|tsubst_copy
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|f
operator|=
name|make_typename_type
argument_list|(
name|ctx
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_variant
argument_list|(
name|f
argument_list|,
name|TYPE_READONLY
argument_list|(
name|f
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|f
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|INDIRECT_REF
case|:
return|return
name|make_pointer_declarator
argument_list|(
name|type
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|make_reference_declarator
argument_list|(
name|type
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
return|return
name|build_parse_node
argument_list|(
name|ARRAY_REF
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|make_call_declarator
argument_list|(
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|build_parse_node
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in template"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_function
name|void
name|do_pushlevel
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|do_poplevel
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
name|int
name|saved_warn_unused
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|saved_warn_unused
operator|=
name|warn_unused
expr_stmt|;
name|warn_unused
operator|=
literal|0
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|kept_level_p
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|warn_unused
operator|=
name|saved_warn_unused
expr_stmt|;
name|t
operator|=
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like tsubst, but deals with expressions.  This function just replaces    template parms; to finish processing the resultant expression, use    tsubst_expr.  */
end_comment

begin_function
name|tree
name|tsubst_copy
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARM_DECL
case|:
return|return
name|do_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
name|ctx
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|lookup_field
argument_list|(
name|ctx
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|t
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|TEMPLATE_DECL
case|:
if|if
condition|(
name|is_member_template
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
return|;
else|else
return|return
name|t
return|;
if|#
directive|if
literal|0
block|case IDENTIFIER_NODE:       return do_identifier (t, 0);
endif|#
directive|endif
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
comment|/* Unary + */
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|THROW_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|NULL_TREE
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|SCOPE_REF
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|MEMBER_REF
case|:
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|get_first_fn
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
comment|/* Sometimes FN is a LOOKUP_EXPR.  */
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|fn
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|METHOD_CALL_EXPR
case|:
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|base
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|BIND_EXPR
case|:
case|case
name|COND_EXPR
case|:
case|case
name|MODOP_EXPR
case|:
block|{
name|tree
name|r
init|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|BIND_EXPR
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* This processing  should really occur in tsubst_expr, 	       However, tsubst_expr does not recurse into expressions, 	       since it assumes that there aren't any statements 	       inside them.  Instead, it simply calls 	       build_expr_from_tree.  So, we need to expand the 	       BIND_EXPR here.  */
name|tree
name|rtl_expr
init|=
name|begin_stmt_expr
argument_list|()
decl_stmt|;
name|tree
name|block
init|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|r
operator|=
name|finish_stmt_expr
argument_list|(
name|rtl_expr
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
case|case
name|NEW_EXPR
case|:
block|{
name|tree
name|r
init|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
decl_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DELETE_EXPR
case|:
block|{
name|tree
name|r
init|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
decl_stmt|;
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_VEC
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
comment|/* Substituted template arguments */
name|tree
name|targs
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|targs
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lookup_template_function
argument_list|(
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|targs
argument_list|)
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst_copy
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst_copy
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst_copy
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|TYPE_DECL
case|:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build_typename_overload
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
else|else
return|return
name|t
return|;
case|case
name|CONSTRUCTOR
case|:
return|return
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|tsubst_copy
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like tsubst_copy, but also does semantic processing and RTL expansion.  */
end_comment

begin_function
name|tree
name|tsubst_expr
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RETURN_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_return_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|RETURN_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_STMT
case|:
block|{
name|int
name|i
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|tree
name|dcl
decl_stmt|,
name|init
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dcl
operator|=
name|start_decl
argument_list|(
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|init
operator|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|dcl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
comment|/*init ? LOOKUP_ONLYCONVERTING :*/
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|dcl
return|;
block|}
case|case
name|FOR_STMT
case|:
block|{
name|tree
name|tmp
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_for_stmt
argument_list|()
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|FOR_INIT_STMT
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_init_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tsubst_expr
argument_list|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_stmt
argument_list|(
name|tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WHILE_STMT
case|:
block|{
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_while_stmt
argument_list|()
expr_stmt|;
name|finish_while_stmt_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|WHILE_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_while_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DO_STMT
case|:
block|{
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_do_stmt
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_do_body
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_do_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|DO_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_STMT
case|:
block|{
name|tree
name|tmp
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
condition|)
block|{
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|=
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
condition|)
block|{
name|begin_else_clause
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_else_clause
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_STMT
case|:
block|{
name|tree
name|substmt
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_compound_stmt
argument_list|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|substmt
operator|=
name|COMPOUND_BODY
argument_list|(
name|t
argument_list|)
init|;
name|substmt
operator|!=
name|NULL_TREE
condition|;
name|substmt
operator|=
name|TREE_CHAIN
argument_list|(
name|substmt
argument_list|)
control|)
name|tsubst_expr
argument_list|(
name|substmt
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|finish_compound_stmt
argument_list|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
break|break;
case|case
name|BREAK_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_break_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONTINUE_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_continue_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|SWITCH_STMT
case|:
block|{
name|tree
name|val
decl_stmt|,
name|tmp
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_switch_stmt
argument_list|()
expr_stmt|;
name|val
operator|=
name|tsubst_expr
argument_list|(
name|SWITCH_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_switch_cond
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|,
name|tmp
condition|)
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_switch_stmt
argument_list|(
name|val
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CASE_LABEL
case|:
name|finish_case_label
argument_list|(
name|tsubst_expr
argument_list|(
name|CASE_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|t
operator|=
name|define_label
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|expand_label
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
comment|/* Computed goto's must be tsubst'd into.  On the other hand, 	   non-computed gotos must not be; the identifier in question 	   will have no binding.  */
name|t
operator|=
name|tsubst_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_goto_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_asm_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|ASM_CV_QUAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_STRING
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_INPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_CLOBBERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_BLOCK
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_try_block
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_try_block
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|{
name|tree
name|handler
init|=
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|handler
condition|;
name|handler
operator|=
name|TREE_CHAIN
argument_list|(
name|handler
argument_list|)
control|)
name|tsubst_expr
argument_list|(
name|handler
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
name|finish_handler_sequence
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HANDLER
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_handler
argument_list|()
expr_stmt|;
if|if
condition|(
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|d
init|=
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|expand_start_catch_block
argument_list|(
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|d
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_start_catch_block
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_handler_parms
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_handler
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_DEFN
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|tsubst_enum
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|build_expr_from_tree
argument_list|(
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|instantiate_template
parameter_list|(
name|tmpl
parameter_list|,
name|targ_ptr
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
name|targ_ptr
decl_stmt|;
block|{
name|tree
name|fndecl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_fmp_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|283
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  This does work      for member template specializations; the list is set up from the      tsubst TEMPLATE_DECL case when the containing class is instantiated.  */
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|spec
init|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|targ_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
block|}
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|old_fmp_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|len
operator|=
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|targ_ptr
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|tree
name|nt
init|=
name|target_type
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|nt
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|nt
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' composed from a local class is not a valid template-argument"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  trying to instantiate `%D'"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|TREE_VEC_ELT
argument_list|(
name|targ_ptr
argument_list|,
name|i
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|targ_ptr
operator|=
name|copy_to_permanent
argument_list|(
name|targ_ptr
argument_list|)
expr_stmt|;
comment|/* substitute template parameters */
name|fndecl
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
condition|)
name|add_pending_template
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|out
label|:
name|function_maybepermanent_obstack
operator|=
name|old_fmp_obstack
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Push the name of the class template into the scope of the instantiation.  */
end_comment

begin_function
name|void
name|overload_template_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
init|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
operator|==
name|type
condition|)
return|return;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like type_unification but designed specially to handle conversion    operators.       The FN is a TEMPLATE_DECL for a function.  The ARGS are the    arguments that are being used when calling it.       If FN is a conversion operator, RETURN_TYPE is the type desired as    the result of the conversion operator.     The EXTRA_FN_ARG, if any, is the type of an additional    parameter to be added to the beginning of FN's parameter list.       The other arguments are as for type_unification.  */
end_comment

begin_function
name|int
name|fn_type_unification
parameter_list|(
name|fn
parameter_list|,
name|explicit_targs
parameter_list|,
name|targs
parameter_list|,
name|args
parameter_list|,
name|return_type
parameter_list|,
name|strict
parameter_list|,
name|extra_fn_arg
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|targs
decl_stmt|,
name|args
decl_stmt|,
name|return_type
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|tree
name|extra_fn_arg
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is a template conversion operator.  Use the return types          as well as the argument types.  */
name|parms
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra_fn_arg
operator|!=
name|NULL_TREE
condition|)
name|parms
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|extra_fn_arg
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/* We allow incomplete unification without an error message here      because the standard doesn't seem to explicitly prohibit it.  Our      callers must be ready to deal with unification failures in any      event.  */
return|return
name|type_unification
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
name|parms
argument_list|,
name|args
argument_list|,
name|explicit_targs
argument_list|,
name|strict
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Type unification.     We have a function template signature with one or more references to    template parameters, and a parameter list we wish to fit to this    template.  If possible, produce a list of parameters for the template    which will cause it to fit the supplied parameter list.     Return zero for success, 2 for an incomplete match that doesn't resolve    all the types, and 1 for complete failure.  An error message will be    printed only for an incomplete match.     TPARMS[NTPARMS] is an array of template parameter types.     TARGS[NTPARMS] is the array into which the deduced template    parameter values are placed.  PARMS is the function template's    signature (using TEMPLATE_PARM_IDX nodes), and ARGS is the argument    list we're trying to match against it.     The EXPLICIT_TARGS are explicit template arguments provided via a    template-id.     The parameter STRICT is one of:     DEDUCE_CALL:       We are deducing arguments for a function call, as in      [temp.deduct.call].     DEDUCE_CONV:      We are deducing arguments for a conversion function, as in       [temp.deduct.conv].     DEDUCE_EXACT:      We are deducing arguments when calculating the partial      ordering between specializations of function or class      templates, as in [temp.func.order] and [temp.class.order],      when doing an explicit instantiation as in [temp.explicit],      when determining an explicit specialization as in      [temp.expl.spec], or when taking the address of a function      template, as in [temp.deduct.funcaddr].  */
end_comment

begin_function
name|int
name|type_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|,
name|explicit_targs
parameter_list|,
name|strict
parameter_list|,
name|allow_incomplete
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|,
name|explicit_targs
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|allow_incomplete
decl_stmt|;
block|{
name|int
modifier|*
name|explicit_mask
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|explicit_targs
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|arg_vec
decl_stmt|;
name|arg_vec
operator|=
name|coerce_template_parms
argument_list|(
name|tparms
argument_list|,
name|explicit_targs
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_vec
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
name|explicit_mask
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|explicit_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|arg_vec
argument_list|)
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|arg_vec
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL_TREE
condition|;
operator|++
name|i
control|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|arg_vec
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Let unify know that this argument was explicit.  */
name|explicit_mask
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|explicit_mask
operator|=
literal|0
expr_stmt|;
return|return
name|type_unification_real
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parms
argument_list|,
name|args
argument_list|,
literal|0
argument_list|,
name|strict
argument_list|,
name|allow_incomplete
argument_list|,
name|explicit_mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adjust types before performing type deduction, as described in    [temp.deduct.call] and [temp.deduct.conv].  The rules in these two    sections are symmetric.  PARM is the type of a function parameter    or the return type of the conversion function.  ARG is the type of    the argument passed to the call, or the type of the value    intialized with the result of the conversion function.  */
end_comment

begin_function
name|void
name|maybe_adjust_types_for_deduction
parameter_list|(
name|strict
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|unification_kind_t
name|strict
decl_stmt|;
name|tree
modifier|*
name|parm
decl_stmt|;
name|tree
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
break|break;
case|case
name|DEDUCE_CONV
case|:
block|{
comment|/* Swap PARM and ARG throughout the remainder of this 	   function; the handling is precisely symmetric since PARM 	   will initialize ARG rather than vice versa.  */
name|tree
modifier|*
name|temp
init|=
name|parm
decl_stmt|;
name|parm
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
block|}
case|case
name|DEDUCE_EXACT
case|:
comment|/* There is nothing to do in this case.  */
return|return;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [temp.deduct.call] 	  	 If P is not a reference type: 	  	 --If A is an array type, the pointer type produced by the 	 array-to-pointer standard conversion (_conv.array_) is 	 used in place of A for type deduction; otherwise, 	  	 --If A is a function type, the pointer type produced by 	 the function-to-pointer standard conversion 	 (_conv.func_) is used in place of A for type deduction; 	 otherwise, 	  	 --If A is a cv-qualified type, the top level 	 cv-qualifiers of A's type are ignored for type 	 deduction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
else|else
operator|*
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.deduct.call]            If P is a cv-qualified type, the top level cv-qualifiers      of P's type are ignored for type deduction.  If P is a      reference type, the type referred to by P is used for      type deduction.  */
operator|*
name|parm
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
operator|*
name|parm
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like type_unfication.  EXPLICIT_MASK, if non-NULL, is an array of    integers, with ones in positions corresponding to arguments in    targs that were provided explicitly, and zeros elsewhere.       If SUBR is 1, we're being called recursively (to unify the    arguments of a function or method parameter of a function    template).  */
end_comment

begin_function
specifier|static
name|int
name|type_unification_real
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|,
name|subr
parameter_list|,
name|strict
parameter_list|,
name|allow_incomplete
parameter_list|,
name|explicit_mask
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
name|int
name|subr
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|allow_incomplete
decl_stmt|;
name|int
modifier|*
name|explicit_mask
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|289
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|parms
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|290
argument_list|)
expr_stmt|;
comment|/* ARGS could be NULL (via a call from parse.y to      build_x_function_call).  */
if|if
condition|(
name|args
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|291
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|ntparms
operator|>
literal|0
argument_list|,
literal|292
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_MORE_CV_QUAL
operator||
name|UNIFY_ALLOW_DERIVED
expr_stmt|;
break|break;
case|case
name|DEDUCE_CONV
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_LESS_CV_QUAL
expr_stmt|;
break|break;
case|case
name|DEDUCE_EXACT
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_NONE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
comment|/* Conversions will be performed on a function argument that 	 corresponds with a function parameter that contains only 	 non-deducible template parameters and explicitly specified 	 template parameters.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|strict
operator|==
name|DEDUCE_EXACT
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|parm
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
block|}
else|else
comment|/* It might work; we shouldn't check now, because we might 	       get into infinite recursion.  Overload resolution will 	       handle it.  */
continue|continue;
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|0
block|if (TREE_CODE (arg) == VAR_DECL) 	arg = TREE_TYPE (arg);       else if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'e') 	arg = TREE_TYPE (arg);
else|#
directive|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|293
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|TREE_CODE
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|targs
decl_stmt|;
name|tree
name|arg_type
decl_stmt|;
comment|/* Have to back unify here */
name|arg
operator|=
name|OVL_FUNCTION
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|targs
operator|=
name|make_scratch_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg_type
argument_list|)
expr_stmt|;
name|parm
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arg_type
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg_type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|type_unification
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|targs
argument_list|,
name|arg_type
argument_list|,
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
name|DEDUCE_EXACT
argument_list|,
name|allow_incomplete
argument_list|)
return|;
block|}
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|flag_ansi
operator|&&
name|arg
operator|==
name|TREE_TYPE
argument_list|(
name|null_node
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"using type void* for NULL"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|ptr_type_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|subr
condition|)
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|sub_strict
argument_list|,
name|explicit_mask
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
block|}
block|}
comment|/* Fail if we've reached the end of the parm list, and more args      are present, and the parm list isn't variadic.  */
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|1
return|;
comment|/* Fail if parms are left and they don't have default values.	 */
if|if
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|subr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|allow_incomplete
condition|)
name|error
argument_list|(
literal|"incomplete type unification"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the level of DECL, which declares a template parameter.  */
end_comment

begin_function
name|int
name|template_decl_level
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
return|return
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
case|case
name|PARM_DECL
case|:
return|return
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Decide whether ARG can be unified with PARM, considering only the    cv-qualifiers of each type, given STRICT as documented for unify.    Returns non-zero iff the unification is OK on that basis.*/
end_comment

begin_function
name|int
name|check_cv_quals_for_unify
parameter_list|(
name|strict
parameter_list|,
name|arg
parameter_list|,
name|parm
parameter_list|)
name|int
name|strict
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
return|return
operator|!
operator|(
operator|(
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_MORE_CV_QUAL
operator|)
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|arg
argument_list|)
operator|<
name|TYPE_READONLY
argument_list|(
name|parm
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|arg
argument_list|)
operator|<
name|TYPE_VOLATILE
argument_list|(
name|parm
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_LESS_CV_QUAL
operator|)
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|arg
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|parm
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|arg
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|parm
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Takes parameters as for type_unification.  Returns 0 if the    type deduction suceeds, 1 otherwise.  The parameter STRICT is a    bitwise or of the following flags:       UNIFY_ALLOW_NONE:        Require an exact match between PARM and ARG.      UNIFY_ALLOW_MORE_CV_QUAL:        Allow the deduced ARG to be more cv-qualified than ARG.      UNIFY_ALLOW_LESS_CV_QUAL:        Allow the deduced ARG to be less cv-qualified than ARG.      UNIFY_ALLOW_DERIVED:        Allow the deduced ARG to be a template base class of ARG,        or a pointer to a template base class of the type pointed to by        ARG.  */
end_comment

begin_function
name|int
name|unify
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|,
name|explicit_mask
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|strict
decl_stmt|;
name|int
modifier|*
name|explicit_mask
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
name|tree
name|targ
decl_stmt|;
name|tree
name|tparm
decl_stmt|;
comment|/* I don't think this will do the right thing with respect to types.      But the only case I've seen it in so far has been array bounds, where      signedness is the only information lost, and I think that will be      okay.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|parm
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
return|return
literal|1
return|;
comment|/* If PARM uses template parameters, then we can't bail out here,      even in ARG == PARM, since we won't record unifications for the      template parameters.  We might need them if we're trying to      figure out which of two things is more specialized.  */
if|if
condition|(
name|arg
operator|==
name|parm
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Immediately reject some pairs that won't unify because of      cv-qualification mismatches.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
comment|/* We check the cv-qualifiers when unifying with template type 	 parameters below.  We want to allow ARG `const T' to unify with 	 PARM `T' for example, when computing which of two templates 	 is more specialized, for example.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPENAME_TYPE
case|:
comment|/* In a type which contains a nested-name-specifier, template 	 argument values cannot be deduced for template parameters used 	 within the nested-name-specifier.  */
return|return
literal|0
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mixed types and values.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strict
operator|&&
name|targ
operator|!=
name|NULL_TREE
operator|&&
name|explicit_mask
operator|&&
name|explicit_mask
index|[
name|idx
index|]
condition|)
comment|/* An explicit template argument.  Don't even try to match 	   here; the overload resolution code will manage check to 	   see whether the call is legal.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
condition|)
block|{
comment|/* We arrive here when PARM does not involve template  		 specialization.  */
comment|/* ARG must be constructed from a template class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
block|{
name|tree
name|parmtmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|parmvec
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|argtmplvec
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The parameter and argument roles have to be switched here  		   in order to handle default arguments properly.  For example,  		   template<template<class> class TT> void f(TT<int>)  		   should be able to accept vector<int> which comes from  		   template<class T, class Allocator = allocator>  		   class vector.  */
if|if
condition|(
name|coerce_template_parms
argument_list|(
name|argtmplvec
argument_list|,
name|parmvec
argument_list|,
name|parmtmpl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Deduce arguments T, i from TT<T> or TT<i>.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parmvec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
continue|continue;
comment|/* This argument can be deduced.  */
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|argvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
name|arg
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If PARM is `const T' and ARG is only `int', we don't have 	     a match unless we are allowing additional qualification. 	     If ARG is `const int' and PARM is just `T' that's OK; 	     that binds `const int' to `T'.  */
if|if
condition|(
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict
operator||
name|UNIFY_ALLOW_LESS_CV_QUAL
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Consider the case where ARG is `const volatile int' and 	     PARM is `const T'.  Then, T should be `volatile int'.  */
name|arg
operator|=
name|cp_build_type_variant
argument_list|(
name|arg
argument_list|,
name|TYPE_READONLY
argument_list|(
name|arg
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|arg
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targ
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|comptypes
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|explicit_mask
operator|&&
name|explicit_mask
index|[
name|idx
index|]
operator|)
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targ
condition|)
return|return
literal|1
return|;
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
condition|)
block|{
name|int
name|i
init|=
operator|(
name|cp_tree_equal
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|POINTER_TYPE
case|:
block|{
name|int
name|sub_strict
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|arg
argument_list|)
condition|)
return|return
operator|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|,
name|explicit_mask
argument_list|)
operator|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
comment|/* [temp.deduct.call]  	   A can be another pointer or pointer to member type that can 	   be converted to the deduced A via a qualification 	   conversion (_conv.qual_).  	   We pass down STRICT here rather than UNIFY_ALLOW_NONE. 	   This will allow for additional cv-qualification of the 	   pointed-to types if appropriate.  In general, this is a bit 	   too generous; we are only supposed to allow qualification 	   conversions and this method will allow an ARG of char** and 	   a deduced ARG of const char**.  However, overload 	   resolution will subsequently invalidate the candidate, so 	   this is probably OK.  */
name|sub_strict
operator|=
name|strict
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
comment|/* The derived-to-base conversion only persists through one 	     level of pointers.  */
name|sub_strict
operator|&=
operator|~
name|UNIFY_ALLOW_DERIVED
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|sub_strict
argument_list|,
name|explicit_mask
argument_list|)
return|;
block|}
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|!=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|REAL_TYPE
comment|/* We use the TYPE_MAIN_VARIANT since we have already 		  checked cv-qualification at the top of the 		  function.  */
operator|&&
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* As far as unification is concerned, this wins.	 Later checks 	 will invalidate it if necessary.  */
return|return
literal|0
return|;
comment|/* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */
comment|/* Type INTEGER_CST can come from ordinary constant template args.  */
case|case
name|INTEGER_CST
case|:
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|tree_int_cst_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_VEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parm
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|strict
argument_list|,
name|explicit_mask
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|strict
operator|&
name|UNIFY_ALLOW_DERIVED
condition|)
comment|/* [temp.deduct.call]  	       If P is a class, and P has the form template-id, then A 	       can be a derived class of the deduced A.  Likewise, if 	       P is a pointer to a class of the form template-id, A 	       can be a pointer to a derived class pointed to by the 	       deduced A.  */
name|t
operator|=
name|get_template_base
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
operator|==
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
condition|)
name|t
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|type_unification_real
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|DEDUCE_EXACT
argument_list|,
literal|0
argument_list|,
name|explicit_mask
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|arg
operator|!=
name|decl_constant_value
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_DECL
case|:
comment|/* Matched cases are handled by the ARG == PARM test above.  */
return|return
literal|1
return|;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* We handle this case specially, since it comes up with 	     arrays.  In particular, something like:  	     template<int N> void f(int (&x)[N]);  	     Here, we are trying to unify the range type, which 	     looks like [0 ... (N - 1)].  */
name|tree
name|t
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Should this be a regular fold?  */
name|t
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t1
argument_list|,
name|t
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
return|;
block|}
comment|/* else fall through */
default|default:
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We're looking at an expression.  This can happen with 	     something like:  	       template<int I> 	       void foo(S<I>, S<I + 2>);               If the call looked like:                 foo(S<2>(), S<4>());  	     we would have already matched `I' with `2'.  Now, we'd 	     like to know if `4' matches `I + 2'.  So, we substitute 	     into that expression, and fold constants, in the hope of 	     figuring it out.  */
name|tree
name|t
init|=
name|maybe_fold_nontype_arg
argument_list|(
name|tsubst_expr
argument_list|(
name|parm
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|a
init|=
name|maybe_fold_nontype_arg
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Good, we mangaged to simplify the exression.  */
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t
argument_list|,
name|a
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
name|explicit_mask
argument_list|)
return|;
else|else
comment|/* Bad, we couldn't simplify this.  Assume it doesn't 	       unify.  */
return|return
literal|1
return|;
block|}
else|else
name|sorry
argument_list|(
literal|"use of `%s' in template type unification"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|mark_decl_instantiated
parameter_list|(
name|result
parameter_list|,
name|extern_p
parameter_list|)
name|tree
name|result
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* The TREE_PUBLIC flag for function declarations will have been        set correctly by tsubst.  */
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For WIN32 we also want to put explicit instantiations in 	 linkonce sections.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
condition|)
name|maybe_make_one_only
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|mark_inline_for_output
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given two function templates PAT1 and PAT2, and explicit template    arguments EXPLICIT_ARGS return:     1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.  */
end_comment

begin_function
name|int
name|more_specialized
parameter_list|(
name|pat1
parameter_list|,
name|pat2
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|pat1
decl_stmt|,
name|pat2
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
name|tree
name|targs
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|targs
operator|=
name|get_bindings_overload
argument_list|(
name|pat1
argument_list|,
name|pat2
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
block|{
operator|--
name|winner
expr_stmt|;
block|}
name|targs
operator|=
name|get_bindings_overload
argument_list|(
name|pat2
argument_list|,
name|pat1
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
block|{
operator|++
name|winner
expr_stmt|;
block|}
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Given two class template specialization list nodes PAT1 and PAT2, return:     1 if PAT1 is more specialized than PAT2 as described in [temp.class.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.  */
end_comment

begin_function
name|int
name|more_specialized_class
parameter_list|(
name|pat1
parameter_list|,
name|pat2
parameter_list|)
name|tree
name|pat1
decl_stmt|,
name|pat2
decl_stmt|;
block|{
name|tree
name|targs
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|--
name|winner
expr_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|++
name|winner
expr_stmt|;
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Return the template arguments that will produce the function signature    DECL from the function template FN, with the explicit template    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must    also match.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings_real
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|,
name|check_rettype
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
name|int
name|check_rettype
decl_stmt|;
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_scratch_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|tree
name|decl_arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|extra_fn_arg
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Sometimes we are trying to figure out what's being 	 specialized by a declaration that looks like a method, and it 	 turns out to be a static member function.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|&&
operator|!
name|is_member_template
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* The natural thing to do here seems to be to remove the 	   spurious `this' parameter from the DECL, but that prevents 	   unification from making use of the class type.  So, 	   instead, we have fn_type_unification add to the parameters 	   for FN.  */
name|extra_fn_arg
operator|=
name|build_pointer_type
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* In this case, though, adding the extra_fn_arg can confuse 	   things, so we remove from decl_arg_types instead.  */
name|decl_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_arg_types
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_args
argument_list|,
name|targs
argument_list|,
name|decl_arg_types
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|DEDUCE_EXACT
argument_list|,
name|extra_fn_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|check_rettype
condition|)
block|{
comment|/* Check to see that the resulting return type is also OK.  */
name|tree
name|t
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|complete_template_args
argument_list|(
name|fn
argument_list|,
name|targs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|targs
return|;
block|}
end_function

begin_comment
comment|/* For most uses, we want to check the return type.  */
end_comment

begin_function
name|tree
name|get_bindings
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
return|return
name|get_bindings_real
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* But for more_specialized, we only care about the parameter types.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings_overload
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
return|return
name|get_bindings_real
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|get_class_bindings
parameter_list|(
name|tparms
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|,
name|outer_args
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|,
name|outer_args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|tree
name|vec
init|=
name|make_temp_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
if|if
condition|(
name|outer_args
condition|)
block|{
name|tparms
operator|=
name|tsubst
argument_list|(
name|tparms
argument_list|,
name|outer_args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tsubst
argument_list|(
name|parms
argument_list|,
name|outer_args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|vec
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
name|NULL_TREE
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the list of templates in FNS that can    produce an instantiation matching DECL, given the explicit template    arguments EXPLICIT_ARGS.  */
end_comment

begin_function
name|tree
name|most_specialized
parameter_list|(
name|fns
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fns
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|,
name|champ
decl_stmt|,
name|args
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|fate
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|fns
init|;
operator|*
name|p
condition|;
control|)
block|{
name|args
operator|=
name|get_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fns
condition|)
return|return
name|NULL_TREE
return|;
name|fn
operator|=
name|fns
expr_stmt|;
name|champ
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized
argument_list|(
name|champ
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
block|}
name|champ
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
operator|&&
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
operator|!=
name|champ
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized
argument_list|(
name|champ
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the class template specializations in    SPECS that can produce an instantiation matching ARGS.  */
end_comment

begin_function
name|tree
name|most_specialized_class
parameter_list|(
name|specs
parameter_list|,
name|mainargs
parameter_list|,
name|outer_args
parameter_list|)
name|tree
name|specs
decl_stmt|,
name|mainargs
decl_stmt|,
name|outer_args
decl_stmt|;
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|,
name|t
decl_stmt|,
name|args
decl_stmt|,
name|champ
decl_stmt|;
name|int
name|fate
decl_stmt|;
for|for
control|(
name|t
operator|=
name|specs
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|args
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|mainargs
argument_list|,
name|outer_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|list
operator|=
name|decl_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|list
expr_stmt|;
name|champ
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|error_mark_node
return|;
block|}
name|champ
operator|=
name|t
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
operator|&&
name|t
operator|!=
name|champ
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* called from the parser.  */
end_comment

begin_function
name|void
name|do_decl_instantiation
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|storage
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of non-template `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we've already seen this template instance, use it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|result
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|VAR_DECL
condition|)
name|result
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
name|result
operator|=
name|decl
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|cp_error
argument_list|(
literal|"no matching template for `%D' found"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"explicit instantiation of non-template `%#D'"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|extern_p
operator|=
literal|1
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|mark_decl_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mark_class_instantiated
parameter_list|(
name|t
parameter_list|,
name|extern_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
block|{
name|SET_CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|extern_p
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|extern_p
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|extern_p
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|do_type_instantiation
parameter_list|(
name|t
parameter_list|,
name|storage
parameter_list|)
name|tree
name|t
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
name|int
name|nomem_p
init|=
literal|0
decl_stmt|;
name|int
name|static_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of non-template type `%T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* With -fexternal-templates, explicit instantiations are treated the same      as implicit ones.  */
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of `%#T' before definition of template"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
condition|)
name|nomem_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|extern_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
condition|)
name|static_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We've already instantiated this.  */
if|if
condition|(
name|CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|extern_p
condition|)
return|return;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|mark_class_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nomem_p
condition|)
return|return;
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|static_p
condition|)
for|for
control|(
name|tmp
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|mark_decl_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|mark_decl_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
name|do_type_instantiation
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a function DECL, which is a specialization of TEMP, modify    DECL to be a re-instantiation of TEMPL with the same template    arguments.     One reason for doing this is a scenario like this:       template<class T>      void f(const T&, int i);       void g() { f(3, 7); }       template<class T>      void f(const T& t, const int i) { }     Note that when the template is first instantiated, with    instantiate_template, the resulting DECL will have no name for the    first parameter, and the wrong type for the second.  So, when we go    to instantiate the DECL, we regenerate it.  */
end_comment

begin_function
name|void
name|regenerate_decl_from_template
parameter_list|(
name|decl
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
name|args
decl_stmt|;
name|tree
name|save_ti
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|tree
name|new_decl
decl_stmt|;
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Trick tsubst into giving us a new decl.  CODE_PATTERN must be the      most distant ancestor of DECL, since that's the one that will      actually be altered by a redefinition.  */
name|save_ti
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|code_pattern
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|new_decl
operator|=
name|tsubst
argument_list|(
name|code_pattern
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|code_pattern
argument_list|)
operator|=
name|save_ti
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Set up DECL_INITIAL, since tsubst doesn't.  */
name|pushclass
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|popclass
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Convince duplicate_decls to use the DECL_ARGUMENTS from the 	 new decl.  */
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|new_decl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_decl
argument_list|)
condition|)
comment|/* Set up the information about what is being specialized. */
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|duplicate_decls
argument_list|(
name|new_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce the definition of D, a _DECL generated from a template.  */
end_comment

begin_function
name|tree
name|instantiate_decl
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|ti
init|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|tmpl
init|=
name|TI_TEMPLATE
argument_list|(
name|ti
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TI_ARGS
argument_list|(
name|ti
argument_list|)
decl_stmt|;
name|tree
name|td
decl_stmt|;
name|tree
name|decl_pattern
decl_stmt|,
name|code_pattern
decl_stmt|;
name|int
name|nested
init|=
name|in_function_p
argument_list|()
decl_stmt|;
name|int
name|d_defined
decl_stmt|;
name|int
name|pattern_defined
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
for|for
control|(
name|td
operator|=
name|tmpl
init|;
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|td
argument_list|)
comment|/* This next clause handles friend templates defined inside 	    class templates.  The friend templates are not really 	    instantiations from the point of view of the language, but 	    they are instantiations from the point of view of the 	    compiler.  */
operator|||
operator|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|td
argument_list|)
operator|)
condition|;
control|)
name|td
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* In the case of a member template, decl_pattern is the partially      instantiated declaration (in the instantiated class), and code_pattern      is the original template definition.  */
name|decl_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|d_defined
operator|=
operator|(
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
name|pattern_defined
operator|=
operator|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d_defined
operator|=
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pattern_defined
operator|=
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d_defined
condition|)
return|return
name|d
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|spec
init|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
return|return
name|spec
return|;
block|}
comment|/* This needs to happen before any tsubsting.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
return|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_defined
condition|)
block|{
name|repo_template_used
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
if|if
condition|(
name|interface_unknown
condition|)
name|warn_if_unknown_interface
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|code_pattern
argument_list|)
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
else|else
name|warn_if_unknown_interface
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|at_eof
condition|)
name|import_export_decl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* Reject all external templates except inline functions.  */
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|d
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|d
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* We need to set up DECL_INITIAL regardless of pattern_defined if 	 the variable is a static const initialized in the class body.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pattern_defined
operator|||
operator|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|d
argument_list|)
operator|&&
name|nested
operator|)
operator|&&
operator|!
name|at_eof
operator|)
condition|)
block|{
comment|/* Defer all templates except inline functions used in another          function.  */
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
name|add_pending_template
argument_list|(
name|d
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|regenerate_decl_from_template
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* We already set the file and line above.  Reset them now in case      they changed as a result of calling regenerate_decl_from_template.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|DECL_IN_AGGR_P
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|t
init|=
name|DECL_SAVED_TREE
argument_list|(
name|code_pattern
argument_list|)
decl_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RETURN_INIT
condition|)
block|{
name|store_return_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CTOR_INITIALIZER
condition|)
block|{
name|current_member_init_list
operator|=
name|tsubst_expr_values
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|tsubst_expr_values
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|setup_vtbl_ptr
argument_list|()
expr_stmt|;
comment|/* Always keep the BLOCK node associated with the outermost 	 pair of curly braces of a function.  These are needed 	 for correct operation of dwarfout.c.  */
name|keep_next_level
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPOUND_STMT
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
name|nested
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|tree
name|tsubst_chain
parameter_list|(
name|t
parameter_list|,
name|argvec
parameter_list|)
name|tree
name|t
decl_stmt|,
name|argvec
decl_stmt|;
block|{
if|if
condition|(
name|t
condition|)
block|{
name|tree
name|first
init|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|first
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|x
init|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|x
expr_stmt|;
name|last
operator|=
name|x
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|tsubst_expr_values
parameter_list|(
name|t
parameter_list|,
name|argvec
parameter_list|)
name|tree
name|t
decl_stmt|,
name|argvec
decl_stmt|;
block|{
name|tree
name|first
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|p
init|=
operator|&
name|first
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|pur
init|=
name|tsubst_copy
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|tsubst_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|build_tree_list
argument_list|(
name|pur
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_decl_stmt
name|tree
name|last_tree
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|add_tree
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|last_tree
operator|=
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|begin_tree
parameter_list|()
block|{
name|saved_trees
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|last_tree
argument_list|,
name|saved_trees
argument_list|)
expr_stmt|;
name|last_tree
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_tree
parameter_list|()
block|{
name|my_friendly_assert
argument_list|(
name|saved_trees
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_tree
operator|=
name|TREE_VALUE
argument_list|(
name|saved_trees
argument_list|)
expr_stmt|;
name|saved_trees
operator|=
name|TREE_CHAIN
argument_list|(
name|saved_trees
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* D is an undefined function declaration in the presence of templates with    the same name, listed in FNS.  If one of them can produce D as an    instantiation, remember this so we can instantiate it at EOF if D has    not been defined by that time.  */
end_comment

begin_function
name|void
name|add_maybe_template
parameter_list|(
name|d
parameter_list|,
name|fns
parameter_list|)
name|tree
name|d
decl_stmt|,
name|fns
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|DECL_MAYBE_TEMPLATE
argument_list|(
name|d
argument_list|)
condition|)
return|return;
name|t
operator|=
name|most_specialized
argument_list|(
name|fns
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"ambiguous template instantiation for `%D'"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|maybe_template_tail
operator|=
name|perm_tree_cons
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|maybe_template_tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|maybe_template_tail
argument_list|)
expr_stmt|;
name|DECL_MAYBE_TEMPLATE
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instantiate an enumerated type.  Used by instantiate_class_template and    tsubst_expr.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_enum
parameter_list|(
name|tag
parameter_list|,
name|args
parameter_list|,
name|field_chain
parameter_list|)
name|tree
name|tag
decl_stmt|,
name|args
decl_stmt|;
name|tree
modifier|*
name|field_chain
decl_stmt|;
block|{
specifier|extern
name|tree
name|current_local_enum
decl_stmt|;
name|tree
name|prev_local_enum
init|=
name|current_local_enum
decl_stmt|;
name|tree
name|newtag
init|=
name|start_enum
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|tag
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|e
decl_stmt|,
name|values
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|e
operator|=
name|TYPE_VALUES
argument_list|(
name|tag
argument_list|)
init|;
name|e
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
name|tree
name|elt
init|=
name|build_enumerator
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|e
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|=
name|values
expr_stmt|;
name|values
operator|=
name|elt
expr_stmt|;
block|}
name|finish_enum
argument_list|(
name|newtag
argument_list|,
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|field_chain
condition|)
operator|*
name|field_chain
operator|=
name|grok_enum_decls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_local_enum
operator|=
name|prev_local_enum
expr_stmt|;
return|return
name|newtag
return|;
block|}
end_function

end_unit

