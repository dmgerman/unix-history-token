begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle parameterized types (templates) for GNU C++.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002  Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.    Rewritten by Jason Merrill (jason@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Known bugs or deficiencies include:       all methods must be provided in header files; can't use a source      file that contains only the method templates and "just win".  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* The type of functions taking a tree, and some additional data, and    returning an int.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*tree_fn_t
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The PENDING_TEMPLATES is a TREE_LIST of templates whose    instantiations have been deferred, either because their definitions    were not yet available, or because we were putting off doing the    work.  The TREE_PURPOSE of each entry is a SRCLOC indicating where    the instantiate request occurred; the TREE_VALUE is a either a DECL    (for a function or static data member), or a TYPE (for a class)    indicating what we are hoping to instantiate.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|last_pending_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_parmlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_header_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|saved_trees
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_type
name|inline_parm_levels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|inline_parm_levels_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|current_tinst_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A map from local variable declarations in the body of the template    presently being instantiated to the corresponding instantiated    local variables.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|local_specializations
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_NONE
value|0
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_MORE_CV_QUAL
value|1
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_LESS_CV_QUAL
value|2
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_DERIVED
value|4
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_INTEGER
value|8
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_OUTER_LEVEL
value|16
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
value|32
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_OUTER_LESS_CV_QUAL
value|64
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_MAX_CORRECTION
value|128
end_define

begin_define
define|#
directive|define
name|GTB_VIA_VIRTUAL
value|1
end_define

begin_comment
comment|/* The base class we are examining is 			     virtual, or a base class of a virtual 			     base.  */
end_comment

begin_define
define|#
directive|define
name|GTB_IGNORE_TYPE
value|2
end_define

begin_comment
comment|/* We don't need to try to unify the current 			     type with the desired type.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|resolve_overloaded_unification
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|unification_kind_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_one_overload
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|unification_kind_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unify
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pending_template
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reopen_tinst_level
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|classtype_mangled_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_initializer_list
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list_eq
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_bindings
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|coerce_template_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tsubst_enum
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_to_template_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_outermost_template_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_adjust_types_for_deduction
name|PARAMS
argument_list|(
operator|(
name|unification_kind_t
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_unification_real
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|unification_kind_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_template_header
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_fold_nontype_arg
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_nontype_argument
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_template_argument
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_bindings_overload
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|for_each_template_parm
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree_fn_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_template_parm_index
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inline_needs_template_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_inline_template_parms_recursive
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|retrieve_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|retrieve_local_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|register_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|register_local_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unregister_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|reduce_template_parm_level
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_template_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_template_parm
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_friend_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_friend_class
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_bindings_real
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_decl_level
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_get_template_decl_from_type_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_cv_quals_for_unify
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_template_arg_vector
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_template_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regenerate_decl_from_template
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|most_specialized
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|most_specialized_class
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_class_depth_real
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_aggr_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_arg_types
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_function_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_specialization_scope
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|process_partial_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_current_access_from_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_default_tmpl_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_call_declarator_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_template_base_recursive
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_template_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verify_class_unification
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|try_class_unification
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coerce_template_template_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|determine_specialization
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_args_equal
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tsubst_default_arguments
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|for_each_template_parm_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|copy_default_args_to_explicit_spec_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_default_args_to_explicit_spec
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|invalid_nontype_parm_type_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called once to initialize pt.c.  */
end_comment

begin_function
name|void
name|init_pt
parameter_list|()
block|{
name|ggc_add_tree_root
argument_list|(
operator|&
name|pending_templates
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|saved_trees
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|current_tinst_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do any processing required when DECL (a member template declaration    using TEMPLATE_PARAMETERS as its innermost parameter list) is    finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless    it is a specialization, in which case the DECL itself is returned.  */
end_comment

begin_function
name|tree
name|finish_member_template_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
comment|/* By returning NULL_TREE, the parser will just ignore this        declaration.  We have already issued the error.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Assume that the class is the only declspec.  */
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|check_member_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error
argument_list|(
literal|"data member `%D' cannot be a member template"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|check_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
return|;
block|}
else|else
return|return
name|decl
return|;
block|}
else|else
name|error
argument_list|(
literal|"invalid member template declaration `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the template nesting level of the indicated class TYPE.        For example, in:      template<class T>      struct A      {        template<class U>        struct B {};      };     A<T>::B<U> has depth two, while A<T> has depth one.      Both A<T>::B<int> and A<int>::B<U> have depth one, if    COUNT_SPECIALIZATIONS is 0 or if they are instantiations, not    specializations.       This function is guaranteed to return 0 if passed NULL_TREE so    that, for example, `template_class_depth (current_class_type)' is    always safe.  */
end_comment

begin_function
specifier|static
name|int
name|template_class_depth_real
parameter_list|(
name|type
parameter_list|,
name|count_specializations
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|count_specializations
decl_stmt|;
block|{
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|?
name|CP_DECL_CONTEXT
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|count_specializations
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
operator|++
name|depth
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|count_specializations
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
operator|++
name|depth
expr_stmt|;
block|}
block|}
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Returns the template nesting level of the indicated class TYPE.    Like template_class_depth_real, but instantiations do not count in    the depth.  */
end_comment

begin_function
name|int
name|template_class_depth
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|template_class_depth_real
argument_list|(
name|type
argument_list|,
comment|/*count_specializations=*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if processing DECL as part of do_pending_inlines    needs us to push template parms.  */
end_comment

begin_function
specifier|static
name|int
name|inline_needs_template_parms
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|most_general_template
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|>
operator|(
name|processing_template_decl
operator|+
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of maybe_begin_member_template_processing.    Push the template parms in PARMS, starting from LEVELS steps into the    chain, and ending at the beginning, since template parms are listed    innermost first.  */
end_comment

begin_function
specifier|static
name|void
name|push_inline_template_parms_recursive
parameter_list|(
name|parmlist
parameter_list|,
name|levels
parameter_list|)
name|tree
name|parmlist
decl_stmt|;
name|int
name|levels
decl_stmt|;
block|{
name|tree
name|parms
init|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|levels
operator|>
literal|1
condition|)
name|push_inline_template_parms_recursive
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|levels
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|processing_template_decl
argument_list|)
argument_list|,
name|parms
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
block|{
comment|/* Make a CONST_DECL as is done in process_template_parm. 	       It is ugly that we recreate this here; the original 	       version built in process_template_parm is no longer 	       available.  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Restore the template parameter context for a member template or    a friend template defined in a class definition.  */
end_comment

begin_function
name|void
name|maybe_begin_member_template_processing
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|levels
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inline_needs_template_parms
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|most_general_template
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|levels
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|-
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|--
name|levels
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|push_inline_template_parms_recursive
argument_list|(
name|parms
argument_list|,
name|levels
argument_list|)
expr_stmt|;
block|}
comment|/* Remember how many levels of template parameters we pushed so that      we can pop them later.  */
if|if
condition|(
operator|!
name|inline_parm_levels
condition|)
name|VARRAY_INT_INIT
argument_list|(
name|inline_parm_levels
argument_list|,
literal|4
argument_list|,
literal|"inline_parm_levels"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_parm_levels_used
operator|==
name|inline_parm_levels
operator|->
name|num_elements
condition|)
name|VARRAY_GROW
argument_list|(
name|inline_parm_levels
argument_list|,
literal|2
operator|*
name|inline_parm_levels_used
argument_list|)
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|inline_parm_levels
argument_list|,
name|inline_parm_levels_used
argument_list|)
operator|=
name|levels
expr_stmt|;
operator|++
name|inline_parm_levels_used
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the effects of begin_member_template_processing. */
end_comment

begin_function
name|void
name|maybe_end_member_template_processing
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|inline_parm_levels_used
condition|)
return|return;
operator|--
name|inline_parm_levels_used
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_INT
argument_list|(
name|inline_parm_levels
argument_list|,
name|inline_parm_levels_used
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero iff T is a member template function.  We must be    careful as in       template<class T> class C { void f(); }     Here, f is a template function, and a member, but not a member    template.  This function does not concern itself with the origin of    T, only its present state.  So if we have        template<class T> class C { template<class U> void f(U); }     then neither C<int>::f<char> nor C<T>::f<double> is considered    to be a member template.  But, `template<class U> void    C<int>::f(U)' is considered a member template.  */
end_comment

begin_function
name|int
name|is_member_template
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Anything that isn't a function or a template function is        certainly not a member template.  */
return|return
literal|0
return|;
comment|/* A local class can't have member templates.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
comment|/* If there are more levels of template parameters than 	     there are template classes surrounding the declaration, 	     then we have a member template.  */
operator|&&
operator|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|>
name|template_class_depth
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/* Returns non-zero iff T is a member template class.  See    is_member_template for a description of what precisely constitutes    a member template.  */
end_comment

begin_comment
unit|int is_member_template_class (t)      tree t; {   if (!DECL_CLASS_TEMPLATE_P (t))
comment|/* Anything that isn't a class template, is certainly not a member        template.  */
end_comment

begin_comment
unit|return 0;    if (!DECL_CLASS_SCOPE_P (t))
comment|/* Anything whose context isn't a class type is surely not a        member template.  */
end_comment

begin_comment
unit|return 0;
comment|/* If there are more levels of template parameters than there are      template classes surrounding the declaration, then we have a      member template.  */
end_comment

begin_endif
unit|return  (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (t))>  	   template_class_depth (DECL_CONTEXT (t))); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a new template argument vector which contains all of ARGS,    but has as its innermost set of arguments the EXTRA_ARGS.  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_template_args
parameter_list|(
name|args
parameter_list|,
name|extra_args
parameter_list|)
name|tree
name|args
decl_stmt|;
name|tree
name|extra_args
decl_stmt|;
block|{
name|tree
name|new_args
decl_stmt|;
name|int
name|extra_depth
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|extra_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|+
name|extra_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|extra_depth
condition|;
operator|++
name|j
operator|,
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|extra_args
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* Like add_to_template_args, but only the outermost ARGS are added to    the EXTRA_ARGS.  In particular, all but TMPL_ARGS_DEPTH    (EXTRA_ARGS) levels are added.  This function is used to combine    the template arguments from a partial instantiation with the    template arguments used to attain the full instantiation from the    partial instantiation.  */
end_comment

begin_function
specifier|static
name|tree
name|add_outermost_template_args
parameter_list|(
name|args
parameter_list|,
name|extra_args
parameter_list|)
name|tree
name|args
decl_stmt|;
name|tree
name|extra_args
decl_stmt|;
block|{
name|tree
name|new_args
decl_stmt|;
comment|/* If there are more levels of EXTRA_ARGS than there are ARGS,      something very fishy is going on.  */
name|my_friendly_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|>=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If *all* the new arguments will be the EXTRA_ARGS, just return      them.  */
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
condition|)
return|return
name|extra_args
return|;
comment|/* For the moment, we make ARGS look like it contains fewer levels.  */
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|add_to_template_args
argument_list|(
name|args
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
comment|/* Now, we restore ARGS to its full dimensions.  */
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|+=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* Return the N levels of innermost template arguments from the ARGS.  */
end_comment

begin_function
name|tree
name|get_innermost_template_args
parameter_list|(
name|args
parameter_list|,
name|n
parameter_list|)
name|tree
name|args
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|tree
name|new_args
decl_stmt|;
name|int
name|extra_levels
decl_stmt|;
name|int
name|i
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|n
operator|>=
literal|0
argument_list|,
literal|20000603
argument_list|)
expr_stmt|;
comment|/* If N is 1, just return the innermost set of template arguments.  */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
comment|/* If we're not removing anything, just return the arguments we were      given.  */
name|extra_levels
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|-
name|n
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|extra_levels
operator|>=
literal|0
argument_list|,
literal|20000603
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_levels
operator|==
literal|0
condition|)
return|return
name|args
return|;
comment|/* Make a new set of arguments, not containing the outer arguments.  */
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
operator|+
name|extra_levels
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* We've got a template header coming up; push to a new level for storing    the parms.  */
end_comment

begin_function
name|void
name|begin_template_parm_list
parameter_list|()
block|{
comment|/* We use a non-tag-transparent scope here, which causes pushtag to      put tags in this scope, rather than in the enclosing class or      namespace scope.  This is the right thing, since we want      TEMPLATE_DECLS, and not TYPE_DECLS for template classes.  For a      global template class, push_template_decl handles putting the      TEMPLATE_DECL into top-level scope.  For a nested template class,      e.g.:         template<class T> struct S1 {          template<class T> struct S2 {};         };       pushtag contains special code to call pushdecl_with_scope on the      TEMPLATE_DECL for S2.  */
name|begin_scope
argument_list|(
name|sk_template_parms
argument_list|)
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
operator|++
name|processing_template_parmlist
expr_stmt|;
name|note_template_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is called when a specialization is declared.  If it is    illegal to declare a specialization here, an error is reported.  */
end_comment

begin_function
specifier|static
name|void
name|check_specialization_scope
parameter_list|()
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
comment|/* [temp.expl.spec]             An explicit specialization shall be declared in the namespace of      which the template is a member, or, for member templates, in the      namespace of which the enclosing class or enclosing class      template is a member.  An explicit specialization of a member      function, member class or static data member of a class template      shall be declared in the namespace of which the class template      is a member.  */
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|error
argument_list|(
literal|"explicit specialization in non-namespace scope `%D'"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* [temp.expl.spec]        In an explicit specialization declaration for a member of a class      template or a member template that appears in namespace scope,      the member template and some of its enclosing class templates may      remain unspecialized, except that the declaration shall not      explicitly specialize a class member template if its enclosing      class templates are not explicitly specialized as well.  */
if|if
condition|(
name|current_template_parms
condition|)
name|error
argument_list|(
literal|"enclosing class templates are not explicitly specialized"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen template<>. */
end_comment

begin_function
name|void
name|begin_specialization
parameter_list|()
block|{
name|begin_scope
argument_list|(
name|sk_template_spec
argument_list|)
expr_stmt|;
name|note_template_header
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|check_specialization_scope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at then end of processing a declaration preceded by    template<>.  */
end_comment

begin_function
name|void
name|end_specialization
parameter_list|()
block|{
name|finish_scope
argument_list|()
expr_stmt|;
name|reset_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any template<>'s that we have seen thus far are not referring to a    function specialization. */
end_comment

begin_function
name|void
name|reset_specialization
parameter_list|()
block|{
name|processing_specialization
operator|=
literal|0
expr_stmt|;
name|template_header_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen a template header.  If SPECIALIZATION is non-zero,    it was of the form template<>.  */
end_comment

begin_function
specifier|static
name|void
name|note_template_header
parameter_list|(
name|specialization
parameter_list|)
name|int
name|specialization
decl_stmt|;
block|{
name|processing_specialization
operator|=
name|specialization
expr_stmt|;
name|template_header_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're beginning an explicit instantiation.  */
end_comment

begin_function
name|void
name|begin_explicit_instantiation
parameter_list|()
block|{
operator|++
name|processing_explicit_instantiation
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_explicit_instantiation
parameter_list|()
block|{
name|my_friendly_assert
argument_list|(
name|processing_explicit_instantiation
operator|>
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|processing_explicit_instantiation
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The TYPE is being declared.  If it is a template type, that means it    is a partial specialization.  Do appropriate error-checking.  */
end_comment

begin_function
name|void
name|maybe_process_partial_specialization
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_namespace
operator|!=
name|decl_namespace_context
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"specializing `%#T' in different namespace"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  from definition of `%#D'"
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|push_template_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"specialization of `%T' after instantiation"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|processing_specialization
condition|)
name|error
argument_list|(
literal|"explicit specialization of non-template `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the specialization (in the sense of [temp.spec] - a    specialization is either an instantiation or an explicit    specialization) of TMPL for the given template ARGS.  If there is    no such specialization, return NULL_TREE.  The ARGS are a vector of    arguments, or a vector of vectors of arguments, in the case of    templates with more than one level of parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|retrieve_specialization
parameter_list|(
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|s
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* There should be as many levels of arguments as there are      levels of parameters.  */
name|my_friendly_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like retrieve_specialization, but for local declarations.  */
end_comment

begin_function
specifier|static
name|tree
name|retrieve_local_specialization
parameter_list|(
name|tmpl
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
block|{
return|return
operator|(
name|tree
operator|)
name|htab_find
argument_list|(
name|local_specializations
argument_list|,
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff DECL is a specialization of TMPL.  */
end_comment

begin_function
name|int
name|is_specialization_of
parameter_list|(
name|decl
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
for|for
control|(
name|t
operator|=
name|decl
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|t
operator|==
name|tmpl
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Register the specialization SPEC as a specialization of TMPL with    the indicated ARGS.  Returns SPEC, or an equivalent prior    declaration, if available.  */
end_comment

begin_function
specifier|static
name|tree
name|register_specialization
parameter_list|(
name|spec
parameter_list|,
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|s
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
condition|)
comment|/* This is the FUNCTION_DECL for a partial instantiation.  Don't        register it; we want the corresponding TEMPLATE_DECL instead.        We use `uses_template_parms (DECL_TI_ARGS (spec))' rather than        the more obvious `uses_template_parms (spec)' to avoid problems        with default function arguments.  In particular, given        something like this:            template<class T> void f(T t1, T t = T())         the default argument expression is not substituted for in an        instantiation unless and until it is actually needed.  */
return|return
name|spec
return|;
comment|/* There should be as many levels of arguments as there are      levels of parameters.  */
name|my_friendly_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|/* We can sometimes try to re-register a specialization that we've 	 already got.  In particular, regenerate_decl_from_template 	 calls duplicate_decls which will update the specialization 	 list.  But, we'll still get called again here anyhow.  It's 	 more convenient to simply allow this than to try to prevent it.  */
if|if
condition|(
name|fn
operator|==
name|spec
condition|)
return|return
name|spec
return|;
elseif|else
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"specialization of %D after instantiation"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|spec
return|;
block|}
else|else
block|{
comment|/* This situation should occur only if the first 			 specialization is an implicit instantiation, 			 the second is an explicit specialization, and 			 the implicit instantiation has not yet been 			 used.  That situation can occur if we have 			 implicitly instantiated a member function and 			 then specialized it later.  			 We can also wind up here if a friend 			 declaration that looked like an instantiation 			 turns out to be a specialization:  			   template<class T> void foo(T); 			   class S { friend void foo<>(int) }; 			   template<> void foo(int);    			 We transform the existing DECL in place so that 			 any pointers to it become pointers to the 			 updated declaration.    			 If there was a definition for the template, but 			 not for the specialization, we want this to 			 look as if there is no definition, and vice 			 versa.  */
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|duplicate_decls
argument_list|(
name|spec
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|duplicate_decls
argument_list|(
name|spec
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
block|}
block|}
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|args
argument_list|,
name|spec
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|spec
return|;
block|}
end_function

begin_comment
comment|/* Unregister the specialization SPEC as a specialization of TMPL.    Returns nonzero if the SPEC was listed as a specialization of    TMPL.  */
end_comment

begin_function
specifier|static
name|int
name|unregister_specialization
parameter_list|(
name|spec
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
operator|&
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
operator|*
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|s
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|s
argument_list|)
operator|==
name|spec
condition|)
block|{
operator|*
name|s
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like register_specialization, but for local declarations.  We are    registering SPEC, an instantiation of TMPL.  */
end_comment

begin_function
specifier|static
name|void
name|register_local_specialization
parameter_list|(
name|spec
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|local_specializations
argument_list|,
name|tmpl
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|spec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the list of candidate FNS in an error message.  */
end_comment

begin_function
name|void
name|print_candidates
parameter_list|(
name|fns
parameter_list|)
name|tree
name|fns
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
operator|!=
name|NULL_TREE
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|OVL_NEXT
argument_list|(
name|f
argument_list|)
control|)
name|cp_error_at
argument_list|(
literal|"%s %+#D"
argument_list|,
name|str
argument_list|,
name|OVL_CURRENT
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the template (one of the functions given by TEMPLATE_ID)    which can be specialized to match the indicated DECL with the    explicit template args given in TEMPLATE_ID.  The DECL may be    NULL_TREE if none is available.  In that case, the functions in    TEMPLATE_ID are non-members.     If NEED_MEMBER_TEMPLATE is non-zero the function is known to be a    specialization of a member template.     The template args (those explicitly specified and those deduced)    are output in a newly created vector *TARGS_OUT.     If it is impossible to determine the result, an error message is    issued.  The error_mark_node is returned to indicate failure.  */
end_comment

begin_function
specifier|static
name|tree
name|determine_specialization
parameter_list|(
name|template_id
parameter_list|,
name|decl
parameter_list|,
name|targs_out
parameter_list|,
name|need_member_template
parameter_list|)
name|tree
name|template_id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|targs_out
decl_stmt|;
name|int
name|need_member_template
decl_stmt|;
block|{
name|tree
name|fns
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|explicit_targs
decl_stmt|;
name|tree
name|candidates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
operator|*
name|targs_out
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|template_id
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check for baselinks. */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%D' is not a function template"
argument_list|,
name|fns
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* DECL might be a specialization of FN.  */
name|tmpl
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
name|need_member_template
condition|)
comment|/* FN is an ordinary member function, and we need a 	   specialization of a member template.  */
continue|continue;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* We can get IDENTIFIER_NODEs here in certain erroneous 	   cases.  */
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* This is just an ordinary non-member function.  Nothing can 	   be a specialization of that.  */
continue|continue;
elseif|else
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Cannot specialize functions that are created implicitly.  */
continue|continue;
else|else
block|{
name|tree
name|decl_arg_types
decl_stmt|;
comment|/* This is an ordinary member function.  However, since 	     we're here, we can assume it's enclosing class is a 	     template class.  For example, 	      	       template<typename T> struct S { void f(); }; 	       template<> void S<int>::f() {}  	     Here, S<int>::f is a non-template, but S<int> is a 	     template class.  If FN has the same type as DECL, we 	     might be in business.  */
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Its enclosing class is an explicit specialization 	       of a template class.  This is not a candidate.  */
continue|continue;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* The return types differ.  */
continue|continue;
comment|/* Adjust the type of DECL in case FN is a static member.  */
name|decl_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|decl_arg_types
argument_list|)
condition|)
comment|/* They match!  */
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See whether this function might be a specialization of this 	 template.  */
name|targs
operator|=
name|get_bindings
argument_list|(
name|tmpl
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targs
condition|)
comment|/* We cannot deduce template arguments that when used to 	   specialize TMPL will produce DECL.  */
continue|continue;
comment|/* Save this template, and the arguments deduced.  */
name|templates
operator|=
name|tree_cons
argument_list|(
name|targs
argument_list|,
name|tmpl
argument_list|,
name|templates
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|templates
operator|&&
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
condition|)
block|{
comment|/* We have: 	  	   [temp.expl.spec]  	   It is possible for a specialization with a given function 	   signature to be instantiated from more than one function 	   template.  In such cases, explicit specification of the 	   template arguments must be used to uniquely identify the 	   function template specialization being specialized.  	 Note that here, there's no suggestion that we're supposed to 	 determine which of the candidate templates is most 	 specialized.  However, we, also have:  	   [temp.func.order]  	   Partial ordering of overloaded function template 	   declarations is used in the following contexts to select 	   the function template to which a function template 	   specialization refers:              -- when an explicit specialization refers to a function 	      template.   	 So, we do use the partial ordering rules, at least for now. 	 This extension can only serve to make illegal programs legal, 	 so it's safe.  And, there is strong anecdotal evidence that 	 the committee intended the partial ordering rules to apply; 	 the EDG front-end has that behavior, and John Spicer claims 	 that the committee simply forgot to delete the wording in 	 [temp.expl.spec].  */
name|tree
name|tmpl
init|=
name|most_specialized
argument_list|(
name|templates
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpl
operator|&&
name|tmpl
operator|!=
name|error_mark_node
condition|)
block|{
name|targs
operator|=
name|get_bindings
argument_list|(
name|tmpl
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|)
expr_stmt|;
name|templates
operator|=
name|tree_cons
argument_list|(
name|targs
argument_list|,
name|tmpl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|templates
operator|==
name|NULL_TREE
operator|&&
name|candidates
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"template-id `%D' for `%+D' does not match any template declaration"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|templates
operator|&&
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
operator|)
operator|||
operator|(
name|candidates
operator|&&
name|TREE_CHAIN
argument_list|(
name|candidates
argument_list|)
operator|)
operator|||
operator|(
name|templates
operator|&&
name|candidates
operator|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"ambiguous template specialization `%D' for `%+D'"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|candidates
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We have one, and exactly one, match. */
if|if
condition|(
name|candidates
condition|)
block|{
comment|/* It was a specialization of an ordinary member function in a 	 template class.  */
operator|*
name|targs_out
operator|=
name|copy_node
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
return|;
block|}
comment|/* It was a specialization of a template.  */
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|targs
argument_list|)
condition|)
block|{
operator|*
name|targs_out
operator|=
name|copy_node
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
operator|*
name|targs_out
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
operator|*
name|targs_out
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|targs_out
operator|=
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a chain of parameter types, exactly like the SPEC_TYPES,    but with the default argument values filled in from those in the    TMPL_TYPES.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_default_args_to_explicit_spec_1
parameter_list|(
name|spec_types
parameter_list|,
name|tmpl_types
parameter_list|)
name|tree
name|spec_types
decl_stmt|;
name|tree
name|tmpl_types
decl_stmt|;
block|{
name|tree
name|new_spec_types
decl_stmt|;
if|if
condition|(
operator|!
name|spec_types
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|spec_types
operator|==
name|void_list_node
condition|)
return|return
name|void_list_node
return|;
comment|/* Substitute into the rest of the list.  */
name|new_spec_types
operator|=
name|copy_default_args_to_explicit_spec_1
argument_list|(
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|tmpl_types
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the default argument for this parameter.  */
return|return
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmpl_types
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|spec_types
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is an explicit specialization.  Replicate default arguments    from the template it specializes.  (That way, code like:       template<class T> void f(T = 3);      template<> void f(double);      void g () { f (); }      works, as required.)  An alternative approach would be to look up    the correct default arguments at the call-site, but this approach    is consistent with how implicit instantiations are handled.  */
end_comment

begin_function
specifier|static
name|void
name|copy_default_args_to_explicit_spec
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|spec_types
decl_stmt|;
name|tree
name|tmpl_types
decl_stmt|;
name|tree
name|new_spec_types
decl_stmt|;
name|tree
name|old_type
decl_stmt|;
name|tree
name|new_type
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|object_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|in_charge
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vtt
init|=
name|NULL_TREE
decl_stmt|;
comment|/* See if there's anything we need to do.  */
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|tmpl_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tmpl_types
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
name|old_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|spec_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|old_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Remove the this pointer, but remember the object's type for          CV quals.  */
name|object_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|spec_types
argument_list|)
argument_list|)
expr_stmt|;
name|spec_types
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
expr_stmt|;
name|tmpl_types
operator|=
name|TREE_CHAIN
argument_list|(
name|tmpl_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* DECL may contain more parameters than TMPL due to the extra              in-charge parameter in constructors and destructors.  */
name|in_charge
operator|=
name|spec_types
expr_stmt|;
name|spec_types
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|vtt
operator|=
name|spec_types
expr_stmt|;
name|spec_types
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compute the merged default arguments.  */
name|new_spec_types
operator|=
name|copy_default_args_to_explicit_spec_1
argument_list|(
name|spec_types
argument_list|,
name|tmpl_types
argument_list|)
expr_stmt|;
comment|/* Compute the new FUNCTION_TYPE.  */
if|if
condition|(
name|object_type
condition|)
block|{
if|if
condition|(
name|vtt
condition|)
name|new_spec_types
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_charge
condition|)
comment|/* Put the in-charge parameter back.  */
name|new_spec_types
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|in_charge
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|in_charge
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|build_cplus_method_type
argument_list|(
name|object_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|old_type
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
block|}
else|else
name|new_type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_type
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|build_type_attribute_variant
argument_list|(
name|new_type
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|old_type
argument_list|)
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|build_exception_variant
argument_list|(
name|new_type
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|old_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|new_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see if the function just declared, as indicated in    DECLARATOR, and in DECL, is a specialization of a function    template.  We may also discover that the declaration is an explicit    instantiation at this point.     Returns DECL, or an equivalent declaration that should be used    instead if all goes well.  Issues an error message if something is    amiss.  Returns error_mark_node if the error is not easily    recoverable.        FLAGS is a bitmask consisting of the following flags:      2: The function has a definition.    4: The function is a friend.     The TEMPLATE_COUNT is the number of references to qualifying    template classes that appeared in the name of the function.  For    example, in       template<class T> struct S { void f(); };      void S<int>::f();          the TEMPLATE_COUNT would be 1.  However, explicitly specialized    classes are not counted in the TEMPLATE_COUNT, so that in       template<class T> struct S {};      template<> struct S<int> { void f(); }      template<> void S<int>::f();     the TEMPLATE_COUNT would be 0.  (Note that this declaration is    illegal; there should be no template<>.)     If the function is a specialization, it is marked as such via    DECL_TEMPLATE_SPECIALIZATION.  Furthermore, its DECL_TEMPLATE_INFO    is set up correctly, and it is added to the list of specializations     for that template.  */
end_comment

begin_function
name|tree
name|check_explicit_specialization
parameter_list|(
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|template_count
parameter_list|,
name|flags
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|template_count
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|have_def
init|=
name|flags
operator|&
literal|2
decl_stmt|;
name|int
name|is_friend
init|=
name|flags
operator|&
literal|4
decl_stmt|;
name|int
name|specialization
init|=
literal|0
decl_stmt|;
name|int
name|explicit_instantiation
init|=
literal|0
decl_stmt|;
name|int
name|member_specialization
init|=
literal|0
decl_stmt|;
name|tree
name|ctype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|dname
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tmpl_spec_kind
name|tsk
decl_stmt|;
name|tsk
operator|=
name|current_tmpl_spec_kind
argument_list|(
name|template_count
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tsk
condition|)
block|{
case|case
name|tsk_none
case|:
if|if
condition|(
name|processing_specialization
condition|)
block|{
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|is_friend
condition|)
comment|/* This could be something like:  	       template<class T> void f(T); 	       class S { friend void f<>(int); }  */
name|specialization
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* This case handles bogus declarations like template<> 		 template<class T> void f<int>(); */
name|error
argument_list|(
literal|"template-id `%D' in declaration of primary template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
break|break;
case|case
name|tsk_invalid_member_spec
case|:
comment|/* The error has already been reported in 	 check_specialization_scope.  */
return|return
name|error_mark_node
return|;
case|case
name|tsk_invalid_expl_inst
case|:
name|error
argument_list|(
literal|"template parameter list used in explicit instantiation"
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|tsk_expl_inst
case|:
if|if
condition|(
name|have_def
condition|)
name|error
argument_list|(
literal|"definition provided for explicit instantiation"
argument_list|)
expr_stmt|;
name|explicit_instantiation
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tsk_excessive_parms
case|:
name|error
argument_list|(
literal|"too many template parameter lists in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|tsk_expl_spec
case|:
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
name|member_specialization
operator|=
literal|1
expr_stmt|;
else|else
name|specialization
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tsk_insufficient_parms
case|:
if|if
condition|(
name|template_header_count
condition|)
block|{
name|error
argument_list|(
literal|"too few template parameter lists in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|is_friend
condition|)
block|{
comment|/* For backwards compatibility, we accept:  	       template<class T> struct S { void f(); }; 	       void S<int>::f() {} // Missing template<>  	     That used to be legal C++.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"explicit specialization not preceded by `template<>'"
argument_list|)
expr_stmt|;
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tsk_template
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* This case handles bogus declarations like template<> 	     template<class T> void f<int>(); */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|declarator
argument_list|)
condition|)
name|error
argument_list|(
literal|"partial specialization `%D' of function template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"template-id `%D' in declaration of primary template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
condition|)
comment|/* This is a specialization of a member template, without 	   specialization the containing class.  Something like:  	     template<class T> struct S { 	       template<class U> void f (U);               }; 	     template<> template<class U> void S<int>::f(U) {} 	      	   That's a specialization -- but of the entire template.  */
name|specialization
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
condition|)
block|{
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"default argument specified in explicit specialization"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|error
argument_list|(
literal|"template specialization with C linkage"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
operator|||
name|explicit_instantiation
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|targs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|fns
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctype
condition|)
name|fns
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
name|fns
operator|=
name|dname
expr_stmt|;
name|declarator
operator|=
name|lookup_template_function
argument_list|(
name|fns
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit_instantiation
condition|)
comment|/* A specialization in class scope.  This is illegal, 	       but the error will already have been flagged by 	       check_specialization_scope.  */
return|return
name|error_mark_node
return|;
else|else
block|{
comment|/* It's not legal to write an explicit instantiation in 		 class scope, e.g.:  	           class C { template void f(); }  		   This case is caught by the parser.  However, on 		   something like: 	        		   template class C { void f(); };  		   (which is illegal) we can get here.  The error will be 		   issued later.  */
empty_stmt|;
block|}
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
block|{
comment|/* A friend declaration.  We can't do much, because we don't 	     know what this resolves to, yet.  */
name|my_friendly_assert
argument_list|(
name|is_friend
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|explicit_instantiation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
comment|/* Find the list of functions in ctype that have the same 	     name as the declared function.  */
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|fns
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|int
name|is_constructor
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_constructor
condition|?
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
else|:
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* From [temp.expl.spec]: 		        		     If such an explicit specialization for the member 		     of a class template names an implicitly-declared 		     special member function (clause _special_), the 		     program is ill-formed.    		     Similar language is found in [temp.explicit].  */
name|error
argument_list|(
literal|"specialization of implicitly-declared special member function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|name
operator|=
name|is_constructor
condition|?
name|ctor_identifier
else|:
name|dtor_identifier
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|idx
operator|=
name|lookup_fnfields_1
argument_list|(
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|methods
decl_stmt|;
comment|/* For a type-conversion operator, we cannot do a 		 name-based lookup.  We might be looking for `operator 		 int' which will be a specialization of `operator T'. 		 So, we find *all* the conversion operators, and then 		 select from them.  */
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
condition|)
for|for
control|(
name|idx
operator|=
literal|2
init|;
name|idx
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|methods
argument_list|)
condition|;
operator|++
name|idx
control|)
block|{
name|tree
name|ovl
init|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ovl
operator|||
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ovl
argument_list|)
argument_list|)
condition|)
comment|/* There are no more conversion functions.  */
break|break;
comment|/* Glue all these conversion functions together 		       with those we already have.  */
for|for
control|(
init|;
name|ovl
condition|;
name|ovl
operator|=
name|OVL_NEXT
argument_list|(
name|ovl
argument_list|)
control|)
name|fns
operator|=
name|ovl_cons
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ovl
argument_list|)
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"no member function `%D' declared in `%T'"
argument_list|,
name|name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|=
name|fns
expr_stmt|;
block|}
comment|/* Figure out what exactly is being specialized at this point. 	 Note that for an explicit instantiation, even one for a 	 member function, we cannot tell apriori whether the 	 instantiation is for a member template, or just a member 	 function of a template class.  Even if a member template is 	 being instantiated, the member template arguments may be 	 elided if they can be deduced from the rest of the 	 declaration.  */
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|declarator
argument_list|,
name|decl
argument_list|,
operator|&
name|targs
argument_list|,
name|member_specialization
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
name|tmpl
operator|==
name|error_mark_node
condition|)
comment|/* We couldn't figure out what this declaration was 	   specializing.  */
return|return
name|error_mark_node
return|;
else|else
block|{
name|tree
name|gen_tmpl
init|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
if|if
condition|(
name|explicit_instantiation
condition|)
block|{
comment|/* We don't set DECL_EXPLICIT_INSTANTIATION here; that 		 is done by do_decl_instantiation later.  */
name|int
name|arg_depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|parm_depth
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_depth
operator|>
name|parm_depth
condition|)
block|{
comment|/* If TMPL is not the most general template (for 		     example, if TMPL is a friend template that is 		     injected into namespace scope), then there will 		     be too many levels of TARGS.  Remove some of them 		     here.  */
name|int
name|i
decl_stmt|;
name|tree
name|new_targs
decl_stmt|;
name|new_targs
operator|=
name|make_tree_vec
argument_list|(
name|parm_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg_depth
operator|-
name|parm_depth
init|;
name|i
operator|<
name|arg_depth
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_targs
argument_list|,
name|i
operator|-
operator|(
name|arg_depth
operator|-
name|parm_depth
operator|)
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|targs
operator|=
name|new_targs
expr_stmt|;
block|}
return|return
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|)
return|;
block|}
comment|/* If this is a specialization of a member template of a 	     template class.  In we want to return the TEMPLATE_DECL, 	     not the specialization of it.  */
if|if
condition|(
name|tsk
operator|==
name|tsk_template
condition|)
block|{
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|tmpl
return|;
block|}
comment|/* If we thought that the DECL was a member function, but it 	     turns out to be specializing a static member function, 	     make DECL a static member function as well.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|revert_static_member_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the DECL_TEMPLATE_INFO for DECL.  */
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Inherit default function arguments from the template 	     DECL is specializing.  */
name|copy_default_args_to_explicit_spec
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This specialization has the same protection as the 	     template it specializes.  */
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_friend
operator|&&
operator|!
name|have_def
condition|)
comment|/* This is not really a declaration of a specialization. 	       It's just the name of an instantiation.  But, it's not 	       a request for an instantiation, either.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* This is indeed a specialization.  In case of constructors 	       and destructors, we need in-charge and not-in-charge 	       versions in V3 ABI.  */
name|clone_function_decl
argument_list|(
name|decl
argument_list|,
comment|/*update_method_vec_p=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Register this specialization so that we can find it 	     again.  */
name|decl
operator|=
name|register_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* TYPE is being declared.  Verify that the use of template headers    and such is reasonable.  Issue error messages if not.  */
end_comment

begin_function
name|void
name|maybe_check_template_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|template_header_count
condition|)
block|{
comment|/* We are in the scope of some `template<...>' header.  */
name|int
name|context_depth
init|=
name|template_class_depth_real
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*count_specializations=*/
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|template_header_count
operator|<=
name|context_depth
condition|)
comment|/* This is OK; the template headers are for the context.  We 	   are actually too lenient here; like 	   check_explicit_specialization we should consider the number 	   of template types included in the actual declaration.  For 	   example,   	     template<class T> struct S { 	       template<class U> template<class V> 	       struct I {}; 	     };   	   is illegal, but:  	     template<class T> struct S { 	       template<class U> struct I; 	     };   	     template<class T> template<class U. 	     struct S<T>::I {};  	   is not.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|template_header_count
operator|>
name|context_depth
operator|+
literal|1
condition|)
comment|/* There are two many template parameter lists.  */
name|error
argument_list|(
literal|"too many template parameter lists in declaration of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 iff PARMS1 and PARMS2 are identical sets of template    parameters.  These are represented in the same format used for    DECL_TEMPLATE_PARMS.  */
end_comment

begin_function
name|int
name|comp_template_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|;
name|tree
name|parms2
decl_stmt|;
block|{
name|tree
name|p1
decl_stmt|;
name|tree
name|p2
decl_stmt|;
if|if
condition|(
name|parms1
operator|==
name|parms2
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p1
operator|=
name|parms1
operator|,
name|p2
operator|=
name|parms2
init|;
name|p1
operator|!=
name|NULL_TREE
operator|&&
name|p2
operator|!=
name|NULL_TREE
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|p1
operator|!=
name|NULL_TREE
operator|)
operator|!=
operator|(
name|p2
operator|!=
name|NULL_TREE
operator|)
condition|)
comment|/* One set of parameters has more parameters lists than the        other.  */
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Complain if DECL shadows a template parameter.     [temp.local]: A template-parameter shall not be redeclared within its    scope (including nested scopes).  */
end_comment

begin_function
name|void
name|check_template_shadow
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|olddecl
decl_stmt|;
comment|/* If we're not in a template, we can't possibly shadow a template      parameter.  */
if|if
condition|(
operator|!
name|current_template_parms
condition|)
return|return;
comment|/* Figure out what we're shadowing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|decl
operator|=
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|olddecl
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no previous binding for this name, we're not shadowing      anything, let alone a template parameter.  */
if|if
condition|(
operator|!
name|olddecl
condition|)
return|return;
comment|/* If we're not shadowing a template parameter, we're done.  Note      that OLDDECL might be an OVERLOAD (or perhaps even an      ERROR_MARK), so we can't just blithely assume it to be a _DECL      node.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return;
comment|/* We check for decl != olddecl to avoid bogus errors for using a      name inside a class.  We check TPFI to avoid duplicate errors for      inline member templates.  */
if|if
condition|(
name|decl
operator|==
name|olddecl
operator|||
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
condition|)
return|return;
name|cp_error_at
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|" shadows template parm `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,    ORIG_LEVEL, DECL, and TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_parm_index
parameter_list|(
name|index
parameter_list|,
name|level
parameter_list|,
name|orig_level
parameter_list|,
name|decl
parameter_list|,
name|type
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|orig_level
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TEMPLATE_PARM_INDEX
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
operator|=
name|index
expr_stmt|;
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|level
expr_stmt|;
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|orig_level
expr_stmt|;
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose    TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a    new one is created.  */
end_comment

begin_function
specifier|static
name|tree
name|reduce_template_parm_level
parameter_list|(
name|index
parameter_list|,
name|type
parameter_list|,
name|levels
parameter_list|)
name|tree
name|index
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|levels
decl_stmt|;
block|{
if|if
condition|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
operator|)
condition|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|build_template_parm_index
argument_list|(
name|TEMPLATE_PARM_IDX
argument_list|(
name|index
argument_list|)
argument_list|,
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
argument_list|,
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|index
argument_list|)
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Template template parameters need this.  */
name|DECL_TEMPLATE_PARMS
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process information from new template parameter NEXT and append it to the    LIST being built.  */
end_comment

begin_function
name|tree
name|process_template_parm
parameter_list|(
name|list
parameter_list|,
name|next
parameter_list|)
name|tree
name|list
decl_stmt|,
name|next
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|tree
name|defval
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|idx
decl_stmt|;
name|parm
operator|=
name|next
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|259
argument_list|)
expr_stmt|;
name|defval
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|==
name|class_type_node
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
else|else
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|260
argument_list|)
expr_stmt|;
comment|/* is a const-param */
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* [temp.param]  	 The top-level cv-qualifiers on the template-parameter are 	 ignored when determining its type.  */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A template parameter is not modifiable.  */
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|invalid_nontype_parm_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|&&
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TEMPLATE_TEMPLATE_PARM
argument_list|)
expr_stmt|;
comment|/* This is for distinguishing between real templates and template  	     template parameters */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
name|t
expr_stmt|;
name|decl
operator|=
name|parm
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TEMPLATE_TYPE_PARM
argument_list|)
expr_stmt|;
comment|/* parm is either IDENTIFIER_NODE or NULL_TREE */
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|parm
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|parm
operator|=
name|decl
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_tree_list
argument_list|(
name|defval
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The end of a template parameter list has been reached.  Process the    tree list into a parameter vector, converting each parameter into a more    useful form.	 Type parameters are saved as IDENTIFIER_NODEs, and others    as PARM_DECLs.  */
end_comment

begin_function
name|tree
name|end_template_parm_list
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|next
decl_stmt|;
name|tree
name|saved_parmlist
init|=
name|make_tree_vec
argument_list|(
name|list_length
argument_list|(
name|parms
argument_list|)
argument_list|)
decl_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|processing_template_decl
argument_list|)
argument_list|,
name|saved_parmlist
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
operator|,
name|nparms
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|next
operator|,
name|nparms
operator|++
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|--
name|processing_template_parmlist
expr_stmt|;
return|return
name|saved_parmlist
return|;
block|}
end_function

begin_comment
comment|/* end_template_decl is called after a template declaration is seen.  */
end_comment

begin_function
name|void
name|end_template_decl
parameter_list|()
block|{
name|reset_specialization
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return;
comment|/* This matches the pushlevel in begin_template_parm_list.  */
name|finish_scope
argument_list|()
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a template argument vector containing the template PARMS.    The innermost PARMS are given first.  */
end_comment

begin_function
name|tree
name|current_template_args
parameter_list|()
block|{
name|tree
name|header
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|length
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|current_template_parms
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|length
decl_stmt|;
comment|/* If there is only one level of template parameters, we do not      create a TREE_VEC of TREE_VECs.  Instead, we return a single      TREE_VEC containing the arguments.  */
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|args
operator|=
name|make_tree_vec
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|current_template_parms
init|;
name|header
condition|;
name|header
operator|=
name|TREE_CHAIN
argument_list|(
name|header
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|copy_node
argument_list|(
name|TREE_VALUE
argument_list|(
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* T will be a list if we are called from within a 	     begin/end_template_parm_list pair, but a vector directly 	     if within a begin/end_member_template_processing pair.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
operator|--
name|l
argument_list|)
operator|=
name|a
expr_stmt|;
else|else
name|args
operator|=
name|a
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_DECL corresponding to DECL, using the indicated    template PARMS.  Used by push_template_decl below.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_decl
parameter_list|(
name|decl
parameter_list|,
name|parms
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|parms
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_NONCONVERTING_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|tmpl
argument_list|,
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmpl
return|;
block|}
end_function

begin_struct
struct|struct
name|template_parm_data
block|{
comment|/* The level of the template parameters we are currently      processing.  */
name|int
name|level
decl_stmt|;
comment|/* The index of the specialization argument we are currently      processing.  */
name|int
name|current_arg
decl_stmt|;
comment|/* An array whose size is the number of template parameters.  The      elements are non-zero if the parameter has been used in any one      of the arguments processed so far.  */
name|int
modifier|*
name|parms
decl_stmt|;
comment|/* An array whose size is the number of template arguments.  The      elements are non-zero if the argument makes use of template      parameters of this level.  */
name|int
modifier|*
name|arg_uses_template_parms
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Subroutine of push_template_decl used to see if each template    parameter in a partial specialization is used in the explicit    argument list.  If T is of the LEVEL given in DATA (which is    treated as a template_parm_data*), then DATA->PARMS is marked    appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|mark_template_parm
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|template_parm_data
modifier|*
name|tpd
init|=
operator|(
expr|struct
name|template_parm_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|tpd
operator|->
name|level
condition|)
block|{
name|tpd
operator|->
name|parms
index|[
name|idx
index|]
operator|=
literal|1
expr_stmt|;
name|tpd
operator|->
name|arg_uses_template_parms
index|[
name|tpd
operator|->
name|current_arg
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return zero so that for_each_template_parm will continue the      traversal of the tree; we want to mark *every* template parm.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the partial specialization DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|process_partial_specialization
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|maintmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|specargs
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|inner_args
init|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|specargs
argument_list|)
decl_stmt|;
name|tree
name|inner_parms
init|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|current_template_parms
argument_list|)
decl_stmt|;
name|tree
name|main_inner_parms
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|maintmpl
argument_list|)
decl_stmt|;
name|int
name|nargs
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_args
argument_list|)
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|did_error_intro
init|=
literal|0
decl_stmt|;
name|struct
name|template_parm_data
name|tpd
decl_stmt|;
name|struct
name|template_parm_data
name|tpd2
decl_stmt|;
comment|/* We check that each of the template parameters given in the      partial specialization is used in the argument list to the      specialization.  For example:         template<class T> struct S;        template<class T> struct S<T*>;       The second declaration is OK because `T*' uses the template      parameter T, whereas         template<class T> struct S<int>;       is no good.  Even trickier is:         template<class T>        struct S1        { 	  template<class U> 	  struct S2; 	  template<class U> 	  struct S2<T>;        };       The S2<T> declaration is actually illegal; it is a      full-specialization.  Of course,   	  template<class U> 	  struct S2<T (*)(U)>;       or some such would have been OK.  */
name|tpd
operator|.
name|level
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|parms
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|tpd
operator|.
name|parms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|arg_uses_template_parms
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|tpd
operator|.
name|arg_uses_template_parms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|tpd
operator|.
name|current_arg
operator|=
name|i
expr_stmt|;
name|for_each_template_parm
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|tpd
operator|.
name|parms
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* One of the template parms was not used in the 	   specialization.  */
if|if
condition|(
operator|!
name|did_error_intro
condition|)
block|{
name|error
argument_list|(
literal|"template parameters not used in partial specialization:"
argument_list|)
expr_stmt|;
name|did_error_intro
operator|=
literal|1
expr_stmt|;
block|}
name|error
argument_list|(
literal|"        `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.class.spec]       The argument list of the specialization shall not be identical to      the implicit argument list of the primary template.  */
if|if
condition|(
name|comp_template_args
argument_list|(
name|inner_args
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"partial specialization `%T' does not specialize any template arguments"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* [temp.class.spec]       A partially specialized non-type argument expression shall not      involve template parameters of the partial specialization except      when the argument expression is a simple identifier.       The type of a template parameter corresponding to a specialized      non-type argument shall not be dependent on a parameter of the      specialization.  */
name|my_friendly_assert
argument_list|(
name|nargs
operator|==
name|DECL_NTPARMS
argument_list|(
name|maintmpl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tpd2
operator|.
name|parms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
comment|/* These first two lines are the `non-type' bit.  */
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_DECL
comment|/* This next line is the `argument expression is not just a 	     simple identifier' condition and also the `specialized 	     non-type argument' bit.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
block|{
if|if
condition|(
name|tpd
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"template argument `%E' involves template parameter(s)"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Look at the corresponding template parameter, 		 marking which template parameters its type depends 		 upon.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|main_inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tpd2
operator|.
name|parms
condition|)
block|{
comment|/* We haven't yet initialized TPD2.  Do so now.  */
name|tpd2
operator|.
name|arg_uses_template_parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
comment|/* The number of parameters here is the number in the 		     main template, which, as checked in the assertion 		     above, is NARGS.  */
name|tpd2
operator|.
name|parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|tpd2
operator|.
name|level
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the template parameters.  But this time, we're 		 looking for the template parameters of the main 		 template, not in the specialization.  */
name|tpd2
operator|.
name|current_arg
operator|=
name|i
expr_stmt|;
name|tpd2
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|tpd2
operator|.
name|parms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|for_each_template_parm
argument_list|(
name|type
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpd2
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
condition|)
block|{
comment|/* The type depended on some template parameters. 		     If they are fully specialized in the 		     specialization, that's OK.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nargs
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|tpd2
operator|.
name|parms
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|tpd
operator|.
name|arg_uses_template_parms
index|[
name|j
index|]
condition|)
block|{
name|error
argument_list|(
literal|"type `%T' of template argument `%E' depends on template parameter(s)"
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|retrieve_specialization
argument_list|(
name|maintmpl
argument_list|,
name|specargs
argument_list|)
condition|)
comment|/* We've already got this specialization.  */
return|return
name|decl
return|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|inner_args
argument_list|,
name|inner_parms
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Check that a template declaration's use of default arguments is not    invalid.  Here, PARMS are the template parameters.  IS_PRIMARY is    non-zero if DECL is the thing declared by a primary template.    IS_PARTIAL is non-zero if DECL is a partial specialization.  */
end_comment

begin_function
specifier|static
name|void
name|check_default_tmpl_args
parameter_list|(
name|decl
parameter_list|,
name|parms
parameter_list|,
name|is_primary
parameter_list|,
name|is_partial
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|is_primary
decl_stmt|;
name|int
name|is_partial
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|last_level_to_check
decl_stmt|;
name|tree
name|parm_level
decl_stmt|;
comment|/* [temp.param]        A default template-argument shall not be specified in a      function template declaration or a function template definition, nor      in the template-parameter-list of the definition of a member of a      class template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* You can't have a function template declaration in a local        scope, nor you can you define a member of a class template in a        local scope.  */
return|return;
if|if
condition|(
name|current_class_type
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
comment|/* If this is either a friend defined in the scope of the class 	 or a member function.  */
operator|&&
operator|(
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|||
operator|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|)
comment|/* And, if it was a member function, it really was defined in 	 the scope of the class.  */
operator|&&
operator|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We already checked these parameters when the template was        declared, so there's no need to do it again now.  This function        was defined in class scope, but we're processing it's body now        that the class is complete.  */
return|return;
comment|/* [temp.param] 	       If a template-parameter has a default template-argument, all      subsequent template-parameters shall have a default      template-argument supplied.  */
for|for
control|(
name|parm_level
operator|=
name|parms
init|;
name|parm_level
condition|;
name|parm_level
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_level
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|TREE_VALUE
argument_list|(
name|parm_level
argument_list|)
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|int
name|seen_def_arg_p
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
name|seen_def_arg_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|seen_def_arg_p
condition|)
block|{
name|error
argument_list|(
literal|"no default argument for `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For better subsequent error-recovery, we indicate that 		 there should have been a default argument.  */
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|is_partial
operator|||
operator|!
name|is_primary
condition|)
comment|/* For an ordinary class template, default template arguments are        allowed at the innermost level, e.g.:          template<class T = int> 	 struct S {};        but, in a partial specialization, they're not allowed even        there, as we have in [temp.class.spec]:       	 The template parameter list of a specialization shall not 	 contain default template argument values.           So, for a partial specialization, or for a function template,        we look at all of them.  */
empty_stmt|;
else|else
comment|/* But, for a primary class template that is not a partial        specialization we look at all template parameters except the        innermost ones.  */
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Figure out what error message to issue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|msg
operator|=
literal|"default template arguments may not be used in function templates"
expr_stmt|;
elseif|else
if|if
condition|(
name|is_partial
condition|)
name|msg
operator|=
literal|"default template arguments may not be used in partial specializations"
expr_stmt|;
else|else
name|msg
operator|=
literal|"default argument for template parameter for class enclosing `%D'"
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* If we're inside a class definition, there's no need to        examine the parameters to the class itself.  On the one        hand, they will be checked when the class is defined, and,        on the other, default arguments are legal in things like:          template<class T = double>          struct S { template<class U> void f(U); };        Here the default argument for `S' has no bearing on the        declaration of `f'.  */
name|last_level_to_check
operator|=
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* Check everything.  */
name|last_level_to_check
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm_level
operator|=
name|parms
init|;
name|parm_level
operator|&&
name|TMPL_PARMS_DEPTH
argument_list|(
name|parm_level
argument_list|)
operator|>=
name|last_level_to_check
condition|;
name|parm_level
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_level
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|TREE_VALUE
argument_list|(
name|parm_level
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
decl_stmt|;
name|ntparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
condition|)
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear out the default argument so that we are not 	       confused later.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* At this point, if we're still interested in issuing messages, 	 they must apply to classes surrounding the object declared.  */
if|if
condition|(
name|msg
condition|)
name|msg
operator|=
literal|"default argument for template parameter for class enclosing `%D'"
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates a TEMPLATE_DECL for the indicated DECL using the template    parameters given by current_template_args, or reuses a    previously existing one, if appropriate.  Returns the DECL, or an    equivalent one, if it is replaced via a call to duplicate_decls.       If IS_FRIEND is non-zero, DECL is a friend declaration.  */
end_comment

begin_function
name|tree
name|push_template_decl_real
parameter_list|(
name|decl
parameter_list|,
name|is_friend
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|is_friend
decl_stmt|;
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|info
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|primary
decl_stmt|;
name|int
name|is_partial
decl_stmt|;
name|int
name|new_template_p
init|=
literal|0
decl_stmt|;
comment|/* See if this is a partial specialization.  */
name|is_partial
operator|=
operator|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|is_friend
operator||=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_friend
condition|)
comment|/* For a friend, we want the context of the friend function, not        the type of which it is a friend.  */
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
comment|/* In the case of a virtual function, we want the class in which        it is defined.  */
name|ctx
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, if we're currently defining some class, the DECL        is assumed to be a member of the class.  */
name|ctx
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* See if this is a primary template.  */
name|primary
operator|=
name|template_parm_scope_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|error
argument_list|(
literal|"template with C linkage"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"template class without a name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|ctx
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|error
argument_list|(
literal|"template declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that the rules regarding the use of default      arguments are not being violated.  */
name|check_default_tmpl_args
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|,
name|primary
argument_list|,
name|is_partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_partial
condition|)
return|return
name|process_partial_specialization
argument_list|(
name|decl
argument_list|)
return|;
name|args
operator|=
name|current_template_args
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
operator|||
operator|(
name|is_friend
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If DECL is a TYPE_DECL for a class-template, then there won't 	 be DECL_LANG_SPECIFIC.  The information equivalent to 	 DECL_TEMPLATE_INFO is found in TYPE_TEMPLATE_INFO instead.  */
elseif|else
if|if
condition|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Since a template declaration already existed for this 	     class-type, we must be redeclaring it here.  Make sure 	     that the redeclaration is legal.  */
name|redeclare_class_template
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
comment|/* We don't need to create a new TEMPLATE_DECL; just use the 	     one we already had.  */
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|new_template_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* A specialization of a member template of a template 		 class. */
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|,
name|current
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"`%D' does not declare a template type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"template definition of non-template `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|new_tmpl
decl_stmt|;
comment|/* The declaration is a specialization of a member 	     template, declared outside the class.  Therefore, the 	     innermost template arguments will be NULL, so we 	     replace them with the arguments determined by the 	     earlier call to check_explicit_specialization.  */
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|new_tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|=
name|new_tmpl
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|new_tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|new_tmpl
argument_list|,
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Make sure the template headers we got make sense.  */
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|i
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|!=
name|i
condition|)
block|{
name|error
argument_list|(
literal|"expected %d levels of template parms for `%#D', got %d"
argument_list|,
name|i
argument_list|,
name|decl
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|current
operator|=
name|decl
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|a
operator|=
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|decl
condition|)
name|error
argument_list|(
literal|"got %d template parameters for `%#D'"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"got %d template parameters for `%#T'"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  but %d required"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Perhaps we should also check that the parms are used in the                appropriate qualifying scopes in the declarator?  */
if|if
condition|(
name|current
operator|==
name|decl
condition|)
name|current
operator|=
name|ctx
expr_stmt|;
else|else
name|current
operator|=
name|TYPE_CONTEXT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Push template declarations for global functions and types.  Note      that we do not try to push a global template friend declared in a      template class; such a thing may well depend on the template      parameters of the class.  */
if|if
condition|(
name|new_template_p
operator|&&
operator|!
name|ctx
operator|&&
operator|!
operator|(
name|is_friend
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|tmpl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|info
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|SET_TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
comment|/* Don't change the name if we've already set it up.  */
operator|&&
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|info
expr_stmt|;
return|return
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|push_template_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when a class template TYPE is redeclared with the indicated    template PARMS, e.g.:       template<class T> struct S;      template<class T> struct S {};  */
end_comment

begin_function
name|void
name|redeclare_class_template
parameter_list|(
name|type
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|tmpl_parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%T' is not a template type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
comment|/* The type is nested in some template class.  Nothing to worry        about here; there are no new template parameters for the nested        type.  */
return|return;
name|parms
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|tmpl_parms
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"previous declaration `%D'"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"used %d template parameter%s instead of %d"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmpl_parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmpl_default
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm_default
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmpl_parm
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"template parameter `%#D'"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"redeclared here as `%#D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmpl_default
operator|!=
name|NULL_TREE
operator|&&
name|parm_default
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We have in [temp.param]:  	     A template-parameter may not be given default arguments 	     by two different declarations in the same scope.  */
name|error
argument_list|(
literal|"redefinition of default argument for `%#D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  original definition appeared here"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm_default
operator|!=
name|NULL_TREE
condition|)
comment|/* Update the previous template parameters (which are the ones 	   that will really count) with the new default value.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|parm_default
expr_stmt|;
elseif|else
if|if
condition|(
name|tmpl_default
operator|!=
name|NULL_TREE
condition|)
comment|/* Update the new parameters, too; they'll be used as the 	   parameters for any members.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|tmpl_default
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to convert the non-type template parameter EXPR to the    indicated TYPE.  If the conversion is successful, return the    converted value.  If the conversion is unsuccessful, return    NULL_TREE if we issued an error message, or error_mark_node if we    did not.  We issue error messages for out-and-out bad template    parameters, but not simply because the conversion failed, since we    might be just trying to do argument deduction.  By the time this    function is called, neither TYPE nor EXPR may make use of template    parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nontype_argument
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|expr_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* A template-argument for a non-type, non-template      template-parameter shall be one of:       --an integral constant-expression of integral or enumeration      type; or            --the name of a non-type template-parameter; or            --the name of an object or function with external linkage,      including function templates and function template-ids but      excluding non-static class members, expressed as id-expression;      or            --the address of an object or function with external linkage,      including function templates and function template-ids but      excluding non-static class members, expressed as& id-expression      where the& is optional if the name refers to a function or      array; or            --a pointer to member expressed as described in _expr.unary.op_.  */
comment|/* An integral constant-expression can include const variables or      enumerators.  Simplify things by folding them to their values,      unless we're about to bind the declaration to a reference      parameter.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* OK for now.  We'll check that it has external linkage later.        Check this first since if expr_type is the unknown_type_node        we would otherwise complain below.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PTRMEM_CST
condition|)
goto|goto
name|bad_argument
goto|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
comment|/* If expr is the address of an overloaded function, we 	      will get the unknown_type_node at this point.  */
operator|||
name|expr_type
operator|==
name|unknown_type_node
condition|)
block|{
name|tree
name|referent
decl_stmt|;
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|ADDR_EXPR
operator|)
condition|)
name|referent
operator|=
name|e
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
name|bad_argument
label|:
name|error
argument_list|(
literal|"`%E' is not a valid template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|error
argument_list|(
literal|"it must be the address of a function with external linkage"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"it must be the address of an object with external linkage"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"it must be a pointer-to-member of the form `&X::Y'"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|referent
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|referent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|referent
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"string literal %E is not a valid template argument because it is the address of an object with static linkage"
argument_list|,
name|referent
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|referent
argument_list|)
condition|)
comment|/* We'll check that it has external linkage later.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|referent
argument_list|)
operator|!=
name|VAR_DECL
condition|)
goto|goto
name|bad_argument
goto|;
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|referent
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of non-extern `%E' cannot be used as template argument"
argument_list|,
name|referent
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|non_constant
label|:
name|error
argument_list|(
literal|"non-constant `%E' cannot be used as template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"object `%E' cannot be used as template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* For a non-type template-parameter of integral or enumeration          type, integral promotions (_conv.prom_) and integral          conversions (_conv.integral_) are applied. */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* It's safe to call digest_init in this case; we know we're 	 just converting one integral constant expression to another.  */
name|expr
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* Curiously, some TREE_CONSTANT integral expressions do not 	   simplify to integer constants.  For example, `3 % 0', 	   remains a TRUNC_MOD_EXPR.  */
goto|goto
name|non_constant
goto|;
return|return
name|expr
return|;
case|case
name|POINTER_TYPE
case|:
block|{
name|tree
name|type_pointed_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|e
decl_stmt|;
comment|/* For a non-type template-parameter of type pointer to data 	       member, qualification conversions (_conv.qual_) are 	       applied.  */
name|e
operator|=
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|NOP_EXPR
condition|)
comment|/* The call to perform_qualification_conversions will 		 insert a NOP_EXPR over EXPR to do express conversion, 		 if necessary.  But, that will confuse us if we use 		 this (converted) template parameter to instantiate 		 another template; then the thing will not look like a 		 valid template argument.  So, just make a new 		 constant, of the appropriate type.  */
name|e
operator|=
name|make_ptrmem_cst
argument_list|(
name|type
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_pointed_to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* For a non-type template-parameter of type pointer to 	       function, only the function-to-pointer conversion 	       (_conv.func_) is applied.  If the template-argument 	       represents a set of overloaded functions (or a pointer to 	       such), the matching function is selected from the set 	       (_over.over_).  */
name|tree
name|fns
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fns
operator|=
name|expr
expr_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type_pointed_to
argument_list|,
name|fns
argument_list|,
name|itf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
goto|goto
name|bad_argument
goto|;
block|}
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
block|{
comment|/* For a non-type template-parameter of type pointer to 	       object, qualification conversions (_conv.qual_) and the 	       array-to-pointer conversion (_conv.array_) are applied. 	       [Note: In particular, neither the null pointer conversion 	       (_conv.ptr_) nor the derived-to-base conversion 	       (_conv.ptr_) are applied.  Although 0 is a valid 	       template-argument for a non-type template-parameter of 	       integral type, it is not a valid template-argument for a 	       non-type template-parameter of pointer type.]   	     	       The call to decay_conversion performs the 	       array-to-pointer conversion, if appropriate.  */
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|type_referred_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If this expression already has reference type, get the 	   underling object.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|,
literal|20000604
argument_list|)
expr_stmt|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_referred_to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* For a non-type template-parameter of type reference to 	       function, no conversions apply.  If the 	       template-argument represents a set of overloaded 	       functions, the matching function is selected from the 	       set (_over.over_).  */
name|tree
name|fn
decl_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type_referred_to
argument_list|,
name|expr
argument_list|,
name|itf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* Don't issue an error here; we might get a different 		     function if the overloading had worked out 		     differently.  */
return|return
name|error_mark_node
return|;
else|else
goto|goto
name|bad_argument
goto|;
block|}
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|type_referred_to
argument_list|,
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fn
expr_stmt|;
block|}
else|else
block|{
comment|/* For a non-type template-parameter of type reference to 	       object, no conversions apply.  The type referred to by the 	       reference may be more cv-qualified than the (otherwise 	       identical) type of the template-argument.  The 	       template-parameter is bound directly to the 	       template-argument, which must be an lvalue.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|expr_type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_referred_to
argument_list|)
argument_list|)
operator|||
operator|!
name|at_least_as_qualified_p
argument_list|(
name|type_referred_to
argument_list|,
name|expr_type
argument_list|)
operator|||
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
name|mark_addressable
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
block|{
name|my_friendly_assert
argument_list|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
argument_list|,
literal|20010112
argument_list|)
expr_stmt|;
comment|/* For a non-type template-parameter of type pointer to member 	   function, no conversions apply.  If the template-argument 	   represents a set of overloaded member functions, the 	   matching member function is selected from the set 	   (_over.over_).  */
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|expr_type
operator|!=
name|unknown_type_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
comment|/* A ptr-to-member constant.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|itf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
break|break;
default|default:
comment|/* All non-type parameters must have one of these types.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARM_PARMS and ARG_PARMS matches using rule for     template template parameters.  Both PARM_PARMS and ARG_PARMS are     vectors of TREE_LIST nodes containing TYPE_DECL, TEMPLATE_DECL     or PARM_DECL.        ARG_PARMS may contain more parameters than PARM_PARMS.  If this is     the case, then extra parameters must have default arguments.     Consider the example:      template<class T, class Allocator = allocator> class vector;      template<template<class U> class TT> class C;     C<vector> is a valid instantiation.  PARM_PARMS for the above code     contains a TYPE_DECL (for U),  ARG_PARMS contains two TYPE_DECLs (for     T and Allocator) and OUTER_ARGS contains the argument that is used to     substitute the TT parameter.  */
end_comment

begin_function
specifier|static
name|int
name|coerce_template_template_parms
parameter_list|(
name|parm_parms
parameter_list|,
name|arg_parms
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|,
name|outer_args
parameter_list|)
name|tree
name|parm_parms
decl_stmt|,
name|arg_parms
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|,
name|outer_args
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm_parms
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arg_parms
argument_list|)
expr_stmt|;
comment|/* The rule here is opposite of coerce_template_parms.  */
if|if
condition|(
name|nargs
operator|<
name|nparms
operator|||
operator|(
name|nargs
operator|>
name|nparms
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|nparms
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
operator|++
name|i
control|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parm_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
operator|||
name|arg
operator|==
name|error_mark_node
operator|||
name|parm
operator|==
name|NULL_TREE
operator|||
name|parm
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
break|break;
case|case
name|TEMPLATE_DECL
case|:
comment|/* We encounter instantiations of templates like 	       template<template<template<class> class> class TT> 	       class C;  */
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|outer_args
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
comment|/* The tsubst call is used to handle cases such as 	       template<class T, template<T> class TT> class D;   	     i.e. the parameter list of TT depends on earlier parameters.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|outer_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert the indicated template ARG as necessary to match the    indicated template PARM.  Returns the converted ARG, or    error_mark_node if the conversion was unsuccessful.  Error messages    are issued if COMPLAIN is non-zero.  This conversion is for the Ith    parameter in the parameter list.  ARGS is the full set of template    arguments deduced so far.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_template_argument
parameter_list|(
name|parm
parameter_list|,
name|arg
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|i
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|requires_type
decl_stmt|,
name|is_tmpl_type
decl_stmt|,
name|requires_tmpl_type
decl_stmt|;
name|inner_args
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The template argument was the name of some 	 member function.  That's usually 	 illegal, but static members are OK.  In any 	 case, grab the underlying fields/functions 	 and issue an error later if required.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
name|requires_tmpl_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
expr_stmt|;
name|requires_type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|requires_tmpl_type
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
name|is_tmpl_type
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|arg
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_base_of_enclosing_class
argument_list|(
name|arg
argument_list|,
name|current_class_type
argument_list|)
condition|)
comment|/* This is a template name used within the scope of the 	   template. It could be the template, or it could be the 	   instantiation. Choose whichever makes sense.  */
name|is_tmpl_type
operator|=
name|requires_tmpl_type
expr_stmt|;
else|else
name|is_tmpl_type
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* It is a non-template class, or a specialization of a template        class, or a non-template member of a template class.  */
name|is_tmpl_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
operator|)
condition|)
name|arg
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tmpl_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|arg
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|||
name|is_tmpl_type
expr_stmt|;
if|if
condition|(
name|requires_type
operator|&&
operator|!
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|pedwarn
argument_list|(
literal|"to refer to a type member of a template parameter, use `typename %E'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|make_typename_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
name|is_type
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_type
operator|!=
name|requires_type
condition|)
block|{
if|if
condition|(
name|in_decl
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
name|error
argument_list|(
literal|"  expected a constant of type `%T', got `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|(
name|is_tmpl_type
condition|?
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
else|:
name|arg
operator|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"  expected a type, got `%E'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_tmpl_type
operator|^
name|requires_tmpl_type
condition|)
block|{
if|if
condition|(
name|in_decl
operator|&&
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
condition|)
name|error
argument_list|(
literal|"  expected a type, got `%T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"  expected a class template, got `%T'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_type
condition|)
block|{
if|if
condition|(
name|requires_tmpl_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
condition|)
comment|/* The number of argument required is not known yet. 	       Just accept it for now.  */
name|val
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|inner_args
argument_list|)
condition|)
block|{
name|val
operator|=
name|arg
expr_stmt|;
comment|/* TEMPLATE_TEMPLATE_PARM node is preferred over  		     TEMPLATE_DECL.  */
if|if
condition|(
name|val
operator|!=
name|error_mark_node
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in_decl
operator|&&
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  expected a template of type `%D', got `%D'"
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|val
operator|=
name|groktypename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the 		 name of a class or enumeration declared in a local 		 scope) shall not be used to declare an entity with 		 linkage.  This implies that names with no linkage 		 cannot be used as template arguments.  */
name|tree
name|t
init|=
name|no_linkage_check
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"template-argument `%T' uses anonymous type"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"template-argument `%T' uses local type `%T'"
argument_list|,
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|invalid_nontype_parm_type_p
argument_list|(
name|t
argument_list|,
name|complain
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
name|arg
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|t
argument_list|)
condition|)
comment|/* We used to call digest_init here.  However, digest_init 	   will report errors, which we don't want when complain 	   is zero.  More importantly, digest_init will try too 	   hard to convert things: for example, `0' should not be 	   converted to pointer type at this point according to 	   the standard.  Accepting this is not merely an 	   extension, since deciding whether or not these 	   conversions can occur is part of determining which 	   function template to call, or whether a given explicit 	   argument specification is legal.  */
name|val
operator|=
name|convert_nontype_argument
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|error_mark_node
operator|&&
name|complain
condition|)
name|error
argument_list|(
literal|"could not convert template argument `%E' to `%T'"
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Convert all template arguments to their appropriate types, and    return a vector containing the innermost resulting template    arguments.  If any error occurs, return error_mark_node, and, if    COMPLAIN is non-zero, issue an error message.  Some error messages    are issued even if COMPLAIN is zero; for instance, if a template    argument is composed from a local class.     If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be    provided in ARGLIST, or else trailing parameters must have default    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument    deduction for any unspecified trailing arguments.  */
end_comment

begin_function
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|,
name|in_decl
parameter_list|,
name|complain
parameter_list|,
name|require_all_arguments
parameter_list|)
name|tree
name|parms
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|require_all_arguments
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|,
name|lost
init|=
literal|0
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|new_inner_args
decl_stmt|;
name|inner_args
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|NUM_TMPL_ARGS
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|nparms
operator|||
operator|(
name|nargs
operator|<
name|nparms
operator|&&
name|require_all_arguments
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|nargs
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of template arguments (%d, should be %d)"
argument_list|,
name|nargs
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"provided for `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|new_inner_args
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|add_outermost_template_args
argument_list|(
name|args
argument_list|,
name|new_inner_args
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* Get the Ith template parameter.  */
name|parm
operator|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Calculate the Ith argument.  */
if|if
condition|(
name|inner_args
operator|&&
name|TREE_CODE
argument_list|(
name|inner_args
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
name|inner_args
operator|=
name|TREE_CHAIN
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If no template argument was supplied, look for a default 	 value.  */
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There was no default value.  */
name|my_friendly_assert
argument_list|(
operator|!
name|require_all_arguments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|arg
operator|=
name|tsubst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|arg
operator|=
name|tsubst_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Now, convert the Ith argument, as necessary.  */
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
condition|)
comment|/* We're out of arguments.  */
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|require_all_arguments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"template argument %d is invalid"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|convert_template_argument
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|i
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_inner_args
argument_list|,
name|i
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|lost
condition|)
return|return
name|error_mark_node
return|;
return|return
name|new_inner_args
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if template args OT and NT are equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|template_args_equal
parameter_list|(
name|ot
parameter_list|,
name|nt
parameter_list|)
name|tree
name|ot
decl_stmt|,
name|nt
decl_stmt|;
block|{
if|if
condition|(
name|nt
operator|==
name|ot
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|nt
argument_list|)
operator|==
name|TREE_VEC
condition|)
comment|/* For member templates */
return|return
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|comp_template_args
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|nt
argument_list|)
condition|)
return|return
name|TYPE_P
argument_list|(
name|ot
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
operator|==
name|TREE_VEC
operator|||
name|TYPE_P
argument_list|(
name|ot
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
name|cp_tree_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets    of template arguments.  Returns 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_template_args
parameter_list|(
name|oldargs
parameter_list|,
name|newargs
parameter_list|)
name|tree
name|oldargs
decl_stmt|,
name|newargs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|newargs
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|nt
init|=
name|TREE_VEC_ELT
argument_list|(
name|newargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|ot
init|=
name|TREE_VEC_ELT
argument_list|(
name|oldargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|template_args_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given class template name and parameter list, produce a user-friendly name    for the instantiation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
name|name
parameter_list|,
name|parms
parameter_list|,
name|arglist
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
block|{
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
if|if
condition|(
operator|!
name|scratch_firstobj
condition|)
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
else|else
name|obstack_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|scratch_firstobj
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|ccat
parameter_list|(
name|C
parameter_list|)
value|obstack_1grow (&scratch_obstack, (C));
define|#
directive|define
name|cat
parameter_list|(
name|S
parameter_list|)
value|obstack_grow (&scratch_obstack, (S), strlen (S))
name|cat
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nparms
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|268
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|ccat
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cat
argument_list|(
name|type_as_string
argument_list|(
name|arg
argument_list|,
name|TFF_CHASE_TYPEDEF
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* Already substituted with real template.  Just output  		 the template name here */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
comment|/* The template may be defined in a namespace, or                      may be a member template.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
argument_list|,
literal|980422
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|decl_as_string
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|cat
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output the parameter declaration */
name|cat
argument_list|(
name|type_as_string
argument_list|(
name|arg
argument_list|,
name|TFF_CHASE_TYPEDEF
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|269
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* New list cell was built because old chain link was in 	     use.  */
name|my_friendly_assert
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|270
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* No need to check arglist against parmlist here; we did that 	 in coerce_template_parms, called from lookup_template_class.  */
name|cat
argument_list|(
name|expr_as_string
argument_list|(
name|arg
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|bufp
init|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|offset
operator|--
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* B<C<char>>, not B<C<char>> */
if|if
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|ccat
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ccat
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|classtype_mangled_name
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
comment|/* Specializations have already had their names set up in 	 lookup_template_class.  */
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For non-primary templates, the template parameters are 	 implicit from their surrounding context.  */
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|mangled_name
init|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
decl_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|ti
init|=
operator|(
name|TYPE_P
argument_list|(
name|d
argument_list|)
condition|?
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
else|:
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
operator|)
decl_stmt|;
name|tree
name|pt
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
condition|)
return|return;
comment|/* We are called both from instantiate_decl, where we've already had a      tinst_level pushed, and instantiate_template, where we haven't.      Compensate.  */
name|level
operator|=
operator|!
operator|(
name|current_tinst_level
operator|&&
name|TINST_DECL
argument_list|(
name|current_tinst_level
argument_list|)
operator|==
name|d
operator|)
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|push_tinst_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pt
operator|=
name|tree_cons
argument_list|(
name|current_tinst_level
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_pending_template
condition|)
name|TREE_CHAIN
argument_list|(
name|last_pending_template
argument_list|)
operator|=
name|pt
expr_stmt|;
else|else
name|pending_templates
operator|=
name|pt
expr_stmt|;
name|last_pending_template
operator|=
name|pt
expr_stmt|;
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|pop_tinst_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS (which    may be either a _DECL or an overloaded function or an    IDENTIFIER_NODE), and ARGLIST.  */
end_comment

begin_function
name|tree
name|lookup_template_function
parameter_list|(
name|fns
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|fns
decl_stmt|,
name|arglist
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"non-template used as template"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|!
name|type
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|type
argument_list|,
name|fns
argument_list|,
name|arglist
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|type
argument_list|,
name|fns
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class S<T>, the name S gets bound    (in build_self_reference) to a TYPE_DECL for the class, not a    TEMPLATE_DECL.  If DECL is a TYPE_DECL for current_class_type,    or one of its enclosing classes, and that type is a template,    return the associated TEMPLATE_DECL.  Otherwise, the original    DECL is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_get_template_decl_from_type_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|?
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of    parameters, find the desired type.     D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.    (Actually ARGLIST may be either a TREE_LIST or a TREE_VEC.  It will    be a TREE_LIST if called directly from the parser, and a TREE_VEC    otherwise.)     IN_DECL, if non-NULL, is the template declaration we are trying to    instantiate.       If ENTERING_SCOPE is non-zero, we are about to enter the scope of    the class we are looking up.        If COMPLAIN is non-zero, issue error messages.     If the template class is really a local class in a template    function, then the FUNCTION_CONTEXT is the function in which it is    being instantiated.  */
end_comment

begin_function
name|tree
name|lookup_template_class
parameter_list|(
name|d1
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|,
name|context
parameter_list|,
name|entering_scope
parameter_list|,
name|complain
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|entering_scope
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|template
init|=
name|NULL_TREE
decl_stmt|,
name|parmlist
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_VALUE
argument_list|(
name|d1
argument_list|)
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|IDENTIFIER_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
name|template
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|context
condition|)
name|push_decl_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|template
operator|=
name|lookup_name
argument_list|(
name|d1
argument_list|,
comment|/*prefer_type=*/
literal|0
argument_list|)
expr_stmt|;
name|template
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|template
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
decl_stmt|;
comment|/* If we are declaring a constructor, say A<T>::A<T>, we will get 	 an implicit typename for the second A.  Deal with it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
operator|(
name|TYPE_P
argument_list|(
name|d1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|d1
argument_list|)
operator|)
condition|)
block|{
name|template
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|template
operator|=
name|d1
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
comment|/* With something like `template<class T> class X class X { ... };'      we could end up with D1 having nothing but an IDENTIFIER_VALUE.      We don't want to do that, but we have to deal with the situation,      so let's give them some syntax errors to chew on instead of a      crash. Alternatively D1 might not be a template type at all.  */
if|if
condition|(
operator|!
name|template
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"`%T' is not a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|!=
name|TEMPLATE_DECL
comment|/* If we're called from the parser, make sure it's a user visible             template.  */
operator|||
operator|(
operator|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_LIST
operator|)
operator|&&
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"non-template type `%T' used as a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"for template declaration `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
comment|/* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store          template arguments */
name|tree
name|parm
decl_stmt|;
name|tree
name|arglist2
decl_stmt|;
name|parmlist
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
comment|/* Consider an example where a template template parameter declared as  	   template<class T, class U = std::allocator<T>> class TT  	 The template parameter level of T and U are one level larger than  	 of TT.  To proper process the default argument of U, say when an  	 instantiation `TT<int>' is seen, we need to build the full 	 arguments containing {int} as the innermost level.  Outer levels 	 can be obtained from `current_template_args ()'.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|arglist
operator|=
name|add_to_template_args
argument_list|(
name|current_template_args
argument_list|()
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist2
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
name|complain
argument_list|,
comment|/*require_all_args=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|parm
operator|=
name|bind_template_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|arglist2
argument_list|)
expr_stmt|;
return|return
name|parm
return|;
block|}
else|else
block|{
name|tree
name|template_type
init|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|type_decl
decl_stmt|;
name|tree
name|found
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
name|arg_depth
decl_stmt|;
name|int
name|parm_depth
decl_stmt|;
name|int
name|is_partial_instantiation
decl_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|parm_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|arg_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_depth
operator|==
literal|1
operator|&&
name|parm_depth
operator|>
literal|1
condition|)
block|{
comment|/* We've been given an incomplete set of template arguments. 	     For example, given:  	       template<class T> struct S1 { 	         template<class U> struct S2 {}; 		 template<class U> struct S2<U*> {}; 	        }; 	      	     we will be called with an ARGLIST of `U*', but the 	     TEMPLATE will be `template<class T> template<class U> struct S1<T>::S2'.  We must fill in the missing 	     arguments.  */
name|arglist
operator|=
name|add_outermost_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arg_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
comment|/* Now we should have enough arguments.  */
name|my_friendly_assert
argument_list|(
name|parm_depth
operator|==
name|arg_depth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* From here on, we're only interested in the most general 	 template.  */
name|template
operator|=
name|gen_tmpl
expr_stmt|;
comment|/* Calculate the BOUND_ARGS.  These will be the args that are 	 actually tsubst'd into the definition to create the 	 instantiation.  */
if|if
condition|(
name|parm_depth
operator|>
literal|1
condition|)
block|{
comment|/* We have multiple levels of arguments to coerce, at once.  */
name|int
name|i
decl_stmt|;
name|int
name|saved_depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|bound_args
init|=
name|make_tree_vec
argument_list|(
name|parm_depth
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|saved_depth
operator|,
name|t
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|t
operator|!=
name|NULL_TREE
condition|;
operator|--
name|i
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|coerce_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
name|complain
argument_list|,
comment|/*require_all_args=*/
literal|1
argument_list|)
decl_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|bound_args
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
expr_stmt|;
comment|/* We temporarily reduce the length of the ARGLIST so 		 that coerce_template_parms will see only the arguments 		 corresponding to the template parameters it is 		 examining.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
block|}
comment|/* Restore the ARGLIST to its full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|=
name|saved_depth
expr_stmt|;
name|arglist
operator|=
name|bound_args
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|coerce_template_parms
argument_list|(
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|template
argument_list|,
name|complain
argument_list|,
comment|/*require_all_args=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|==
name|error_mark_node
condition|)
comment|/* We were unable to bind the arguments.  */
return|return
name|error_mark_node
return|;
comment|/* In the scope of a template class, explicit references to the 	 template class refer to the type of the template, not any 	 instantiation of it.  For example, in: 	  	   template<class T> class C { void f(C<T>); }  	 the `C<T>' is just the same as `C'.  Outside of the 	 class, however, such a reference is an instantiation.  */
if|if
condition|(
name|comp_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|template_type
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
block|{
name|found
operator|=
name|template_type
expr_stmt|;
if|if
condition|(
operator|!
name|entering_scope
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
comment|/* Note that we use DECL_CONTEXT, rather than 		 CP_DECL_CONTEXT, so that the termination test is 		 always just `ctx'.  We're not interested in namespace 		 scopes.  */
for|for
control|(
name|ctx
operator|=
name|current_class_type
init|;
name|ctx
condition|;
name|ctx
operator|=
operator|(
name|TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|ctx
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|ctx
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|ctx
argument_list|,
name|template_type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ctx
condition|)
comment|/* We're not in the scope of the class, so the 		   TEMPLATE_TYPE is not the type we want after 		   all.  */
name|found
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
return|return
name|found
return|;
for|for
control|(
name|tp
operator|=
operator|&
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
init|;
operator|*
name|tp
condition|;
name|tp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
block|{
name|found
operator|=
operator|*
name|tp
expr_stmt|;
comment|/* Use the move-to-front heuristic to speed up future 	       searches.  */
operator|*
name|tp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
operator|=
name|found
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
return|;
block|}
comment|/* This type is a "partial instantiation" if any of the template 	 arguments still involve template parameters.  Note that we set 	 IS_PARTIAL_INSTANTIATION for partial specializations as 	 well.  */
name|is_partial_instantiation
operator|=
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_partial_instantiation
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|template
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|found
operator|=
name|xref_tag_from_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
comment|/*globalize=*/
literal|1
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
name|context
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
argument_list|,
name|arglist
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
comment|/* Create the type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|is_partial_instantiation
condition|)
block|{
name|set_current_access_from_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|start_enum
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We don't want to call start_enum for this type, since 	       the values for the enumeration constants may involve 	       template parameters.  And, no one should be interested 	       in the enumeration constants for such a type.  */
name|t
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TREE_CODE
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
comment|/* A local class.  Make sure the decl gets registered properly.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
name|pushtag
argument_list|(
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we called start_enum or pushtag above, this information 	 will already be set up.  */
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|create_implicit_typedef
argument_list|(
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|type_decl
argument_list|)
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|type_decl
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Set up the template information.  We have to figure out which 	 template is the immediate parent if this is a full 	 instantiation.  */
if|if
condition|(
name|parm_depth
operator|==
literal|1
operator|||
name|is_partial_instantiation
operator|||
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
comment|/* This case is easy; there are no member templates involved.  */
name|found
operator|=
name|template
expr_stmt|;
else|else
block|{
comment|/* This is a full instantiation of a member template.  Look 	     for a partial instantiation of which this is an instance.  */
for|for
control|(
name|found
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
init|;
name|found
condition|;
name|found
operator|=
name|TREE_CHAIN
argument_list|(
name|found
argument_list|)
control|)
block|{
name|int
name|success
decl_stmt|;
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We only want partial instantiations, here, not 		 specializations or full instantiations.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Temporarily reduce by one the number of levels in the 		 ARGLIST and in FOUND so as to avoid comparing the 		 last set of arguments.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* See if the arguments match.  If they do, then TMPL is 		 the partial instantiation we want.  */
name|success
operator|=
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Restore the argument vectors to their full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|++
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|found
operator|=
name|tmpl
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* There was no partial instantiation. This happens                  where C<T> is a member template of A<T> and it's used                  in something like                                    template<typename T> struct B { A<T>::C<int> m; };                   B<float>;                                   Create the partial instantiation.                */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
name|found
operator|=
name|tsubst
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
name|SET_TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|,
name|tree_cons
argument_list|(
name|found
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|arglist
argument_list|,
name|t
argument_list|,
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|is_partial_instantiation
condition|)
comment|/* Now that the type has been registered on the instantiations 	   list, we set up the enumerators.  Because the enumeration 	   constants may involve the enumeration type itself, we make 	   sure to register the type first, and then create the 	   constants.  That way, doing tsubst_expr for the enumeration 	   constants won't result in recursive calls here; we'll find 	   the instantiation and exit above.  */
name|tsubst_enum
argument_list|(
name|template_type
argument_list|,
name|t
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO 	 is set up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|DECL_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_partial_instantiation
condition|)
block|{
comment|/* For backwards compatibility; code that uses 	     -fexternal-templates expects looking up a template to 	     instantiate it.  I think DDD still relies on this. 	     (jason 8/20/1998) */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|flag_external_templates
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
condition|)
name|add_pending_template
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If the type makes use of template parameters, the 	   code that generates debugging information will crash.  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|pair_fn_data
block|{
name|tree_fn_t
name|fn
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called from for_each_template_parm via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|for_each_template_parm_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|d
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|;
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|struct
name|pair_fn_data
modifier|*
name|pfd
init|=
operator|(
expr|struct
name|pair_fn_data
operator|*
operator|)
name|d
decl_stmt|;
name|tree_fn_t
name|fn
init|=
name|pfd
operator|->
name|fn
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|pfd
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Since we're not going to walk subtrees, we have to do this 	 explicitly here.  */
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
comment|/* Check the return type.  */
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check the parameter types.  Since default arguments are not 	 instantiated until they are needed, the TYPE_ARG_TYPES may 	 contain expressions that involve template parameters.  But, 	 no-one should be looking at them yet.  And, once they're 	 instantiated, they don't contain template parameters, so 	 there's no point in looking at them then, either.  */
block|{
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Since we've already handled the TYPE_ARG_TYPES, we don't 	   want walk_tree walking into them itself.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
comment|/* Record template parameters such as `T' inside `TT<T>'.  */
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
if|if
condition|(
name|fn
operator|&&
call|(
modifier|*
name|fn
call|)
argument_list|(
name|t
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|TEMPLATE_DECL
case|:
comment|/* A template template parameter is encountered */
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Already substituted template template parameter */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
if|if
condition|(
operator|!
name|fn
operator|||
name|for_each_template_parm
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* If there's no type, then this thing must be some expression 	 involving template parameters.  */
if|if
condition|(
operator|!
name|fn
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|MODOP_EXPR
case|:
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
case|case
name|LOOKUP_EXPR
case|:
case|case
name|PSEUDO_DTOR_EXPR
case|:
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
break|break;
default|default:
break|break;
block|}
comment|/* We didn't find any template parameters we liked.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM,     BOUND_TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX in T,     call FN with the parameter and the DATA.    If FN returns non-zero, the iteration is terminated, and    for_each_template_parm returns 1.  Otherwise, the iteration    continues.  If FN never returns a non-zero value, the value    returned by for_each_template_parm is 0.  If FN is NULL, it is    considered to be the function which always returns 1.  */
end_comment

begin_function
specifier|static
name|int
name|for_each_template_parm
parameter_list|(
name|t
parameter_list|,
name|fn
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree_fn_t
name|fn
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|pair_fn_data
name|pfd
decl_stmt|;
comment|/* Set up.  */
name|pfd
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|pfd
operator|.
name|data
operator|=
name|data
expr_stmt|;
comment|/* Walk the tree.  (Conceptually, we would like to walk without      duplicates, but for_each_template_parm_r recursively calls      for_each_template_parm, so we would need to reorganize a fair      bit to use walk_tree_without_duplicates.)  */
return|return
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|for_each_template_parm_r
argument_list|,
operator|&
name|pfd
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|int
name|uses_template_parms
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|for_each_template_parm
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|tinst_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_tinst_depth
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|tinst_level_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_template_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're starting to instantiate D; record the template instantiation context    for diagnostics and to restore it later.  */
end_comment

begin_function
name|int
name|push_tinst_level
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|new
decl_stmt|;
if|if
condition|(
name|tinst_depth
operator|>=
name|max_tinst_depth
condition|)
block|{
comment|/* If the instantiation in question still has unbound template parms, 	 we don't really care if we can't instantiate it, so just return.          This happens with base instantiation for implicit `typename'.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
name|error
argument_list|(
literal|"template instantiation depth exceeds maximum of %d (use -ftemplate-depth-NN to increase the maximum) instantiating `%D'"
argument_list|,
name|max_tinst_depth
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|print_instantiation_context
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|new
operator|=
name|build_expr_wfl
argument_list|(
name|d
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new
argument_list|)
operator|=
name|current_tinst_level
expr_stmt|;
name|current_tinst_level
operator|=
name|new
expr_stmt|;
operator|++
name|tinst_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|tinst_depth
operator|>
name|depth_reached
condition|)
name|depth_reached
operator|=
name|tinst_depth
expr_stmt|;
endif|#
directive|endif
operator|++
name|tinst_level_tick
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We're done instantiating this template; return to the instantiation    context.  */
end_comment

begin_function
name|void
name|pop_tinst_level
parameter_list|()
block|{
name|tree
name|old
init|=
name|current_tinst_level
decl_stmt|;
comment|/* Restore the filename and line number stashed away when we started      this instantiation.  */
name|lineno
operator|=
name|TINST_LINE
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|TINST_FILE
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
name|current_tinst_level
operator|=
name|TREE_CHAIN
argument_list|(
name|old
argument_list|)
expr_stmt|;
operator|--
name|tinst_depth
expr_stmt|;
operator|++
name|tinst_level_tick
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're instantiating a deferred template; restore the template    instantiation context in which the instantiation was requested, which    is one step out from LEVEL.  */
end_comment

begin_function
specifier|static
name|void
name|reopen_tinst_level
parameter_list|(
name|level
parameter_list|)
name|tree
name|level
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tinst_depth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|level
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
operator|++
name|tinst_depth
expr_stmt|;
name|current_tinst_level
operator|=
name|level
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the outermost template instantiation context, for use with    -falt-external-templates.  */
end_comment

begin_function
name|tree
name|tinst_for_decl
parameter_list|()
block|{
name|tree
name|p
init|=
name|current_tinst_level
decl_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the    vector of template arguments, as for tsubst.     Returns an appropriate tsubst'd friend declaration.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_function
parameter_list|(
name|decl
parameter_list|,
name|args
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|new_friend
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* This was a friend declared with an explicit template        argument list, e.g.:                friend void f<>(T);                to indicate that f was a template instantiation, not a new        function declaration.  Now, we have to figure out what        instantiation of what template.  */
block|{
name|tree
name|template_id
decl_stmt|,
name|arglist
decl_stmt|,
name|fns
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|ns
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Friend functions are looked up in the containing namespace scope.          We must enter that scope, to avoid finding member functions of the          current cless with same name.  */
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|fns
operator|=
name|tsubst_expr
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|template_id
operator|=
name|lookup_template_function
argument_list|(
name|fns
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|template_id
argument_list|,
name|new_friend
argument_list|,
operator|&
name|new_args
argument_list|,
comment|/*need_member_template=*/
literal|0
argument_list|)
expr_stmt|;
name|new_friend
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|new_args
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The NEW_FRIEND will look like an instantiation, to the      compiler, but is not an instantiation from the point of view of      the language.  For example, we might have had:            template<class T> struct S {        template<class U> friend void f(T, U);      };            Then, in S<int>, template<class U> void f(int, U) is not an      instantiation of anything.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|DECL_USE_TEMPLATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The mangled name for the NEW_FRIEND is incorrect.  The function      is not a template instantiation and should not be mangled like      one.  Therefore, we forget the mangling here; we'll recompute it      later if we need it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|new_friend
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|new_friend
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|new_friend
argument_list|)
condition|)
block|{
name|tree
name|old_decl
decl_stmt|;
name|tree
name|new_friend_template_info
decl_stmt|;
name|tree
name|new_friend_result_template_info
decl_stmt|;
name|tree
name|ns
decl_stmt|;
name|int
name|new_friend_is_defn
decl_stmt|;
comment|/* We must save some information from NEW_FRIEND before calling 	 duplicate decls since that function will free NEW_FRIEND if 	 possible.  */
name|new_friend_template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This declaration is a `primary' template.  */
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
name|new_friend
expr_stmt|;
name|new_friend_is_defn
operator|=
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
name|new_friend_result_template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_friend_is_defn
operator|=
name|DECL_INITIAL
argument_list|(
name|new_friend
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
name|new_friend_result_template_info
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Inside pushdecl_namespace_level, we will push into the 	 current namespace. However, the friend function should go 	 into the namespace of the template. */
name|ns
operator|=
name|decl_namespace_context
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|old_decl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|!=
name|new_friend
condition|)
block|{
comment|/* This new friend declaration matched an existing 	     declaration.  For example, given:  	       template<class T> void f(T); 	       template<class U> class C {  		 template<class T> friend void f(T) {}  	       };  	     the friend declaration actually provides the definition 	     of `f', once C has been instantiated for some type.  So, 	     old_decl will be the out-of-class template declaration, 	     while new_friend is the in-class definition.  	     But, if `f' was called before this point, the 	     instantiation of `f' will have DECL_TI_ARGS corresponding 	     to `T' but not to `U', references to which might appear 	     in the definition of `f'.  Previously, the most general 	     template for an instantiation of `f' was the out-of-class 	     version; now it is the in-class version.  Therefore, we 	     run through all specialization of `f', adding to their 	     DECL_TI_ARGS appropriately.  In particular, they need a 	     new set of outer arguments, corresponding to the 	     arguments for this class instantiation.    	     The same situation can arise with something like this:  	       friend void f(int); 	       template<class T> class C {  	         friend void f(T) {}                };  	     when `C<int>' is instantiated.  Now, `f(int)' is defined 	     in the class.  */
if|if
condition|(
operator|!
name|new_friend_is_defn
condition|)
comment|/* On the other hand, if the in-class declaration does 	       *not* provide a definition, then we don't want to alter 	       existing definitions.  We can just leave everything 	       alone.  */
empty_stmt|;
else|else
block|{
comment|/* Overwrite whatever template info was there before, if 		 any, with the new template information pertaining to 		 the declaration.  */
name|DECL_TEMPLATE_INFO
argument_list|(
name|old_decl
argument_list|)
operator|=
name|new_friend_template_info
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* duplicate_decls will take care of this case.  */
empty_stmt|;
else|else
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|new_friend_args
decl_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|=
name|new_friend_result_template_info
expr_stmt|;
name|new_friend_args
operator|=
name|TI_ARGS
argument_list|(
name|new_friend_template_info
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|spec
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
operator|=
name|add_outermost_template_args
argument_list|(
name|new_friend_args
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now, since specializations are always supposed to 		     hang off of the most general template, we must move 		     them.  */
name|t
operator|=
name|most_general_template
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|old_decl
condition|)
block|{
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
comment|/* The information from NEW_FRIEND has been merged into OLD_DECL 	     by duplicate_decls.  */
name|new_friend
operator|=
name|old_decl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check to see that the declaration is really present, and, 	 possibly obtain an improved declaration.  */
name|tree
name|fn
init|=
name|check_classfn
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
argument_list|,
name|new_friend
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|new_friend
operator|=
name|fn
expr_stmt|;
block|}
name|done
label|:
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
return|return
name|new_friend
return|;
block|}
end_function

begin_comment
comment|/* FRIEND_TMPL is a friend TEMPLATE_DECL.  ARGS is the vector of    template arguments, as for tsubst.     Returns an appropriate tsubst'd friend type or error_mark_node on    failure.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_class
parameter_list|(
name|friend_tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|friend_tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|friend_type
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
comment|/* First, we look for a class template.  */
name|tmpl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
comment|/*prefer_type=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* But, if we don't find one, it might be because we're in a      situation like this:         template<class T>        struct S {          template<class U> 	 friend struct S;        };       Here, in the scope of (say) S<int>, `S' is bound to a TYPE_DECL      for `S<int>', not the TEMPLATE_DECL.  */
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tmpl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
comment|/*prefer_type=*/
literal|1
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpl
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* The friend template has already been declared.  Just 	 check to see that the declarations match, and install any new 	 default parameters.  We must tsubst the default parameters, 	 of course.  We only need the innermost template parameters 	 because that is all that redeclare_class_template will look 	 at.  */
name|tree
name|parms
init|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parms
condition|)
return|return
name|error_mark_node
return|;
name|redeclare_class_template
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The friend template has not already been declared.  In this 	 case, the instantiation of the template class will cause the 	 injection of this template into the global scope.  */
name|tmpl
operator|=
name|tsubst
argument_list|(
name|friend_tmpl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The new TMPL is not an instantiation of anything, so we  	 forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for 	 the new type because that is supposed to be the corresponding 	 template decl, i.e., TMPL.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Inject this template into the global scope.  */
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|pushdecl_top_level
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|friend_type
return|;
block|}
end_function

begin_function
name|tree
name|instantiate_class_template
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|args
decl_stmt|,
name|pattern
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|typedecl
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* Figure out which template is being instantiated.  */
name|template
operator|=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|279
argument_list|)
expr_stmt|;
comment|/* Figure out which arguments are being used to do the      instantiation.  */
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
operator|=
name|uses_template_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* If this is a partial instantiation, then we can't instantiate        the type; there's no telling whether or not one of the        template parameters might eventually be instantiated to some        value that results in a specialization being used.  For        example, consider:           template<class T>          struct S {};           template<class U>           void f(S<U>); 	               template<>           struct S<int> {};         Now, the `S<U>' in `f<int>' is the specialization, not an        instantiation of the original template.  */
return|return
name|type
return|;
comment|/* Determine what specialization of the original template to      instantiate.  */
if|if
condition|(
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* There's no telling which specialization is appropriate at this        point.  Since all peeking at the innards of this partial        instantiation are extensions (like the "implicit typename"        extension, which allows users to omit the keyword `typename' on        names that are declared as types in template base classes), we        are free to do what we please.         Trying to figure out which partial instantiation to use can        cause a crash.  (Some of the template arguments don't even have        types.)  So, we just use the most general version.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|t
operator|=
name|most_specialized_class
argument_list|(
name|template
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
name|error
argument_list|(
literal|"ambiguous class template instantiation for `%#T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|template
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"%s %+#T"
argument_list|,
name|str
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|t
condition|)
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
expr_stmt|;
comment|/* If the template we're instantiating is incomplete, then clearly      there's nothing we can do.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|pattern
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* If this is a partial instantiation, don't tsubst anything.  We will      only use this type for implicit typename, so the actual contents don't      matter.  All that matters is whether a particular name is a type.  */
if|if
condition|(
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The fields set here must be kept in sync with those cleared 	 in begin_class_definition.  */
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* Pretend that the type is complete, so that we will look 	 inside it during name lookup and such.  */
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* If we've recursively instantiated too many templates, stop.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* Now we're really doing the instantiation.  Mark the type as in      the process of being defined.  */
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|maybe_push_to_top_level
argument_list|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
comment|/* This TYPE is actually a instantiation of of a partial 	 specialization.  We replace the innermost set of ARGS with 	 the arguments appropriate for substitution.  For example, 	 given:  	   template<class T> struct S {}; 	   template<class T> struct S<T*> {}; 	  	 and supposing that we are instantiating S<int*>, ARGS will 	 present be {int*} but we need {int}.  */
name|tree
name|inner_args
init|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|/* If there were multiple levels in ARGS, replacing the 	 innermost level would alter CLASSTYPE_TI_ARGS, which we don't 	 want, so we make a copy first.  */
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|args
operator|=
name|copy_node
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|,
name|inner_args
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|inner_args
expr_stmt|;
block|}
if|if
condition|(
name|flag_external_templates
condition|)
block|{
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|type
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_GETS_DELETE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONVERSION
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_PACKED
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* For libjava's JArray<T> */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|pattern
argument_list|)
condition|)
name|SET_ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
name|tree
name|base_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|pbases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Substitute into each of the bases to determine the actual 	 basetypes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|pbases
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base
decl_stmt|;
name|tree
name|access
decl_stmt|;
name|tree
name|pbase
decl_stmt|;
name|pbase
operator|=
name|TREE_VEC_ELT
argument_list|(
name|pbases
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Substitute to figure out the base class.  */
name|base
operator|=
name|tsubst
argument_list|(
name|BINFO_TYPE
argument_list|(
name|pbase
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* Calculate the correct access node.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|pbase
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_public_virtual_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_protected_virtual_node
expr_stmt|;
else|else
name|access
operator|=
name|access_private_virtual_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_public_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|access
operator|=
name|access_private_node
expr_stmt|;
block|}
name|base_list
operator|=
name|tree_cons
argument_list|(
name|access
argument_list|,
name|base
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
block|}
comment|/* The list is now in reverse order; correct that.  */
name|base_list
operator|=
name|nreverse
argument_list|(
name|base_list
argument_list|)
expr_stmt|;
comment|/* Now call xref_basetypes to set up all the base-class 	 information.  */
name|xref_basetypes
argument_list|(
name|TREE_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|RECORD_TYPE
condition|?
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|pattern
argument_list|)
condition|?
name|class_type_node
else|:
name|record_type_node
operator|)
else|:
name|union_type_node
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|pattern
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
block|}
comment|/* Now that our base classes are set up, enter the scope of the      class, so that name lookups into base classes, etc. will work      correctly.  This is precisely analogous to what we do in      begin_class_definition when defining an ordinary non-template      class.  */
name|pushclass
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|tag
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|tree
name|newtag
decl_stmt|;
name|newtag
operator|=
name|tsubst
argument_list|(
name|tag
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|newtag
operator|!=
name|error_mark_node
argument_list|,
literal|20010206
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtag
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|tag
argument_list|)
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|tag
argument_list|)
condition|)
comment|/* Unfortunately, lookup_template_class sets 	       CLASSTYPE_IMPLICIT_INSTANTIATION for a partial 	       instantiation (i.e., for the type of a member template 	       class nested within a template class.)  This behavior is 	       required for maybe_process_partial_specialization to work 	       correctly, but is not accurate in this case; the TAG is not 	       an instantiation of anything.  (The corresponding 	       TEMPLATE_DECL is an instantiation, but the TYPE is not.) */
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|newtag
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now, we call pushtag to put this NEWTAG into the scope of 	     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid 	     pushtag calling push_template_decl.  We don't have to do 	     this for enums because it will already have been done in 	     tsubst_enum.  */
if|if
condition|(
name|name
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newtag
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|newtag
argument_list|,
comment|/*globalize=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't replace enum constants here.  */
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
name|tree
name|r
decl_stmt|;
comment|/* The the file and line for this declaration, to assist in 	   error message reporting.  Since we called push_tinst_level 	   above, we don't need to restore these.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|r
argument_list|)
condition|)
name|init
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_static_data_member_decl
argument_list|(
name|r
argument_list|,
name|init
argument_list|,
comment|/*asmspec_tree=*/
name|NULL_TREE
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|r
argument_list|)
condition|)
name|check_static_variable_definition
argument_list|(
name|r
argument_list|,
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* R will have a TREE_CHAIN if and only if it has already been 	   processed by finish_member_declaration.  This can happen 	   if, for example, it is a TYPE_DECL for a class-scoped 	   ENUMERAL_TYPE; such a thing will already have been added to 	   the field list by tsubst_enum above.  */
if|if
condition|(
operator|!
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|set_current_access_from_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up the list (TYPE_METHODS) and vector (CLASSTYPE_METHOD_VEC)      for this instantiation.  */
for|for
control|(
name|t
operator|=
name|TYPE_METHODS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|r
init|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|set_current_access_from_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|grok_special_member_properties
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the DECL_FRIENDLIST for the new class type.  */
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|pattern
argument_list|)
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|friends
decl_stmt|;
for|for
control|(
name|friends
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
init|;
name|friends
operator|!=
name|NULL_TREE
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
operator|==
name|error_mark_node
condition|)
name|add_friend
argument_list|(
name|type
argument_list|,
name|tsubst_friend_function
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|pattern
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|friend_type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|new_friend_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|new_friend_type
operator|=
name|tsubst_friend_class
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|friend_type
argument_list|)
condition|)
name|new_friend_type
operator|=
name|tsubst
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|ns
init|=
name|decl_namespace_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|friend_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The call to xref_tag_from_type does injection for friend 	     classes.  */
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|new_friend_type
operator|=
name|xref_tag_from_type
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* Trick make_friend_class into realizing that the friend 	   we're adding is a template, not an ordinary class.  It's 	   important that we use make_friend_class since it will 	   perform some error-checking and output cross-reference 	   information.  */
operator|++
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|new_friend_type
operator|!=
name|error_mark_node
condition|)
name|make_friend_class
argument_list|(
name|type
argument_list|,
name|new_friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|require_complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Set the file and line number information to whatever is given for      the class itself.  This puts error messages involving generated      implicit functions at a predictable point, and the same point      that would be used for non-template classes.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|unreverse_member_declarations
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|finish_struct_1
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Clear this now so repo_template_used is happy.  */
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|repo_template_used
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Now that the class is complete, instantiate default arguments for      any member functions.  We don't do this earlier because the      default arguments may reference members of the class.  */
if|if
condition|(
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
for|for
control|(
name|t
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* Implicitly generated member functions will not have template 	     information; they are not instantiations, but instead are 	     created "fresh" for each instantiation.  */
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
name|tsubst_default_arguments
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|popclass
argument_list|()
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_eq
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Don't care if one declares its arg const and the other doesn't -- the      main variant of the arg type is all that matters.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|list_eq
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If arg is a non-type template parameter that does not depend on template    arguments, fold it like we weren't in the body of a template.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_nontype_arg
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Sometimes, one of the args was an expression involving a 	 template constant parameter, like N - 1.  Now that we've 	 tsubst'd, we might have something like 2 - 1.  This will 	 confuse lookup_template_class, so we do constant folding 	 here.  We have to unset processing_template_decl, to 	 fool build_expr_from_tree() into building an actual 	 tree.  */
comment|/* If the TREE_TYPE of ARG is not NULL_TREE, ARG is already 	 as simple as it's going to get, and trying to reprocess 	 the trees will break.  */
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|int
name|saved_processing_template_decl
init|=
name|processing_template_decl
decl_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|build_expr_from_tree
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
block|}
name|arg
operator|=
name|fold
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Substitute ARGS into the vector of template arguments T.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_template_arg_vector
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|need_new
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|elts
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elts
argument_list|,
literal|0
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|elts
index|[
name|i
index|]
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
else|else
name|elts
index|[
name|i
index|]
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|tsubst_expr
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|need_new
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_new
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|elts
index|[
name|i
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the result of substituting ARGS into the template parameters    given by PARMS.  If there are m levels of ARGS and m + n levels of    PARMS, then the result will contain n levels of PARMS.  For    example, if PARMS is `template<class T> template<class U>    template<T*, U, class V>' and ARGS is {{int}, {double}} then the    result will be `template<int*, double, class V>'.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_template_parms
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|)
name|tree
name|parms
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|new_parms
decl_stmt|;
for|for
control|(
name|new_parms
operator|=
operator|&
name|r
init|;
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|>
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
name|new_parms
operator|=
operator|&
operator|(
name|TREE_CHAIN
argument_list|(
operator|*
name|new_parms
argument_list|)
operator|)
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|new_vec
init|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|new_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tuple
init|=
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|default_value
init|=
name|TREE_PURPOSE
argument_list|(
name|tuple
argument_list|)
decl_stmt|;
name|tree
name|parm_decl
init|=
name|TREE_VALUE
argument_list|(
name|tuple
argument_list|)
decl_stmt|;
name|parm_decl
operator|=
name|tsubst
argument_list|(
name|parm_decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|default_value
operator|=
name|tsubst_expr
argument_list|(
name|default_value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tuple
operator|=
name|build_tree_list
argument_list|(
name|maybe_fold_nontype_arg
argument_list|(
name|default_value
argument_list|)
argument_list|,
name|parm_decl
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
name|i
argument_list|)
operator|=
name|tuple
expr_stmt|;
block|}
operator|*
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|-
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|new_vec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitute the ARGS into the indicated aggregate (or enumeration)    type T.  If T is not an aggregate or enumeration type, it is    handled as if by tsubst.  IN_DECL is as for tsubst.  If    ENTERING_SCOPE is non-zero, T is the context for a template which    we are presently tsubst'ing.  Return the substituted value.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_aggr_type
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|,
name|entering_scope
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|int
name|entering_scope
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
comment|/* else fall through */
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|argvec
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|r
decl_stmt|;
comment|/* First, determine the context for the type we are looking 	     up.  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|context
operator|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Then, figure out what arguments are appropriate for the 	     type we are trying to find.  For example, given:  	       template<class T> struct S; 	       template<class T, class U> void f(T, U) { S<U> su; }  	     and supposing that we are instantiating f<int, double>, 	     then our ARGS will be {int, double}, but, when looking up 	     S we only want {double}.  */
name|argvec
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|t
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|context
argument_list|,
name|entering_scope
argument_list|,
name|complain
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
else|else
comment|/* This is not a template type, so there's nothing to do.  */
return|return
name|t
return|;
default|default:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Substitute into the default argument ARG (a default argument for    FN), which has the indicated TYPE.  */
end_comment

begin_function
name|tree
name|tsubst_default_argument
parameter_list|(
name|fn
parameter_list|,
name|type
parameter_list|,
name|arg
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* This default argument came from a template.  Instantiate the      default argument here, not in tsubst.  In the case of      something like:               template<class T>        struct S { 	 static T t(); 	 void f(T = t());        };            we must be careful to do name lookup in the scope of S<T>,      rather than in the current class.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|pushclass
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tsubst_expr
argument_list|(
name|arg
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|popclass
argument_list|()
expr_stmt|;
comment|/* Make sure the default argument is reasonable.  */
name|arg
operator|=
name|check_default_argument
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Substitute into all the default arguments for FN.  */
end_comment

begin_function
specifier|static
name|void
name|tsubst_default_arguments
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|tmpl_args
decl_stmt|;
name|tmpl_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If this function is not yet instantiated, we certainly don't need      its default arguments.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|tmpl_args
argument_list|)
condition|)
return|return;
for|for
control|(
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|=
name|tsubst_default_argument
argument_list|(
name|fn
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Substitute the ARGS into the T, which is a _DECL.  TYPE is the    (already computed) substitution of ARGS into TREE_TYPE (T), if    appropriate.  Return the result of the substitution.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_decl
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|type
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|saved_lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_filename
decl_stmt|;
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|in_decl
init|=
name|t
decl_stmt|;
comment|/* Set the filename and linenumber to improve error-reporting.  */
name|saved_lineno
operator|=
name|lineno
expr_stmt|;
name|saved_filename
operator|=
name|input_filename
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
block|{
comment|/* We can get here when processing a member template function 	   of a template class.  */
name|tree
name|decl
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|int
name|is_template_template_parm
init|=
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_template_template_parm
condition|)
block|{
comment|/* We might already have an instance of this template. 	       The ARGS are for the surrounding class type, so the 	       full args contain the tsubst'd args for the context, 	       plus the innermost args from the template decl.  */
name|tree
name|tmpl_args
init|=
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|?
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|full_args
decl_stmt|;
name|full_args
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|tmpl_args
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* tsubst_template_arg_vector doesn't copy the vector if 	       nothing changed.  But, *something* should have 	       changed.  */
name|my_friendly_assert
argument_list|(
name|full_args
operator|!=
name|tmpl_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|t
argument_list|,
name|full_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make a new template decl.  It will be similar to the 	   original, but will record the current template arguments.  	   We also create a new function declaration, which is just 	   like the old one, but points to this new template, rather 	   than the old one.  */
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|r
argument_list|)
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_template_template_parm
condition|)
block|{
name|tree
name|new_decl
init|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
break|break;
block|}
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|new_type
expr_stmt|;
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|new_type
argument_list|)
operator|=
name|r
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|r
argument_list|)
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|new_decl
init|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|r
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_TI_ARGS
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The template parameters for this new template are all the 	   template parameters for the old template, except the 	   outermost level of parameters. */
name|DECL_TEMPLATE_PARMS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
comment|/* We don't partially instantiate partial specializations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
break|break;
comment|/* Record this partial instantiation.  */
name|register_specialization
argument_list|(
name|r
argument_list|,
name|t
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|ctx
decl_stmt|;
name|tree
name|argvec
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|friends
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|int
name|member
decl_stmt|;
name|int
name|args_depth
decl_stmt|;
name|int
name|parms_depth
decl_stmt|;
comment|/* Nobody should be tsubst'ing into non-template functions.  */
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|spec
decl_stmt|;
comment|/* Calculate the most general template of which R is a 	       specialization, and the complete set of arguments used to 	       specialize R.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|argvec
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
comment|/* We can see more levels of arguments than parameters if 	       there was a specialization of a member template, like 	       this:  	         template<class T> struct S { template<class U> void f(); } 		 template<> template<class U> void S<int>::f(U);   	       Here, we'll be substituting into the specialization, 	       because that's where we can find the code we actually 	       want to generate, but we'll have enough arguments for 	       the most general template.	         	       We also deal with the peculiar case:  		 template<class T> struct S {  		   template<class U> friend void f(); 		 }; 		 template<class U> void f() {} 		 template S<int>; 		 template void f<double>();  	       Here, the ARGS for the instantiation of will be {int, 	       double}.  But, we only need as many ARGS as there are 	       levels of template parameters in CODE_PATTERN.  We are 	       careful not to get fooled into reducing the ARGS in 	       situations like:  		 template<class T> struct S { template<class U> void f(U); } 		 template<class T> template<> void S<T>::f(int) {}  	       which we can spot because the pattern will be a 	       specialization in this case.  */
name|args_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|parms_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_depth
operator|>
name|parms_depth
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
name|args
operator|=
name|get_innermost_template_args
argument_list|(
name|args
argument_list|,
name|parms_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This special case arises when we have something like this:  	         template<class T> struct S {  		   friend void f<int>(int, double);  		 };  	       Here, the DECL_TI_TEMPLATE for the friend declaration 	       will be a LOOKUP_EXPR or an IDENTIFIER_NODE.  We are 	       being called from tsubst_friend_function, and we want 	       only to create a new decl (R) with appropriate types so 	       that we can call determine_specialization.  */
name|my_friendly_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|LOOKUP_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gen_tmpl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|member
operator|=
literal|2
expr_stmt|;
else|else
name|member
operator|=
literal|1
expr_stmt|;
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|member
operator|=
literal|0
expr_stmt|;
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* We do NOT check for matching decls pushed separately at this            point, as they may not represent instantiations of this            template, and in any case are considered separate under the            discrete model.  */
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Clear out the mangled name and RTL for the instantiation.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|r
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|&&
name|DECL_CONV_FN_P
argument_list|(
name|r
argument_list|)
condition|)
comment|/* Type-conversion operator.  Reconstruct the name, in 	     case it's the name of one of the template's parameters.  */
name|DECL_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|mangle_conv_op_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_USED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
argument_list|)
operator|=
name|r
expr_stmt|;
block|}
comment|/* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do 	   this in the special friend case mentioned above where 	   GEN_TMPL is NULL.  */
if|if
condition|(
name|gen_tmpl
condition|)
block|{
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
comment|/* We're not supposed to instantiate default arguments 	       until they are called, for a template.  But, for a 	       declaration like:  	         template<class T> void f ()                   { extern void g(int i = T()); } 		  	       we should do the substitution when the template is 	       instantiated.  We handle the member function case in 	       instantiate_class_template since the default arguments 	       might refer to other members of the class.  */
if|if
condition|(
operator|!
name|member
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|gen_tmpl
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|argvec
argument_list|)
condition|)
name|tsubst_default_arguments
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the list of befriending classes.  */
for|for
control|(
name|friends
operator|=
operator|&
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|r
argument_list|)
init|;
operator|*
name|friends
condition|;
name|friends
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|friends
argument_list|)
control|)
block|{
operator|*
name|friends
operator|=
name|copy_node
argument_list|(
operator|*
name|friends
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
operator|*
name|friends
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|friends
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|r
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|maybe_retrofit_in_chrg
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|r
argument_list|)
condition|)
name|grok_ctor_properties
argument_list|(
name|ctx
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* If this is an instantiation of a member template, clone it. 	       If it isn't, that'll be handled by 	       clone_constructors_and_destructors.  */
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|gen_tmpl
argument_list|)
condition|)
name|clone_function_decl
argument_list|(
name|r
argument_list|,
comment|/*update_method_vec_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|r
argument_list|,
name|DECL_FRIEND_P
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|r
argument_list|)
operator|&&
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIELD_DECL
case|:
block|{
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* We don't have to set DECL_CONTEXT here; it is set by 	   finish_member_declaration.  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"instantiation of `%D' as type `%T'"
argument_list|,
name|r
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USING_DECL
case|:
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_copy
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|t
operator|==
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is the canonical decl, we don't have to mess with              instantiations, and often we can't (for typename, template 	     type parms and such).  Note that TYPE_NAME is not correct for 	     the above test if we've copied the type for a typedef.  */
name|r
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|VAR_DECL
case|:
block|{
name|tree
name|argvec
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|gen_tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|local_p
decl_stmt|;
comment|/* Assume this is a non-local variable.  */
name|local_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Subsequent calls to pushdecl will fill this in.  */
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
name|local_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check to see if we already have this specialization.  */
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|argvec
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
block|}
else|else
name|spec
operator|=
name|retrieve_local_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
comment|/* Clear out the mangled name and RTL for the instantiation.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|r
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Don't try to expand the initializer until someone tries to use 	   this variable; otherwise we run into circular dependencies.  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|r
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* For __PRETTY_FUNCTION__ we have to adjust the initializer.  */
if|if
condition|(
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|cp_fname_init
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Even if the original location is out of scope, the newly 	   substituted one is not.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
comment|/* A static data member declaration is always marked 	       external when it is declared in-class, even if an 	       initializer is present.  We mimic the non-template 	       processing here.  */
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|register_local_specialization
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"instantiation of `%D' as type `%T'"
argument_list|,
name|r
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Restore the file and line information.  */
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|input_filename
operator|=
name|saved_filename
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitue into the ARG_TYPES of a function type.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_arg_types
parameter_list|(
name|arg_types
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|arg_types
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|remaining_arg_types
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|arg_types
operator|||
name|arg_types
operator|==
name|void_list_node
condition|)
return|return
name|arg_types
return|;
name|remaining_arg_types
operator|=
name|tsubst_arg_types
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_arg_types
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"invalid parameter type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"in declaration `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* Do array-to-pointer, function-to-pointer conversion, and ignore      top-level qualifiers as required.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we do not substitute into default arguments here.  The      standard mandates that they be instantiated only when needed,      which is done in build_over_call.  */
return|return
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|type
argument_list|,
name|remaining_arg_types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Substitute into a FUNCTION_TYPE or METHOD_TYPE.  This routine does    *not* handle the exception-specification for FNTYPE, because the    initial substitution of explicitly provided template parameters    during argument deduction forbids substitution into the    exception-specification:       [temp.deduct]       All references in the function type of the function template to  the      corresponding template parameters are replaced by the specified tem-      plate argument values.  If a substitution in a template parameter or      in  the function type of the function template results in an invalid      type, type deduction fails.  [Note: The equivalent  substitution  in      exception specifications is done only when the function is instanti-      ated, at which point a program is  ill-formed  if  the  substitution      results in an invalid type.]  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_function_type
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|return_type
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
comment|/* The TYPE_CONTEXT is not used for function/method types.  */
name|my_friendly_assert
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Substitute the return type.  */
name|return_type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Substitue the argument types.  */
name|arg_types
operator|=
name|tsubst_arg_types
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Construct a new type node and return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|return_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|r
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* [temp.deduct] 	      	     Type deduction may fail for any of the following 	     reasons: 	      	     -- Attempting to create "pointer to member of T" when T 	     is not a class type.  */
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"creating pointer to member function of non-class type `%T'"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|r
argument_list|,
name|return_type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|build_qualified_type
argument_list|(
name|fntype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_type_attribute_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fntype
return|;
block|}
end_function

begin_comment
comment|/* Substitute into the PARMS of a call-declarator.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_call_declarator_parms
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|parms
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|new_parms
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|defarg
decl_stmt|;
if|if
condition|(
operator|!
name|parms
operator|||
name|parms
operator|==
name|void_list_node
condition|)
return|return
name|parms
return|;
name|new_parms
operator|=
name|tsubst_call_declarator_parms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Figure out the type of this parameter.  */
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Figure out the default argument as well.  Note that we use      tsubst_expr since the default argument is really an expression.  */
name|defarg
operator|=
name|tsubst_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Chain this parameter on to the front of those we have already      processed.  We don't use hash_tree_cons because that function      doesn't check TREE_PARMLIST.  */
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|defarg
argument_list|,
name|type
argument_list|,
name|new_parms
argument_list|)
expr_stmt|;
comment|/* And note that these are parameters.  */
name|TREE_PARMLIST
argument_list|(
name|new_parms
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|new_parms
return|;
block|}
end_function

begin_comment
comment|/* Take the tree structure T and replace template parameters used    therein with the argument vector ARGS.  IN_DECL is an associated    decl for diagnostics.  If an error occurs, returns ERROR_MARK_NODE.    An appropriate error message is issued only if COMPLAIN is    non-zero.  Note that we must be relatively non-tolerant of    extensions here, in order to preserve conformance; if we allow    substitutions that should not be allowed, we may allow argument    deductions that should not succeed, and therefore report ambiguous    overload situations where there are none.  In theory, we could    allow the substitution, but indicate that it should have failed,    and allow our caller to make sure that the right thing happens, but    we don't try to do this yet.     This function is used for dealing with types, decls and the like;    for expressions, use tsubst_expr or tsubst_copy.  */
end_comment

begin_function
name|tree
name|tsubst
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
operator|||
name|t
operator|==
name|integer_type_node
operator|||
name|t
operator|==
name|void_type_node
operator|||
name|t
operator|==
name|char_type_node
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|unknown_type_node
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst_decl
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|type
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|tsubst_aggr_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|t
return|;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|t
operator|==
name|integer_type_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|t
return|;
block|{
name|tree
name|max
decl_stmt|,
name|omax
init|=
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|max
operator|=
name|tsubst_expr
argument_list|(
name|omax
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* See if we can reduce this expression to something simpler.  */
name|max
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|max
operator|=
name|decl_constant_value
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
comment|/* When providing explicit arguments to a template 	       function, but leaving some arguments for subsequent 	       deduction, MAX may be template-dependent even if we're 	       not PROCESSING_TEMPLATE_DECL.  We still need to check for 	       template parms, though; MAX won't be an INTEGER_CST for 	       dynamic arrays, either.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|uses_template_parms
argument_list|(
name|max
argument_list|)
operator|)
condition|)
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|max
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
return|return
name|itype
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|omax
argument_list|)
condition|)
block|{
comment|/* Still allow an explicit array of size zero.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"creating array with size zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|max
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|INT_CST_LT
argument_list|(
name|max
argument_list|,
name|integer_zero_node
argument_list|)
operator|)
condition|)
block|{
comment|/* [temp.deduct]  	       Type deduction may fail for any of the following 	       reasons:    		 Attempting to create an array with a size that is 		 zero or negative.  */
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"creating array with size zero (`%E')"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|compute_array_index_type
argument_list|(
name|NULL_TREE
argument_list|,
name|max
argument_list|)
return|;
block|}
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
block|{
name|int
name|idx
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|levels
decl_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|arg
init|=
name|NULL_TREE
decl_stmt|;
name|levels
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|levels
condition|)
name|arg
operator|=
name|TMPL_ARG
argument_list|(
name|args
argument_list|,
name|level
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|arg
argument_list|,
name|cp_type_quals
argument_list|(
name|arg
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
comment|/* We are processing a type constructed from 		       a template template parameter */
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* We can get a TEMPLATE_TEMPLATE_PARM here when  		       we are resolving nested-types in the signature of  		       a member function templates. 		       Otherwise ARG is a TEMPLATE_DECL and is the real  		       template to be instantiated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|arg
operator|=
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|arg
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
name|complain
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
else|else
comment|/* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */
return|return
name|arg
return|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
comment|/* This can happen during the attempted tsubst'ing in 	     unify.  This means that we don't yet have any information 	     about the template parameter in question.  */
return|return
name|t
return|;
comment|/* If we get here, we must have been looking at a parm for a 	   more deeply nested template.  Make a new version of this 	   template parameter, but with a lower level.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
if|if
condition|(
name|cp_type_quals
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|r
operator|=
name|tsubst
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|copy_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|r
argument_list|)
operator|=
name|reduce_template_parm_level
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|,
name|r
argument_list|,
name|levels
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|TEMPLATE_TYPE_DECL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|r
operator|=
name|reduce_template_parm_level
argument_list|(
name|t
argument_list|,
name|type
argument_list|,
name|levels
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
block|{
name|purpose
operator|=
name|tsubst
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|value
operator|=
name|tsubst
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
block|{
name|chain
operator|=
name|tsubst
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_PARMLIST
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|result
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|=
name|hash_tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
case|case
name|TREE_VEC
case|:
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* A binfo node.  We always need to make a copy, of the node 	     itself and of its BINFO_BASETYPES.  */
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Make sure type isn't a typedef copy.  */
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* Otherwise, a vector of template arguments.  */
return|return
name|tsubst_template_arg_vector
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* [temp.deduct] 	    	   Type deduction may fail for any of the following 	   reasons:    	   -- Attempting to create a pointer to reference type. 	   -- Attempting to create a reference to a reference type or 	      a reference to void.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|code
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
block|{
specifier|static
name|int
name|last_line
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|last_file
init|=
literal|0
decl_stmt|;
comment|/* We keep track of the last time we issued this error 	       message to avoid spewing a ton of messages during a 	       single bad template instantiation.  */
if|if
condition|(
name|complain
operator|&&
operator|(
name|last_line
operator|!=
name|lineno
operator|||
name|last_file
operator|!=
name|input_filename
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|error
argument_list|(
literal|"forming reference to void"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"forming %s to reference type `%T'"
argument_list|,
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|)
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|last_line
operator|=
name|lineno
expr_stmt|;
name|last_file
operator|=
name|input_filename
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|r
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|r
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|error_mark_node
condition|)
comment|/* Will this ever be needed for TYPE_..._TO values?  */
name|layout_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
block|{
name|r
operator|=
name|tsubst
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* [temp.deduct]  	       Type deduction may fail for any of the following 	       reasons: 	        	       -- Attempting to create "pointer to member of T" when T 	          is not a class type.  */
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"creating pointer to member of non-class type `%T'"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"creating pointer to member reference type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
argument_list|,
literal|20011231
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
comment|/* This is really a method type. The cv qualifiers of the 	     this pointer should _not_ be determined by the cv 	     qualifiers of the class type.  They should be held 	     somewhere in the FUNCTION_TYPE, but we don't do that at 	     the moment.  Consider 	        typedef void (Func) () const;  		template<typename T1> void Foo (Func T1::*);  	      */
return|return
name|build_cplus_method_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_offset_type
argument_list|(
name|r
argument_list|,
name|type
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|fntype
decl_stmt|;
name|tree
name|raises
decl_stmt|;
name|fntype
operator|=
name|tsubst_function_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Substitue the exception specification. */
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|raises
argument_list|)
condition|)
name|list
operator|=
name|raises
expr_stmt|;
else|else
for|for
control|(
init|;
name|raises
operator|!=
name|NULL_TREE
condition|;
name|raises
operator|=
name|TREE_CHAIN
argument_list|(
name|raises
argument_list|)
control|)
block|{
name|tree
name|spec
init|=
name|TREE_VALUE
argument_list|(
name|raises
argument_list|)
decl_stmt|;
name|spec
operator|=
name|tsubst
argument_list|(
name|spec
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|error_mark_node
condition|)
return|return
name|spec
return|;
name|list
operator|=
name|add_exception_specifier
argument_list|(
name|list
argument_list|,
name|spec
argument_list|,
name|complain
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|fntype
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|domain
init|=
name|tsubst
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* As an optimization, we avoid regenerating the array type if 	   it will obviously be the same as T.  */
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|domain
operator|==
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* These checks should match the ones in grokdeclarator.    	   [temp.deduct]  	 	   The deduction may fail for any of the following reasons:   	   -- Attempting to create an array with an element type that 	      is void, a function type, or a reference type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"creating array of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|r
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|NEGATE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
case|case
name|TYPENAME_TYPE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
decl_stmt|;
name|tree
name|f
init|=
name|tsubst_copy
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|error_mark_node
operator|||
name|f
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"`%T' is not a class, struct, or union type"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|ctx
argument_list|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* Normally, make_typename_type does not require that the CTX 	       have complete type in order to allow things like: 	      	         template<class T> struct S { typename S<T>::X Y; };  	       But, such constructs have already been resolved by this 	       point, so here CTX really should have complete type, unless 	       it's a partial instantiation.  */
name|ctx
operator|=
name|complete_type
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|f
operator|=
name|make_typename_type
argument_list|(
name|ctx
argument_list|,
name|f
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|error_mark_node
condition|)
return|return
name|f
return|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|f
argument_list|,
name|cp_type_quals
argument_list|(
name|f
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_unbound_class_template
argument_list|(
name|ctx
argument_list|,
name|name
argument_list|,
name|complain
argument_list|)
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_pointer_declarator
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_reference_declarator
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|tsubst_expr
argument_list|)
return|;
block|}
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
operator|(
name|tsubst_call_declarator_parms
argument_list|(
name|CALL_DECLARATOR_PARMS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
operator|)
decl_stmt|;
name|tree
name|e3
init|=
name|tsubst
argument_list|(
name|CALL_DECLARATOR_EXCEPTION_SPEC
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
operator|||
name|e3
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_call_declarator
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|CALL_DECLARATOR_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|e3
argument_list|)
return|;
block|}
case|case
name|SCOPE_REF
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_nt
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
return|;
block|}
case|case
name|TYPEOF_TYPE
case|:
block|{
name|tree
name|e1
init|=
name|tsubst_expr
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
return|;
block|}
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in template"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like tsubst, but deals with expressions.  This function just replaces    template parms; to finish processing the resultant expression, use    tsubst_expr.  */
end_comment

begin_function
name|tree
name|tsubst_copy
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARM_DECL
case|:
return|return
name|do_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
block|{
name|tree
name|enum_type
decl_stmt|;
name|tree
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
comment|/* This is a global enumeration constant.  */
return|return
name|t
return|;
comment|/* Unfortunately, we cannot just call lookup_name here. 	   Consider: 	    	     template<int I> int f() { 	     enum E { a = I }; 	     struct S { void g() { E e = a; } }; 	     }; 	    	   When we instantiate f<7>::S::g(), say, lookup_name is not 	   clever enough to find f<7>::a.  */
name|enum_type
operator|=
name|tsubst_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|TYPE_VALUES
argument_list|(
name|enum_type
argument_list|)
init|;
name|v
operator|!=
name|NULL_TREE
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
return|;
comment|/* We didn't find the name.  That should never happen; if 	     name-lookup found it during preliminary parsing, we 	     should find it again here during instantiation.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|lookup_field
argument_list|(
name|ctx
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|t
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|TEMPLATE_DECL
case|:
if|if
condition|(
name|is_member_template
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
else|else
return|return
name|t
return|;
case|case
name|LOOKUP_EXPR
case|:
block|{
comment|/* We must tsubst into a LOOKUP_EXPR in case the names to 	   which it refers is a conversion operator; in that case the 	   name will change.  We avoid making unnecessary copies, 	   however.  */
name|tree
name|id
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|!=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|r
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|NOP_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
comment|/* Unary + */
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|THROW_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|SCOPE_REF
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|MEMBER_REF
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|get_first_fn
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
comment|/* Sometimes FN is a LOOKUP_EXPR.  */
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|fn
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|METHOD_CALL_EXPR
case|:
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|base
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|STMT_EXPR
case|:
comment|/* This processing should really occur in tsubst_expr, However, 	 tsubst_expr does not recurse into expressions, since it 	 assumes that there aren't any statements inside them. 	 Instead, it simply calls build_expr_from_tree.  So, we need 	 to expand the STMT_EXPR here.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|stmt_expr
init|=
name|begin_stmt_expr
argument_list|()
decl_stmt|;
name|tsubst_expr
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|finish_stmt_expr
argument_list|(
name|stmt_expr
argument_list|)
return|;
block|}
return|return
name|t
return|;
case|case
name|COND_EXPR
case|:
case|case
name|MODOP_EXPR
case|:
case|case
name|PSEUDO_DTOR_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|NEW_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DELETE_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_VEC
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
comment|/* Substituted template arguments */
name|tree
name|targs
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|targs
operator|&&
name|TREE_CODE
argument_list|(
name|targs
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|targs
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targs
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup_template_function
argument_list|(
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|targs
argument_list|)
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst_copy
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst_copy
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst_copy
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
case|case
name|TYPEOF_TYPE
case|:
case|case
name|TYPE_DECL
case|:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
return|return
name|mangle_conv_op_name_for_type
argument_list|(
name|new_type
argument_list|)
return|;
block|}
else|else
return|return
name|t
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|r
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|tsubst_copy
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|VA_ARG_EXPR
case|:
return|return
name|build_x_va_arg
argument_list|(
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like tsubst_copy, but also does semantic processing.  */
end_comment

begin_function
name|tree
name|tsubst_expr
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|stmt
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
if|if
condition|(
operator|!
name|statement_code_p
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|build_expr_from_tree
argument_list|(
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RETURN_INIT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_named_return_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTOR_INITIALIZER
case|:
block|{
name|tree
name|member_init_list
decl_stmt|;
name|tree
name|base_init_list
decl_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|member_init_list
operator|=
name|tsubst_initializer_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|base_init_list
operator|=
name|tsubst_initializer_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|emit_base_init
argument_list|(
name|member_init_list
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RETURN_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_return_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|RETURN_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|do_using_directive
argument_list|(
name|tsubst_expr
argument_list|(
name|USING_STMT_NAMESPACE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_STMT
case|:
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|decl
operator|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|finish_label_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
name|tree
name|scope
init|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|scope
operator|=
name|tsubst_expr
argument_list|(
name|scope
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|do_local_using_decl
argument_list|(
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|tsubst_expr
argument_list|(
name|init
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
comment|/* Make sure the type is instantiated now. */
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* By marking the declaration as instantiated, we avoid 	           trying to instantiate it.  Since instantiate_decl can't 	           handle local variables, and since we've already done 	           all that needs to be done, that's the right thing to 	           do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|maybe_push_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A DECL_STMT can also be used as an expression, in the condition 	   clause of a if/for/while construct.  If we aren't followed by 	   another statement, return our decl.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|decl
return|;
block|}
break|break;
case|case
name|FOR_STMT
case|:
block|{
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_for_stmt
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|FOR_INIT_STMT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_init_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tsubst_expr
argument_list|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WHILE_STMT
case|:
block|{
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_while_stmt
argument_list|()
expr_stmt|;
name|finish_while_stmt_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|WHILE_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_while_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DO_STMT
case|:
block|{
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_do_stmt
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_do_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finish_do_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|DO_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_STMT
case|:
block|{
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
condition|)
block|{
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|=
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
condition|)
block|{
name|begin_else_clause
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_else_clause
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_STMT
case|:
block|{
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPOUND_STMT_BODY_BLOCK
argument_list|(
name|t
argument_list|)
condition|)
name|stmt
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
else|else
name|stmt
operator|=
name|begin_compound_stmt
argument_list|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPOUND_STMT_BODY_BLOCK
argument_list|(
name|t
argument_list|)
condition|)
name|finish_function_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
name|finish_compound_stmt
argument_list|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BREAK_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_break_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONTINUE_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_continue_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|SWITCH_STMT
case|:
block|{
name|tree
name|val
decl_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_switch_stmt
argument_list|()
expr_stmt|;
name|val
operator|=
name|tsubst_expr
argument_list|(
name|SWITCH_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_switch_cond
argument_list|(
name|val
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|SWITCH_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_switch_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CASE_LABEL
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_case_label
argument_list|(
name|tsubst_expr
argument_list|(
name|CASE_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_STMT
case|:
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_label_stmt
argument_list|(
name|DECL_NAME
argument_list|(
name|LABEL_STMT_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
comment|/* Computed goto's must be tsubst'd into.  On the other hand, 	   non-computed gotos must not be; the identifier in question 	   will have no binding.  */
name|tmp
operator|=
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|finish_goto_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_STMT
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_asm_stmt
argument_list|(
name|ASM_CV_QUAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_STRING
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_INPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_CLOBBERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_BLOCK
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLEANUP_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_cleanup_try_block
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finish_cleanup
argument_list|(
name|tsubst_expr
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|stmt
operator|=
name|begin_function_try_block
argument_list|()
expr_stmt|;
else|else
name|stmt
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|finish_function_try_block
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
name|finish_try_block
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|finish_function_handler_sequence
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
name|finish_handler_sequence
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HANDLER
case|:
block|{
name|tree
name|decl
decl_stmt|;
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_handler
argument_list|()
expr_stmt|;
if|if
condition|(
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|decl
operator|=
name|DECL_STMT_DECL
argument_list|(
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Prevent instantiate_decl from trying to instantiate 	       this variable.  We've already done all that needs to be 	       done.  */
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_handler_parms
argument_list|(
name|decl
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_handler
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_DEFN
case|:
name|prep_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTOR_STMT
case|:
name|add_stmt
argument_list|(
name|copy_node
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|tsubst_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Instantiate the indicated variable or function template TMPL with    the template arguments in TARG_PTR.  */
end_comment

begin_function
name|tree
name|instantiate_template
parameter_list|(
name|tmpl
parameter_list|,
name|targ_ptr
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
name|targ_ptr
decl_stmt|;
block|{
name|tree
name|fndecl
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|283
argument_list|)
expr_stmt|;
comment|/* If this function is a clone, handle it specially.  */
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|spec
init|=
name|instantiate_template
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|)
decl_stmt|;
name|tree
name|clone
decl_stmt|;
comment|/* Look for the clone. */
for|for
control|(
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
init|;
name|clone
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|clone
argument_list|)
condition|;
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|clone
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|clone
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|tmpl
argument_list|)
condition|)
return|return
name|clone
return|;
comment|/* We should always have found the clone by now.  */
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|!=
name|gen_tmpl
condition|)
block|{
comment|/* The TMPL is a partial instantiation.  To get a full set of 	 arguments we must add the arguments used to perform the 	 partial instantiation.  */
name|targ_ptr
operator|=
name|add_outermost_template_args
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
block|}
name|len
operator|=
name|DECL_NTPARMS
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|inner_args
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targ_ptr
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|nt
init|=
name|target_type
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|nt
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|nt
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type `%T' composed from a local class is not a valid template-argument"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  trying to instantiate `%D'"
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
comment|/* substitute template parameters */
name|fndecl
operator|=
name|tsubst
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
comment|/* The DECL_TI_TEMPLATE should always be the immediate parent      template, not the most general template.  */
name|DECL_TI_TEMPLATE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
if|if
condition|(
name|flag_external_templates
condition|)
name|add_pending_template
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* If we've just instantiated the main entry point for a function,      instantiate all the alternate entry points as well.  We do this      by cloning the instantiation of the main entry point, not by      instantiating the template clones.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|gen_tmpl
argument_list|)
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|TREE_CHAIN
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|)
condition|)
name|clone_function_decl
argument_list|(
name|fndecl
argument_list|,
comment|/*update_method_vec_p=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* The FN is a TEMPLATE_DECL for a function.  The ARGS are the    arguments that are being used when calling it.  TARGS is a vector    into which the deduced template arguments are placed.       Return zero for success, 2 for an incomplete match that doesn't resolve    all the types, and 1 for complete failure.  An error message will be    printed only for an incomplete match.     If FN is a conversion operator, or we are trying to produce a specific    specialization, RETURN_TYPE is the return type desired.     The EXPLICIT_TARGS are explicit template arguments provided via a    template-id.     The parameter STRICT is one of:     DEDUCE_CALL:       We are deducing arguments for a function call, as in      [temp.deduct.call].     DEDUCE_CONV:      We are deducing arguments for a conversion function, as in       [temp.deduct.conv].     DEDUCE_EXACT:      We are deducing arguments when doing an explicit instantiation      as in [temp.explicit], when determining an explicit specialization      as in [temp.expl.spec], or when taking the address of a function      template, as in [temp.deduct.funcaddr].      DEDUCE_ORDER:      We are deducing arguments when calculating the partial      ordering between specializations of function or class      templates, as in [temp.func.order] and [temp.class.order].     LEN is the number of parms to consider before returning success, or -1    for all.  This is used in partial ordering to avoid comparing parms for    which no actual argument was passed, since they are not considered in    overload resolution (and are explicitly excluded from consideration in    partial ordering in [temp.func.order]/6).  */
end_comment

begin_function
name|int
name|fn_type_unification
parameter_list|(
name|fn
parameter_list|,
name|explicit_targs
parameter_list|,
name|targs
parameter_list|,
name|args
parameter_list|,
name|return_type
parameter_list|,
name|strict
parameter_list|,
name|len
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|targs
decl_stmt|,
name|args
decl_stmt|,
name|return_type
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|int
name|result
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_targs
condition|)
block|{
comment|/* [temp.deduct] 	   	 The specified template arguments must match the template 	 parameters in kind (i.e., type, nontype, template), and there 	 must not be more arguments than there are parameters; 	 otherwise type deduction fails.  	 Nontype arguments must match the types of the corresponding 	 nontype template parameters, or must be convertible to the 	 types of the corresponding nontype parameters as specified in 	 _temp.arg.nontype_, otherwise type deduction fails.  	 All references in the function type of the function template 	 to the corresponding template parameters are replaced by the 	 specified template argument values.  If a substitution in a 	 template parameter or in the function type of the function 	 template results in an invalid type, type deduction fails.  */
name|int
name|i
decl_stmt|;
name|tree
name|converted_args
decl_stmt|;
name|converted_args
operator|=
operator|(
name|coerce_template_parms
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_targs
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
comment|/*require_all_arguments=*/
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|converted_args
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
name|fntype
operator|=
name|tsubst
argument_list|(
name|fntype
argument_list|,
name|converted_args
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Place the explicitly specified arguments in TARGS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|converted_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Never do unification on the 'this' parameter.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
condition|)
block|{
comment|/* We've been given a return type to match, prepend it.  */
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
operator|++
name|len
expr_stmt|;
block|}
comment|/* We allow incomplete unification without an error message here      because the standard doesn't seem to explicitly prohibit it.  Our      callers must be ready to deal with unification failures in any      event.  */
name|result
operator|=
name|type_unification_real
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
name|parms
argument_list|,
name|args
argument_list|,
comment|/*subr=*/
literal|0
argument_list|,
name|strict
argument_list|,
comment|/*allow_incomplete*/
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
comment|/* All is well so far.  Now, check:                [temp.deduct]                 When all template arguments have been deduced, all uses of        template parameters in nondeduced contexts are replaced with        the corresponding deduced argument values.  If the        substitution results in an invalid type, as described above,        type deduction fails.  */
if|if
condition|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Adjust types before performing type deduction, as described in    [temp.deduct.call] and [temp.deduct.conv].  The rules in these two    sections are symmetric.  PARM is the type of a function parameter    or the return type of the conversion function.  ARG is the type of    the argument passed to the call, or the type of the value    initialized with the result of the conversion function.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_adjust_types_for_deduction
parameter_list|(
name|strict
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|unification_kind_t
name|strict
decl_stmt|;
name|tree
modifier|*
name|parm
decl_stmt|;
name|tree
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
break|break;
case|case
name|DEDUCE_CONV
case|:
block|{
comment|/* Swap PARM and ARG throughout the remainder of this 	   function; the handling is precisely symmetric since PARM 	   will initialize ARG rather than vice versa.  */
name|tree
modifier|*
name|temp
init|=
name|parm
decl_stmt|;
name|parm
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
block|}
case|case
name|DEDUCE_EXACT
case|:
comment|/* There is nothing to do in this case.  */
return|return
literal|0
return|;
case|case
name|DEDUCE_ORDER
case|:
comment|/* DR 214. [temp.func.order] is underspecified, and leads to no          ordering between things like `T *' and `T const&' for `U *'.          The former has T=U and the latter T=U*. The former looks more          specialized and John Spicer considers it well-formed (the EDG          compiler accepts it).           John also confirms that deduction should proceed as in a function          call. Which implies the usual ARG and PARM conversions as DEDUCE_CALL.          However, in ordering, ARG can have REFERENCE_TYPE, but no argument          to an actual call can have such a type.                    If both ARG and PARM are REFERENCE_TYPE, we change neither.          If only ARG is a REFERENCE_TYPE, we look through that and then          proceed as with DEDUCE_CALL (which could further convert it).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
literal|0
return|;
operator|*
name|arg
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [temp.deduct.call] 	  	 If P is not a reference type: 	  	 --If A is an array type, the pointer type produced by the 	 array-to-pointer standard conversion (_conv.array_) is 	 used in place of A for type deduction; otherwise, 	  	 --If A is a function type, the pointer type produced by 	 the function-to-pointer standard conversion 	 (_conv.func_) is used in place of A for type deduction; 	 otherwise, 	  	 --If A is a cv-qualified type, the top level 	 cv-qualifiers of A's type are ignored for type 	 deduction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
else|else
operator|*
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.deduct.call]            If P is a cv-qualified type, the top level cv-qualifiers      of P's type are ignored for type deduction.  If P is a      reference type, the type referred to by P is used for      type deduction.  */
operator|*
name|parm
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
operator|*
name|parm
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
name|result
operator||=
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Most parms like fn_type_unification.     If SUBR is 1, we're being called recursively (to unify the    arguments of a function or method parameter of a function    template).  */
end_comment

begin_function
specifier|static
name|int
name|type_unification_real
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|xparms
parameter_list|,
name|xargs
parameter_list|,
name|subr
parameter_list|,
name|strict
parameter_list|,
name|allow_incomplete
parameter_list|,
name|xlen
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|xparms
decl_stmt|,
name|xargs
decl_stmt|;
name|int
name|subr
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|allow_incomplete
decl_stmt|,
name|xlen
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
name|int
name|saw_undeduced
init|=
literal|0
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|289
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|xparms
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|xparms
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|290
argument_list|)
expr_stmt|;
comment|/* ARGS could be NULL (via a call from parse.y to      build_x_function_call).  */
if|if
condition|(
name|xargs
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|xargs
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|291
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|ntparms
operator|>
literal|0
argument_list|,
literal|292
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
name|sub_strict
operator|=
operator|(
name|UNIFY_ALLOW_OUTER_LEVEL
operator||
name|UNIFY_ALLOW_MORE_CV_QUAL
operator||
name|UNIFY_ALLOW_DERIVED
operator|)
expr_stmt|;
break|break;
case|case
name|DEDUCE_CONV
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_LESS_CV_QUAL
expr_stmt|;
break|break;
case|case
name|DEDUCE_EXACT
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_NONE
expr_stmt|;
break|break;
case|case
name|DEDUCE_ORDER
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_NONE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|xlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|again
label|:
name|parms
operator|=
name|xparms
expr_stmt|;
name|args
operator|=
name|xargs
expr_stmt|;
name|len
operator|=
name|xlen
expr_stmt|;
while|while
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
comment|/* We can't deduce anything from this, but we might get all the 	   template args from other function args.  */
continue|continue;
comment|/* Conversions will be performed on a function argument that 	 corresponds with a function parameter that contains only 	 non-deducible template parameters and explicitly specified 	 template parameters.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|strict
operator|==
name|DEDUCE_EXACT
operator|||
name|strict
operator|==
name|DEDUCE_ORDER
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|parm
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
block|}
else|else
comment|/* It might work; we shouldn't check now, because we might 	       get into infinite recursion.  Overload resolution will 	       handle it.  */
continue|continue;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|293
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* [temp.deduct.type] A template-argument can be deduced from 		 a pointer to function or pointer to member function 		 argument if the set of overloaded functions does not 		 contain function templates and at most one of a set of 		 overloaded functions provides a unique match.  */
if|if
condition|(
name|resolve_overloaded_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|arg_strict
init|=
name|sub_strict
decl_stmt|;
if|if
condition|(
operator|!
name|subr
condition|)
name|arg_strict
operator||=
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|arg_strict
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Are we done with the interesting parms?  */
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Fail if we've reached the end of the parm list, and more args      are present, and the parm list isn't variadic.  */
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|1
return|;
comment|/* Fail if parms are left and they don't have default values.	 */
if|if
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
name|done
label|:
if|if
condition|(
operator|!
name|subr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tparm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is an undeduced nontype parameter that depends on 	     a type parameter, try another pass; its type may have been 	     deduced from a later argument than the one from which 	     this parameter can be deduced.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|tparm
argument_list|)
argument_list|)
operator|&&
operator|!
name|saw_undeduced
operator|++
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
operator|!
name|allow_incomplete
condition|)
name|error
argument_list|(
literal|"incomplete type unification"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of type_unification_real.  Args are like the variables at the    call site.  ARG is an overloaded function (or template-id); we try    deducing template args from each of the overloads, and if only one    succeeds, we go with that.  Modifies TARGS and returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|resolve_overloaded_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|,
name|sub_strict
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
block|{
name|tree
name|tempargs
init|=
name|copy_node
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|good
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
comment|/* Handle `&x' where `x' is some static or non-static member        function name.  */
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Strip baselink information.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* If we got some explicit template args, we need to plug them into 	 the affected templates before we try to unify, in case the 	 explicit args will completely resolve the templates in question.  */
name|tree
name|expl_subargs
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|OVL_NEXT
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|subargs
decl_stmt|,
name|elem
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
continue|continue;
name|subargs
operator|=
name|get_bindings_overload
argument_list|(
name|fn
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|expl_subargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|subargs
condition|)
block|{
name|elem
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|subargs
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|elem
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|good
operator|+=
name|try_one_overload
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|elem
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|OVL_NEXT
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|good
operator|+=
name|try_one_overload
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|type
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* [temp.deduct.type] A template-argument can be deduced from a pointer      to function or pointer to member function argument if the set of      overloaded functions does not contain function templates and at most      one of a set of overloaded functions provides a unique match.       So if we found multiple possibilities, we return success but don't      deduce anything.  */
if|if
condition|(
name|good
operator|==
literal|1
condition|)
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|good
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of resolve_overloaded_unification; does deduction for a single    overload.  Fills TARGS with any deduced arguments, or error_mark_node if    different overloads deduce different arguments for a given parm.    Returns 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|try_one_overload
parameter_list|(
name|tparms
parameter_list|,
name|orig_targs
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|,
name|sub_strict
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|orig_targs
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|tree
name|tempargs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* [temp.deduct.type] A template-argument can be deduced from a pointer      to function or pointer to member function argument if the set of      overloaded functions does not contain function templates and at most      one of a set of overloaded functions provides a unique match.       So if this is a template, just return success.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
name|sub_strict
operator||=
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* We don't copy orig_targs for this because if we have already deduced      some template args from previous args, unify would complain when we      try to deduce a template parameter for the same argument, even though      there isn't really a conflict.  */
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|tempargs
operator|=
name|make_tree_vec
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|sub_strict
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* First make sure we didn't deduce anything that conflicts with      explicitly specified args.  */
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|oldelt
init|=
name|TREE_VEC_ELT
argument_list|(
name|orig_targs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|==
name|NULL_TREE
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* Since we're unifying against ourselves, we will fill in template 	     args used in the function parm list with our own template parms. 	     Discard them.  */
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|oldelt
operator|&&
operator|!
name|template_args_equal
argument_list|(
name|oldelt
argument_list|,
name|elt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|elt
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Verify that nondeduce template argument agrees with the type    obtained from argument deduction.  Return nonzero if the    verification fails.     For example:       struct A { typedef int X; };      template<class T, class U> struct C {};      template<class T> struct C<T, typename T::X> {};     Then with the instantiation `C<A, int>', we can deduce that    `T' is `A' but unify () does not check whether `typename T::X'    is `int'.  This function ensure that they agree.     TARGS, PARMS are the same as the arguments of unify.    ARGS contains template arguments from all levels.  */
end_comment

begin_function
specifier|static
name|int
name|verify_class_unification
parameter_list|(
name|targs
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|)
name|tree
name|targs
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|nparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|tree
name|new_parms
init|=
name|tsubst
argument_list|(
name|parms
argument_list|,
name|add_outermost_template_args
argument_list|(
name|args
argument_list|,
name|targs
argument_list|)
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_parms
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
name|args
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|new_parms
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* In case we are deducing from a function argument of a function 	 templates, some parameters may not be deduced yet.  So we 	 make sure that only fully substituted elements of PARM are 	 compared below.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|template_args_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PARM is a template class (perhaps with unbound template    parameters).  ARG is a fully instantiated type.  If ARG can be    bound to PARM, return ARG, otherwise return NULL_TREE.  TPARMS and    TARGS are as for unify.  */
end_comment

begin_function
specifier|static
name|tree
name|try_class_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|copy_of_targs
decl_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|||
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
operator|!=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We need to make a new template argument vector for the call to      unify.  If we used TARGS, we'd clutter it up with the result of      the attempted unification, even if this class didn't work out.      We also don't want to commit ourselves to all the unifications      we've already done, since unification is supposed to be done on      an argument-by-argument basis.  In other words, consider the      following pathological case:         template<int I, int J, int K>        struct S {};                template<int I, int J>        struct S<I, J, 2> : public S<I, I, I>, S<J, J, J> {};                template<int I, int J, int K>        void f(S<I, J, K>, S<I, I, I>);                void g() {          S<0, 0, 0> s0;          S<0, 1, 2> s2;                  f(s0, s2);        }       Now, by the time we consider the unification involving `s2', we      already know that we must have `f<0, 0, 0>'.  But, even though      `S<0, 1, 2>' is derived from `S<0, 0, 0>', the code is not legal      because there are two ways to unify base classes of S<0, 1, 2>      with S<I, I, I>.  If we kept the already deduced knowledge, we      would reject the possibility I=1.  */
name|copy_of_targs
operator|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If unification failed, we're done.  */
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|copy_of_targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of get_template_base.  RVAL, if non-NULL, is a base we    have already discovered to be satisfactory.  ARG_BINFO is the binfo    for the base class of ARG that we are currently examining.  */
end_comment

begin_function
specifier|static
name|tree
name|get_template_base_recursive
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg_binfo
parameter_list|,
name|rval
parameter_list|,
name|flags
parameter_list|)
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|arg_binfo
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|tree
name|arg
init|=
name|BINFO_TYPE
argument_list|(
name|arg_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|GTB_IGNORE_TYPE
operator|)
condition|)
block|{
name|tree
name|r
init|=
name|try_class_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
decl_stmt|;
comment|/* If there is more than one satisfactory baseclass, then:  	   [temp.deduct.call]  	   If they yield more than one possible deduced A, the type 	   deduction fails.  	   applies.  */
if|if
condition|(
name|r
operator|&&
name|rval
operator|&&
operator|!
name|same_type_p
argument_list|(
name|r
argument_list|,
name|rval
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|r
condition|)
name|rval
operator|=
name|r
expr_stmt|;
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|arg_binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|this_virtual
decl_stmt|;
comment|/* Skip this base, if we've already seen it.  */
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|this_virtual
operator|=
operator|(
name|flags
operator|&
name|GTB_VIA_VIRTUAL
operator|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* When searching for a non-virtual, we cannot mark virtually 	 found binfos.  */
if|if
condition|(
operator|!
name|this_virtual
condition|)
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_template_base_recursive
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|base_binfo
argument_list|,
name|rval
argument_list|,
name|GTB_VIA_VIRTUAL
operator|*
name|this_virtual
argument_list|)
expr_stmt|;
comment|/* If we discovered more than one matching base class, we can 	 stop now.  */
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Given a template type PARM and a class type ARG, find the unique    base type in ARG that is an instance of PARM.  We do not examine    ARG itself; only its base-classes.  If there is no appropriate base    class, return NULL_TREE.  If there is more than one, return    error_mark_node.  PARM may be the type of a partial specialization,    as well as a plain template type.  Used by unify.  */
end_comment

begin_function
specifier|static
name|tree
name|get_template_base
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|arg_binfo
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|92
argument_list|)
expr_stmt|;
name|arg_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|complete_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_template_base_recursive
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg_binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|GTB_IGNORE_TYPE
argument_list|)
expr_stmt|;
comment|/* Since get_template_base_recursive marks the bases classes, we      must unmark them here.  */
name|dfs_walk
argument_list|(
name|arg_binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Returns the level of DECL, which declares a template parameter.  */
end_comment

begin_function
specifier|static
name|int
name|template_decl_level
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
return|return
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
case|case
name|PARM_DECL
case|:
return|return
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Decide whether ARG can be unified with PARM, considering only the    cv-qualifiers of each type, given STRICT as documented for unify.    Returns non-zero iff the unification is OK on that basis.*/
end_comment

begin_function
specifier|static
name|int
name|check_cv_quals_for_unify
parameter_list|(
name|strict
parameter_list|,
name|arg
parameter_list|,
name|parm
parameter_list|)
name|int
name|strict
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|strict
operator|&
operator|(
name|UNIFY_ALLOW_MORE_CV_QUAL
operator||
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
operator|)
operator|)
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|strict
operator|&
operator|(
name|UNIFY_ALLOW_LESS_CV_QUAL
operator||
name|UNIFY_ALLOW_OUTER_LESS_CV_QUAL
operator|)
operator|)
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Takes parameters as for type_unification.  Returns 0 if the    type deduction succeeds, 1 otherwise.  The parameter STRICT is a    bitwise or of the following flags:       UNIFY_ALLOW_NONE:        Require an exact match between PARM and ARG.      UNIFY_ALLOW_MORE_CV_QUAL:        Allow the deduced ARG to be more cv-qualified (by qualification        conversion) than ARG.      UNIFY_ALLOW_LESS_CV_QUAL:        Allow the deduced ARG to be less cv-qualified than ARG.      UNIFY_ALLOW_DERIVED:        Allow the deduced ARG to be a template base class of ARG,        or a pointer to a template base class of the type pointed to by        ARG.      UNIFY_ALLOW_INTEGER:        Allow any integral type to be deduced.  See the TEMPLATE_PARM_INDEX        case for more information.       UNIFY_ALLOW_OUTER_LEVEL:        This is the outermost level of a deduction. Used to determine validity        of qualification conversions. A valid qualification conversion must        have const qualified pointers leading up to the inner type which        requires additional CV quals, except at the outer level, where const        is not required [conv.qual]. It would be normal to set this flag in        addition to setting UNIFY_ALLOW_MORE_CV_QUAL.      UNIFY_ALLOW_OUTER_MORE_CV_QUAL:        This is the outermost level of a deduction, and PARM can be more CV        qualified at this point.      UNIFY_ALLOW_OUTER_LESS_CV_QUAL:        This is the outermost level of a deduction, and PARM can be less CV        qualified at this point.      UNIFY_ALLOW_MAX_CORRECTION:        This is an INTEGER_TYPE's maximum value.  Used if the range may        have been derived from a size specification, such as an array size.        If the size was given by a nontype template parameter N, the maximum        value will have the form N-1.  The flag says that we can (and indeed        must) unify N with (ARG + 1), an exception to the normal rules on        folding PARM.  */
end_comment

begin_function
specifier|static
name|int
name|unify
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
name|tree
name|targ
decl_stmt|;
name|tree
name|tparm
decl_stmt|;
name|int
name|strict_in
init|=
name|strict
decl_stmt|;
comment|/* I don't think this will do the right thing with respect to types.      But the only case I've seen it in so far has been array bounds, where      signedness is the only information lost, and I think that will be      okay.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|parm
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
comment|/* We can't deduce anything from this, but we might get all the        template args from other function args.  */
return|return
literal|0
return|;
comment|/* If PARM uses template parameters, then we can't bail out here,      even if ARG == PARM, since we won't record unifications for the      template parameters.  We might need them if we're trying to      figure out which of two things is more specialized.  */
if|if
condition|(
name|arg
operator|==
name|parm
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Immediately reject some pairs that won't unify because of      cv-qualification mismatches.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|arg
argument_list|)
comment|/* It is the elements of the array which hold the cv quals of an array          type, and the elements might be template type parms. We'll check          when we recurse.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
comment|/* We check the cv-qualifiers when unifying with template type 	 parameters below.  We want to allow ARG `const T' to unify with 	 PARM `T' for example, when computing which of two templates 	 is more specialized, for example.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict_in
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_OUTER_LEVEL
operator|)
operator|&&
name|TYPE_P
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|CP_TYPE_CONST_P
argument_list|(
name|parm
argument_list|)
condition|)
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_MORE_CV_QUAL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_OUTER_LEVEL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_DERIVED
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_OUTER_LESS_CV_QUAL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_MAX_CORRECTION
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPENAME_TYPE
case|:
case|case
name|SCOPE_REF
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
comment|/* In a type which contains a nested-name-specifier, template 	 argument values cannot be deduced for template parameters used 	 within the nested-name-specifier.  */
return|return
literal|0
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mixed types and values.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
comment|/* ARG must be constructed from a template class or a template 	     template parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|{
name|tree
name|parmtmpl
init|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|parmvec
init|=
name|TYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|TYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|argtmplvec
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The parameter and argument roles have to be switched here  	       in order to handle default arguments properly.  For example,  	       template<template<class> class TT> void f(TT<int>)  	       should be able to accept vector<int> which comes from  	       template<class T, class Allocator = allocator>  	       class vector.  */
if|if
condition|(
name|coerce_template_parms
argument_list|(
name|argtmplvec
argument_list|,
name|parmvec
argument_list|,
name|parmtmpl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Deduce arguments T, i from TT<T> or TT<i>.   	       We check each element of PARMVEC and ARGVEC individually 	       rather than the whole TREE_VEC since they can have 	       different number of elements.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parmvec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|argvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
name|arg
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Fall through to deduce template name.  */
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
comment|/* Deduce template name TT from TT, TT<>, TT<T> and TT<i>.  */
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targ
operator|!=
name|NULL_TREE
operator|&&
name|template_args_equal
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targ
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* If PARM is `const T' and ARG is only `int', we don't have 	     a match unless we are allowing additional qualification. 	     If ARG is `const int' and PARM is just `T' that's OK; 	     that binds `const int' to `T'.  */
if|if
condition|(
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict_in
operator||
name|UNIFY_ALLOW_LESS_CV_QUAL
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Consider the case where ARG is `const volatile int' and 	     PARM is `const T'.  Then, T should be `volatile int'.  */
name|arg
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|arg
argument_list|,
name|cp_type_quals
argument_list|(
name|arg
argument_list|)
operator|&
operator|~
name|cp_type_quals
argument_list|(
name|parm
argument_list|)
argument_list|,
comment|/*complain=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targ
operator|!=
name|NULL_TREE
operator|&&
name|same_type_p
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targ
condition|)
return|return
literal|1
return|;
block|}
comment|/* Make sure that ARG is not a variable-sized array.  (Note that 	 were talking about variable-sized arrays (like `int[n]'), 	 rather than arrays of unknown size (like `int[]').)  We'll 	 get very confused by such a type since the bound of the array 	 will not be computable in an instantiation.  Besides, such 	 types are not allowed in ISO C++, so we can do as we please 	 here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
return|return
literal|1
return|;
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
condition|)
block|{
name|int
name|i
init|=
operator|(
name|cp_tree_equal
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* [temp.deduct.type] If, in the declaration of a function template 	 with a non-type template-parameter, the non-type 	 template-parameter is used in an expression in the function 	 parameter-list and, if the corresponding template-argument is 	 deduced, the template-argument type shall match the type of the 	 template-parameter exactly, except that a template-argument 	 deduced from an array bound may be of any integral type.  	 The non-type parameter might use already deduced type parameters.  */
name|tparm
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|targs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|tparm
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_INTEGER
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* We haven't deduced the type of this parameter yet.  Try again 	   later.  */
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|POINTER_TYPE
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
comment|/* [temp.deduct.call]  	   A can be another pointer or pointer to member type that can 	   be converted to the deduced A via a qualification 	   conversion (_conv.qual_).  	   We pass down STRICT here rather than UNIFY_ALLOW_NONE. 	   This will allow for additional cv-qualification of the 	   pointed-to types if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
comment|/* The derived-to-base conversion only persists through one 	     level of pointers.  */
name|strict
operator||=
operator|(
name|strict_in
operator|&
name|UNIFY_ALLOW_DERIVED
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Avoid getting confused about cv-quals; don't recurse here. 	       Pointers to members should really be just OFFSET_TYPE, not 	       this two-level nonsense... */
name|parm
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|offset
goto|;
block|}
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
block|}
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
operator|&
name|UNIFY_ALLOW_MORE_CV_QUAL
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|!=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_INTEGER
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_INTEGER
operator||
name|UNIFY_ALLOW_MAX_CORRECTION
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* We have already checked cv-qualification at the top of the 	 function.  */
elseif|else
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* As far as unification is concerned, this wins.	 Later checks 	 will invalidate it if necessary.  */
return|return
literal|0
return|;
comment|/* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */
comment|/* Type INTEGER_CST can come from ordinary constant template args.  */
case|case
name|INTEGER_CST
case|:
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|tree_int_cst_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_VEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parm
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
block|}
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|strict_in
operator|&
name|UNIFY_ALLOW_DERIVED
condition|)
block|{
comment|/* First, we try to unify the PARM and ARG directly.  */
name|t
operator|=
name|try_class_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* Fallback to the special case allowed in 		     [temp.deduct.call]: 		      		       If P is a class, and P has the form 		       template-id, then A can be a derived class of 		       the deduced A.  Likewise, if P is a pointer to 		       a class of the form template-id, A can be a 		       pointer to a derived class pointed to by the 		       deduced A.  */
name|t
operator|=
name|get_template_base
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
operator|==
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
comment|/* Perhaps PARM is something like S<U> and ARG is S<int>. 	       Then, we should unify `int' and `U'.  */
name|t
operator|=
name|arg
expr_stmt|;
else|else
comment|/* There's no chance of unification succeeding.  */
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|type_unification_real
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|DEDUCE_EXACT
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
name|offset
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|arg
operator|!=
name|decl_constant_value
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_DECL
case|:
comment|/* Matched cases are handled by the ARG == PARM test above.  */
return|return
literal|1
return|;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
operator|&&
operator|(
name|strict_in
operator|&
name|UNIFY_ALLOW_MAX_CORRECTION
operator|)
condition|)
block|{
comment|/* We handle this case specially, since it comes up with 	     arrays.  In particular, something like:  	     template<int N> void f(int (&x)[N]);  	     Here, we are trying to unify the range type, which 	     looks like [0 ... (N - 1)].  */
name|tree
name|t
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t1
argument_list|,
name|t
argument_list|,
name|strict
argument_list|)
return|;
block|}
comment|/* else fall through */
default|default:
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We're looking at an expression.  This can happen with 	     something like:  	    	       template<int I> 	       void foo(S<I>, S<I + 2>);  	     This is a "nondeduced context":  	       [deduct.type] 	    	       The nondeduced contexts are:  	       --A type that is a template-id in which one or more of 	         the template-arguments is an expression that references 	         a template-parameter.    	     In these cases, we assume deduction succeeded, but don't 	     actually infer any unifications.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|template_args_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
name|sorry
argument_list|(
literal|"use of `%s' in template type unification"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called if RESULT is explicitly instantiated, or is a member of an    explicitly instantiated class, or if using -frepo and the    instantiation of RESULT has been assigned to this file.  */
end_comment

begin_function
name|void
name|mark_decl_instantiated
parameter_list|(
name|result
parameter_list|,
name|extern_p
parameter_list|)
name|tree
name|result
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* The TREE_PUBLIC flag for function declarations will have been        set correctly by tsubst.  */
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We used to set this unconditionally; we moved that to      do_decl_instantiation so it wouldn't get set on members of      explicit class template instantiations.  But we still need to set      it here for the 'extern template' case in order to suppress      implicit instantiations.  */
if|if
condition|(
name|extern_p
condition|)
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Always make artificials weak.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|result
argument_list|)
operator|&&
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* For WIN32 we also want to put explicit instantiations in 	 linkonce sections.  */
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
condition|)
name|maybe_make_one_only
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|defer_fn
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given two function templates PAT1 and PAT2, return:     DEDUCE should be DEDUCE_EXACT or DEDUCE_ORDER.        1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.     LEN is passed through to fn_type_unification.  */
end_comment

begin_function
name|int
name|more_specialized
parameter_list|(
name|pat1
parameter_list|,
name|pat2
parameter_list|,
name|deduce
parameter_list|,
name|len
parameter_list|)
name|tree
name|pat1
decl_stmt|,
name|pat2
decl_stmt|;
name|int
name|deduce
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|tree
name|targs
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|targs
operator|=
name|get_bindings_real
argument_list|(
name|pat1
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|deduce
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|--
name|winner
expr_stmt|;
name|targs
operator|=
name|get_bindings_real
argument_list|(
name|pat2
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|deduce
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|++
name|winner
expr_stmt|;
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Given two class template specialization list nodes PAT1 and PAT2, return:     1 if PAT1 is more specialized than PAT2 as described in [temp.class.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.  */
end_comment

begin_function
name|int
name|more_specialized_class
parameter_list|(
name|pat1
parameter_list|,
name|pat2
parameter_list|)
name|tree
name|pat1
decl_stmt|,
name|pat2
decl_stmt|;
block|{
name|tree
name|targs
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|--
name|winner
expr_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|++
name|winner
expr_stmt|;
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Return the template arguments that will produce the function signature    DECL from the function template FN, with the explicit template    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must    also match.  Return NULL_TREE if no satisfactory arguments could be    found.  DEDUCE and LEN are passed through to fn_type_unification.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings_real
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|,
name|check_rettype
parameter_list|,
name|deduce
parameter_list|,
name|len
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
name|int
name|check_rettype
decl_stmt|,
name|deduce
decl_stmt|,
name|len
decl_stmt|;
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_tree_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
name|tree
name|decl_arg_types
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Substitute the explicit template arguments into the type of DECL.      The call to fn_type_unification will handle substitution into the      FN.  */
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_args
operator|&&
name|uses_template_parms
argument_list|(
name|decl_type
argument_list|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|converted_args
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* We can get here for some illegal specializations.  */
return|return
name|NULL_TREE
return|;
name|converted_args
operator|=
operator|(
name|coerce_template_parms
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|explicit_args
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
comment|/*require_all_arguments=*/
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|converted_args
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|decl_type
operator|=
name|tsubst
argument_list|(
name|decl_type
argument_list|,
name|converted_args
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
block|}
name|decl_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|decl_type
argument_list|)
expr_stmt|;
comment|/* Never do unification on the 'this' parameter.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_arg_types
argument_list|)
expr_stmt|;
name|i
operator|=
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_args
argument_list|,
name|targs
argument_list|,
name|decl_arg_types
argument_list|,
operator|(
name|check_rettype
operator|||
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|decl_type
argument_list|)
else|:
name|NULL_TREE
operator|)
argument_list|,
name|deduce
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|targs
return|;
block|}
end_function

begin_comment
comment|/* For most uses, we want to check the return type.  */
end_comment

begin_function
name|tree
name|get_bindings
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
return|return
name|get_bindings_real
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|,
literal|1
argument_list|,
name|DEDUCE_EXACT
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* But for resolve_overloaded_unification, we only care about the parameter    types.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings_overload
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
return|return
name|get_bindings_real
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|,
literal|0
argument_list|,
name|DEDUCE_EXACT
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost template arguments that, when applied to a    template specialization whose innermost template parameters are    TPARMS, and whose specialization arguments are PARMS, yield the    ARGS.       For example, suppose we have:       template<class T, class U> struct S {};      template<class T> struct S<T*, int> {};     Then, suppose we want to get `S<double*, int>'.  The TPARMS will be    {T}, the PARMS will be {T*, int} and the ARGS will be {double*,    int}.  The resulting vector will be {double}, indicating that `T'    is bound to `double'.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_bindings
parameter_list|(
name|tparms
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|tree
name|vec
init|=
name|make_tree_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|vec
argument_list|,
name|parms
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|verify_class_unification
argument_list|(
name|vec
argument_list|,
name|parms
argument_list|,
name|args
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* In INSTANTIATIONS is a list of<INSTANTIATION, TEMPLATE> pairs.    Pick the most specialized template, and return the corresponding    instantiation, or if there is no corresponding instantiation, the    template itself.  If there is no most specialized template,    error_mark_node is returned.  If there are no templates at all,    NULL_TREE is returned.  */
end_comment

begin_function
name|tree
name|most_specialized_instantiation
parameter_list|(
name|instantiations
parameter_list|)
name|tree
name|instantiations
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|,
name|champ
decl_stmt|;
name|int
name|fate
decl_stmt|;
if|if
condition|(
operator|!
name|instantiations
condition|)
return|return
name|NULL_TREE
return|;
name|champ
operator|=
name|instantiations
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|instantiations
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DEDUCE_EXACT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
block|}
name|champ
operator|=
name|fn
expr_stmt|;
block|}
block|}
for|for
control|(
name|fn
operator|=
name|instantiations
init|;
name|fn
operator|&&
name|fn
operator|!=
name|champ
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DEDUCE_EXACT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|TREE_PURPOSE
argument_list|(
name|champ
argument_list|)
condition|?
name|TREE_PURPOSE
argument_list|(
name|champ
argument_list|)
else|:
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the list of templates in FNS that can    produce an instantiation matching DECL, given the explicit template    arguments EXPLICIT_ARGS.  */
end_comment

begin_function
specifier|static
name|tree
name|most_specialized
parameter_list|(
name|fns
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fns
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
name|tree
name|candidates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|candidate
init|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|args
operator|=
name|get_bindings
argument_list|(
name|candidate
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|candidate
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|most_specialized_instantiation
argument_list|(
name|candidates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a specialization of some template, return the most    general such template.  Otherwise, returns NULL_TREE.     For example, given:       template<class T> struct S { template<class U> void f(U); };     if TMPL is `template<class U> void S<int>::f(U)' this will return    the full template.  This function will not trace past partial    specializations, however.  For example, given in addition:       template<class T> struct S<T*> { template<class U> void f(U); };     if TMPL is `template<class U> void S<int*>::f(U)' this will return    `template<class T> template<class U> S<T*>::f(U)'.  */
end_comment

begin_function
name|tree
name|most_general_template
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* If DECL is a FUNCTION_DECL, find the TEMPLATE_DECL of which it is      an immediate specialization.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The DECL_TI_TEMPLATE can be an IDENTIFIER_NODE for a 	   template friend.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
comment|/* Look for more and more general templates.  */
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The DECL_TI_TEMPLATE can be a LOOKUP_EXPR or IDENTIFIER_NODE 	 in some cases.  (See cp-tree.h for details.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
break|break;
comment|/* Stop if we run into an explicitly specialized class template.  */
if|if
condition|(
operator|!
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
break|break;
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the class template specializations    of TMPL which can produce an instantiation matching ARGS, or    error_mark_node if the choice is ambiguous.  */
end_comment

begin_function
specifier|static
name|tree
name|most_specialized_class
parameter_list|(
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|champ
decl_stmt|;
name|int
name|fate
decl_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|spec_args
init|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec_args
condition|)
block|{
name|list
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|list
expr_stmt|;
name|champ
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|error_mark_node
return|;
block|}
name|champ
operator|=
name|t
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
operator|&&
name|t
operator|!=
name|champ
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* called from the parser.  */
end_comment

begin_function
name|void
name|do_decl_instantiation
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|storage
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
comment|/* An error occurred, for which grokdeclarator has already issued        an appropriate message.  */
return|return;
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of non-template `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* There is an asymmetry here in the way VAR_DECLs and 	 FUNCTION_DECLs are handled by grokdeclarator.  In the case of 	 the latter, the DECL we get back will be marked as a 	 template instantiation, and the appropriate 	 DECL_TEMPLATE_INFO will be set up.  This does not happen for 	 VAR_DECLs so we do the lookup here.  Probably, grokdeclarator 	 should handle VAR_DECLs as it currently handles 	 FUNCTION_DECLs.  */
name|result
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|error
argument_list|(
literal|"no matching template for `%D' found"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|result
operator|=
name|decl
expr_stmt|;
comment|/* Check for various error cases.  Note that if the explicit      instantiation is legal the RESULT will currently be marked as an      *implicit* instantiation; DECL_EXPLICIT_INSTANTIATION is not set      until we get here.  */
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall both explicitly instantiate and explicitly 	 specialize a template.  */
name|pedwarn
argument_list|(
literal|"explicit instantiation of `%#D' after"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"explicit specialization here"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall explicitly instantiate any template more 	 than once.    	 We check DECL_INTERFACE_KNOWN so as not to complain when the first 	 instantiation was `extern' and the second is not, and EXTERN_P for 	 the opposite case.  If -frepo, chances are we already got marked 	 as an explicit instantiation because of the repo file.  */
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|extern_p
operator|&&
operator|!
name|flag_use_repository
condition|)
name|pedwarn
argument_list|(
literal|"duplicate explicit instantiation of `%#D'"
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* If we've already instantiated the template, just return now.  */
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no matching template for `%D' found"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"explicit instantiation of non-template `%#D'"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids the use of `extern' on explicit instantiations"
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|mark_decl_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|result
argument_list|,
comment|/*defer_ok=*/
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mark_class_instantiated
parameter_list|(
name|t
parameter_list|,
name|extern_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
block|{
name|SET_CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|extern_p
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|extern_p
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform an explicit instantiation of template class T.  STORAGE, if    non-null, is the RID for extern, inline or static.  COMPLAIN is    non-zero if this is called from the parser, zero if called recursively,    since the standard is unclear (as detailed below).  */
end_comment

begin_function
name|void
name|do_type_instantiation
parameter_list|(
name|t
parameter_list|,
name|storage
parameter_list|,
name|complain
parameter_list|)
name|tree
name|t
decl_stmt|,
name|storage
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
name|int
name|nomem_p
init|=
literal|0
decl_stmt|;
name|int
name|static_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of non-template type `%T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* With -fexternal-templates, explicit instantiations are treated the same      as implicit ones.  */
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"explicit instantiation of `%#T' before definition of template"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|storage
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids the use of `%s' on explicit instantiations"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|storage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
condition|)
name|nomem_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|extern_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
condition|)
name|static_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall both explicitly instantiate and explicitly 	 specialize a template.  */
if|if
condition|(
name|complain
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of `%#T' after"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"explicit specialization here"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall explicitly instantiate any template more 	 than once.             If CLASSTYPE_INTERFACE_ONLY, then the first explicit instantiation 	 was `extern'.  If EXTERN_P then the second is.  If -frepo, chances 	 are we already got marked as an explicit instantiation because of the 	 repo file.  All these cases are OK.  */
if|if
condition|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|extern_p
operator|&&
operator|!
name|flag_use_repository
operator|&&
name|complain
condition|)
name|pedwarn
argument_list|(
literal|"duplicate explicit instantiation of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we've already instantiated the template, just return now.  */
if|if
condition|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
return|return;
block|}
name|mark_class_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nomem_p
condition|)
return|return;
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* In contrast to implicit instantiation, where only the        declarations, and not the definitions, of members are        instantiated, we have here:           [temp.explicit]  	 The explicit instantiation of a class template specialization 	 implies the instantiation of all of its members not 	 previously explicitly specialized in the translation unit 	 containing the explicit instantiation.           Of course, we can't instantiate member template classes, since        we don't have any arguments for them.  Note that the standard        is unclear on whether the instantiation of the members are        *explicit* instantiations or not.  We choose to be generous,        and not set DECL_EXPLICIT_INSTANTIATION.  Therefore, we allow        the explicit instantiation of a class where some of the members        have no definition in the current translation unit.  */
if|if
condition|(
operator|!
name|static_p
condition|)
for|for
control|(
name|tmp
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|mark_decl_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|tmp
argument_list|,
comment|/*defer_ok=*/
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|mark_decl_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|tmp
argument_list|,
comment|/*defer_ok=*/
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_type_instantiation
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|storage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a function DECL, which is a specialization of TMPL, modify    DECL to be a re-instantiation of TMPL with the same template    arguments.  TMPL should be the template into which tsubst'ing    should occur for DECL, not the most general template.     One reason for doing this is a scenario like this:       template<class T>      void f(const T&, int i);       void g() { f(3, 7); }       template<class T>      void f(const T& t, const int i) { }     Note that when the template is first instantiated, with    instantiate_template, the resulting DECL will have no name for the    first parameter, and the wrong type for the second.  So, when we go    to instantiate the DECL, we regenerate it.  */
end_comment

begin_function
specifier|static
name|void
name|regenerate_decl_from_template
parameter_list|(
name|decl
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
comment|/* The most general version of TMPL.  */
name|tree
name|gen_tmpl
decl_stmt|;
comment|/* The arguments used to instantiate DECL, from the most general      template.  */
name|tree
name|args
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|tree
name|new_decl
decl_stmt|;
name|int
name|unregistered
decl_stmt|;
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Unregister the specialization so that when we tsubst we will not      just return DECL.  We don't have to unregister DECL from TMPL      because if would only be registered there if it were a partial      instantiation of a specialization, which it isn't: it's a full      instantiation.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|unregistered
operator|=
name|unregister_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
comment|/* If the DECL was not unregistered then something peculiar is      happening: we created a specialization but did not call      register_specialization for it.  */
name|my_friendly_assert
argument_list|(
name|unregistered
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
comment|/* Make sure that we can see identifiers, and compute access        correctly, for the class members used in the declaration of        this static variable.  */
name|pushclass
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Do the substitution to get the new declaration.  */
name|new_decl
operator|=
name|tsubst
argument_list|(
name|code_pattern
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Set up DECL_INITIAL, since tsubst doesn't.  */
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop the class context we pushed above.  */
name|popclass
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Convince duplicate_decls to use the DECL_ARGUMENTS from the 	 new decl.  */
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* And don't complain about a duplicate definition.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* The immediate parent of the new template is still whatever it was      before, even though tsubst sets DECL_TI_TEMPLATE up as the most      general template.  We also reset the DECL_ASSEMBLER_NAME since      tsubst always calculates the name as if the function in question      were really a template instance, and sometimes, with friend      functions, this is not so.  See tsubst_friend_function for      details.  */
name|DECL_TI_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
name|COPY_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Call duplicate decls to merge the old and new declarations.  */
name|duplicate_decls
argument_list|(
name|new_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Now, re-register the specialization.  */
name|register_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce the definition of D, a _DECL generated from a template.  If    DEFER_OK is non-zero, then we don't have to actually do the    instantiation now; we just have to do it sometime.  */
end_comment

begin_function
name|tree
name|instantiate_decl
parameter_list|(
name|d
parameter_list|,
name|defer_ok
parameter_list|)
name|tree
name|d
decl_stmt|;
name|int
name|defer_ok
decl_stmt|;
block|{
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|DECL_TI_ARGS
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|td
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|int
name|pattern_defined
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|int
name|need_push
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
comment|/* This function should only be used to instantiate templates for      functions and static member variables.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't instantiate cloned functions.  Instead, instantiate the      functions they cloned.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|DECL_CLONED_FUNCTION
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|d
argument_list|)
condition|)
comment|/* D has already been instantiated.  It might seem reasonable to        check whether or not D is an explicit instantiation, and, if so,        stop here.  But when an explicit instantiation is deferred        until the end of the compilation, DECL_EXPLICIT_INSTANTIATION        is set, even though we still need to do the instantiation.  */
return|return
name|d
return|;
comment|/* If we already have a specialization of this declaration, then      there's no reason to instantiate it.  Note that      retrieve_specialization gives us both instantiations and      specializations, so we must explicitly check      DECL_TEMPLATE_SPECIALIZATION.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
return|return
name|spec
return|;
comment|/* This needs to happen before any tsubsting.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
return|;
name|timevar_push
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
comment|/* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern      for the instantiation.  This is not always the most general      template.  Consider, for example:          template<class T> 	struct S { template<class U> void f(); 	           template<> void f<int>(); };       and an instantiation of S<double>::f<int>.  We want TD to be the      specialization S<T>::f<int>, not the more general S<T>::f<U>.  */
name|td
operator|=
name|tmpl
expr_stmt|;
while|while
condition|(
comment|/* An instantiation cannot have a definition, so we need a 	    more general template.  */
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|td
argument_list|)
comment|/* We must also deal with friend templates.  Given:  		template<class T> struct S {  		  template<class U> friend void f() {}; 		};  	      S<int>::f<U> say, is not an instantiation of S<T>::f<U>, 	      so far as the language is concerned, but that's still 	      where we get the pattern for the instantiation from.  On 	      other hand, if the definition comes outside the class, say:  		template<class T> struct S {  		  template<class U> friend void f(); 		}; 		template<class U> friend void f() {}  	      we don't need to look any further.  That's what the check for 	      DECL_INITIAL is for.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* The present template, TD, should not be a definition.  If it 	 were a definition, we should be using it!  Note that we 	 cannot restructure the loop to just keep going until we find 	 a template with a definition, since that might go too far if 	 a specialization was declared, but not defined.  */
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fetch the more general template.  */
name|td
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|pattern_defined
operator|=
operator|(
name|DECL_SAVED_TREE
argument_list|(
name|code_pattern
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
else|else
name|pattern_defined
operator|=
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_defined
condition|)
block|{
comment|/* Let the repository code that this template definition is 	 available.  	 The repository doesn't need to know about cloned functions 	 because they never actually show up in the object file.  It 	 does need to know about the clones; those are the symbols 	 that the linker will be emitting error messages about.  */
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|d
argument_list|)
operator|||
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
init|;
name|t
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|repo_template_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|repo_template_used
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
if|if
condition|(
name|interface_unknown
condition|)
name|warn_if_unknown_interface
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|code_pattern
argument_list|)
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
else|else
name|warn_if_unknown_interface
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|at_eof
condition|)
name|import_export_decl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|d
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* We should have set up DECL_INITIAL in instantiate_class_template.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Reject all external templates except inline functions.  */
elseif|else
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|d
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Defer all other templates, unless we have been explicitly      forbidden from doing so.  We restore the source position here      because it's used by add_pending_template.  */
elseif|else
if|if
condition|(
operator|!
name|pattern_defined
operator|||
name|defer_ok
condition|)
block|{
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|at_eof
operator|&&
operator|!
name|pattern_defined
operator|&&
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|d
argument_list|)
condition|)
comment|/* [temp.explicit]  	   The definition of a non-exported function template, a 	   non-exported member function template, or a non-exported 	   member function or static data member of a class template 	   shall be present in every translation unit in which it is 	   explicitly instantiated.  */
name|pedwarn
argument_list|(
literal|"explicit instantiation of `%D' but no definition available"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|add_pending_template
argument_list|(
name|d
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|need_push
operator|=
operator|!
name|global_bindings_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_push
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* We're now committed to instantiating this template.  Mark it as      instantiated so that recursive calls to instantiate_decl do not      try to instantiate it again.  */
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Regenerate the declaration in case the template has been modified      by a subsequent redeclaration.  */
name|regenerate_decl_from_template
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* We already set the file and line above.  Reset them now in case      they changed as a result of calling regenerate_decl_from_template.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|DECL_IN_AGGR_P
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|htab_t
name|saved_local_specializations
decl_stmt|;
comment|/* Save away the current list, in case we are instantiating one 	 template from within the body of another.  */
name|saved_local_specializations
operator|=
name|local_specializations
expr_stmt|;
comment|/* Set up the list of local specializations.  */
name|local_specializations
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set up context.  */
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* Substitute into the body of the function.  */
name|tsubst_expr
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
comment|/* We don't need the local specializations any more.  */
name|htab_delete
argument_list|(
name|local_specializations
argument_list|)
expr_stmt|;
name|local_specializations
operator|=
name|saved_local_specializations
expr_stmt|;
comment|/* Finish the function.  */
name|expand_body
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We're not deferring instantiation any more.  */
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_push
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|out
label|:
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Run through the list of templates that we wish we could    instantiate, and instantiate any we can.  */
end_comment

begin_function
name|int
name|instantiate_pending_templates
parameter_list|()
block|{
name|tree
modifier|*
name|t
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|instantiated_something
init|=
literal|0
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
do|do
block|{
name|reconsider
operator|=
literal|0
expr_stmt|;
name|t
operator|=
operator|&
name|pending_templates
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|tree
name|instantiation
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
name|reopen_tinst_level
argument_list|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiate_class_template
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|instantiation
argument_list|)
condition|)
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|instantiation
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|fn
argument_list|,
comment|/*defer_ok=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiated_something
operator|=
literal|1
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
comment|/* If INSTANTIATION has been instantiated, then we don't 		   need to consider it again in the future.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|last
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|instantiation
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiation
operator|=
name|instantiate_decl
argument_list|(
name|instantiation
argument_list|,
comment|/*defer_ok=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiated_something
operator|=
literal|1
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|instantiation
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
comment|/* If INSTANTIATION has been instantiated, then we don't 		   need to consider it again in the future.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|last
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|tinst_depth
operator|=
literal|0
expr_stmt|;
name|current_tinst_level
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|last_pending_template
operator|=
name|last
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
return|return
name|instantiated_something
return|;
block|}
end_function

begin_comment
comment|/* Substitute ARGVEC into T, which is a list of initializers for    either base class or a non-static data member.  The TREE_PURPOSEs    are DECLs, and the TREE_VALUEs are the initializer values.  Used by    instantiate_decl.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_initializer_list
parameter_list|(
name|t
parameter_list|,
name|argvec
parameter_list|)
name|tree
name|t
decl_stmt|,
name|argvec
decl_stmt|;
block|{
name|tree
name|first
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|p
init|=
operator|&
name|first
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|decl
operator|=
name|tsubst_copy
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|init
operator|=
name|tsubst_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
for|for
control|(
name|val
operator|=
name|init
init|;
name|val
condition|;
name|val
operator|=
name|TREE_CHAIN
argument_list|(
name|val
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
operator|=
name|convert_from_reference
argument_list|(
name|TREE_VALUE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|convert_from_reference
argument_list|(
name|init
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|build_tree_list
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */
end_comment

begin_function
specifier|static
name|void
name|set_current_access_from_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|current_access_specifier
operator|=
name|access_private_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|current_access_specifier
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|current_access_specifier
operator|=
name|access_public_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instantiate an enumerated type.  TAG is the template type, NEWTAG    is the instantiation (which should have been created with    start_enum) and ARGS are the template arguments to use.  */
end_comment

begin_function
specifier|static
name|void
name|tsubst_enum
parameter_list|(
name|tag
parameter_list|,
name|newtag
parameter_list|,
name|args
parameter_list|)
name|tree
name|tag
decl_stmt|;
name|tree
name|newtag
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|TYPE_VALUES
argument_list|(
name|tag
argument_list|)
init|;
name|e
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
name|tree
name|value
decl_stmt|;
comment|/* Note that in a template enum, the TREE_VALUE is the 	 CONST_DECL, not the corresponding INTEGER_CST.  */
name|value
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Give this enumeration constant the correct access.  */
name|set_current_access_from_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actually build the enumerator itself.  */
name|build_enumerator
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|e
argument_list|)
argument_list|,
name|value
argument_list|,
name|newtag
argument_list|)
expr_stmt|;
block|}
name|finish_enum
argument_list|(
name|newtag
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_NAME
argument_list|(
name|newtag
argument_list|)
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_NAME
argument_list|(
name|newtag
argument_list|)
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL that is a template specialization.  Return    its type -- but without substituting the innermost set of template    arguments.  So, innermost set of template parameters will appear in    the type.  If CONTEXTP is non-NULL, then the partially substituted    DECL_CONTEXT (if any) will also be filled in.  Similarly, TPARMSP    will be filled in with the substituted template parameters, if it    is non-NULL.  */
end_comment

begin_function
name|tree
name|get_mostly_instantiated_function_type
parameter_list|(
name|decl
parameter_list|,
name|contextp
parameter_list|,
name|tparmsp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|contextp
decl_stmt|;
name|tree
modifier|*
name|tparmsp
decl_stmt|;
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn_type
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|tparms
decl_stmt|;
name|int
name|parm_depth
decl_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|tparms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|parm_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|tparms
argument_list|)
expr_stmt|;
comment|/* There should be as many levels of arguments as there are levels      of parameters.  */
name|my_friendly_assert
argument_list|(
name|parm_depth
operator|==
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm_depth
operator|==
literal|1
condition|)
comment|/* No substitution is necessary.  */
empty_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|partial_args
decl_stmt|;
comment|/* Replace the innermost level of the TARGS with NULL_TREEs to 	 let tsubst know not to substitute for those parameters.  */
name|partial_args
operator|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|partial_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|partial_args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
argument_list|,
name|make_tree_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, do the (partial) substitution to figure out the 	 appropriate function type.  */
name|fn_type
operator|=
name|tsubst
argument_list|(
name|fn_type
argument_list|,
name|partial_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|tsubst
argument_list|(
name|context
argument_list|,
name|partial_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Substitute into the template parameters to obtain the real 	 innermost set of parameters.  This step is important if the 	 innermost set of template parameters contains value 	 parameters whose types depend on outer template parameters.  */
name|TREE_VEC_LENGTH
argument_list|(
name|partial_args
argument_list|)
operator|--
expr_stmt|;
name|tparms
operator|=
name|tsubst_template_parms
argument_list|(
name|tparms
argument_list|,
name|partial_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|contextp
condition|)
operator|*
name|contextp
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|tparmsp
condition|)
operator|*
name|tparmsp
operator|=
name|tparms
expr_stmt|;
return|return
name|fn_type
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue if we're processing a template different from    the last one involved in diagnostics.  */
end_comment

begin_function
name|int
name|problematic_instantiation_changed
parameter_list|()
block|{
return|return
name|last_template_error_tick
operator|!=
name|tinst_level_tick
return|;
block|}
end_function

begin_comment
comment|/* Remember current template involved in diagnostics.  */
end_comment

begin_function
name|void
name|record_last_problematic_instantiation
parameter_list|()
block|{
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|current_instantiation
parameter_list|()
block|{
return|return
name|current_tinst_level
return|;
block|}
end_function

begin_comment
comment|/* [temp.param] Check that template non-type parm TYPE is of an allowable    type. Return zero for ok, non-zero for disallowed. If COMPLAIN is    non-zero, then complain. */
end_comment

begin_function
specifier|static
name|int
name|invalid_nontype_parm_type_p
parameter_list|(
name|type
parameter_list|,
name|complain
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"`%#T' is not a valid type for a template constant parameter"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

