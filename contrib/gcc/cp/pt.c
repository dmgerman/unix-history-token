begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle parameterized types (templates) for GNU C++.    Copyright (C) 1992, 93-97, 1998, 1999 Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.    Rewritten by Jason Merrill (jason@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Known bugs or deficiencies include:       all methods must be provided in header files; can't use a source      file that contains only the method templates and "just win".  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_comment
comment|/* The type of functions taking a tree, and some additional data, and    returning an int.  */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*tree_fn_t
argument_list|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_template_parms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|processing_template_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The PENDING_TEMPLATES is a TREE_LIST of templates whose    instantiations have been deferred, either because their definitions    were not yet available, or because we were putting off doing the    work.  The TREE_PURPOSE of each entry is a SRCLOC indicating where    the instantiate request occurred; the TREE_VALUE is a either a DECL    (for a function or static data member), or a TYPE (for a class)    indicating what we are hoping to instantiate.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|template_tail
init|=
operator|&
name|pending_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|maybe_template_tail
init|=
operator|&
name|maybe_templates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minimal_parse_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_specialization
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_explicit_instantiation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|processing_template_parmlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_header_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|saved_trees
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_type
name|inline_parm_levels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|inline_parm_levels_used
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_NONE
value|0
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_MORE_CV_QUAL
value|1
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_LESS_CV_QUAL
value|2
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_DERIVED
value|4
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_INTEGER
value|8
end_define

begin_define
define|#
directive|define
name|GTB_VIA_VIRTUAL
value|1
end_define

begin_comment
comment|/* The base class we are examining is 			     virtual, or a base class of a virtual 			     base.  */
end_comment

begin_define
define|#
directive|define
name|GTB_IGNORE_TYPE
value|2
end_define

begin_comment
comment|/* We don't need to try to unify the current 			     type with the desired type.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|resolve_overloaded_unification
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|unification_kind_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_one_overload
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|unification_kind_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unify
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pending_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|push_tinst_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|classtype_mangled_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_expr_values
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list_eq
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_class_bindings
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|coerce_template_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tsubst_enum
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_to_template_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|add_outermost_template_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_adjust_types_for_deduction
name|PROTO
argument_list|(
operator|(
name|unification_kind_t
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_unification_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|unification_kind_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_template_header
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_fold_nontype_arg
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_nontype_argument
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|convert_template_argument
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_bindings_overload
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|for_each_template_parm
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree_fn_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_template_parm_index
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inline_needs_template_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_inline_template_parms_recursive
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|retrieve_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|register_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unregister_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|reduce_template_parm_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_template_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_template_parm
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_friend_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_friend_class
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_bindings_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_decl_level
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|maybe_get_template_decl_from_type_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_cv_quals_for_unify
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_template_arg_vector
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_template_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regenerate_decl_from_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|most_specialized
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|most_specialized_class
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|most_general_template
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_mangled_name_for_template_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_class_depth_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_aggr_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_arg_types
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_function_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_specialization_scope
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|process_partial_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_current_access_from_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_default_tmpl_args
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|tsubst_call_declarator_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_template_base_recursive
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_template_base
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|try_class_unification
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coerce_template_template_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|determine_specialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_args_equal
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_template_context
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use TREE_VECs to hold template arguments.  If there is only one    level of template arguments, then the TREE_VEC contains the    arguments directly.  If there is more than one level of template    arguments, then each entry in the TREE_VEC is itself a TREE_VEC,    containing the template arguments for a single level.  The first    entry in the outer TREE_VEC is the outermost level of template    parameters; the last is the innermost.       It is incorrect to ever form a template argument vector containing    only one level of arguments, but which is a TREE_VEC containing as    its only entry the TREE_VEC for that level.  */
end_comment

begin_comment
comment|/* Non-zero if the template arguments is actually a vector of vectors,    rather than just a vector.  */
end_comment

begin_define
define|#
directive|define
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(NODE != NULL_TREE						\&& TREE_CODE (NODE) == TREE_VEC				\&& TREE_VEC_LENGTH (NODE)> 0				\&& TREE_VEC_ELT (NODE, 0) != NULL_TREE			\&& TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)
end_define

begin_comment
comment|/* The depth of a template argument vector.  When called directly by    the parser, we use a TREE_LIST rather than a TREE_VEC to represent    template arguments.  In fact, we may even see NULL_TREE if there    are no template arguments.  In both of those cases, there is only    one level of template arguments.  */
end_comment

begin_define
define|#
directive|define
name|TMPL_ARGS_DEPTH
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(TMPL_ARGS_HAVE_MULTIPLE_LEVELS (NODE) ? TREE_VEC_LENGTH (NODE) : 1)
end_define

begin_comment
comment|/* The LEVELth level of the template ARGS.  Note that template    parameter levels are indexed from 1, not from 0.  */
end_comment

begin_define
define|#
directive|define
name|TMPL_ARGS_LEVEL
parameter_list|(
name|ARGS
parameter_list|,
name|LEVEL
parameter_list|)
define|\
value|(TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS) 	\    ? TREE_VEC_ELT ((ARGS), (LEVEL) - 1) : ARGS)
end_define

begin_comment
comment|/* Set the LEVELth level of the template ARGS to VAL.  This macro does    not work with single-level argument vectors.  */
end_comment

begin_define
define|#
directive|define
name|SET_TMPL_ARGS_LEVEL
parameter_list|(
name|ARGS
parameter_list|,
name|LEVEL
parameter_list|,
name|VAL
parameter_list|)
define|\
value|(TREE_VEC_ELT ((ARGS), (LEVEL) - 1) = (VAL))
end_define

begin_comment
comment|/* Accesses the IDXth parameter in the LEVELth level of the ARGS.  */
end_comment

begin_define
define|#
directive|define
name|TMPL_ARG
parameter_list|(
name|ARGS
parameter_list|,
name|LEVEL
parameter_list|,
name|IDX
parameter_list|)
define|\
value|(TREE_VEC_ELT (TMPL_ARGS_LEVEL (ARGS, LEVEL), IDX))
end_define

begin_comment
comment|/* Set the IDXth element in the LEVELth level of ARGS to VAL.  This    macro does not work with single-level argument vectors.  */
end_comment

begin_define
define|#
directive|define
name|SET_TMPL_ARG
parameter_list|(
name|ARGS
parameter_list|,
name|LEVEL
parameter_list|,
name|IDX
parameter_list|,
name|VAL
parameter_list|)
define|\
value|(TREE_VEC_ELT (TREE_VEC_ELT ((ARGS), (LEVEL) - 1), (IDX)) = (VAL))
end_define

begin_comment
comment|/* Given a single level of template arguments in NODE, return the    number of arguments.  */
end_comment

begin_define
define|#
directive|define
name|NUM_TMPL_ARGS
parameter_list|(
name|NODE
parameter_list|)
define|\
value|((NODE) == NULL_TREE ? 0 				\    : (TREE_CODE (NODE) == TREE_VEC 			\       ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))
end_define

begin_comment
comment|/* The number of levels of template parameters given by NODE.  */
end_comment

begin_define
define|#
directive|define
name|TMPL_PARMS_DEPTH
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(TREE_INT_CST_HIGH (TREE_PURPOSE (NODE)))
end_define

begin_comment
comment|/* Do any processing required when DECL (a member template declaration    using TEMPLATE_PARAMETERS as its innermost parameter list) is    finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless    it is a specialization, in which case the DECL itself is returned.  */
end_comment

begin_function
name|tree
name|finish_member_template_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|decl
operator|==
name|void_type_node
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
comment|/* By returning NULL_TREE, the parser will just ignore this        declaration.  We have already issued the error.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Assume that the class is the only declspec.  */
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|check_member_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|check_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
return|;
block|}
else|else
return|return
name|decl
return|;
block|}
else|else
name|cp_error
argument_list|(
literal|"invalid member template declaration `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the template nesting level of the indicated class TYPE.        For example, in:      template<class T>      struct A      {        template<class U>        struct B {};      };     A<T>::B<U> has depth two, while A<T> has depth one.      Both A<T>::B<int> and A<int>::B<U> have depth one, if    COUNT_SPECIALIZATIONS is 0 or if they are instantiations, not    specializations.       This function is guaranteed to return 0 if passed NULL_TREE so    that, for example, `template_class_depth (current_class_type)' is    always safe.  */
end_comment

begin_function
specifier|static
name|int
name|template_class_depth_real
parameter_list|(
name|type
parameter_list|,
name|count_specializations
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|count_specializations
decl_stmt|;
block|{
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|?
name|DECL_REAL_CONTEXT
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|count_specializations
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
operator|++
name|depth
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|count_specializations
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
operator|++
name|depth
expr_stmt|;
block|}
block|}
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Returns the template nesting level of the indicated class TYPE.    Like template_class_depth_real, but instantiations do not count in    the depth.  */
end_comment

begin_function
name|int
name|template_class_depth
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|template_class_depth_real
argument_list|(
name|type
argument_list|,
comment|/*count_specializations=*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if processing DECL as part of do_pending_inlines    needs us to push template parms.  */
end_comment

begin_function
specifier|static
name|int
name|inline_needs_template_parms
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|most_general_template
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|>
operator|(
name|processing_template_decl
operator|+
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of maybe_begin_member_template_processing.    Push the template parms in PARMS, starting from LEVELS steps into the    chain, and ending at the beginning, since template parms are listed    innermost first.  */
end_comment

begin_function
specifier|static
name|void
name|push_inline_template_parms_recursive
parameter_list|(
name|parmlist
parameter_list|,
name|levels
parameter_list|)
name|tree
name|parmlist
decl_stmt|;
name|int
name|levels
decl_stmt|;
block|{
name|tree
name|parms
init|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|levels
operator|>
literal|1
condition|)
name|push_inline_template_parms_recursive
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|levels
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|build_int_2
argument_list|(
literal|0
argument_list|,
name|processing_template_decl
argument_list|)
argument_list|,
name|parms
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
block|{
comment|/* Make a CONST_DECL as is done in process_template_parm. 	       It is ugly that we recreate this here; the original 	       version built in process_template_parm is no longer 	       available.  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Restore the template parameter context for a member template or    a friend template defined in a class definition.  */
end_comment

begin_function
name|void
name|maybe_begin_member_template_processing
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|levels
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inline_needs_template_parms
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|most_general_template
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|levels
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|-
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|--
name|levels
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|push_inline_template_parms_recursive
argument_list|(
name|parms
argument_list|,
name|levels
argument_list|)
expr_stmt|;
block|}
comment|/* Remember how many levels of template parameters we pushed so that      we can pop them later.  */
if|if
condition|(
operator|!
name|inline_parm_levels
condition|)
name|VARRAY_INT_INIT
argument_list|(
name|inline_parm_levels
argument_list|,
literal|4
argument_list|,
literal|"inline_parm_levels"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_parm_levels_used
operator|==
name|inline_parm_levels
operator|->
name|num_elements
condition|)
name|VARRAY_GROW
argument_list|(
name|inline_parm_levels
argument_list|,
literal|2
operator|*
name|inline_parm_levels_used
argument_list|)
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|inline_parm_levels
argument_list|,
name|inline_parm_levels_used
argument_list|)
operator|=
name|levels
expr_stmt|;
operator|++
name|inline_parm_levels_used
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the effects of begin_member_template_processing. */
end_comment

begin_function
name|void
name|maybe_end_member_template_processing
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|inline_parm_levels_used
condition|)
return|return;
operator|--
name|inline_parm_levels_used
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_INT
argument_list|(
name|inline_parm_levels
argument_list|,
name|inline_parm_levels_used
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns non-zero iff T is a member template function.  We must be    careful as in       template<class T> class C { void f(); }     Here, f is a template function, and a member, but not a member    template.  This function does not concern itself with the origin of    T, only its present state.  So if we have        template<class T> class C { template<class U> void f(U); }     then neither C<int>::f<char> nor C<T>::f<double> is considered    to be a member template.  But, `template<class U> void    C<int>::f(U)' is considered a member template.  */
end_comment

begin_function
name|int
name|is_member_template
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Anything that isn't a function or a template function is        certainly not a member template.  */
return|return
literal|0
return|;
comment|/* A local class can't have member templates.  */
if|if
condition|(
name|hack_decl_function_context
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
comment|/* If there are more levels of template parameters than 	     there are template classes surrounding the declaration, 	     then we have a member template.  */
operator|&&
operator|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|>
name|template_class_depth
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/* Returns non-zero iff T is a member template class.  See    is_member_template for a description of what precisely constitutes    a member template.  */
end_comment

begin_comment
unit|int is_member_template_class (t)      tree t; {   if (!DECL_CLASS_TEMPLATE_P (t))
comment|/* Anything that isn't a class template, is certainly not a member        template.  */
end_comment

begin_comment
unit|return 0;    if (!DECL_CLASS_SCOPE_P (t))
comment|/* Anything whose context isn't a class type is surely not a        member template.  */
end_comment

begin_comment
unit|return 0;
comment|/* If there are more levels of template parameters than there are      template classes surrounding the declaration, then we have a      member template.  */
end_comment

begin_endif
unit|return  (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (t))>  	   template_class_depth (DECL_CONTEXT (t))); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a new template argument vector which contains all of ARGS,    but has as its innermost set of arguments the EXTRA_ARGS.  The    resulting vector will be built on a temporary obstack, and so must    be explicitly copied to the permanent obstack, if required.  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_template_args
parameter_list|(
name|args
parameter_list|,
name|extra_args
parameter_list|)
name|tree
name|args
decl_stmt|;
name|tree
name|extra_args
decl_stmt|;
block|{
name|tree
name|new_args
decl_stmt|;
name|int
name|extra_depth
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|extra_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|make_temp_vec
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|+
name|extra_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|extra_depth
condition|;
operator|++
name|j
operator|,
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|extra_args
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* Like add_to_template_args, but only the outermost ARGS are added to    the EXTRA_ARGS.  In particular, all but TMPL_ARGS_DEPTH    (EXTRA_ARGS) levels are added.  This function is used to combine    the template arguments from a partial instantiation with the    template arguments used to attain the full instantiation from the    partial instantiation.  */
end_comment

begin_function
specifier|static
name|tree
name|add_outermost_template_args
parameter_list|(
name|args
parameter_list|,
name|extra_args
parameter_list|)
name|tree
name|args
decl_stmt|;
name|tree
name|extra_args
decl_stmt|;
block|{
name|tree
name|new_args
decl_stmt|;
comment|/* If there are more levels of EXTRA_ARGS than there are ARGS,      something very fishy is going on.  */
name|my_friendly_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|>=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If *all* the new arguments will be the EXTRA_ARGS, just return      them.  */
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
condition|)
return|return
name|extra_args
return|;
comment|/* For the moment, we make ARGS look like it contains fewer levels.  */
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|add_to_template_args
argument_list|(
name|args
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
comment|/* Now, we restore ARGS to its full dimensions.  */
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|+=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* We've got a template header coming up; push to a new level for storing    the parms.  */
end_comment

begin_function
name|void
name|begin_template_parm_list
parameter_list|()
block|{
comment|/* We use a non-tag-transparent scope here, which causes pushtag to      put tags in this scope, rather than in the enclosing class or      namespace scope.  This is the right thing, since we want      TEMPLATE_DECLS, and not TYPE_DECLS for template classes.  For a      global template class, push_template_decl handles putting the      TEMPLATE_DECL into top-level scope.  For a nested template class,      e.g.:         template<class T> struct S1 {          template<class T> struct S2 {};         };       pushtag contains special code to call pushdecl_with_scope on the      TEMPLATE_DECL for S2.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_pseudo_global_level
argument_list|()
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
operator|++
name|processing_template_parmlist
expr_stmt|;
name|note_template_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is called when a specialization is declared.  If it is    illegal to declare a specialization here, an error is reported.  */
end_comment

begin_function
specifier|static
name|void
name|check_specialization_scope
parameter_list|()
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
comment|/* [temp.expl.spec]             An explicit specialization shall be declared in the namespace of      which the template is a member, or, for member templates, in the      namespace of which the enclosing class or enclosing class      template is a member.  An explicit specialization of a member      function, member class or static data member of a class template      shall be declared in the namespace of which the class template      is a member.  */
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|cp_error
argument_list|(
literal|"explicit specialization in non-namespace scope `%D'"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* [temp.expl.spec]        In an explicit specialization declaration for a member of a class      template or a member template that appears in namespace scope,      the member template and some of its enclosing class templates may      remain unspecialized, except that the declaration shall not      explicitly specialize a class member template if its enclosing      class templates are not explicitly specialized as well.  */
if|if
condition|(
name|current_template_parms
condition|)
name|cp_error
argument_list|(
literal|"enclosing class templates are not explicitly specialized"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen template<>. */
end_comment

begin_function
name|void
name|begin_specialization
parameter_list|()
block|{
name|note_template_header
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|check_specialization_scope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at then end of processing a declaration preceeded by    template<>.  */
end_comment

begin_function
name|void
name|end_specialization
parameter_list|()
block|{
name|reset_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any template<>'s that we have seen thus far are not referring to a    function specialization. */
end_comment

begin_function
name|void
name|reset_specialization
parameter_list|()
block|{
name|processing_specialization
operator|=
literal|0
expr_stmt|;
name|template_header_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen a template header.  If SPECIALIZATION is non-zero,    it was of the form template<>.  */
end_comment

begin_function
specifier|static
name|void
name|note_template_header
parameter_list|(
name|specialization
parameter_list|)
name|int
name|specialization
decl_stmt|;
block|{
name|processing_specialization
operator|=
name|specialization
expr_stmt|;
name|template_header_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're beginning an explicit instantiation.  */
end_comment

begin_function
name|void
name|begin_explicit_instantiation
parameter_list|()
block|{
operator|++
name|processing_explicit_instantiation
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_explicit_instantiation
parameter_list|()
block|{
name|my_friendly_assert
argument_list|(
name|processing_explicit_instantiation
operator|>
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|processing_explicit_instantiation
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The TYPE is being declared.  If it is a template type, that means it    is a partial specialization.  Do appropriate error-checking.  */
end_comment

begin_function
name|void
name|maybe_process_partial_specialization
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_namespace
operator|!=
name|decl_namespace_context
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"specializing `%#T' in different namespace"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  from definition of `%#D'"
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|push_template_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"specialization of `%T' after instantiation"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|processing_specialization
condition|)
name|cp_error
argument_list|(
literal|"explicit specialization of non-template `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the specialization (in the sense of [temp.spec] - a    specialization is either an instantiation or an explicit    specialization) of TMPL for the given template ARGS.  If there is    no such specialization, return NULL_TREE.  The ARGS are a vector of    arguments, or a vector of vectors of arguments, in the case of    templates with more than one level of parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|retrieve_specialization
parameter_list|(
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|s
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* There should be as many levels of arguments as there are      levels of parameters.  */
name|my_friendly_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero iff DECL is a specialization of TMPL.  */
end_comment

begin_function
name|int
name|is_specialization_of
parameter_list|(
name|decl
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
for|for
control|(
name|t
operator|=
name|decl
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|t
operator|==
name|tmpl
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Register the specialization SPEC as a specialization of TMPL with    the indicated ARGS.  Returns SPEC, or an equivalent prior    declaration, if available.  */
end_comment

begin_function
specifier|static
name|tree
name|register_specialization
parameter_list|(
name|spec
parameter_list|,
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|s
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
condition|)
comment|/* This is the FUNCTION_DECL for a partial instantiation.  Don't        register it; we want the corresponding TEMPLATE_DECL instead.        We use `uses_template_parms (DECL_TI_ARGS (spec))' rather than        the more obvious `uses_template_parms (spec)' to avoid problems        with default function arguments.  In particular, given        something like this:            template<class T> void f(T t1, T t = T())         the default argument expression is not substituted for in an        instantiation unless and until it is actually needed.  */
return|return
name|spec
return|;
comment|/* There should be as many levels of arguments as there are      levels of parameters.  */
name|my_friendly_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|s
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"specialization of %D after instantiation"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|spec
return|;
block|}
else|else
block|{
comment|/* This situation should occur only if the first 		       specialization is an implicit instantiation, 		       the second is an explicit specialization, and 		       the implicit instantiation has not yet been 		       used.  That situation can occur if we have 		       implicitly instantiated a member function and 		       then specialized it later.  		       We can also wind up here if a friend 		       declaration that looked like an instantiation 		       turns out to be a specialization:  		         template<class T> void foo(T); 			 class S { friend void foo<>(int) }; 			 template<> void foo(int);    		       We transform the existing DECL in place so that 		       any pointers to it become pointers to the 		       updated declaration.    		       If there was a definition for the template, but 		       not for the specialization, we want this to 		       look as if there is no definition, and vice 		       versa.  */
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|duplicate_decls
argument_list|(
name|spec
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|duplicate_decls
argument_list|(
name|spec
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
block|}
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|args
argument_list|,
name|spec
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|spec
return|;
block|}
end_function

begin_comment
comment|/* Unregister the specialization SPEC as a specialization of TMPL.    Returns nonzero if the SPEC was listed as a specialization of    TMPL.  */
end_comment

begin_function
specifier|static
name|int
name|unregister_specialization
parameter_list|(
name|spec
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
operator|&
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
operator|*
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|s
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|s
argument_list|)
operator|==
name|spec
condition|)
block|{
operator|*
name|s
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print the list of candidate FNS in an error message.  */
end_comment

begin_function
name|void
name|print_candidates
parameter_list|(
name|fns
parameter_list|)
name|tree
name|fns
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
operator|!=
name|NULL_TREE
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|OVL_NEXT
argument_list|(
name|f
argument_list|)
control|)
name|cp_error_at
argument_list|(
literal|"%s %+#D"
argument_list|,
name|str
argument_list|,
name|OVL_CURRENT
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the template (one of the functions given by TEMPLATE_ID)    which can be specialized to match the indicated DECL with the    explicit template args given in TEMPLATE_ID.  The DECL may be    NULL_TREE if none is available.  In that case, the functions in    TEMPLATE_ID are non-members.     If NEED_MEMBER_TEMPLATE is non-zero the function is known to be a    specialization of a member template.     The template args (those explicitly specified and those deduced)    are output in a newly created vector *TARGS_OUT.     If it is impossible to determine the result, an error message is    issued.  The error_mark_node is returned to indicate failure.  */
end_comment

begin_function
specifier|static
name|tree
name|determine_specialization
parameter_list|(
name|template_id
parameter_list|,
name|decl
parameter_list|,
name|targs_out
parameter_list|,
name|need_member_template
parameter_list|)
name|tree
name|template_id
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|targs_out
decl_stmt|;
name|int
name|need_member_template
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|explicit_targs
decl_stmt|;
name|tree
name|candidates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
operator|*
name|targs_out
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|template_id
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check for baselinks. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|fns
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* DECL might be a specialization of FN.  */
name|tmpl
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
name|need_member_template
condition|)
comment|/* FN is an ordinary member function, and we need a 	   specialization of a member template.  */
continue|continue;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* We can get IDENTIFIER_NODEs here in certain erroneous 	   cases.  */
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* This is just an ordinary non-member function.  Nothing can 	   be a specialization of that.  */
continue|continue;
else|else
block|{
name|tree
name|decl_arg_types
decl_stmt|;
comment|/* This is an ordinary member function.  However, since 	     we're here, we can assume it's enclosing class is a 	     template class.  For example, 	      	       template<typename T> struct S { void f(); }; 	       template<> void S<int>::f() {}  	     Here, S<int>::f is a non-template, but S<int> is a 	     template class.  If FN has the same type as DECL, we 	     might be in business.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* The return types differ.  */
continue|continue;
comment|/* Adjust the type of DECL in case FN is a static member.  */
name|decl_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|decl_arg_types
argument_list|)
condition|)
comment|/* They match!  */
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See whether this function might be a specialization of this 	 template.  */
name|targs
operator|=
name|get_bindings
argument_list|(
name|tmpl
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targs
condition|)
comment|/* We cannot deduce template arguments that when used to 	   specialize TMPL will produce DECL.  */
continue|continue;
comment|/* Save this template, and the arguments deduced.  */
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|targs
argument_list|,
name|tmpl
argument_list|,
name|templates
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|templates
operator|&&
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
condition|)
block|{
comment|/* We have: 	  	   [temp.expl.spec]  	   It is possible for a specialization with a given function 	   signature to be instantiated from more than one function 	   template.  In such cases, explicit specification of the 	   template arguments must be used to uniquely identify the 	   function template specialization being specialized.  	 Note that here, there's no suggestion that we're supposed to 	 determine which of the candidate templates is most 	 specialized.  However, we, also have:  	   [temp.func.order]  	   Partial ordering of overloaded function template 	   declarations is used in the following contexts to select 	   the function template to which a function template 	   specialization refers:              -- when an explicit specialization refers to a function 	      template.   	 So, we do use the partial ordering rules, at least for now. 	 This extension can only serve to make illegal programs legal, 	 so it's safe.  And, there is strong anecdotal evidence that 	 the committee intended the partial ordering rules to apply; 	 the EDG front-end has that behavior, and John Spicer claims 	 that the committee simply forgot to delete the wording in 	 [temp.expl.spec].  */
name|tree
name|tmpl
init|=
name|most_specialized
argument_list|(
name|templates
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpl
operator|&&
name|tmpl
operator|!=
name|error_mark_node
condition|)
block|{
name|targs
operator|=
name|get_bindings
argument_list|(
name|tmpl
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|)
expr_stmt|;
name|templates
operator|=
name|scratch_tree_cons
argument_list|(
name|targs
argument_list|,
name|tmpl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|templates
operator|==
name|NULL_TREE
operator|&&
name|candidates
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"template-id `%D' for `%+D' does not match any template declaration"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|templates
operator|&&
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
operator|)
operator|||
operator|(
name|candidates
operator|&&
name|TREE_CHAIN
argument_list|(
name|candidates
argument_list|)
operator|)
operator|||
operator|(
name|templates
operator|&&
name|candidates
operator|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"ambiguous template specialization `%D' for `%+D'"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|candidates
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We have one, and exactly one, match. */
if|if
condition|(
name|candidates
condition|)
block|{
comment|/* It was a specialization of an ordinary member function in a 	 template class.  */
operator|*
name|targs_out
operator|=
name|copy_node
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
argument_list|)
return|;
block|}
comment|/* It was a specialization of a template.  */
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|DECL_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|targs
argument_list|)
condition|)
block|{
operator|*
name|targs_out
operator|=
name|copy_node
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
operator|*
name|targs_out
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
operator|*
name|targs_out
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|targs_out
operator|=
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the function just declared, as indicated in    DECLARATOR, and in DECL, is a specialization of a function    template.  We may also discover that the declaration is an explicit    instantiation at this point.     Returns DECL, or an equivalent declaration that should be used    instead if all goes well.  Issues an error message if something is    amiss.  Returns error_mark_node if the error is not easily    recoverable.        FLAGS is a bitmask consisting of the following flags:      2: The function has a definition.    4: The function is a friend.     The TEMPLATE_COUNT is the number of references to qualifying    template classes that appeared in the name of the function.  For    example, in       template<class T> struct S { void f(); };      void S<int>::f();          the TEMPLATE_COUNT would be 1.  However, explicitly specialized    classes are not counted in the TEMPLATE_COUNT, so that in       template<class T> struct S {};      template<> struct S<int> { void f(); }      template<> void S<int>::f();     the TEMPLATE_COUNT would be 0.  (Note that this declaration is    illegal; there should be no template<>.)     If the function is a specialization, it is marked as such via    DECL_TEMPLATE_SPECIALIZATION.  Furthermore, its DECL_TEMPLATE_INFO    is set up correctly, and it is added to the list of specializations     for that template.  */
end_comment

begin_function
name|tree
name|check_explicit_specialization
parameter_list|(
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|template_count
parameter_list|,
name|flags
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|template_count
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|have_def
init|=
name|flags
operator|&
literal|2
decl_stmt|;
name|int
name|is_friend
init|=
name|flags
operator|&
literal|4
decl_stmt|;
name|int
name|specialization
init|=
literal|0
decl_stmt|;
name|int
name|explicit_instantiation
init|=
literal|0
decl_stmt|;
name|int
name|member_specialization
init|=
literal|0
decl_stmt|;
name|tree
name|ctype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|dname
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_specialization
condition|)
block|{
comment|/* The last template header was of the form template<>.  */
if|if
condition|(
name|template_header_count
operator|>
name|template_count
condition|)
block|{
comment|/* There were more template headers than qualifying template 	     classes.  */
if|if
condition|(
name|template_header_count
operator|-
name|template_count
operator|>
literal|1
condition|)
comment|/* There shouldn't be that many template parameter lists. 	       There can be at most one parameter list for every 	       qualifying class, plus one for the function itself.  */
name|cp_error
argument_list|(
literal|"too many template parameter lists in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
name|member_specialization
operator|=
literal|1
expr_stmt|;
else|else
name|specialization
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|template_header_count
operator|==
name|template_count
condition|)
block|{
comment|/* The counts are equal.  So, this might be a 	     specialization, but it is not a specialization of a 	     member template.  It might be something like 		  	     template<class T> struct S {  	     void f(int i);  	     }; 	     template<> 	     void S<int>::f(int i) {}  */
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This cannot be an explicit specialization.  There are not 	     enough headers for all of the qualifying classes.  For 	     example, we might have: 	      	     template<> 	     void S<int>::T<char>::f();  	     But, we're missing another template<>.  */
name|cp_error
argument_list|(
literal|"too few template parameter lists in declaration of `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|processing_explicit_instantiation
condition|)
block|{
if|if
condition|(
name|template_header_count
condition|)
name|cp_error
argument_list|(
literal|"template parameter list used in explicit instantiation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_def
condition|)
name|cp_error
argument_list|(
literal|"definition provided for explicit instantiation"
argument_list|)
expr_stmt|;
name|explicit_instantiation
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|is_friend
condition|)
block|{
comment|/* This case catches outdated code that looks like this:  	 template<class T> struct S { void f(); }; 	 void S<int>::f() {} // Missing template<>  	 We disable this check when the type is being defined to 	 avoid complaining about default compiler-generated 	 constructors, destructors, and assignment operators. 	 Since the type is an instantiation, not a specialization, 	 these are the only functions that can be defined before 	 the class is complete.  */
comment|/* If they said 	       template<class T> void S<int>::f() {} 	     that's bogus.  */
if|if
condition|(
name|template_header_count
condition|)
block|{
name|cp_error
argument_list|(
literal|"template parameters specified in specialization"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"explicit specialization not preceded by `template<>'"
argument_list|)
expr_stmt|;
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|is_friend
condition|)
comment|/* This could be something like:  	   template<class T> void f(T); 	   class S { friend void f<>(int); }  */
name|specialization
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* This case handles bogus declarations like template<> 	     template<class T> void f<int>(); */
name|cp_error
argument_list|(
literal|"template-id `%D' in declaration of primary template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
condition|)
block|{
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"default argument specified in explicit specialization"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|cp_error
argument_list|(
literal|"template specialization with C linkage"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
operator|||
name|explicit_instantiation
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|targs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|fns
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctype
condition|)
name|fns
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
name|fns
operator|=
name|dname
expr_stmt|;
name|declarator
operator|=
name|lookup_template_function
argument_list|(
name|fns
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit_instantiation
condition|)
comment|/* A specialization in class scope.  This is illegal, 	       but the error will already have been flagged by 	       check_specialization_scope.  */
return|return
name|error_mark_node
return|;
else|else
block|{
comment|/* It's not legal to write an explicit instantiation in 		 class scope, e.g.:  	           class C { template void f(); }  		   This case is caught by the parser.  However, on 		   something like: 	        		   template class C { void f(); };  		   (which is illegal) we can get here.  The error will be 		   issued later.  */
empty_stmt|;
block|}
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
block|{
comment|/* A friend declaration.  We can't do much, because we don't 	   know what this resolves to, yet.  */
name|my_friendly_assert
argument_list|(
name|is_friend
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|explicit_instantiation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
comment|/* Find the list of functions in ctype that have the same 	     name as the declared function.  */
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|fns
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|constructor_name
argument_list|(
name|ctype
argument_list|)
operator|||
name|name
operator|==
name|constructor_name_full
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|int
name|is_constructor
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_constructor
condition|?
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
else|:
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* From [temp.expl.spec]: 		        		     If such an explicit specialization for the member 		     of a class template names an implicitly-declared 		     special member function (clause _special_), the 		     program is ill-formed.    		     Similar language is found in [temp.explicit].  */
name|cp_error
argument_list|(
literal|"specialization of implicitly-declared special member function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|name
operator|=
name|is_constructor
condition|?
name|ctor_identifier
else|:
name|dtor_identifier
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|idx
operator|=
name|lookup_fnfields_1
argument_list|(
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|methods
decl_stmt|;
comment|/* For a type-conversion operator, we cannot do a 		 name-based lookup.  We might be looking for `operator 		 int' which will be a specialization of `operator T'. 		 So, we find *all* the conversion operators, and then 		 select from them.  */
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
condition|)
for|for
control|(
name|idx
operator|=
literal|2
init|;
name|idx
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|methods
argument_list|)
condition|;
operator|++
name|idx
control|)
block|{
name|tree
name|ovl
init|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ovl
operator|||
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ovl
argument_list|)
argument_list|)
condition|)
comment|/* There are no more conversion functions.  */
break|break;
comment|/* Glue all these conversion functions together 		       with those we already have.  */
for|for
control|(
init|;
name|ovl
condition|;
name|ovl
operator|=
name|OVL_NEXT
argument_list|(
name|ovl
argument_list|)
control|)
name|fns
operator|=
name|ovl_cons
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ovl
argument_list|)
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"no member function `%D' declared in `%T'"
argument_list|,
name|name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|=
name|fns
expr_stmt|;
block|}
comment|/* Figure out what exactly is being specialized at this point. 	 Note that for an explicit instantiation, even one for a 	 member function, we cannot tell apriori whether the 	 instantiation is for a member template, or just a member 	 function of a template class.  Even if a member template is 	 being instantiated, the member template arguments may be 	 elided if they can be deduced from the rest of the 	 declaration.  */
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|declarator
argument_list|,
name|decl
argument_list|,
operator|&
name|targs
argument_list|,
name|member_specialization
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
name|tmpl
operator|==
name|error_mark_node
condition|)
comment|/* We couldn't figure out what this declaration was 	   specializing.  */
return|return
name|error_mark_node
return|;
else|else
block|{
name|tree
name|gen_tmpl
init|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
if|if
condition|(
name|explicit_instantiation
condition|)
block|{
comment|/* We don't set DECL_EXPLICIT_INSTANTIATION here; that 		 is done by do_decl_instantiation later.  */
name|int
name|arg_depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|parm_depth
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_depth
operator|>
name|parm_depth
condition|)
block|{
comment|/* If TMPL is not the most general template (for 		     example, if TMPL is a friend template that is 		     injected into namespace scope), then there will 		     be too many levels fo TARGS.  Remove some of them 		     here.  */
name|int
name|i
decl_stmt|;
name|tree
name|new_targs
decl_stmt|;
name|new_targs
operator|=
name|make_temp_vec
argument_list|(
name|parm_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg_depth
operator|-
name|parm_depth
init|;
name|i
operator|<
name|arg_depth
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_targs
argument_list|,
name|i
operator|-
operator|(
name|arg_depth
operator|-
name|parm_depth
operator|)
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|targs
operator|=
name|new_targs
expr_stmt|;
block|}
name|decl
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* If we though that the DECL was a member function, but it 	     turns out to be specializing a static member function, 	     make DECL a static member function as well.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|revert_static_member_fn
argument_list|(
operator|&
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the DECL_TEMPLATE_INFO for DECL.  */
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Mangle the function name appropriately.  Note that we do 	     not mangle specializations of non-template member 	     functions of template classes, e.g. with  	       template<class T> struct S { void f(); }  	     and given the specialization   	       template<> void S<int>::f() {}  	     we do not mangle S<int>::f() here.  That's because it's 	     just an ordinary member function and doesn't need special 	     treatment.  We do this here so that the ordinary, 	     non-template, name-mangling algorith will not be used 	     later.  */
if|if
condition|(
operator|(
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|||
name|ctype
operator|==
name|NULL_TREE
operator|)
operator|&&
name|name_mangling_version
operator|>=
literal|1
condition|)
name|set_mangled_name_for_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_friend
operator|&&
operator|!
name|have_def
condition|)
comment|/* This is not really a declaration of a specialization. 	       It's just the name of an instantiation.  But, it's not 	       a request for an instantiation, either.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Register this specialization so that we can find it 	     again.  */
name|decl
operator|=
name|register_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|,
name|targs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* TYPE is being declared.  Verify that the use of template headers    and such is reasonable.  Issue error messages if not.  */
end_comment

begin_function
name|void
name|maybe_check_template_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|template_header_count
condition|)
block|{
comment|/* We are in the scope of some `template<...>' header.  */
name|int
name|context_depth
init|=
name|template_class_depth_real
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*count_specializations=*/
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|template_header_count
operator|<=
name|context_depth
condition|)
comment|/* This is OK; the template headers are for the context.  We 	   are actually too lenient here; like 	   check_explicit_specialization we should consider the number 	   of template types included in the actual declaration.  For 	   example,   	     template<class T> struct S { 	       template<class U> template<class V> 	       struct I {}; 	     };   	   is illegal, but:  	     template<class T> struct S { 	       template<class U> struct I; 	     };   	     template<class T> template<class U. 	     struct S<T>::I {};  	   is not.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|template_header_count
operator|>
name|context_depth
operator|+
literal|1
condition|)
comment|/* There are two many template parameter lists.  */
name|cp_error
argument_list|(
literal|"too many template parameter lists in declaration of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 iff PARMS1 and PARMS2 are identical sets of template    parameters.  These are represented in the same format used for    DECL_TEMPLATE_PARMS.  */
end_comment

begin_function
name|int
name|comp_template_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|;
name|tree
name|parms2
decl_stmt|;
block|{
name|tree
name|p1
decl_stmt|;
name|tree
name|p2
decl_stmt|;
if|if
condition|(
name|parms1
operator|==
name|parms2
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p1
operator|=
name|parms1
operator|,
name|p2
operator|=
name|parms2
init|;
name|p1
operator|!=
name|NULL_TREE
operator|&&
name|p2
operator|!=
name|NULL_TREE
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|p1
operator|!=
name|NULL_TREE
operator|)
operator|!=
operator|(
name|p2
operator|!=
name|NULL_TREE
operator|)
condition|)
comment|/* One set of parameters has more parameters lists than the        other.  */
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Complain if DECL shadows a template parameter.     [temp.local]: A template-parameter shall not be redeclared within its    scope (including nested scopes).  */
end_comment

begin_function
name|void
name|check_template_shadow
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|olddecl
decl_stmt|;
comment|/* If we're not in a template, we can't possibly shadow a template      parameter.  */
if|if
condition|(
operator|!
name|current_template_parms
condition|)
return|return;
comment|/* Figure out what we're shadowing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|decl
operator|=
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|olddecl
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no previous binding for this name, we're not shadowing      anything, let alone a template parameter.  */
if|if
condition|(
operator|!
name|olddecl
condition|)
return|return;
comment|/* If we're not shadowing a template parameter, we're done.  Note      that OLDDECL might be an OVERLOAD (or perhaps even an      ERROR_MARK), so we can't just blithely assume it to be a _DECL      node.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|!=
literal|'d'
operator|||
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return;
comment|/* We check for decl != olddecl to avoid bogus errors for using a      name inside a class.  We check TPFI to avoid duplicate errors for      inline member templates.  */
if|if
condition|(
name|decl
operator|==
name|olddecl
operator|||
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
condition|)
return|return;
name|cp_error_at
argument_list|(
literal|"declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|" shadows template parm `%#D'"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,    ORIG_LEVEL, DECL, and TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_parm_index
parameter_list|(
name|index
parameter_list|,
name|level
parameter_list|,
name|orig_level
parameter_list|,
name|decl
parameter_list|,
name|type
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|orig_level
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TEMPLATE_PARM_INDEX
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
operator|=
name|index
expr_stmt|;
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|level
expr_stmt|;
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|orig_level
expr_stmt|;
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose    TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a    new one is created.  */
end_comment

begin_function
specifier|static
name|tree
name|reduce_template_parm_level
parameter_list|(
name|index
parameter_list|,
name|type
parameter_list|,
name|levels
parameter_list|)
name|tree
name|index
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|levels
decl_stmt|;
block|{
if|if
condition|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
operator|)
condition|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
init|=
name|build_template_parm_index
argument_list|(
name|TEMPLATE_PARM_IDX
argument_list|(
name|index
argument_list|)
argument_list|,
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
argument_list|,
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|index
argument_list|)
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Template template parameters need this.  */
name|DECL_TEMPLATE_PARMS
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process information from new template parameter NEXT and append it to the    LIST being built.  */
end_comment

begin_function
name|tree
name|process_template_parm
parameter_list|(
name|list
parameter_list|,
name|next
parameter_list|)
name|tree
name|list
decl_stmt|,
name|next
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|tree
name|defval
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|idx
decl_stmt|;
name|parm
operator|=
name|next
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|259
argument_list|)
expr_stmt|;
name|defval
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|==
name|class_type_node
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|list
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
else|else
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|260
argument_list|)
expr_stmt|;
comment|/* is a const-param */
name|parm
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* [temp.param]  	 The top-level cv-qualifiers on the template-parameter are 	 ignored when determining its type.  */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A template parameter is not modifiable.  */
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|TYPENAME_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%#T' is not a valid type for a template constant parameter"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"  a template type parameter must begin with `class' or `typename'"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"`%T' is not a valid type for a template constant parameter"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parm
operator|=
name|copy_node
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|&&
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|TEMPLATE_TEMPLATE_PARM
argument_list|)
expr_stmt|;
comment|/* This is for distinguishing between real templates and template  	     template parameters */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
name|t
expr_stmt|;
name|decl
operator|=
name|parm
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|TEMPLATE_TYPE_PARM
argument_list|)
expr_stmt|;
comment|/* parm is either IDENTIFIER_NODE or NULL_TREE */
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|parm
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|parm
operator|=
name|decl
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_tree_list
argument_list|(
name|defval
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The end of a template parameter list has been reached.  Process the    tree list into a parameter vector, converting each parameter into a more    useful form.	 Type parameters are saved as IDENTIFIER_NODEs, and others    as PARM_DECLs.  */
end_comment

begin_function
name|tree
name|end_template_parm_list
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|saved_parmlist
init|=
name|make_tree_vec
argument_list|(
name|list_length
argument_list|(
name|parms
argument_list|)
argument_list|)
decl_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|build_int_2
argument_list|(
literal|0
argument_list|,
name|processing_template_decl
argument_list|)
argument_list|,
name|saved_parmlist
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
operator|,
name|nparms
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|nparms
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
operator|=
name|parm
expr_stmt|;
operator|--
name|processing_template_parmlist
expr_stmt|;
return|return
name|saved_parmlist
return|;
block|}
end_function

begin_comment
comment|/* end_template_decl is called after a template declaration is seen.  */
end_comment

begin_function
name|void
name|end_template_decl
parameter_list|()
block|{
name|reset_specialization
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return;
comment|/* This matches the pushlevel in begin_template_parm_list.  */
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
comment|/* Why? */
block|}
end_function

begin_comment
comment|/* Given a template argument vector containing the template PARMS.    The innermost PARMS are given first.  */
end_comment

begin_function
name|tree
name|current_template_args
parameter_list|()
block|{
name|tree
name|header
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|length
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|current_template_parms
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|length
decl_stmt|;
comment|/* If there is only one level of template parameters, we do not      create a TREE_VEC of TREE_VECs.  Instead, we return a single      TREE_VEC containing the arguments.  */
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|args
operator|=
name|make_tree_vec
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|current_template_parms
init|;
name|header
condition|;
name|header
operator|=
name|TREE_CHAIN
argument_list|(
name|header
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|copy_node
argument_list|(
name|TREE_VALUE
argument_list|(
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* T will be a list if we are called from within a 	     begin/end_template_parm_list pair, but a vector directly 	     if within a begin/end_member_template_processing pair.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
operator|--
name|l
argument_list|)
operator|=
name|a
expr_stmt|;
else|else
name|args
operator|=
name|a
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_DECL corresponding to DECL, using the indicated    template PARMS.  Used by push_template_decl below.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_decl
parameter_list|(
name|decl
parameter_list|,
name|parms
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|parms
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_CLASS_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|tmpl
return|;
block|}
end_function

begin_struct
struct|struct
name|template_parm_data
block|{
comment|/* The level of the template parameters we are currently      processing.  */
name|int
name|level
decl_stmt|;
comment|/* The index of the specialization argument we are currently      processing.  */
name|int
name|current_arg
decl_stmt|;
comment|/* An array whose size is the number of template parameters.  The      elements are non-zero if the parameter has been used in any one      of the arguments processed so far.  */
name|int
modifier|*
name|parms
decl_stmt|;
comment|/* An array whose size is the number of template arguments.  The      elements are non-zero if the argument makes use of template      parameters of this level.  */
name|int
modifier|*
name|arg_uses_template_parms
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Subroutine of push_template_decl used to see if each template    parameter in a partial specialization is used in the explicit    argument list.  If T is of the LEVEL given in DATA (which is    treated as a template_parm_data*), then DATA->PARMS is marked    appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|mark_template_parm
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|template_parm_data
modifier|*
name|tpd
init|=
operator|(
expr|struct
name|template_parm_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|tpd
operator|->
name|level
condition|)
block|{
name|tpd
operator|->
name|parms
index|[
name|idx
index|]
operator|=
literal|1
expr_stmt|;
name|tpd
operator|->
name|arg_uses_template_parms
index|[
name|tpd
operator|->
name|current_arg
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return zero so that for_each_template_parm will continue the      traversal of the tree; we want to mark *every* template parm.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the partial specialization DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|process_partial_specialization
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|maintmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|specargs
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|inner_args
init|=
name|innermost_args
argument_list|(
name|specargs
argument_list|)
decl_stmt|;
name|tree
name|inner_parms
init|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|current_template_parms
argument_list|)
decl_stmt|;
name|tree
name|main_inner_parms
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|maintmpl
argument_list|)
decl_stmt|;
name|int
name|nargs
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_args
argument_list|)
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|did_error_intro
init|=
literal|0
decl_stmt|;
name|struct
name|template_parm_data
name|tpd
decl_stmt|;
name|struct
name|template_parm_data
name|tpd2
decl_stmt|;
comment|/* We check that each of the template parameters given in the      partial specialization is used in the argument list to the      specialization.  For example:         template<class T> struct S;        template<class T> struct S<T*>;       The second declaration is OK because `T*' uses the template      parameter T, whereas         template<class T> struct S<int>;       is no good.  Even trickier is:         template<class T>        struct S1        { 	  template<class U> 	  struct S2; 	  template<class U> 	  struct S2<T>;        };       The S2<T> declaration is actually illegal; it is a      full-specialization.  Of course,   	  template<class U> 	  struct S2<T (*)(U)>;       or some such would have been OK.  */
name|tpd
operator|.
name|level
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|parms
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|PTR
operator|)
name|tpd
operator|.
name|parms
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|arg_uses_template_parms
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|PTR
operator|)
name|tpd
operator|.
name|arg_uses_template_parms
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|tpd
operator|.
name|current_arg
operator|=
name|i
expr_stmt|;
name|for_each_template_parm
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|tpd
operator|.
name|parms
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* One of the template parms was not used in the            specialization.  */
if|if
condition|(
operator|!
name|did_error_intro
condition|)
block|{
name|cp_error
argument_list|(
literal|"template parameters not used in partial specialization:"
argument_list|)
expr_stmt|;
name|did_error_intro
operator|=
literal|1
expr_stmt|;
block|}
name|cp_error
argument_list|(
literal|"        `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.class.spec]       The argument list of the specialization shall not be identical to      the implicit argument list of the primary template.  */
if|if
condition|(
name|comp_template_args
argument_list|(
name|inner_args
argument_list|,
name|innermost_args
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"partial specialization `%T' does not specialize any template arguments"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* [temp.class.spec]       A partially specialized non-type argument expression shall not      involve template parameters of the partial specialization except      when the argument expression is a simple identifier.       The type of a template parameter corresponding to a specialized      non-type argument shall not be dependent on a parameter of the      specialization.  */
name|my_friendly_assert
argument_list|(
name|nargs
operator|==
name|DECL_NTPARMS
argument_list|(
name|maintmpl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tpd2
operator|.
name|parms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
comment|/* These first two lines are the `non-type' bit.  */
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_DECL
comment|/* This next line is the `argument expression is not just a 	     simple identifier' condition and also the `specialized 	     non-type argument' bit.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
block|{
if|if
condition|(
name|tpd
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
condition|)
name|cp_error
argument_list|(
literal|"template argument `%E' involves template parameter(s)"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Look at the corresponding template parameter, 		 marking which template parameters its type depends 		 upon.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|main_inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tpd2
operator|.
name|parms
condition|)
block|{
comment|/* We haven't yet initialized TPD2.  Do so now.  */
name|tpd2
operator|.
name|arg_uses_template_parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
comment|/* The number of parameters here is the number in the 		     main template, which, as checked in the assertion 		     above, is NARGS.  */
name|tpd2
operator|.
name|parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|tpd2
operator|.
name|level
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the template parameters.  But this time, we're 		 looking for the template parameters of the main 		 template, not in the specialization.  */
name|tpd2
operator|.
name|current_arg
operator|=
name|i
expr_stmt|;
name|tpd2
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|PTR
operator|)
name|tpd2
operator|.
name|parms
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|for_each_template_parm
argument_list|(
name|type
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpd2
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
condition|)
block|{
comment|/* The type depended on some template parameters. 		     If they are fully specialized in the 		     specialization, that's OK.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nargs
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|tpd2
operator|.
name|parms
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|tpd
operator|.
name|arg_uses_template_parms
index|[
name|j
index|]
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' of template argument `%E' depends on template parameter(s)"
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|retrieve_specialization
argument_list|(
name|maintmpl
argument_list|,
name|specargs
argument_list|)
condition|)
comment|/* We've already got this specialization.  */
return|return
name|decl
return|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
operator|=
name|CLASSTYPE_TI_SPEC_INFO
argument_list|(
name|type
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|inner_args
argument_list|,
name|inner_parms
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Check that a template declaration's use of default arguments is not    invalid.  Here, PARMS are the template parameters.  IS_PRIMARY is    non-zero if DECL is the thing declared by a primary template.    IS_PARTIAL is non-zero if DECL is a partial specialization.  */
end_comment

begin_function
specifier|static
name|void
name|check_default_tmpl_args
parameter_list|(
name|decl
parameter_list|,
name|parms
parameter_list|,
name|is_primary
parameter_list|,
name|is_partial
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|is_primary
decl_stmt|;
name|int
name|is_partial
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|last_level_to_check
decl_stmt|;
comment|/* [temp.param]        A default template-argument shall not be specified in a      function template declaration or a function template definition, nor      in the template-parameter-list of the definition of a member of a      class template.  */
if|if
condition|(
name|current_class_type
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
comment|/* If this is either a friend defined in the scope of the class 	 or a member function.  */
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
comment|/* And, if it was a member function, it really was defined in 	 the scope of the class.  */
operator|&&
operator|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_DEFINED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We already checked these parameters when the template was        declared, so there's no need to do it again now.  This function        was defined in class scope, but we're processing it's body now        that the class is complete.  */
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|is_partial
operator|||
operator|!
name|is_primary
condition|)
comment|/* For an ordinary class template, default template arguments are        allowed at the innermost level, e.g.:          template<class T = int> 	 struct S {};        but, in a partial specialization, they're not allowed even        there, as we have in [temp.class.spec]:       	 The template parameter list of a specialization shall not 	 contain default template argument values.           So, for a partial specialization, or for a function template,        we look at all of them.  */
empty_stmt|;
else|else
comment|/* But, for a primary class template that is not a partial        specialization we look at all template parameters except the        innermost ones.  */
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Figure out what error message to issue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|msg
operator|=
literal|"default argument for template parameter in function template `%D'"
expr_stmt|;
elseif|else
if|if
condition|(
name|is_partial
condition|)
name|msg
operator|=
literal|"default argument in partial specialization `%D'"
expr_stmt|;
else|else
name|msg
operator|=
literal|"default argument for template parameter for class enclosing `%D'"
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* If we're inside a class definition, there's no need to        examine the parameters to the class itself.  On the one        hand, they will be checked when the class is defined, and,        on the other, default arguments are legal in things like:          template<class T = double>          struct S { template<class U> void f(U); };        Here the default argument for `S' has no bearing on the        declaration of `f'.  */
name|last_level_to_check
operator|=
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* Check everything.  */
name|last_level_to_check
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|parms
operator|&&
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|>=
name|last_level_to_check
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ntparms
decl_stmt|;
name|ntparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
condition|)
block|{
name|cp_error
argument_list|(
name|msg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear out the default argument so that we are not 	       confused later.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* At this point, if we're still interested in issuing messages, 	 they must apply to classes surrounding the object declared.  */
if|if
condition|(
name|msg
condition|)
name|msg
operator|=
literal|"default argument for template parameter for class enclosing `%D'"
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates a TEMPLATE_DECL for the indicated DECL using the template    parameters given by current_template_args, or reuses a    previously existing one, if appropriate.  Returns the DECL, or an    equivalent one, if it is replaced via a call to duplicate_decls.       If IS_FRIEND is non-zero, DECL is a friend declaration.  */
end_comment

begin_function
name|tree
name|push_template_decl_real
parameter_list|(
name|decl
parameter_list|,
name|is_friend
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|is_friend
decl_stmt|;
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|info
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|primary
decl_stmt|;
name|int
name|is_partial
decl_stmt|;
comment|/* See if this is a partial specialization.  */
name|is_partial
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|is_friend
operator||=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_friend
condition|)
comment|/* For a friend, we want the context of the friend function, not        the type of which it is a friend.  */
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
comment|/* In the case of a virtual function, we want the class in which        it is defined.  */
name|ctx
operator|=
name|DECL_REAL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, if we're currently definining some class, the DECL        is assumed to be a member of the class.  */
name|ctx
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* For determining whether this is a primary template or not, we're really      interested in the lexical context, not the true context.  */
if|if
condition|(
name|is_friend
condition|)
name|info
operator|=
name|current_class_type
expr_stmt|;
else|else
name|info
operator|=
name|ctx
expr_stmt|;
comment|/* See if this is a primary template.  */
if|if
condition|(
name|info
operator|&&
name|TREE_CODE
argument_list|(
name|info
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|primary
operator|=
literal|0
expr_stmt|;
comment|/* Note that template_class_depth returns 0 if given NULL_TREE, so      this next line works even when we are at global scope.  */
elseif|else
if|if
condition|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|info
argument_list|)
condition|)
name|primary
operator|=
literal|1
expr_stmt|;
else|else
name|primary
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|cp_error
argument_list|(
literal|"template with C linkage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"template class without a name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|cp_error
argument_list|(
literal|"template declaration of `%#T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that the rules regarding the use of default      arguments are not being violated.  */
name|check_default_tmpl_args
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|,
name|primary
argument_list|,
name|is_partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_partial
condition|)
return|return
name|process_partial_specialization
argument_list|(
name|decl
argument_list|)
return|;
name|args
operator|=
name|current_template_args
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
operator|||
operator|(
name|is_friend
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* A specialization of a member template of a template 		 class. */
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|,
name|current
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctx
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"must specialize `%#T' before defining member `%#D'"
argument_list|,
name|ctx
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"`%D' does not declare a template type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"template definition of non-template `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|new_tmpl
decl_stmt|;
comment|/* The declaration is a specialization of a member 	     template, declared outside the class.  Therefore, the 	     innermost template arguments will be NULL, so we 	     replace them with the arguments determined by the 	     earlier call to check_explicit_specialization.  */
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|new_tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|=
name|new_tmpl
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|new_tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|new_tmpl
argument_list|,
name|tmpl
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Make sure the template headers we got make sense.  */
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|i
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|!=
name|i
condition|)
block|{
name|cp_error
argument_list|(
literal|"expected %d levels of template parms for `%#D', got %d"
argument_list|,
name|i
argument_list|,
name|decl
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|current
operator|=
name|decl
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|a
operator|=
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|decl
condition|)
name|cp_error
argument_list|(
literal|"got %d template parameters for `%#D'"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"got %d template parameters for `%#T'"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  but %d required"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Perhaps we should also check that the parms are used in the                appropriate qualifying scopes in the declarator?  */
if|if
condition|(
name|current
operator|==
name|decl
condition|)
name|current
operator|=
name|ctx
expr_stmt|;
else|else
name|current
operator|=
name|TYPE_CONTEXT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Push template declarations for global functions and types.  Note      that we do not try to push a global template friend declared in a      template class; such a thing may well depend on the template      parameters of the class.  */
if|if
condition|(
operator|!
name|ctx
operator|&&
operator|!
operator|(
name|is_friend
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|tmpl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
name|info
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|SET_TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"template declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|info
expr_stmt|;
return|return
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|push_template_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when a class template TYPE is redeclared with the indicated    template PARMS, e.g.:       template<class T> struct S;      template<class T> struct S {};  */
end_comment

begin_function
name|void
name|redeclare_class_template
parameter_list|(
name|type
parameter_list|,
name|parms
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|tmpl_parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is not a template type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
comment|/* The type is nested in some template class.  Nothing to worry        about here; there are no new template parameters for the nested        type.  */
return|return;
name|parms
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|tmpl_parms
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"previous declaration `%D'"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"used %d template parameter%s instead of %d"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmpl_parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tmpl_default
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm_default
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmpl_parm
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"template parameter `%#D'"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"redeclared here as `%#D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmpl_default
operator|!=
name|NULL_TREE
operator|&&
name|parm_default
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We have in [temp.param]:  	     A template-parameter may not be given default arguments 	     by two different declarations in the same scope.  */
name|cp_error
argument_list|(
literal|"redefinition of default argument for `%#D'"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  original definition appeared here"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm_default
operator|!=
name|NULL_TREE
condition|)
comment|/* Update the previous template parameters (which are the ones 	   that will really count) with the new default value.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|parm_default
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to convert the non-type template parameter EXPR to the    indicated TYPE.  If the conversion is successful, return the    converted value.  If the conversion is unsuccesful, return    NULL_TREE if we issued an error message, or error_mark_node if we    did not.  We issue error messages for out-and-out bad template    parameters, but not simply because the conversion failed, since we    might be just trying to do argument deduction.  By the time this    function is called, neither TYPE nor EXPR may make use of template    parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nontype_argument
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|expr_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* A template-argument for a non-type, non-template      template-parameter shall be one of:       --an integral constant-expression of integral or enumeration      type; or            --the name of a non-type template-parameter; or            --the name of an object or function with external linkage,      including function templates and function template-ids but      excluding non-static class members, expressed as id-expression;      or            --the address of an object or function with external linkage,      including function templates and function template-ids but      excluding non-static class members, expressed as& id-expression      where the& is optional if the name refers to a function or      array; or            --a pointer to member expressed as described in _expr.unary.op_.  */
comment|/* An integral constant-expression can include const variables      or enumerators.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TREE_READONLY_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* OK for now.  We'll check that it has external linkage later.        Check this first since if expr_type is the unknown_type_node        we would otherwise complain below.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PTRMEM_CST
condition|)
goto|goto
name|bad_argument
goto|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
comment|/* If expr is the address of an overloaded function, we 	      will get the unknown_type_node at this point.  */
operator|||
name|expr_type
operator|==
name|unknown_type_node
condition|)
block|{
name|tree
name|referent
decl_stmt|;
name|tree
name|e
init|=
name|expr
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|referent
operator|=
name|e
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
name|bad_argument
label|:
name|cp_error
argument_list|(
literal|"`%E' is not a valid template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|cp_error
argument_list|(
literal|"it must be the address of a function with external linkage"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"it must be the address of an object with external linkage"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"it must be a pointer-to-member of the form `&X::Y'"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|referent
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|referent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|referent
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|cp_error
argument_list|(
literal|"string literal %E is not a valid template argument"
argument_list|,
name|referent
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"because it is the address of an object with static linkage"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|referent
argument_list|)
condition|)
comment|/* We'll check that it has external linkage later.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|referent
argument_list|)
operator|!=
name|VAR_DECL
condition|)
goto|goto
name|bad_argument
goto|;
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|referent
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"address of non-extern `%E' cannot be used as template argument"
argument_list|,
name|referent
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|expr_type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
comment|/* The next two are g++ extensions.  */
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|non_constant
label|:
name|cp_error
argument_list|(
literal|"non-constant `%E' cannot be used as template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"object `%E' cannot be used as template argument"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
comment|/* For a non-type template-parameter of integral or enumeration          type, integral promotions (_conv.prom_) and integral          conversions (_conv.integral_) are applied. */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* It's safe to call digest_init in this case; we know we're 	 just converting one integral constant expression to another.  */
name|expr
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
comment|/* Curiously, some TREE_CONSTANT integral expressions do not 	   simplify to integer constants.  For example, `3 % 0', 	   remains a TRUNC_MOD_EXPR.  */
goto|goto
name|non_constant
goto|;
return|return
name|expr
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
comment|/* These are g++ extensions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|REAL_CST
condition|)
goto|goto
name|non_constant
goto|;
return|return
name|expr
return|;
case|case
name|POINTER_TYPE
case|:
block|{
name|tree
name|type_pointed_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|e
decl_stmt|;
comment|/* For a non-type template-parameter of type pointer to data 	       member, qualification conversions (_conv.qual_) are 	       applied.  */
name|e
operator|=
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|NOP_EXPR
condition|)
comment|/* The call to perform_qualification_conversions will 		 insert a NOP_EXPR over EXPR to do express conversion, 		 if necessary.  But, that will confuse us if we use 		 this (converted) template parameter to instantiate 		 another template; then the thing will not look like a 		 valid template argument.  So, just make a new 		 constant, of the appropriate type.  */
name|e
operator|=
name|make_ptrmem_cst
argument_list|(
name|type
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_pointed_to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* For a non-type template-parameter of type pointer to 	       function, only the function-to-pointer conversion 	       (_conv.func_) is applied.  If the template-argument 	       represents a set of overloaded functions (or a pointer to 	       such), the matching function is selected from the set 	       (_over.over_).  */
name|tree
name|fns
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fns
operator|=
name|expr
expr_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type_pointed_to
argument_list|,
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
goto|goto
name|bad_argument
goto|;
block|}
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
block|{
comment|/* For a non-type template-parameter of type pointer to 	       object, qualification conversions (_conv.qual_) and the 	       array-to-pointer conversion (_conv.array_) are applied. 	       [Note: In particular, neither the null pointer conversion 	       (_conv.ptr_) nor the derived-to-base conversion 	       (_conv.ptr_) are applied.  Although 0 is a valid 	       template-argument for a non-type template-parameter of 	       integral type, it is not a valid template-argument for a 	       non-type template-parameter of pointer type.]   	     	       The call to decay_conversion performs the 	       array-to-pointer conversion, if appropriate.  */
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
block|{
name|tree
name|type_referred_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_referred_to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* For a non-type template-parameter of type reference to 	       function, no conversions apply.  If the 	       template-argument represents a set of overloaded 	       functions, the matching function is selected from the 	       set (_over.over_).  */
name|tree
name|fns
init|=
name|expr
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type_referred_to
argument_list|,
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
comment|/* Don't issue an error here; we might get a different 		     function if the overloading had worked out 		     differently.  */
return|return
name|error_mark_node
return|;
else|else
goto|goto
name|bad_argument
goto|;
block|}
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|type_referred_to
argument_list|,
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
else|else
block|{
comment|/* For a non-type template-parameter of type reference to 	       object, no conversions apply.  The type referred to by the 	       reference may be more cv-qualified than the (otherwise 	       identical) type of the template-argument.  The 	       template-parameter is bound directly to the 	       template-argument, which must be an lvalue.  */
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_referred_to
argument_list|)
operator|)
operator|||
operator|!
name|at_least_as_qualified_p
argument_list|(
name|type_referred_to
argument_list|,
name|expr_type
argument_list|)
operator|||
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|expr
return|;
block|}
block|}
break|break;
case|case
name|RECORD_TYPE
case|:
block|{
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* This handles templates like 	       template<class T, T t> void f(); 	     when T is substituted with any class.  The second template 	     parameter becomes invalid and the template candidate is 	     rejected.  */
return|return
name|error_mark_node
return|;
comment|/* For a non-type template-parameter of type pointer to member 	   function, no conversions apply.  If the template-argument 	   represents a set of overloaded member functions, the 	   matching member function is selected from the set 	   (_over.over_).  */
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|expr_type
operator|!=
name|unknown_type_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
comment|/* A ptr-to-member constant.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|type
argument_list|,
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
else|else
return|return
name|expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
break|break;
default|default:
comment|/* All non-type parameters must have one of these types.  */
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARM_PARMS and ARG_PARMS matches using rule for     template template parameters.  Both PARM_PARMS and ARG_PARMS are     vectors of TREE_LIST nodes containing TYPE_DECL, TEMPLATE_DECL     or PARM_DECL.        ARG_PARMS may contain more parameters than PARM_PARMS.  If this is     the case, then extra parameters must have default arguments.     Consider the example:      template<class T, class Allocator = allocator> class vector;      template<template<class U> class TT> class C;     C<vector> is a valid instantiation.  PARM_PARMS for the above code     contains a TYPE_DECL (for U),  ARG_PARMS contains two TYPE_DECLs (for     T and Allocator) and OUTER_ARGS contains the argument that is used to     substitute the TT parameter.  */
end_comment

begin_function
specifier|static
name|int
name|coerce_template_template_parms
parameter_list|(
name|parm_parms
parameter_list|,
name|arg_parms
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|,
name|outer_args
parameter_list|)
name|tree
name|parm_parms
decl_stmt|,
name|arg_parms
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|,
name|outer_args
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm_parms
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arg_parms
argument_list|)
expr_stmt|;
comment|/* The rule here is opposite of coerce_template_parms.  */
if|if
condition|(
name|nargs
operator|<
name|nparms
operator|||
operator|(
name|nargs
operator|>
name|nparms
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|nparms
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
operator|++
name|i
control|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parm_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
operator|||
name|arg
operator|==
name|error_mark_node
operator|||
name|parm
operator|==
name|NULL_TREE
operator|||
name|parm
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
break|break;
case|case
name|TEMPLATE_DECL
case|:
comment|/* We encounter instantiations of templates like 	       template<template<template<class> class> class TT> 	       class C;  */
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|outer_args
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
comment|/* The tsubst call is used to handle cases such as 	       template<class T, template<T> class TT> class D;   	     i.e. the parameter list of TT depends on earlier parameters.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|outer_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert the indicated template ARG as necessary to match the    indicated template PARM.  Returns the converted ARG, or    error_mark_node if the conversion was unsuccessful.  Error messages    are issued if COMPLAIN is non-zero.  This conversion is for the Ith    parameter in the parameter list.  ARGS is the full set of template    arguments deduced so far.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_template_argument
parameter_list|(
name|parm
parameter_list|,
name|arg
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|i
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|requires_type
decl_stmt|,
name|is_tmpl_type
decl_stmt|,
name|requires_tmpl_type
decl_stmt|;
name|inner_args
operator|=
name|innermost_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The template argument was the name of some 	 member function.  That's usually 	 illegal, but static members are OK.  In any 	 case, grab the underlying fields/functions 	 and issue an error later if required.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
name|requires_tmpl_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
expr_stmt|;
name|requires_type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|requires_tmpl_type
operator|)
expr_stmt|;
comment|/* Check if it is a class template.  If REQUIRES_TMPL_TYPE is true,      we also accept implicitly created TYPE_DECL as a valid argument.      This is necessary to handle the case where we pass a template name      to a template template parameter in a scope where we've derived from      in instantiation of that template, so the template name refers to that      instantiation.  We really ought to handle this better.  */
name|is_tmpl_type
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
operator|!
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
name|requires_tmpl_type
operator|&&
name|is_base_of_enclosing_class
argument_list|(
name|arg
argument_list|,
name|current_class_type
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|arg
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tmpl_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|arg
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|||
name|is_tmpl_type
expr_stmt|;
if|if
condition|(
name|requires_type
operator|&&
operator|!
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"to refer to a type member of a template parameter,"
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"  use `typename %E'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|make_typename_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|is_type
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_type
operator|!=
name|requires_type
condition|)
block|{
if|if
condition|(
name|in_decl
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
name|cp_error
argument_list|(
literal|"  expected a constant of type `%T', got `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|(
name|is_tmpl_type
condition|?
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
else|:
name|arg
operator|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"  expected a type, got `%E'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_tmpl_type
operator|^
name|requires_tmpl_type
condition|)
block|{
if|if
condition|(
name|in_decl
operator|&&
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
condition|)
name|cp_error
argument_list|(
literal|"  expected a type, got `%T'"
argument_list|,
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"  expected a class template, got `%T'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_type
condition|)
block|{
if|if
condition|(
name|requires_tmpl_type
condition|)
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|inner_args
argument_list|)
condition|)
block|{
name|val
operator|=
name|arg
expr_stmt|;
comment|/* TEMPLATE_TEMPLATE_PARM node is preferred over  		 TEMPLATE_DECL.  */
if|if
condition|(
name|val
operator|!=
name|error_mark_node
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in_decl
operator|&&
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"type/value mismatch at argument %d in template parameter list for `%D'"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  expected a template of type `%D', got `%D'"
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
name|groktypename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the 		 name of a class or enumeration declared in a local 		 scope) shall not be used to declare an entity with 		 linkage.  This implies that names with no linkage 		 cannot be used as template arguments.  */
name|tree
name|t
init|=
name|no_linkage_check
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"template-argument `%T' uses anonymous type"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"template-argument `%T' uses local type `%T'"
argument_list|,
name|val
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|tree
name|t
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|arg
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|t
argument_list|)
condition|)
comment|/* We used to call digest_init here.  However, digest_init 	   will report errors, which we don't want when complain 	   is zero.  More importantly, digest_init will try too 	   hard to convert things: for example, `0' should not be 	   converted to pointer type at this point according to 	   the standard.  Accepting this is not merely an 	   extension, since deciding whether or not these 	   conversions can occur is part of determining which 	   function template to call, or whether a given epxlicit 	   argument specification is legal.  */
name|val
operator|=
name|convert_nontype_argument
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|error_mark_node
operator|&&
name|complain
condition|)
name|cp_error
argument_list|(
literal|"could not convert template argument `%E' to `%T'"
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Convert all template arguments to their appropriate types, and    return a vector containing the innermost resulting template    arguments.  If any error occurs, return error_mark_node, and, if    COMPLAIN is non-zero, issue an error message.  Some error messages    are issued even if COMPLAIN is zero; for instance, if a template    argument is composed from a local class.     If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be    provided in ARGLIST, or else trailing parameters must have default    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument    deduction for any unspecified trailing arguments.       The resulting TREE_VEC is allocated on a temporary obstack, and    must be explicitly copied if it will be permanent.  */
end_comment

begin_function
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|,
name|in_decl
parameter_list|,
name|complain
parameter_list|,
name|require_all_arguments
parameter_list|)
name|tree
name|parms
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|int
name|require_all_arguments
decl_stmt|;
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|,
name|lost
init|=
literal|0
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|new_inner_args
decl_stmt|;
name|inner_args
operator|=
name|innermost_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|NUM_TMPL_ARGS
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|nparms
operator|||
operator|(
name|nargs
operator|<
name|nparms
operator|&&
name|require_all_arguments
operator|&&
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|nargs
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|cp_error
argument_list|(
literal|"wrong number of template arguments (%d, should be %d)"
argument_list|,
name|nargs
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"provided for `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|new_inner_args
operator|=
name|make_temp_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|add_outermost_template_args
argument_list|(
name|args
argument_list|,
name|new_inner_args
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* Get the Ith template parameter.  */
name|parm
operator|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Calculate the Ith argument.  */
if|if
condition|(
name|inner_args
operator|&&
name|TREE_CODE
argument_list|(
name|inner_args
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
name|inner_args
operator|=
name|TREE_CHAIN
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If no template argument was supplied, look for a default 	 value.  */
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There was no default value.  */
name|my_friendly_assert
argument_list|(
operator|!
name|require_all_arguments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|arg
operator|=
name|tsubst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|arg
operator|=
name|tsubst_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Now, convert the Ith argument, as necessary.  */
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
condition|)
comment|/* We're out of arguments.  */
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|require_all_arguments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"template argument %d is invalid"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|convert_template_argument
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|i
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_inner_args
argument_list|,
name|i
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|lost
condition|)
return|return
name|error_mark_node
return|;
return|return
name|new_inner_args
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if template args OT and NT are equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|template_args_equal
parameter_list|(
name|ot
parameter_list|,
name|nt
parameter_list|)
name|tree
name|ot
decl_stmt|,
name|nt
decl_stmt|;
block|{
if|if
condition|(
name|nt
operator|==
name|ot
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|nt
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|nt
argument_list|)
operator|==
name|TREE_VEC
condition|)
comment|/* For member templates */
return|return
name|comp_template_args
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|same_type_p
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
else|else
return|return
operator|(
name|cp_tree_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets    of template arguments.  Returns 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_template_args
parameter_list|(
name|oldargs
parameter_list|,
name|newargs
parameter_list|)
name|tree
name|oldargs
decl_stmt|,
name|newargs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|newargs
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|nt
init|=
name|TREE_VEC_ELT
argument_list|(
name|newargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|ot
init|=
name|TREE_VEC_ELT
argument_list|(
name|oldargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|template_args_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given class template name and parameter list, produce a user-friendly name    for the instantiation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
name|name
parameter_list|,
name|parms
parameter_list|,
name|arglist
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|arglist
decl_stmt|;
block|{
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
if|if
condition|(
operator|!
name|scratch_firstobj
condition|)
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
else|else
name|obstack_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|scratch_firstobj
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|ccat
parameter_list|(
name|c
parameter_list|)
value|obstack_1grow (&scratch_obstack, (c));
define|#
directive|define
name|cat
parameter_list|(
name|s
parameter_list|)
value|obstack_grow (&scratch_obstack, (s), strlen (s))
name|cat
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|innermost_args
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nparms
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|,
literal|268
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|ccat
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cat
argument_list|(
name|type_as_string_real
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* Already substituted with real template.  Just output  		 the template name here */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|980422
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|decl_as_string
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|cat
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output the parameter declaration */
name|cat
argument_list|(
name|type_as_string_real
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|269
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* New list cell was built because old chain link was in 	     use.  */
name|my_friendly_assert
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|270
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* No need to check arglist against parmlist here; we did that 	 in coerce_template_parms, called from lookup_template_class.  */
name|cat
argument_list|(
name|expr_as_string
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|bufp
init|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|offset
operator|--
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* B<C<char>>, not B<C<char>> */
if|if
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|ccat
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ccat
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|classtype_mangled_name
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
comment|/* Specializations have already had their names set up in 	 lookup_template_class.  */
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For non-primary templates, the template parameters are 	 implicit from their surrounding context.  */
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|mangled_name
init|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
decl_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|ti
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|ti
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|ti
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
condition|)
return|return;
operator|*
name|template_tail
operator|=
name|perm_tree_cons
argument_list|(
name|build_srcloc_here
argument_list|()
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|template_tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|template_tail
argument_list|)
expr_stmt|;
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS (which    may be either a _DECL or an overloaded function or an    IDENTIFIER_NODE), and ARGLIST.  */
end_comment

begin_function
name|tree
name|lookup_template_function
parameter_list|(
name|fns
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|fns
decl_stmt|,
name|arglist
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"non-template used as template"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|!
name|type
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|type
argument_list|,
name|fns
argument_list|,
name|arglist
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|type
argument_list|,
name|fns
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class S<T>, the name S gets bound    (in build_self_reference) to a TYPE_DECL for the class, not a    TEMPLATE_DECL.  If DECL is a TYPE_DECL for current_class_type,    or one of its enclosing classes, and that type is a template,    return the associated TEMPLATE_DECL.  Otherwise, the original    DECL is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_get_template_decl_from_type_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|?
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of    parameters, find the desired type.     D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.    (Actually ARGLIST may be either a TREE_LIST or a TREE_VEC.  It will    be a TREE_LIST if called directly from the parser, and a TREE_VEC    otherwise.)  Since ARGLIST is build on the decl_obstack, we must    copy it here to keep it from being reclaimed when the decl storage    is reclaimed.     IN_DECL, if non-NULL, is the template declaration we are trying to    instantiate.       If ENTERING_SCOPE is non-zero, we are about to enter the scope of    the class we are looking up.     If the template class is really a local class in a template    function, then the FUNCTION_CONTEXT is the function in which it is    being instantiated.  */
end_comment

begin_function
name|tree
name|lookup_template_class
parameter_list|(
name|d1
parameter_list|,
name|arglist
parameter_list|,
name|in_decl
parameter_list|,
name|context
parameter_list|,
name|entering_scope
parameter_list|)
name|tree
name|d1
decl_stmt|,
name|arglist
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|entering_scope
decl_stmt|;
block|{
name|tree
name|template
init|=
name|NULL_TREE
decl_stmt|,
name|parmlist
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_VALUE
argument_list|(
name|d1
argument_list|)
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|IDENTIFIER_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
name|template
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|context
condition|)
name|push_decl_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
name|template
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|template
operator|==
name|NULL_TREE
condition|)
name|template
operator|=
name|lookup_name_nonclass
argument_list|(
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|template
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
decl_stmt|;
comment|/* If we are declaring a constructor, say A<T>::A<T>, we will get 	 an implicit typename for the second A.  Deal with it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|d1
argument_list|)
operator|)
condition|)
block|{
name|template
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|template
operator|=
name|d1
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|272
argument_list|)
expr_stmt|;
comment|/* With something like `template<class T> class X class X { ... };'      we could end up with D1 having nothing but an IDENTIFIER_VALUE.      We don't want to do that, but we have to deal with the situation,      so let's give them some syntax errors to chew on instead of a      crash.  */
if|if
condition|(
operator|!
name|template
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is not a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|context
operator|==
name|NULL_TREE
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"non-template type `%T' used as a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|cp_error_at
argument_list|(
literal|"for template declaration `%D'"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
comment|/* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store          template arguments */
name|tree
name|parm
init|=
name|copy_template_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|template2
init|=
name|TYPE_STUB_DECL
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|arglist2
decl_stmt|;
name|parmlist
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|arglist2
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|arglist2
operator|=
name|copy_to_permanent
argument_list|(
name|arglist2
argument_list|)
expr_stmt|;
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|template2
argument_list|,
name|arglist2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|parm
return|;
block|}
else|else
block|{
name|tree
name|template_type
init|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|type_decl
decl_stmt|;
name|tree
name|found
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|arg_depth
decl_stmt|;
name|int
name|parm_depth
decl_stmt|;
name|int
name|is_partial_instantiation
decl_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|parm_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|arg_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* We build up the coerced arguments and such on the 	 momentary_obstack.  */
name|push_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg_depth
operator|==
literal|1
operator|&&
name|parm_depth
operator|>
literal|1
condition|)
block|{
comment|/* We've been given an incomplete set of template arguments. 	     For example, given:  	       template<class T> struct S1 { 	         template<class U> struct S2 {}; 		 template<class U> struct S2<U*> {}; 	        }; 	      	     we will be called with an ARGLIST of `U*', but the 	     TEMPLATE will be `template<class T> template<class U> struct S1<T>::S2'.  We must fill in the missing 	     arguments.  */
name|arglist
operator|=
name|add_outermost_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arg_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
comment|/* Now we should enough arguments.  */
name|my_friendly_assert
argument_list|(
name|parm_depth
operator|==
name|arg_depth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* From here on, we're only interested in the most general 	 template.  */
name|template
operator|=
name|gen_tmpl
expr_stmt|;
comment|/* Calculate the BOUND_ARGS.  These will be the args that are 	 actually tsubst'd into the definition to create the 	 instantiation.  */
if|if
condition|(
name|parm_depth
operator|>
literal|1
condition|)
block|{
comment|/* We have multiple levels of arguments to coerce, at once.  */
name|int
name|i
decl_stmt|;
name|int
name|saved_depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|bound_args
init|=
name|make_temp_vec
argument_list|(
name|parm_depth
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|saved_depth
operator|,
name|t
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|t
operator|!=
name|NULL_TREE
condition|;
operator|--
name|i
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|coerce_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|bound_args
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
expr_stmt|;
comment|/* We temporarily reduce the length of the ARGLIST so 		 that coerce_template_parms will see only the arguments 		 corresponding to the template parameters it is 		 examining.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
block|}
comment|/* Restore the ARGLIST to its full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|=
name|saved_depth
expr_stmt|;
name|arglist
operator|=
name|bound_args
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|coerce_template_parms
argument_list|(
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|innermost_args
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|template
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|==
name|error_mark_node
condition|)
comment|/* We were unable to bind the arguments.  */
return|return
name|error_mark_node
return|;
comment|/* In the scope of a template class, explicit references to the 	 template class refer to the type of the template, not any 	 instantiation of it.  For example, in: 	  	   template<class T> class C { void f(C<T>); }  	 the `C<T>' is just the same as `C'.  Outside of the 	 class, however, such a reference is an instantiation.  */
if|if
condition|(
name|comp_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|template_type
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
block|{
name|found
operator|=
name|template_type
expr_stmt|;
if|if
condition|(
operator|!
name|entering_scope
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
comment|/* Note that we use DECL_CONTEXT, rather than 		 CP_DECL_CONTEXT, so that the termination test is 		 always just `ctx'.  We're not interested in namepace 		 scopes.  */
for|for
control|(
name|ctx
operator|=
name|current_class_type
init|;
name|ctx
condition|;
name|ctx
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|ctx
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|ctx
argument_list|)
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|ctx
argument_list|,
name|template_type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ctx
condition|)
comment|/* We're not in the scope of the class, so the 		   TEMPLATE_TYPE is not the type we want after 		   all.  */
name|found
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
for|for
control|(
name|found
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
init|;
name|found
condition|;
name|found
operator|=
name|TREE_CHAIN
argument_list|(
name|found
argument_list|)
control|)
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
break|break;
if|if
condition|(
name|found
condition|)
name|found
operator|=
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|pop_momentary
argument_list|()
expr_stmt|;
return|return
name|found
return|;
block|}
comment|/* Since we didn't find the type, we'll have to create it. 	 Since we'll be saving this type on the 	 DECL_TEMPLATE_INSTANTIATIONS list, it must be permanent.  */
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
comment|/* This type is a "partial instantiation" if any of the template 	 arguments still inolve template parameters.  Note that we set 	 IS_PARTIAL_INSTANTIATION for partial specializations as 	 well.  */
name|is_partial_instantiation
operator|=
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* Create the type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|is_partial_instantiation
condition|)
name|t
operator|=
name|start_enum
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* We don't want to call start_enum for this type, since 	       the values for the enumeration constants may involve 	       template parameters.  And, no one should be interested 	       in the enumeration constants for such a type.  */
name|t
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|TREE_CODE
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
block|}
comment|/* If we called start_enum above, this information will already 	 be set up.  */
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Create a stub TYPE_DECL for it.  */
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|type_decl
argument_list|)
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|type_decl
expr_stmt|;
block|}
else|else
name|type_decl
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Set up the template information.  We have to figure out which 	 template is the immediate parent if this is a full 	 instantiation.  */
if|if
condition|(
name|parm_depth
operator|==
literal|1
operator|||
name|is_partial_instantiation
operator|||
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
comment|/* This case is easy; there are no member templates involved.  */
name|found
operator|=
name|template
expr_stmt|;
else|else
block|{
comment|/* This is a full instantiation of a member template.  There 	     should be some partial instantiation of which this is an 	     instance.  */
for|for
control|(
name|found
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
init|;
name|found
condition|;
name|found
operator|=
name|TREE_CHAIN
argument_list|(
name|found
argument_list|)
control|)
block|{
name|int
name|success
decl_stmt|;
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We only want partial instantiations, here, not 		 specializations or full instantiations.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Temporarily reduce by one the number of levels in the 		 ARGLIST and in FOUND so as to avoid comparing the 		 last set of arguments.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* See if the arguments match.  If they do, then TMPL is 		 the partial instantiation we want.  */
name|success
operator|=
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Restore the argument vectors to their full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|++
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|found
operator|=
name|tmpl
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|arglist
operator|=
name|copy_to_permanent
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|SET_TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|,
name|tree_cons
argument_list|(
name|found
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|arglist
argument_list|,
name|t
argument_list|,
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|is_partial_instantiation
condition|)
comment|/* Now that the type has been registered on the instantiations 	   list, we set up the enumerators.  Because the enumeration 	   constants may involve the enumeration type itself, we make 	   sure to register the type first, and then create the 	   constants.  That way, doing tsubst_expr for the enumeration 	   constants won't result in recursive calls here; we'll find 	   the instantiation and exit above.  */
name|tsubst_enum
argument_list|(
name|template_type
argument_list|,
name|t
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* We're done with the permanent obstack, now.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
comment|/* We're also done with the momentary allocation we started 	 above.  */
name|pop_momentary
argument_list|()
expr_stmt|;
comment|/* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO 	 is set up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|DECL_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_partial_instantiation
condition|)
block|{
name|DECL_ASSEMBLER_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For backwards compatibility; code that uses 	     -fexternal-templates expects looking up a template to 	     instantiate it.  I think DDD still relies on this. 	     (jason 8/20/1998) */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|flag_external_templates
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
condition|)
name|add_pending_template
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If the type makes use of template parameters, the 	   code that generates debugging information will crash.  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, or    TEMPLATE_PARM_INDEX in T, call FN with the parameter and the DATA.    If FN returns non-zero, the iteration is terminated, and    for_each_template_parm returns 1.  Otherwise, the iteration    continues.  If FN never returns a non-zero value, the value    returned by for_each_template_parm is 0.  If FN is NULL, it is    considered to be the function which always returns 1.  */
end_comment

begin_function
specifier|static
name|int
name|for_each_template_parm
parameter_list|(
name|t
parameter_list|,
name|fn
parameter_list|,
name|data
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree_fn_t
name|fn
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* We assume that the object must be instantiated in order to build 	 the COMPONENT_REF, so we test only whether the type of the 	 COMPONENT_REF uses template parms.  */
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
case|case
name|OFFSET_REF
case|:
return|return
operator|(
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|||
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
comment|/* aggregates of tree nodes */
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|TREE_LIST
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|||
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|OVERLOAD
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* constructed type nodes */
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|for_each_template_parm
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* Fall through.  */
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
comment|/* Check the parameter types.  Since default arguments are not 	 instantiated until they are needed, the TYPE_ARG_TYPES may 	 contain expressions that involve template parameters.  But, 	 no-one should be looking at them yet.  And, once they're 	 instantiated, they don't contain template parameters, so 	 there's no point in looking at them then, either.  */
block|{
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Check the return type, too.  */
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* decl nodes */
case|case
name|TYPE_DECL
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|TEMPLATE_DECL
case|:
comment|/* A template template parameter is encountered */
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* Already substituted template template parameter */
return|return
literal|0
return|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
goto|goto
name|check_type_and_context
goto|;
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
comment|/* ??? What about FIELD_DECLs?  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* fall through */
case|case
name|PARM_DECL
case|:
name|check_type_and_context
label|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
return|return
operator|(
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|||
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
comment|/* template parm nodes */
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
comment|/* Record template parameters such as `T' inside `TT<T>'.  */
if|if
condition|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
if|if
condition|(
name|fn
condition|)
return|return
call|(
modifier|*
name|fn
call|)
argument_list|(
name|t
argument_list|,
name|data
argument_list|)
return|;
else|else
return|return
literal|1
return|;
comment|/* simple type nodes */
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|NAMESPACE_DECL
case|:
return|return
literal|0
return|;
comment|/* constants */
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
literal|0
return|;
case|case
name|ERROR_MARK
case|:
comment|/* Non-error_mark_node ERROR_MARKs are bad things.  */
name|my_friendly_assert
argument_list|(
name|t
operator|==
name|error_mark_node
argument_list|,
literal|274
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
case|case
name|LOOKUP_EXPR
case|:
case|case
name|TYPENAME_TYPE
case|:
return|return
literal|1
return|;
case|case
name|PTRMEM_CST
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|for_each_template_parm
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
case|case
name|MODOP_EXPR
case|:
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
return|return
literal|1
return|;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
return|return
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
return|;
default|default:
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'e'
case|:
case|case
literal|'<'
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|sorry
argument_list|(
literal|"testing %s for template parms"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|82
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|uses_template_parms
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|for_each_template_parm
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|tinst_level
modifier|*
name|current_tinst_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tinst_level
modifier|*
name|free_tinst_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tinst_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_tinst_depth
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|tinst_level_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_template_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print out all the template instantiations that we are currently    working on.  If ERR, we are being called from cp_thing, so do    the right thing for an error message.  */
end_comment

begin_function
specifier|static
name|void
name|print_template_context
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
name|struct
name|tinst_level
modifier|*
name|p
init|=
name|current_tinst_level
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|p
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|!=
name|p
operator|->
name|decl
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
condition|)
comment|/* We can get here during the processing of some synthesized 	   method.  Then, p->decl will be the function that's causing 	   the synthesis.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|==
name|p
operator|->
name|decl
condition|)
comment|/* Avoid redundancy with the the "In function" line.  */
empty_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: In instantiation of `%s':\n"
argument_list|,
name|file
argument_list|,
name|decl_as_string
argument_list|(
name|p
operator|->
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|p
operator|->
name|line
expr_stmt|;
name|file
operator|=
name|p
operator|->
name|file
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:   instantiated from `%s'\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|decl_as_string
argument_list|(
name|p
operator|->
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|p
operator|->
name|line
expr_stmt|;
name|file
operator|=
name|p
operator|->
name|file
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d:   instantiated from here\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from cp_thing to print the template context for an error.  */
end_comment

begin_function
name|void
name|maybe_print_template_context
parameter_list|()
block|{
if|if
condition|(
name|last_template_error_tick
operator|==
name|tinst_level_tick
operator|||
name|current_tinst_level
operator|==
literal|0
condition|)
return|return;
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
name|print_template_context
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|push_tinst_level
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|struct
name|tinst_level
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|tinst_depth
operator|>=
name|max_tinst_depth
condition|)
block|{
comment|/* If the instantiation in question still has unbound template parms, 	 we don't really care if we can't instantiate it, so just return.          This happens with base instantiation for implicit `typename'.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
name|error
argument_list|(
literal|"template instantiation depth exceeds maximum of %d"
argument_list|,
name|max_tinst_depth
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" (use -ftemplate-depth-NN to increase the maximum)"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  instantiating `%D'"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|print_template_context
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|free_tinst_level
condition|)
block|{
name|new
operator|=
name|free_tinst_level
expr_stmt|;
name|free_tinst_level
operator|=
name|new
operator|->
name|next
expr_stmt|;
block|}
else|else
name|new
operator|=
operator|(
expr|struct
name|tinst_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tinst_level
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|decl
operator|=
name|d
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|lineno
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|input_filename
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|current_tinst_level
expr_stmt|;
name|current_tinst_level
operator|=
name|new
expr_stmt|;
operator|++
name|tinst_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|tinst_depth
operator|>
name|depth_reached
condition|)
name|depth_reached
operator|=
name|tinst_depth
expr_stmt|;
endif|#
directive|endif
operator|++
name|tinst_level_tick
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|pop_tinst_level
parameter_list|()
block|{
name|struct
name|tinst_level
modifier|*
name|old
init|=
name|current_tinst_level
decl_stmt|;
comment|/* Restore the filename and line number stashed away when we started      this instantiation.  */
name|lineno
operator|=
name|old
operator|->
name|line
expr_stmt|;
name|input_filename
operator|=
name|old
operator|->
name|file
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
name|current_tinst_level
operator|=
name|old
operator|->
name|next
expr_stmt|;
name|old
operator|->
name|next
operator|=
name|free_tinst_level
expr_stmt|;
name|free_tinst_level
operator|=
name|old
expr_stmt|;
operator|--
name|tinst_depth
expr_stmt|;
operator|++
name|tinst_level_tick
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|tinst_level
modifier|*
name|tinst_for_decl
parameter_list|()
block|{
name|struct
name|tinst_level
modifier|*
name|p
init|=
name|current_tinst_level
decl_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the    vector of template arguments, as for tsubst.     Returns an appropriate tsbust'd friend declaration.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_function
parameter_list|(
name|decl
parameter_list|,
name|args
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|new_friend
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* This was a friend declared with an explicit template        argument list, e.g.:                friend void f<>(T);                to indicate that f was a template instantiation, not a new        function declaration.  Now, we have to figure out what        instantiation of what template.  */
block|{
name|tree
name|template_id
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|template_id
operator|=
name|lookup_template_function
argument_list|(
name|tsubst_expr
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: The decl we create via the next tsubst could be 	 created on a temporary obstack.  */
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|template_id
argument_list|,
name|new_friend
argument_list|,
operator|&
name|new_args
argument_list|,
comment|/*need_member_template=*/
literal|0
argument_list|)
expr_stmt|;
name|new_friend
operator|=
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|new_args
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The NEW_FRIEND will look like an instantiation, to the      compiler, but is not an instantiation from the point of view of      the language.  For example, we might have had:            template<class T> struct S {        template<class U> friend void f(T, U);      };            Then, in S<int>, template<class U> void f(int, U) is not an      instantiation of anything.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|DECL_USE_TEMPLATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The mangled name for the NEW_FRIEND is incorrect.  The call to      tsubst will have resulted in a call to      set_mangled_name_for_template_decl.  But, the function is not a      template instantiation and should not be mangled like one.      Therefore, we remangle the function name.  We don't have to do      this if the NEW_FRIEND is a template since      set_mangled_name_for_template_decl doesn't do anything if the      function declaration still uses template arguments.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|set_mangled_name_for_decl
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|new_friend
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|new_friend
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|new_friend
argument_list|)
condition|)
block|{
name|tree
name|old_decl
decl_stmt|;
name|tree
name|new_friend_template_info
decl_stmt|;
name|tree
name|new_friend_result_template_info
decl_stmt|;
name|int
name|new_friend_is_defn
decl_stmt|;
comment|/* We must save some information from NEW_FRIEND before calling 	 duplicate decls since that function will free NEW_FRIEND if 	 possible.  */
name|new_friend_template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This declaration is a `primary' template.  */
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
name|new_friend
expr_stmt|;
name|new_friend_is_defn
operator|=
name|DECL_INITIAL
argument_list|(
name|DECL_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
name|new_friend_result_template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|DECL_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_friend_is_defn
operator|=
name|DECL_INITIAL
argument_list|(
name|new_friend
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
name|new_friend_result_template_info
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|old_decl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|!=
name|new_friend
condition|)
block|{
comment|/* This new friend declaration matched an existing 	     declaration.  For example, given:  	       template<class T> void f(T); 	       template<class U> class C {  		 template<class T> friend void f(T) {}  	       };  	     the friend declaration actually provides the definition 	     of `f', once C has been instantiated for some type.  So, 	     old_decl will be the out-of-class template declaration, 	     while new_friend is the in-class definition.  	     But, if `f' was called before this point, the 	     instantiation of `f' will have DECL_TI_ARGS corresponding 	     to `T' but not to `U', references to which might appear 	     in the definition of `f'.  Previously, the most general 	     template for an instantiation of `f' was the out-of-class 	     version; now it is the in-class version.  Therefore, we 	     run through all specialization of `f', adding to their 	     DECL_TI_ARGS appropriately.  In particular, they need a 	     new set of outer arguments, corresponding to the 	     arguments for this class instantiation.    	     The same situation can arise with something like this:  	       friend void f(int); 	       template<class T> class C {  	         friend void f(T) {}                };  	     when `C<int>' is instantiated.  Now, `f(int)' is defined 	     in the class.  */
if|if
condition|(
operator|!
name|new_friend_is_defn
condition|)
comment|/* On the other hand, if the in-class declaration does 	       *not* provide a definition, then we don't want to alter 	       existing definitions.  We can just leave everything 	       alone.  */
empty_stmt|;
else|else
block|{
comment|/* Overwrite whatever template info was there before, if 		 any, with the new template information pertaining to 		 the declaration.  */
name|DECL_TEMPLATE_INFO
argument_list|(
name|old_decl
argument_list|)
operator|=
name|new_friend_template_info
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* duplicate_decls will take care of this case.  */
empty_stmt|;
else|else
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|new_friend_args
decl_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|DECL_RESULT
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|=
name|new_friend_result_template_info
expr_stmt|;
name|new_friend_args
operator|=
name|TI_ARGS
argument_list|(
name|new_friend_template_info
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|spec
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
operator|=
name|add_outermost_template_args
argument_list|(
name|new_friend_args
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now, since specializations are always supposed to 		     hang off of the most general template, we must move 		     them.  */
name|t
operator|=
name|most_general_template
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|old_decl
condition|)
block|{
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
comment|/* The information from NEW_FRIEND has been merged into OLD_DECL 	     by duplicate_decls.  */
name|new_friend
operator|=
name|old_decl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check to see that the declaration is really present, and, 	 possibly obtain an improved declaration.  */
name|tree
name|fn
init|=
name|check_classfn
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
argument_list|,
name|new_friend
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|new_friend
operator|=
name|fn
expr_stmt|;
block|}
name|done
label|:
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
return|return
name|new_friend
return|;
block|}
end_function

begin_comment
comment|/* FRIEND_TMPL is a friend TEMPLATE_DECL.  ARGS is the vector of    template arguments, as for tsubst.     Returns an appropriate tsbust'd friend type.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_class
parameter_list|(
name|friend_tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|friend_tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|friend_type
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
comment|/* First, we look for a class template.  */
name|tmpl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
comment|/*prefer_type=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* But, if we don't find one, it might be because we're in a      situation like this:         template<class T>        struct S {          template<class U> 	 friend struct S;        };       Here, in the scope of (say) S<int>, `S' is bound to a TYPE_DECL      for `S<int>', not the TEMPLATE_DECL.  */
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tmpl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
comment|/*prefer_type=*/
literal|1
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpl
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* The friend template has already been declared.  Just 	 check to see that the declarations match, and install any new 	 default parameters.  We must tsubst the default parameters, 	 of course.  We only need the innermost template parameters 	 because that is all that redeclare_class_template will look 	 at.  */
name|tree
name|parms
init|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
decl_stmt|;
name|redeclare_class_template
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The friend template has not already been declared.  In this 	 case, the instantiation of the template class will cause the 	 injection of this template into the global scope.  */
name|tmpl
operator|=
name|tsubst
argument_list|(
name|friend_tmpl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The new TMPL is not an instantiation of anything, so we  	 forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for 	 the new type because that is supposed to be the corresponding 	 template decl, i.e., TMPL.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Inject this template into the global scope.  */
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|pushdecl_top_level
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|friend_type
return|;
block|}
end_function

begin_function
name|tree
name|instantiate_class_template
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|template
decl_stmt|,
name|args
decl_stmt|,
name|pattern
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|typedecl
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* We want to allocate temporary vectors of template arguments and      template argument expressions on the momentary obstack, not on      the expression obstack.  Otherwise, all the space allocated in      argument coercion and such is simply lost.  */
name|push_momentary
argument_list|()
expr_stmt|;
comment|/* Figure out which template is being instantiated.  */
name|template
operator|=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|279
argument_list|)
expr_stmt|;
comment|/* Figure out which arguments are being used to do the      instantiation.  */
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
operator|=
name|uses_template_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* If this is a partial instantiation, then we can't instantiate        the type; there's no telling whether or not one of the        template parameters might eventually be instantiated to some        value that results in a specialization being used.  For        example, consider:           template<class T>          struct S {};           template<class U>           void f(S<U>); 	               template<>           struct S<int> {};         Now, the `S<U>' in `f<int>' is the specialization, not an        instantiation of the original template.  */
goto|goto
name|end
goto|;
comment|/* Determine what specialization of the original template to      instantiate.  */
if|if
condition|(
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* There's no telling which specialization is appropriate at this        point.  Since all peeking at the innards of this partial        instantiation are extensions (like the "implicit typename"        extension, which allows users to omit the keyword `typename' on        names that are declared as types in template base classes), we        are free to do what we please.         Trying to figure out which partial instantiation to use can        cause a crash.  (Some of the template arguments don't even have        types.)  So, we just use the most general version.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|t
operator|=
name|most_specialized_class
argument_list|(
name|template
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
name|cp_error
argument_list|(
literal|"ambiguous class template instantiation for `%#T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|template
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"%s %+#T"
argument_list|,
name|str
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
if|if
condition|(
name|t
condition|)
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
expr_stmt|;
comment|/* If the template we're instantiating is incomplete, then clearly      there's nothing we can do.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|pattern
argument_list|)
operator|==
name|NULL_TREE
condition|)
goto|goto
name|end
goto|;
comment|/* If this is a partial instantiation, don't tsubst anything.  We will      only use this type for implicit typename, so the actual contents don't      matter.  All that matters is whether a particular name is a type.  */
if|if
condition|(
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The fields set here must be kept in sync with those cleared 	 in begin_class_definition.  */
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* Pretend that the type is complete, so that we will look 	 inside it during name lookup and such.  */
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* If we've recursively instantiated too many templates, stop.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* Now we're really doing the instantiation.  Mark the type as in      the process of being defined.  */
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|maybe_push_to_top_level
argument_list|(
name|uses_template_parms
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
comment|/* This TYPE is actually a instantiation of of a partial 	 specialization.  We replace the innermost set of ARGS with 	 the arguments appropriate for substitution.  For example, 	 given:  	   template<class T> struct S {}; 	   template<class T> struct S<T*> {}; 	  	 and supposing that we are instantiating S<int*>, ARGS will 	 present be {int*} but we need {int}.  */
name|tree
name|inner_args
init|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|/* If there were multiple levels in ARGS, replacing the 	 innermost level would alter CLASSTYPE_TI_ARGS, which we don't 	 want, so we make a copy first.  */
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|args
operator|=
name|copy_node
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|,
name|inner_args
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|inner_args
expr_stmt|;
block|}
if|if
condition|(
name|flag_external_templates
condition|)
block|{
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|type
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
operator|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|type
argument_list|,
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
operator|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_GETS_NEW
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_GETS_NEW
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_GETS_DELETE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VEC_DELETE_TAKES_SIZE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONVERSION
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_PACKED
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* For libjava's JArray<T> */
if|if
condition|(
name|ANON_UNION_TYPE_P
argument_list|(
name|pattern
argument_list|)
condition|)
name|SET_ANON_UNION_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We must copy the arguments to the permanent obstack since      during the tsubst'ing below they may wind up in the      DECL_TI_ARGS of some instantiated member template.  */
name|args
operator|=
name|copy_to_permanent
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
name|tree
name|base_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|pbases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Substitute into each of the bases to determine the actual 	 basetypes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|pbases
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base
decl_stmt|;
name|tree
name|access
decl_stmt|;
name|tree
name|pbase
decl_stmt|;
name|pbase
operator|=
name|TREE_VEC_ELT
argument_list|(
name|pbases
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Substitue to figure out the base class.  */
name|base
operator|=
name|tsubst
argument_list|(
name|BINFO_TYPE
argument_list|(
name|pbase
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* Calculate the correct access node.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|pbase
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_public_virtual_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_protected_virtual_node
expr_stmt|;
else|else
name|access
operator|=
name|access_private_virtual_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_public_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|pbase
argument_list|)
condition|)
name|access
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|access
operator|=
name|access_private_node
expr_stmt|;
block|}
name|base_list
operator|=
name|tree_cons
argument_list|(
name|access
argument_list|,
name|base
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
block|}
comment|/* The list is now in reverse order; correct that.  */
name|base_list
operator|=
name|nreverse
argument_list|(
name|base_list
argument_list|)
expr_stmt|;
comment|/* Now call xref_basetypes to set up all the base-class 	 information.  */
name|xref_basetypes
argument_list|(
name|TREE_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|RECORD_TYPE
condition|?
operator|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|pattern
argument_list|)
condition|?
name|class_type_node
else|:
name|record_type_node
operator|)
else|:
name|union_type_node
argument_list|,
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|pattern
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
block|}
comment|/* Now that our base classes are set up, enter the scope of the      class, so that name lookups into base classes, etc. will work      corectly.  This is precisely analagous to what we do in      begin_class_definition when defining an ordinary non-template      class.  */
name|pushclass
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|tag
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|tree
name|newtag
decl_stmt|;
name|newtag
operator|=
name|tsubst
argument_list|(
name|tag
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtag
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|tag
argument_list|)
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|tag
argument_list|)
condition|)
comment|/* Unfortunately, lookup_template_class sets 	       CLASSTYPE_IMPLICIT_INSTANTIATION for a partial 	       instantiation (i.e., for the type of a member template 	       class nested within a template class.)  This behavior is 	       required for maybe_process_partial_specialization to work 	       correctly, but is not accurate in this case; the TAG is not 	       an instantiation of anything.  (The corresponding 	       TEMPLATE_DECL is an instantiation, but the TYPE is not.) */
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|newtag
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now, we call pushtag to put this NEWTAG into the scope of 	     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid 	     pushtag calling push_template_decl.  We don't have to do 	     this for enums because it will already have been done in 	     tsubst_enum.  */
if|if
condition|(
name|name
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newtag
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|newtag
argument_list|,
comment|/*globalize=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't replace enum constants here.  */
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
name|tree
name|r
decl_stmt|;
comment|/* The the file and line for this declaration, to assist in 	   error message reporting.  Since we called push_tinst_level 	   above, we don't need to restore these.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|DECL_DEFINED_IN_CLASS_P
argument_list|(
name|r
argument_list|)
condition|)
name|init
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_static_data_member_decl
argument_list|(
name|r
argument_list|,
name|init
argument_list|,
comment|/*asmspec_tree=*/
name|NULL_TREE
argument_list|,
comment|/*need_pop=*/
literal|0
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DEFINED_IN_CLASS_P
argument_list|(
name|r
argument_list|)
condition|)
name|check_static_variable_definition
argument_list|(
name|r
argument_list|,
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* R will have a TREE_CHAIN if and only if it has already been 	   processed by finish_member_declaration.  This can happen 	   if, for example, it is a TYPE_DECL for a class-scoped 	   ENUMERAL_TYPE; such a thing will already have been added to 	   the field list by tsubst_enum above.  */
if|if
condition|(
operator|!
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|set_current_access_from_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up the list (TYPE_METHODS) and vector (CLASSTYPE_METHOD_VEC)      for this instantiation.  */
for|for
control|(
name|t
operator|=
name|TYPE_METHODS
argument_list|(
name|pattern
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|r
init|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|set_current_access_from_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the DECL_FRIENDLIST for the new class type.  */
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|pattern
argument_list|)
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|friends
decl_stmt|;
for|for
control|(
name|friends
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
init|;
name|friends
operator|!=
name|NULL_TREE
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
operator|==
name|error_mark_node
condition|)
name|add_friend
argument_list|(
name|type
argument_list|,
name|tsubst_friend_function
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_friends
argument_list|(
name|type
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|pattern
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|friend_type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|new_friend_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|new_friend_type
operator|=
name|tsubst_friend_class
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|friend_type
argument_list|)
condition|)
name|new_friend_type
operator|=
name|tsubst
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
comment|/* The call to xref_tag_from_type does injection for friend 	   classes.  */
name|new_friend_type
operator|=
name|xref_tag_from_type
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
comment|/* Trick make_friend_class into realizing that the friend 	   we're adding is a template, not an ordinary class.  It's 	   important that we use make_friend_class since it will 	   perform some error-checking and output cross-reference 	   information.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|make_friend_class
argument_list|(
name|type
argument_list|,
name|new_friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
block|}
comment|/* This does injection for friend functions. */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|t
operator|=
name|tsubst
argument_list|(
name|DECL_TEMPLATE_INJECT
argument_list|(
name|template
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|d
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Already injected.  */
empty_stmt|;
else|else
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|require_complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Set the file and line number information to whatever is given for      the class itself.  This puts error messages involving generated      implicit functions at a predictable point, and the same point      that would be used for non-template classes.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|unreverse_member_declarations
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|finish_struct_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Clear this now so repo_template_used is happy.  */
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|repo_template_used
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|popclass
argument_list|()
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
name|end
label|:
name|pop_momentary
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_eq
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t2
operator|==
name|NULL_TREE
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
comment|/* Don't care if one declares its arg const and the other doesn't -- the      main variant of the arg type is all that matters.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|list_eq
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If arg is a non-type template parameter that does not depend on template    arguments, fold it like we weren't in the body of a template.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_nontype_arg
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Sometimes, one of the args was an expression involving a 	 template constant parameter, like N - 1.  Now that we've 	 tsubst'd, we might have something like 2 - 1.  This will 	 confuse lookup_template_class, so we do constant folding 	 here.  We have to unset processing_template_decl, to 	 fool build_expr_from_tree() into building an actual 	 tree.  */
name|int
name|saved_processing_template_decl
init|=
name|processing_template_decl
decl_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|fold
argument_list|(
name|build_expr_from_tree
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Return the TREE_VEC with the arguments for the innermost template header,    where ARGS is either that or the VEC of VECs for all the    arguments.  */
end_comment

begin_function
name|tree
name|innermost_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
return|return
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Substitute ARGS into the vector of template arguments T.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_template_arg_vector
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|need_new
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|elts
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elts
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|elts
index|[
name|i
index|]
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
else|else
name|elts
index|[
name|i
index|]
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|tsubst_expr
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elts
index|[
name|i
index|]
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|need_new
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_new
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_temp_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|elts
index|[
name|i
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the result of substituting ARGS into the template parameters    given by PARMS.  If there are m levels of ARGS and m + n levels of    PARMS, then the result will contain n levels of PARMS.  For    example, if PARMS is `template<class T> template<class U>    template<T*, U, class V>' and ARGS is {{int}, {double}} then the    result will be `template<int*, double, class V>'.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_template_parms
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|)
name|tree
name|parms
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
name|tree
modifier|*
name|new_parms
init|=
operator|&
name|r
decl_stmt|;
for|for
control|(
name|new_parms
operator|=
operator|&
name|r
init|;
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|>
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
name|new_parms
operator|=
operator|&
operator|(
name|TREE_CHAIN
argument_list|(
operator|*
name|new_parms
argument_list|)
operator|)
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|new_vec
init|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|new_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|default_value
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm_decl
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
name|i
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|tsubst
argument_list|(
name|default_value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|parm_decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|build_int_2
argument_list|(
literal|0
argument_list|,
operator|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|-
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|)
argument_list|)
argument_list|,
name|new_vec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitute the ARGS into the indicated aggregate (or enumeration)    type T.  If T is not an aggregate or enumeration type, it is    handled as if by tsubst.  IN_DECL is as for tsubst.  If    ENTERING_SCOPE is non-zero, T is the context for a template which    we are presently tsubst'ing.  Return the subsituted value.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_aggr_type
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|,
name|entering_scope
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
name|int
name|entering_scope
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|r
init|=
name|build_ptrmemfunc_type
argument_list|(
name|tsubst
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cp_build_qualified_type
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/* else fall through */
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|argvec
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|r
decl_stmt|;
comment|/* First, determine the context for the type we are looking 	     up.  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|context
operator|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Then, figure out what arguments are appropriate for the 	     type we are trying to find.  For example, given:  	       template<class T> struct S; 	       template<class T, class U> void f(T, U) { S<U> su; }  	     and supposing that we are instantiating f<int, double>, 	     then our ARGS will be {int, double}, but, when looking up 	     S we only want {double}.  */
name|push_momentary
argument_list|()
expr_stmt|;
name|argvec
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|t
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|context
argument_list|,
name|entering_scope
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
return|return
name|cp_build_qualified_type
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
else|else
comment|/* This is not a template type, so there's nothing to do.  */
return|return
name|t
return|;
default|default:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Substitute the ARGS into the T, which is a _DECL.  TYPE is the    (already computed) substitution of ARGS into TREE_TYPE (T), if    appropriate.  Return the result of the substitution.  IN_DECL is as    for tsubst.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_decl
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|type
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|int
name|saved_lineno
decl_stmt|;
name|char
modifier|*
name|saved_filename
decl_stmt|;
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Set the filename and linenumber to improve error-reporting.  */
name|saved_lineno
operator|=
name|lineno
expr_stmt|;
name|saved_filename
operator|=
name|input_filename
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
block|{
comment|/* We can get here when processing a member template function 	   of a template class.  */
name|tree
name|decl
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|int
name|is_template_template_parm
init|=
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_template_template_parm
condition|)
block|{
comment|/* We might already have an instance of this template. 	       The ARGS are for the surrounding class type, so the 	       full args contain the tsubst'd args for the context, 	       plus the innermost args from the template decl.  */
name|tree
name|tmpl_args
init|=
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|?
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|DECL_TI_ARGS
argument_list|(
name|DECL_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|full_args
decl_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|full_args
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|tmpl_args
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* tsubst_template_arg_vector doesn't copy the vector if 	       nothing changed.  But, *something* should have 	       changed.  */
name|my_friendly_assert
argument_list|(
name|full_args
operator|!=
name|tmpl_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|t
argument_list|,
name|full_args
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make a new template decl.  It will be similar to the 	   original, but will record the current template arguments.  	   We also create a new function declaration, which is just 	   like the old one, but points to this new template, rather 	   than the old one.  */
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|r
argument_list|)
operator|!=
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_template_template_parm
condition|)
block|{
name|tree
name|new_decl
init|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
break|break;
block|}
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|new_type
expr_stmt|;
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|new_type
argument_list|)
operator|=
name|r
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|r
argument_list|)
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|new_decl
init|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|r
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_TI_ARGS
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The template parameters for this new template are all the 	   template parameters for the old template, except the 	   outermost level of parameters. */
name|DECL_TEMPLATE_PARMS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
comment|/* We don't partially instantiate partial specializations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
break|break;
for|for
control|(
name|spec
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
init|;
name|spec
operator|!=
name|NULL_TREE
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
comment|/* It helps to consider example here.  Consider:  	       template<class T> 	       struct S { 	         template<class U> 		 void f(U u);  		 template<> 		 void f(T* t) {} 	       }; 	        	       Now, for example, we are instantiating S<int>::f(U u).   	       We want to make a template:  	       template<class U> 	       void S<int>::f(U);  	       It will have a specialization, for the case U = int*, of 	       the form:  	       template<> 	       void S<int>::f<int*>(int*);  	       This specialization will be an instantiation of 	       the specialization given in the declaration of S, with 	       argument list int*.  */
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
name|tree
name|spec_args
decl_stmt|;
name|tree
name|new_fn
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Instantiations are on the same list, but they're of 		 no concern to us.  */
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* A full specialization.  There's no need to record 		 that here.  */
continue|continue;
name|spec_args
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|new_fn
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|most_general_template
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|spec_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|new_fn
argument_list|)
operator|=
name|fn
expr_stmt|;
name|register_specialization
argument_list|(
name|new_fn
argument_list|,
name|r
argument_list|,
name|innermost_args
argument_list|(
name|spec_args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record this partial instantiation.  */
name|register_specialization
argument_list|(
name|r
argument_list|,
name|t
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|ctx
decl_stmt|;
name|tree
name|argvec
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|friends
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|int
name|member
decl_stmt|;
name|int
name|args_depth
decl_stmt|;
name|int
name|parms_depth
decl_stmt|;
comment|/* Nobody should be tsubst'ing into non-template functions.  */
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|spec
decl_stmt|;
comment|/* Allocate template arguments on the momentary obstack, 	       in case we don't need to keep them.  */
name|push_momentary
argument_list|()
expr_stmt|;
comment|/* Calculate the most general template of which R is a 	       specialization, and the complete set of arguments used to 	       specialize R.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|argvec
operator|=
name|tsubst_template_arg_vector
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* We're going to need to keep the ARGVEC, so we copy it 	       here.  */
name|argvec
operator|=
name|copy_to_permanent
argument_list|(
name|argvec
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
comment|/* Here, we deal with the peculiar case:  		 template<class T> struct S {  		   template<class U> friend void f(); 		 }; 		 template<class U> friend void f() {} 		 template S<int>; 		 template void f<double>();  	       Here, the ARGS for the instantiation of will be {int, 	       double}.  But, we only need as many ARGS as there are 	       levels of template parameters in CODE_PATTERN.  We are 	       careful not to get fooled into reducing the ARGS in 	       situations like:  		 template<class T> struct S { template<class U> void f(U); } 		 template<class T> template<> void S<T>::f(int) {}  	       which we can spot because the pattern will be a 	       specialization in this case.  */
name|args_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|parms_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_depth
operator|>
name|parms_depth
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_FRIEND_P
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms_depth
operator|>
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|args
operator|=
name|make_temp_vec
argument_list|(
name|parms_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parms_depth
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
operator|+
operator|(
name|args_depth
operator|-
name|parms_depth
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|args
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|args_depth
operator|-
name|parms_depth
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This special case arises when we have something like this:  	         template<class T> struct S {  		   friend void f<int>(int, double);  		 };  	       Here, the DECL_TI_TEMPLATE for the friend declaration 	       will be a LOOKUP_EXPR or an IDENTIFIER_NODE.  We are 	       being called from tsubst_friend_function, and we want 	       only to create a new decl (R) with appropriate types so 	       that we can call determine_specialization.  */
name|my_friendly_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|LOOKUP_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gen_tmpl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|member
operator|=
literal|2
expr_stmt|;
else|else
name|member
operator|=
literal|1
expr_stmt|;
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|member
operator|=
literal|0
expr_stmt|;
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* We do NOT check for matching decls pushed separately at this            point, as they may not represent instantiations of this            template, and in any case are considered separate under the            discrete model.  Instead, see add_maybe_template.  */
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|member
operator|&&
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
comment|/* Type-conversion operator.  Reconstruct the name, in 	     case it's the name of one of the template's parameters.  */
name|DECL_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_typename_overload
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Set up the DECL_TEMPLATE_INFO for R and compute its mangled 	   name.  There's no need to do this in the special friend 	   case mentioned above where GEN_TMPL is NULL.  */
if|if
condition|(
name|gen_tmpl
condition|)
block|{
comment|/* The ARGVEC was built on the momentary obstack.  Make it 	       permanent now.  */
name|argvec
operator|=
name|copy_to_permanent
argument_list|(
name|argvec
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
comment|/* Set the mangled name for R.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|build_destructor_name
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Instantiations of template functions must be mangled 		   specially, in order to conform to 14.5.5.1 		   [temp.over.link].  */
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* TMPL will be NULL if this is a specialization of a 		   member function of a template class.  */
if|if
condition|(
name|name_mangling_version
operator|<
literal|1
operator|||
name|tmpl
operator|==
name|NULL_TREE
operator|||
operator|(
name|member
operator|&&
operator|!
name|is_member_template
argument_list|(
name|tmpl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|)
condition|)
name|set_mangled_name_for_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|set_mangled_name_for_template_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|r
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Like grokfndecl.  If we don't do this, pushdecl will 	       mess up our TREE_CHAIN because it doesn't find a 	       previous decl.  Sigh.  */
if|if
condition|(
name|member
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|r
argument_list|)
operator|&&
operator|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the list of befriending classes.  */
for|for
control|(
name|friends
operator|=
operator|&
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|r
argument_list|)
init|;
operator|*
name|friends
condition|;
name|friends
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|friends
argument_list|)
control|)
block|{
operator|*
name|friends
operator|=
name|copy_node
argument_list|(
operator|*
name|friends
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
operator|*
name|friends
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|friends
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|maybe_retrofit_in_chrg
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|grok_ctor_properties
argument_list|(
name|ctx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
name|grok_op_properties
argument_list|(
name|r
argument_list|,
name|DECL_VIRTUAL_P
argument_list|(
name|r
argument_list|)
argument_list|,
name|DECL_FRIEND_P
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIELD_DECL
case|:
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* We don't have to set DECL_CONTEXT here; it is set by 	   finish_member_declaration.  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"instantiation of `%D' as type void"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USING_DECL
case|:
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_copy
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
block|{
name|tree
name|argvec
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|ctx
init|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
decl_stmt|;
comment|/* Nobody should be tsubst'ing into non-template variables.  */
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|argvec
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
comment|/* Don't try to expand the initializer until someone tries to use 	   this variable; otherwise we run into circular dependencies.  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_RTL
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* A static data member declaration is always marked external 	   when it is declared in-class, even if an initializer is 	   present.  We mimic the non-template processing here.  */
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|gen_tmpl
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_error_at
argument_list|(
literal|"instantiation of `%D' as type void"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|t
operator|==
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|r
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the file and line information.  */
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|input_filename
operator|=
name|saved_filename
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitue into the ARG_TYPES of a function type.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_arg_types
parameter_list|(
name|arg_types
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|arg_types
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|remaining_arg_types
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|arg_types
operator|||
name|arg_types
operator|==
name|void_list_node
condition|)
return|return
name|arg_types
return|;
name|remaining_arg_types
operator|=
name|tsubst_arg_types
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_arg_types
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Do array-to-pointer, function-to-pointer conversion, and ignore      top-level qualifiers as required.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we do not substitute into default arguments here.  The      standard mandates that they be instantiated only when needed,      which is done in build_over_call.  */
return|return
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|type
argument_list|,
name|remaining_arg_types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Substitute into a FUNCTION_TYPE or METHOD_TYPE.  This routine does    *not* handle the exception-specification for FNTYPE, because the    initial substitution of explicitly provided template parameters    during argument deduction forbids substitution into the    exception-specification:       [temp.deduct]       All references in the function type of the function template to  the      corresponding template parameters are replaced by the specified tem-      plate argument values.  If a substitution in a template parameter or      in  the function type of the function template results in an invalid      type, type deduction fails.  [Note: The equivalent  substitution  in      exception specifications is done only when the function is instanti-      ated, at which point a program is  ill-formed  if  the  substitution      results in an invalid type.]  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_function_type
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|return_type
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
comment|/* The TYPE_CONTEXT is not used for function/method types.  */
name|my_friendly_assert
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Substitue the return type.  */
name|return_type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Substitue the argument types.  */
name|arg_types
operator|=
name|tsubst_arg_types
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Construct a new type node and return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|return_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|r
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* [temp.deduct] 	      	     Type deduction may fail for any of the following 	     reasons: 	      	     -- Attempting to create "pointer to member of T" when T 	     is not a class type.  */
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"creating pointer to member function of non-class type `%T'"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|r
argument_list|,
name|return_type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|build_qualified_type
argument_list|(
name|fntype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_type_attribute_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fntype
return|;
block|}
end_function

begin_comment
comment|/* Substitute into the PARMS of a call-declarator.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_call_declarator_parms
parameter_list|(
name|parms
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|parms
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|new_parms
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|defarg
decl_stmt|;
if|if
condition|(
operator|!
name|parms
operator|||
name|parms
operator|==
name|void_list_node
condition|)
return|return
name|parms
return|;
name|new_parms
operator|=
name|tsubst_call_declarator_parms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Figure out the type of this parameter.  */
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Figure out the default argument as well.  Note that we use      tsubst_expr since the default argument is really an expression.  */
name|defarg
operator|=
name|tsubst_expr
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Chain this parameter on to the front of those we have already      processed.  We don't use hash_tree_cons because that function      doesn't check TREE_PARMLIST.  */
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|defarg
argument_list|,
name|type
argument_list|,
name|new_parms
argument_list|)
expr_stmt|;
comment|/* And note that these are parameters.  */
name|TREE_PARMLIST
argument_list|(
name|new_parms
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|new_parms
return|;
block|}
end_function

begin_comment
comment|/* Take the tree structure T and replace template parameters used    therein with the argument vector ARGS.  IN_DECL is an associated    decl for diagnostics.  If an error occurs, returns ERROR_MARK_NODE.    An appropriate error message is issued only if COMPLAIN is    non-zero.  Note that we must be relatively non-tolerant of    extensions here, in order to preserve conformance; if we allow    substitutions that should not be allowed, we may allow argument    deductions that should not succeed, and therefore report ambiguous    overload situations where there are none.  In theory, we could    allow the substitution, but indicate that it should have failed,    and allow our caller to make sure that the right thing happens, but    we don't try to do this yet.     This function is used for dealing with types, decls and the like;    for expressions, use tsubst_expr or tsubst_copy.  */
end_comment

begin_function
name|tree
name|tsubst
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
operator|||
name|t
operator|==
name|integer_type_node
operator|||
name|t
operator|==
name|void_type_node
operator|||
name|t
operator|==
name|char_type_node
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|unknown_type_node
condition|)
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
return|return
name|tsubst_decl
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|type
argument_list|,
name|in_decl
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|tsubst_aggr_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|OP_IDENTIFIER
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|t
return|;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|t
operator|==
name|integer_type_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|t
return|;
block|{
name|tree
name|max
decl_stmt|,
name|omax
init|=
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|max
operator|=
name|tsubst_expr
argument_list|(
name|omax
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* See if we can reduce this expression to something simpler.  */
name|max
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|TREE_READONLY_DECL_P
argument_list|(
name|max
argument_list|)
condition|)
name|max
operator|=
name|decl_constant_value
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
comment|/* When providing explicit arguments to a template 	       function, but leaving some arguments for subsequent 	       deduction, MAX may be template-dependent even if we're 	       not PROCESSING_TEMPLATE_DECL.  */
operator|||
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|build_min
argument_list|(
name|MINUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|max
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
return|return
name|itype
return|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|omax
argument_list|)
condition|)
block|{
comment|/* Still allow an explicit array of size zero.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"creating array with size zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|max
argument_list|)
operator|||
name|INT_CST_LT
argument_list|(
name|max
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
comment|/* [temp.deduct]  	       Type deduction may fail for any of the following 	       reasons:    		 Attempting to create an array with a size that is 		 zero or negative.  */
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"creating array with size `%E'"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|max
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|max
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|max
argument_list|)
operator|&&
operator|!
name|allocation_temporary_p
argument_list|()
condition|)
name|max
operator|=
name|copy_to_permanent
argument_list|(
name|max
argument_list|)
expr_stmt|;
return|return
name|build_index_type
argument_list|(
name|max
argument_list|)
return|;
block|}
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
block|{
name|int
name|idx
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|levels
decl_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|arg
init|=
name|NULL_TREE
decl_stmt|;
name|levels
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|levels
condition|)
name|arg
operator|=
name|TMPL_ARG
argument_list|(
name|args
argument_list|,
name|level
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type
argument_list|(
name|arg
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|arg
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* We are processing a type constructed from 			   a template template parameter */
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* We can get a TEMPLATE_TEMPLATE_PARM here when  			   we are resolving nested-types in the signature of  			   a member function templates. 			   Otherwise ARG is a TEMPLATE_DECL and is the real  			   template to be instantiated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|arg
operator|=
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
else|else
comment|/* We are processing a template argument list.  */
return|return
name|arg
return|;
block|}
else|else
return|return
name|arg
return|;
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|981018
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
comment|/* This can happen during the attempted tsubst'ing in 	     unify.  This means that we don't yet have any information 	     about the template parameter in question.  */
return|return
name|t
return|;
comment|/* If we get here, we must have been looking at a parm for a 	   more deeply nested template.  Make a new version of this 	   template parameter, but with a lower level.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|r
argument_list|)
operator|=
name|reduce_template_parm_level
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|,
name|r
argument_list|,
name|levels
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|TEMPLATE_TYPE_DECL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|r
operator|=
name|reduce_template_parm_level
argument_list|(
name|t
argument_list|,
name|type
argument_list|,
name|levels
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
block|{
name|purpose
operator|=
name|tsubst
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|value
operator|=
name|tsubst
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
block|{
name|chain
operator|=
name|tsubst
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|result
operator|=
name|hash_tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_PARMLIST
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
case|case
name|TREE_VEC
case|:
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* A binfo node.  We always need to make a copy, of the node 	     itself and of its BINFO_BASETYPES.  */
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Make sure type isn't a typedef copy.  */
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|BINFO_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|BINFO_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* Otherwise, a vector of template arguments.  */
return|return
name|tsubst_template_arg_vector
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* [temp.deduct] 	    	   Type deduction may fail for any of the following 	   reasons:    	   -- Attempting to create a pointer to reference type. 	   -- Attempting to create a reference to a reference type or 	      a reference to void.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|code
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
block|{
specifier|static
name|int
name|last_line
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_file
init|=
literal|0
decl_stmt|;
comment|/* We keep track of the last time we issued this error 	       message to avoid spewing a ton of messages during a 	       single bad template instantiation.  */
if|if
condition|(
name|complain
operator|&&
operator|(
name|last_line
operator|!=
name|lineno
operator|||
name|last_file
operator|!=
name|input_filename
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_error
argument_list|(
literal|"forming reference to void"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"forming %s to reference type `%T'"
argument_list|,
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|)
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|last_line
operator|=
name|lineno
expr_stmt|;
name|last_file
operator|=
name|input_filename
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
name|r
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_qualified_type
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Will this ever be needed for TYPE_..._TO values?  */
name|layout_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
block|{
name|r
operator|=
name|tsubst
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* [temp.deduct]  	       Type deduction may fail for any of the following 	       reasons: 	        	       -- Attempting to create "pointer to member of T" when T 	          is not a class type.  */
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"creating pointer to member of non-class type `%T'"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_offset_type
argument_list|(
name|r
argument_list|,
name|type
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|fntype
decl_stmt|;
name|tree
name|raises
decl_stmt|;
name|fntype
operator|=
name|tsubst_function_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Substitue the exception specification. */
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
block|{
name|raises
operator|=
name|tsubst
argument_list|(
name|raises
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
operator|==
name|error_mark_node
condition|)
return|return
name|raises
return|;
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|raises
argument_list|)
expr_stmt|;
block|}
return|return
name|fntype
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|domain
init|=
name|tsubst
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* As an optimization, we avoid regenerating the array type if 	   it will obviously be the same as T.  */
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|domain
operator|==
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* These checks should match the ones in grokdeclarator.    	   [temp.deduct]  	 	   The deduction may fail for any of the following reasons:   	   -- Attempting to create an array with an element type that 	      is void, a function type, or a reference type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"creating array of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|r
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|NEGATE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|}
case|case
name|TYPENAME_TYPE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
decl_stmt|;
name|tree
name|f
init|=
name|tsubst_copy
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|error_mark_node
operator|||
name|f
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not a class, struct, or union type"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|ctx
argument_list|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* Normally, make_typename_type does not require that the CTX 	       have complete type in order to allow things like: 	      	         template<class T> struct S { typename S<T>::X Y; };  	       But, such constructs have already been resolved by this 	       point, so here CTX really should have complete type, unless 	       it's a partial instantiation.  */
name|ctx
operator|=
name|complete_type
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|f
operator|=
name|make_typename_type
argument_list|(
name|ctx
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|error_mark_node
condition|)
return|return
name|f
return|;
return|return
name|cp_build_qualified_type
argument_list|(
name|f
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|f
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_pointer_declarator
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_reference_declarator
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_parse_node
argument_list|(
name|ARRAY_REF
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|tsubst_expr
argument_list|)
return|;
block|}
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst_call_declarator_parms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e3
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
operator|||
name|e3
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|make_call_declarator
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|e3
argument_list|)
return|;
block|}
case|case
name|SCOPE_REF
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_parse_node
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
return|;
block|}
case|case
name|TYPEOF_TYPE
case|:
block|{
name|tree
name|e1
init|=
name|tsubst_expr
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
return|;
block|}
default|default:
name|sorry
argument_list|(
literal|"use of `%s' in template"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_function
name|void
name|do_pushlevel
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|do_poplevel
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
name|int
name|saved_warn_unused
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|saved_warn_unused
operator|=
name|warn_unused
expr_stmt|;
name|warn_unused
operator|=
literal|0
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|kept_level_p
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|warn_unused
operator|=
name|saved_warn_unused
expr_stmt|;
name|t
operator|=
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like tsubst, but deals with expressions.  This function just replaces    template parms; to finish processing the resultant expression, use    tsubst_expr.  */
end_comment

begin_function
name|tree
name|tsubst_copy
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARM_DECL
case|:
return|return
name|do_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
block|{
name|tree
name|enum_type
decl_stmt|;
name|tree
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
comment|/* This is a global enumeration constant.  */
return|return
name|t
return|;
comment|/* Unfortunately, we cannot just call lookup_name here. 	 Consider:  	 template<int I> int f() { 	   enum E { a = I }; 	   struct S { void g() { E e = a; } }; 	 };  	 When we instantiate f<7>::S::g(), say, lookup_name is not 	 clever enough to find f<7>::a.  */
name|enum_type
operator|=
name|tsubst_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|TYPE_VALUES
argument_list|(
name|enum_type
argument_list|)
init|;
name|v
operator|!=
name|NULL_TREE
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
return|;
comment|/* We didn't find the name.  That should never happen; if 	     name-lookup found it during preliminary parsing, we 	     should find it again here during instantiation.  */
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|lookup_field
argument_list|(
name|ctx
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|t
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|TEMPLATE_DECL
case|:
if|if
condition|(
name|is_member_template
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
else|else
return|return
name|t
return|;
case|case
name|LOOKUP_EXPR
case|:
block|{
comment|/* We must tsbust into a LOOKUP_EXPR in case the names to 	   which it refers is a conversion operator; in that case the 	   name will change.  We avoid making unnecessary copies, 	   however.  */
name|tree
name|id
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|!=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|r
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|NOP_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
comment|/* Unary + */
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|THROW_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|SCOPE_REF
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|MEMBER_REF
case|:
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|get_first_fn
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
comment|/* Sometimes FN is a LOOKUP_EXPR.  */
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|fn
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|METHOD_CALL_EXPR
case|:
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|base
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|BIND_EXPR
case|:
case|case
name|COND_EXPR
case|:
case|case
name|MODOP_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|BIND_EXPR
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* This processing should really occur in tsubst_expr, 	       However, tsubst_expr does not recurse into expressions, 	       since it assumes that there aren't any statements 	       inside them.  Instead, it simply calls 	       build_expr_from_tree.  So, we need to expand the 	       BIND_EXPR here.  */
name|tree
name|rtl_expr
init|=
name|begin_stmt_expr
argument_list|()
decl_stmt|;
name|tree
name|block
init|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|r
operator|=
name|finish_stmt_expr
argument_list|(
name|rtl_expr
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
case|case
name|NEW_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DELETE_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_VEC
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
comment|/* Substituted template arguments */
name|tree
name|targs
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|targs
operator|&&
name|TREE_CODE
argument_list|(
name|targs
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|targs
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targs
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup_template_function
argument_list|(
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|targs
argument_list|)
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst_copy
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst_copy
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst_copy
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|TYPE_DECL
case|:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
comment|/* Make sure it's not just a variable named `__opr', for instance, 	     which can occur in some existing code.  */
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build_typename_overload
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
else|else
return|return
name|t
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|r
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|tsubst_copy
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like tsubst_copy, but also does semantic processing and RTL expansion.  */
end_comment

begin_function
name|tree
name|tsubst_expr
parameter_list|(
name|t
parameter_list|,
name|args
parameter_list|,
name|complain
parameter_list|,
name|in_decl
parameter_list|)
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|tree
name|in_decl
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RETURN_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_return_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|RETURN_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_STMT
case|:
block|{
name|int
name|i
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|tree
name|dcl
decl_stmt|,
name|init
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dcl
operator|=
name|start_decl
argument_list|(
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|init
operator|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|dcl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|,
comment|/*init ? LOOKUP_ONLYCONVERTING :*/
literal|0
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|dcl
return|;
block|}
case|case
name|FOR_STMT
case|:
block|{
name|tree
name|tmp
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_for_stmt
argument_list|()
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|FOR_INIT_STMT
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_init_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tsubst_expr
argument_list|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_for_stmt
argument_list|(
name|tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|WHILE_STMT
case|:
block|{
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_while_stmt
argument_list|()
expr_stmt|;
name|finish_while_stmt_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|WHILE_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_while_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DO_STMT
case|:
block|{
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_do_stmt
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_do_body
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_do_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|DO_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_STMT
case|:
block|{
name|tree
name|tmp
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|tsubst_expr
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
condition|)
block|{
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|=
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
operator|,
name|tmp
condition|)
block|{
name|begin_else_clause
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_else_clause
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_STMT
case|:
block|{
name|tree
name|substmt
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_compound_stmt
argument_list|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|substmt
operator|=
name|COMPOUND_BODY
argument_list|(
name|t
argument_list|)
init|;
name|substmt
operator|!=
name|NULL_TREE
condition|;
name|substmt
operator|=
name|TREE_CHAIN
argument_list|(
name|substmt
argument_list|)
control|)
name|tsubst_expr
argument_list|(
name|substmt
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|finish_compound_stmt
argument_list|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
break|break;
case|case
name|BREAK_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_break_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONTINUE_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_continue_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|SWITCH_STMT
case|:
block|{
name|tree
name|val
decl_stmt|,
name|tmp
decl_stmt|;
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_switch_stmt
argument_list|()
expr_stmt|;
name|val
operator|=
name|tsubst_expr
argument_list|(
name|SWITCH_COND
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_switch_cond
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|,
name|tmp
condition|)
name|tsubst_expr
argument_list|(
name|tmp
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_switch_stmt
argument_list|(
name|val
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CASE_LABEL
case|:
name|finish_case_label
argument_list|(
name|tsubst_expr
argument_list|(
name|CASE_LOW
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
name|t
operator|=
name|define_label
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|expand_label
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
comment|/* Computed goto's must be tsubst'd into.  On the other hand, 	   non-computed gotos must not be; the identifier in question 	   will have no binding.  */
name|t
operator|=
name|tsubst_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_goto_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_STMT
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_asm_stmt
argument_list|(
name|tsubst_expr
argument_list|(
name|ASM_CV_QUAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_STRING
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_INPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|ASM_CLOBBERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_BLOCK
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_try_block
argument_list|()
expr_stmt|;
name|tsubst_expr
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_try_block
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|{
name|tree
name|handler
init|=
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|handler
condition|;
name|handler
operator|=
name|TREE_CHAIN
argument_list|(
name|handler
argument_list|)
control|)
name|tsubst_expr
argument_list|(
name|handler
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
name|finish_handler_sequence
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HANDLER
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|begin_handler
argument_list|()
expr_stmt|;
if|if
condition|(
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|d
init|=
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|expand_start_catch_block
argument_list|(
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|d
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_start_catch_block
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_handler_parms
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|finish_handler
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_DEFN
case|:
name|lineno
operator|=
name|TREE_COMPLEXITY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|build_expr_from_tree
argument_list|(
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Instantiate the indicated variable or function template TMPL with    the template arguments in TARG_PTR.  */
end_comment

begin_function
name|tree
name|instantiate_template
parameter_list|(
name|tmpl
parameter_list|,
name|targ_ptr
parameter_list|)
name|tree
name|tmpl
decl_stmt|,
name|targ_ptr
decl_stmt|;
block|{
name|tree
name|fndecl
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_fmp_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|283
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* The TMPL is a partial instantiation.  To get a full set of 	 arguments we must add the arguments used to perform the 	 partial instantiation.  */
name|targ_ptr
operator|=
name|add_outermost_template_args
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
block|}
else|else
name|gen_tmpl
operator|=
name|tmpl
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|old_fmp_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|len
operator|=
name|DECL_NTPARMS
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|inner_args
operator|=
name|innermost_args
argument_list|(
name|targ_ptr
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|tree
name|nt
init|=
name|target_type
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|nt
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|nt
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' composed from a local class is not a valid template-argument"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  trying to instantiate `%D'"
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|error_mark_node
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|targ_ptr
operator|=
name|copy_to_permanent
argument_list|(
name|targ_ptr
argument_list|)
expr_stmt|;
comment|/* substitute template parameters */
name|fndecl
operator|=
name|tsubst
argument_list|(
name|DECL_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
comment|/* The DECL_TI_TEMPLATE should always be the immediate parent      template, not the most general template.  */
name|DECL_TI_TEMPLATE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
if|if
condition|(
name|flag_external_templates
condition|)
name|add_pending_template
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|out
label|:
name|function_maybepermanent_obstack
operator|=
name|old_fmp_obstack
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* Push the name of the class template into the scope of the instantiation.  */
end_comment

begin_function
name|void
name|overload_template_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
init|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
operator|==
name|type
condition|)
return|return;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The FN is a TEMPLATE_DECL for a function.  The ARGS are the    arguments that are being used when calling it.  TARGS is a vector    into which the deduced template arguments are placed.       Return zero for success, 2 for an incomplete match that doesn't resolve    all the types, and 1 for complete failure.  An error message will be    printed only for an incomplete match.     If FN is a conversion operator, RETURN_TYPE is the type desired as    the result of the conversion operator.     TPARMS is a vector of template parameters.     The EXPLICIT_TARGS are explicit template arguments provided via a    template-id.     The parameter STRICT is one of:     DEDUCE_CALL:       We are deducing arguments for a function call, as in      [temp.deduct.call].     DEDUCE_CONV:      We are deducing arguments for a conversion function, as in       [temp.deduct.conv].     DEDUCE_EXACT:      We are deducing arguments when calculating the partial      ordering between specializations of function or class      templates, as in [temp.func.order] and [temp.class.order],      when doing an explicit instantiation as in [temp.explicit],      when determining an explicit specialization as in      [temp.expl.spec], or when taking the address of a function      template, as in [temp.deduct.funcaddr].      The other arguments are as for type_unification.  */
end_comment

begin_function
name|int
name|fn_type_unification
parameter_list|(
name|fn
parameter_list|,
name|explicit_targs
parameter_list|,
name|targs
parameter_list|,
name|args
parameter_list|,
name|return_type
parameter_list|,
name|strict
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|explicit_targs
decl_stmt|,
name|targs
decl_stmt|,
name|args
decl_stmt|,
name|return_type
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_targs
condition|)
block|{
comment|/* [temp.deduct] 	   	 The specified template arguments must match the template 	 parameters in kind (i.e., type, nontype, template), and there 	 must not be more arguments than there are parameters; 	 otherwise type deduction fails.  	 Nontype arguments must match the types of the corresponding 	 nontype template parameters, or must be convertible to the 	 types of the corresponding nontype parameters as specified in 	 _temp.arg.nontype_, otherwise type deduction fails.  	 All references in the function type of the function template 	 to the corresponding template parameters are replaced by the 	 specified template argument values.  If a substitution in a 	 template parameter or in the function type of the function 	 template results in an invalid type, type deduction fails.  */
name|int
name|i
decl_stmt|;
name|tree
name|converted_args
decl_stmt|;
name|converted_args
operator|=
operator|(
name|coerce_template_parms
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_targs
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
comment|/*require_all_arguments=*/
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|converted_args
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
name|fntype
operator|=
name|tsubst
argument_list|(
name|fntype
argument_list|,
name|converted_args
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Place the explicitly specified arguments in TARGS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|converted_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* This is a template conversion operator.  Use the return types          as well as the argument types.  We use it instead of 'this', since          we could be comparing conversions from different classes.  */
name|parms
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|return_type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We allow incomplete unification without an error message here      because the standard doesn't seem to explicitly prohibit it.  Our      callers must be ready to deal with unification failures in any      event.  */
return|return
name|type_unification_real
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
name|parms
argument_list|,
name|args
argument_list|,
comment|/*subr=*/
literal|0
argument_list|,
name|strict
argument_list|,
comment|/*allow_incomplete*/
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adjust types before performing type deduction, as described in    [temp.deduct.call] and [temp.deduct.conv].  The rules in these two    sections are symmetric.  PARM is the type of a function parameter    or the return type of the conversion function.  ARG is the type of    the argument passed to the call, or the type of the value    intialized with the result of the conversion function.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_adjust_types_for_deduction
parameter_list|(
name|strict
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|unification_kind_t
name|strict
decl_stmt|;
name|tree
modifier|*
name|parm
decl_stmt|;
name|tree
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
break|break;
case|case
name|DEDUCE_CONV
case|:
block|{
comment|/* Swap PARM and ARG throughout the remainder of this 	   function; the handling is precisely symmetric since PARM 	   will initialize ARG rather than vice versa.  */
name|tree
modifier|*
name|temp
init|=
name|parm
decl_stmt|;
name|parm
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
block|}
case|case
name|DEDUCE_EXACT
case|:
comment|/* There is nothing to do in this case.  */
return|return;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [temp.deduct.call] 	  	 If P is not a reference type: 	  	 --If A is an array type, the pointer type produced by the 	 array-to-pointer standard conversion (_conv.array_) is 	 used in place of A for type deduction; otherwise, 	  	 --If A is a function type, the pointer type produced by 	 the function-to-pointer standard conversion 	 (_conv.func_) is used in place of A for type deduction; 	 otherwise, 	  	 --If A is a cv-qualified type, the top level 	 cv-qualifiers of A's type are ignored for type 	 deduction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
else|else
operator|*
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.deduct.call]            If P is a cv-qualified type, the top level cv-qualifiers      of P's type are ignored for type deduction.  If P is a      reference type, the type referred to by P is used for      type deduction.  */
operator|*
name|parm
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
operator|*
name|parm
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like type_unfication.     If SUBR is 1, we're being called recursively (to unify the    arguments of a function or method parameter of a function    template).  */
end_comment

begin_function
specifier|static
name|int
name|type_unification_real
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|,
name|subr
parameter_list|,
name|strict
parameter_list|,
name|allow_incomplete
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
name|int
name|subr
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|allow_incomplete
decl_stmt|;
block|{
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|289
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|parms
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|290
argument_list|)
expr_stmt|;
comment|/* ARGS could be NULL (via a call from parse.y to      build_x_function_call).  */
if|if
condition|(
name|args
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|291
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|ntparms
operator|>
literal|0
argument_list|,
literal|292
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_MORE_CV_QUAL
operator||
name|UNIFY_ALLOW_DERIVED
expr_stmt|;
break|break;
case|case
name|DEDUCE_CONV
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_LESS_CV_QUAL
expr_stmt|;
break|break;
case|case
name|DEDUCE_EXACT
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_NONE
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
comment|/* We can't deduce anything from this, but we might get all the 	   template args from other function args.  */
continue|continue;
comment|/* Conversions will be performed on a function argument that 	 corresponds with a function parameter that contains only 	 non-deducible template parameters and explicitly specified 	 template parameters.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|strict
operator|==
name|DEDUCE_EXACT
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|parm
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
block|}
else|else
comment|/* It might work; we shouldn't check now, because we might 	       get into infinite recursion.  Overload resolution will 	       handle it.  */
continue|continue;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|293
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* [temp.deduct.type] A template-argument can be deduced from 		 a pointer to function or pointer to member function 		 argument if the set of overloaded functions does not 		 contain function templates and at most one of a set of 		 overloaded functions provides a unique match.  */
if|if
condition|(
name|resolve_overloaded_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
name|arg
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|subr
condition|)
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|sub_strict
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
block|}
block|}
comment|/* Fail if we've reached the end of the parm list, and more args      are present, and the parm list isn't variadic.  */
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|1
return|;
comment|/* Fail if parms are left and they don't have default values.	 */
if|if
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|subr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|allow_incomplete
condition|)
name|error
argument_list|(
literal|"incomplete type unification"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of type_unification_real.  Args are like the variables at the    call site.  ARG is an overloaded function (or template-id); we try    deducing template args from each of the overloads, and if only one    succeeds, we go with that.  Modifies TARGS and returns 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|resolve_overloaded_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|,
name|sub_strict
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
block|{
name|tree
name|tempargs
init|=
name|copy_node
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|good
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
comment|/* Handle `&x' where `x' is some static or non-static member        function name.  */
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Strip baselink information.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* If we got some explicit template args, we need to plug them into 	 the affected templates before we try to unify, in case the 	 explicit args will completely resolve the templates in question.  */
name|tree
name|expl_subargs
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|OVL_NEXT
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|subargs
decl_stmt|,
name|elem
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
continue|continue;
name|subargs
operator|=
name|get_bindings_overload
argument_list|(
name|fn
argument_list|,
name|DECL_RESULT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|expl_subargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|subargs
condition|)
block|{
name|elem
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|subargs
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|elem
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|good
operator|+=
name|try_one_overload
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|elem
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|OVL_NEXT
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|good
operator|+=
name|try_one_overload
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|type
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|981006
argument_list|)
expr_stmt|;
comment|/* [temp.deduct.type] A template-argument can be deduced from a pointer      to function or pointer to member function argument if the set of      overloaded functions does not contain function templates and at most      one of a set of overloaded functions provides a unique match.       So if we found multiple possibilities, we return success but don't      deduce anything.  */
if|if
condition|(
name|good
operator|==
literal|1
condition|)
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|good
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of resolve_overloaded_unification; does deduction for a single    overload.  Fills TARGS with any deduced arguments, or error_mark_node if    different overloads deduce different arguments for a given parm.    Returns 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|try_one_overload
parameter_list|(
name|tparms
parameter_list|,
name|orig_targs
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|,
name|sub_strict
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|orig_targs
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|unification_kind_t
name|strict
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|tree
name|tempargs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* [temp.deduct.type] A template-argument can be deduced from a pointer      to function or pointer to member function argument if the set of      overloaded functions does not contain function templates and at most      one of a set of overloaded functions provides a unique match.       So if this is a template, just return success.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* We don't copy orig_targs for this because if we have already deduced      some template args from previous args, unify would complain when we      try to deduce a template parameter for the same argument, even though      there isn't really a conflict.  */
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|tempargs
operator|=
name|make_scratch_vec
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|sub_strict
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* First make sure we didn't deduce anything that conflicts with      explicitly specified args.  */
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|oldelt
init|=
name|TREE_VEC_ELT
argument_list|(
name|orig_targs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|==
name|NULL_TREE
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* Since we're unifying against ourselves, we will fill in template 	     args used in the function parm list with our own template parms. 	     Discard them.  */
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|oldelt
operator|&&
operator|!
name|template_args_equal
argument_list|(
name|oldelt
argument_list|,
name|elt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|elt
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* PARM is a template class (perhaps with unbound template    parameters).  ARG is a fully instantiated type.  If ARG can be    bound to PARM, return ARG, otherwise return NULL_TREE.  TPARMS and    TARGS are as for unify.  */
end_comment

begin_function
specifier|static
name|tree
name|try_class_unification
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tree
name|copy_of_targs
decl_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|||
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
operator|!=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We need to make a new template argument vector for the call to      unify.  If we used TARGS, we'd clutter it up with the result of      the attempted unification, even if this class didn't work out.      We also don't want to commit ourselves to all the unifications      we've already done, since unification is supposed to be done on      an argument-by-argument basis.  In other words, consider the      following pathological case:         template<int I, int J, int K>        struct S {};                template<int I, int J>        struct S<I, J, 2> : public S<I, I, I>, S<J, J, J> {};                template<int I, int J, int K>        void f(S<I, J, K>, S<I, I, I>);                void g() {          S<0, 0, 0> s0;          S<0, 1, 2> s2;                  f(s0, s2);        }       Now, by the time we consider the unification involving `s2', we      already know that we must have `f<0, 0, 0>'.  But, even though      `S<0, 1, 2>' is derived from `S<0, 0, 0>', the code is not legal      because there are two ways to unify base classes of S<0, 1, 2>      with S<I, I, I>.  If we kept the already deduced knowledge, we      would reject the possibility I=1.  */
name|push_momentary
argument_list|()
expr_stmt|;
name|copy_of_targs
operator|=
name|make_temp_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|unify
argument_list|(
name|tparms
argument_list|,
name|copy_of_targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
comment|/* If unification failed, we're done.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of get_template_base.  RVAL, if non-NULL, is a base we    have alreay discovered to be satisfactory.  ARG_BINFO is the binfo    for the base class of ARG that we are currently examining.  */
end_comment

begin_function
specifier|static
name|tree
name|get_template_base_recursive
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg_binfo
parameter_list|,
name|rval
parameter_list|,
name|flags
parameter_list|)
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|arg_binfo
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
decl_stmt|;
name|tree
name|arg
init|=
name|BINFO_TYPE
argument_list|(
name|arg_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|GTB_IGNORE_TYPE
operator|)
condition|)
block|{
name|tree
name|r
init|=
name|try_class_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
decl_stmt|;
comment|/* If there is more than one satisfactory baseclass, then:  	   [temp.deduct.call]  	   If they yield more than one possible deduced A, the type 	   deduction fails.  	   applies.  */
if|if
condition|(
name|r
operator|&&
name|rval
operator|&&
operator|!
name|same_type_p
argument_list|(
name|r
argument_list|,
name|rval
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|r
condition|)
name|rval
operator|=
name|r
expr_stmt|;
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|arg_binfo
argument_list|)
expr_stmt|;
name|n_baselinks
operator|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Process base types.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|this_virtual
decl_stmt|;
comment|/* Skip this base, if we've already seen it.  */
if|if
condition|(
name|BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|this_virtual
operator|=
operator|(
name|flags
operator|&
name|GTB_VIA_VIRTUAL
operator|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
comment|/* When searching for a non-virtual, we cannot mark virtually 	 found binfos.  */
if|if
condition|(
operator|!
name|this_virtual
condition|)
name|SET_BINFO_MARKED
argument_list|(
name|base_binfo
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_template_base_recursive
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|base_binfo
argument_list|,
name|rval
argument_list|,
name|GTB_VIA_VIRTUAL
operator|*
name|this_virtual
argument_list|)
expr_stmt|;
comment|/* If we discovered more than one matching base class, we can 	 stop now.  */
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Given a template type PARM and a class type ARG, find the unique    base type in ARG that is an instance of PARM.  We do not examine    ARG itself; only its base-classes.  If there is no appropriate base    class, return NULL_TREE.  If there is more than one, return    error_mark_node.  PARM may be the type of a partial specialization,    as well as a plain template type.  Used by unify.  */
end_comment

begin_function
specifier|static
name|tree
name|get_template_base
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|)
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|arg_binfo
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
literal|92
argument_list|)
expr_stmt|;
name|arg_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|complete_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_template_base_recursive
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg_binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|GTB_IGNORE_TYPE
argument_list|)
expr_stmt|;
comment|/* Since get_template_base_recursive marks the bases classes, we      must unmark them here.  */
name|dfs_walk
argument_list|(
name|arg_binfo
argument_list|,
name|dfs_unmark
argument_list|,
name|markedp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Returns the level of DECL, which declares a template parameter.  */
end_comment

begin_function
specifier|static
name|int
name|template_decl_level
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
return|return
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
case|case
name|PARM_DECL
case|:
return|return
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Decide whether ARG can be unified with PARM, considering only the    cv-qualifiers of each type, given STRICT as documented for unify.    Returns non-zero iff the unification is OK on that basis.*/
end_comment

begin_function
specifier|static
name|int
name|check_cv_quals_for_unify
parameter_list|(
name|strict
parameter_list|,
name|arg
parameter_list|,
name|parm
parameter_list|)
name|int
name|strict
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
return|return
operator|!
operator|(
operator|(
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_MORE_CV_QUAL
operator|)
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|arg
argument_list|,
name|parm
argument_list|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_LESS_CV_QUAL
operator|)
operator|&&
operator|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Takes parameters as for type_unification.  Returns 0 if the    type deduction suceeds, 1 otherwise.  The parameter STRICT is a    bitwise or of the following flags:       UNIFY_ALLOW_NONE:        Require an exact match between PARM and ARG.      UNIFY_ALLOW_MORE_CV_QUAL:        Allow the deduced ARG to be more cv-qualified than ARG.      UNIFY_ALLOW_LESS_CV_QUAL:        Allow the deduced ARG to be less cv-qualified than ARG.      UNIFY_ALLOW_DERIVED:        Allow the deduced ARG to be a template base class of ARG,        or a pointer to a template base class of the type pointed to by        ARG.      UNIFY_ALLOW_INTEGER:        Allow any integral type to be deduced.  See the TEMPLATE_PARM_INDEX        case for more information.  */
end_comment

begin_function
specifier|static
name|int
name|unify
parameter_list|(
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|parm
parameter_list|,
name|arg
parameter_list|,
name|strict
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|targs
decl_stmt|,
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
name|tree
name|targ
decl_stmt|;
name|tree
name|tparm
decl_stmt|;
comment|/* I don't think this will do the right thing with respect to types.      But the only case I've seen it in so far has been array bounds, where      signedness is the only information lost, and I think that will be      okay.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|parm
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
comment|/* We can't deduce anything from this, but we might get all the        template args from other function args.  */
return|return
literal|0
return|;
comment|/* If PARM uses template parameters, then we can't bail out here,      even if ARG == PARM, since we won't record unifications for the      template parameters.  We might need them if we're trying to      figure out which of two things is more specialized.  */
if|if
condition|(
name|arg
operator|==
name|parm
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Immediately reject some pairs that won't unify because of      cv-qualification mismatches.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'t'
comment|/* We check the cv-qualifiers when unifying with template type 	 parameters below.  We want to allow ARG `const T' to unify with 	 PARM `T' for example, when computing which of two templates 	 is more specialized, for example.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPENAME_TYPE
case|:
comment|/* In a type which contains a nested-name-specifier, template 	 argument values cannot be deduced for template parameters used 	 within the nested-name-specifier.  */
return|return
literal|0
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mixed types and values.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
condition|)
block|{
comment|/* We arrive here when PARM does not involve template  		 specialization.  */
comment|/* ARG must be constructed from a template class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
block|{
name|tree
name|parmtmpl
init|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|parmvec
init|=
name|TYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|argtmplvec
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The parameter and argument roles have to be switched here  		   in order to handle default arguments properly.  For example,  		   template<template<class> class TT> void f(TT<int>)  		   should be able to accept vector<int> which comes from  		   template<class T, class Allocator = allocator>  		   class vector.  */
if|if
condition|(
name|coerce_template_parms
argument_list|(
name|argtmplvec
argument_list|,
name|parmvec
argument_list|,
name|parmtmpl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Deduce arguments T, i from TT<T> or TT<i>.   		   We check each element of PARMVEC and ARGVEC individually 		   rather than the whole TREE_VEC since they can have 		   different number of elements.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parmvec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|argvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
name|arg
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If PARM is `const T' and ARG is only `int', we don't have 	     a match unless we are allowing additional qualification. 	     If ARG is `const int' and PARM is just `T' that's OK; 	     that binds `const int' to `T'.  */
if|if
condition|(
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict
operator||
name|UNIFY_ALLOW_LESS_CV_QUAL
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Consider the case where ARG is `const volatile int' and 	     PARM is `const T'.  Then, T should be `volatile int'.  */
name|arg
operator|=
name|cp_build_qualified_type
argument_list|(
name|arg
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|arg
argument_list|)
operator|&
operator|~
name|CP_TYPE_QUALS
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targ
operator|!=
name|NULL_TREE
operator|&&
name|same_type_p
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targ
condition|)
return|return
literal|1
return|;
comment|/* Make sure that ARG is not a variable-sized array.  (Note that 	 were talking about variable-sized arrays (like `int[n]'), 	 rather than arrays of unknown size (like `int[]').)  We'll 	 get very confused by such a type since the bound of the array 	 will not be computable in an instantiation.  Besides, such 	 types are not allowed in ISO C++, so we can do as we please 	 here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
return|return
literal|1
return|;
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
condition|)
block|{
name|int
name|i
init|=
operator|(
name|cp_tree_equal
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.deduct.type] If, in the declaration of a function template 	 with a non-type template-parameter, the non-type 	 template-parameter is used in an expression in the function 	 parameter-list and, if the corresponding template-argument is 	 deduced, the template-argument type shall match the type of the 	 template-parameter exactly, except that a template-argument 	 deduced from an array bound may be of any integral type.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_INTEGER
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
return|return
literal|1
return|;
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|idx
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|POINTER_TYPE
case|:
block|{
name|int
name|sub_strict
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|arg
argument_list|)
condition|)
return|return
operator|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
comment|/* [temp.deduct.call]  	   A can be another pointer or pointer to member type that can 	   be converted to the deduced A via a qualification 	   conversion (_conv.qual_).  	   We pass down STRICT here rather than UNIFY_ALLOW_NONE. 	   This will allow for additional cv-qualification of the 	   pointed-to types if appropriate.  In general, this is a bit 	   too generous; we are only supposed to allow qualification 	   conversions and this method will allow an ARG of char** and 	   a deduced ARG of const char**.  However, overload 	   resolution will subsequently invalidate the candidate, so 	   this is probably OK.  */
name|sub_strict
operator|=
name|strict
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
comment|/* The derived-to-base conversion only persists through one 	     level of pointers.  */
name|sub_strict
operator|&=
operator|~
name|UNIFY_ALLOW_DERIVED
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|sub_strict
argument_list|)
return|;
block|}
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|!=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_INTEGER
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
operator|&&
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_INTEGER
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* We use the TYPE_MAIN_VARIANT since we have already 	 checked cv-qualification at the top of the 	 function.  */
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* As far as unification is concerned, this wins.	 Later checks 	 will invalidate it if necessary.  */
return|return
literal|0
return|;
comment|/* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */
comment|/* Type INTEGER_CST can come from ordinary constant template args.  */
case|case
name|INTEGER_CST
case|:
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|tree_int_cst_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_VEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parm
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|strict
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|strict
operator|&
name|UNIFY_ALLOW_DERIVED
condition|)
block|{
comment|/* First, we try to unify the PARM and ARG directly.  */
name|t
operator|=
name|try_class_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* Fallback to the special case allowed in 		     [temp.deduct.call]: 		      		       If P is a class, and P has the form 		       template-id, then A can be a derived class of 		       the deduced A.  Likewise, if P is a pointer to 		       a class of the form template-id, A can be a 		       pointer to a derived class pointed to by the 		       deduced A.  */
name|t
operator|=
name|get_template_base
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
operator|==
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
comment|/* Perhaps PARM is something like S<U> and ARG is S<int>. 	       Then, we should unify `int' and `U'.  */
name|t
operator|=
name|arg
expr_stmt|;
else|else
comment|/* There's no chance of unication succeeding.  */
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|type_unification_real
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|DEDUCE_EXACT
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|arg
operator|!=
name|decl_constant_value
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_DECL
case|:
comment|/* Matched cases are handled by the ARG == PARM test above.  */
return|return
literal|1
return|;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* We handle this case specially, since it comes up with 	     arrays.  In particular, something like:  	     template<int N> void f(int (&x)[N]);  	     Here, we are trying to unify the range type, which 	     looks like [0 ... (N - 1)].  */
name|tree
name|t
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Should this be a regular fold?  */
name|t
operator|=
name|maybe_fold_nontype_arg
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|t1
argument_list|,
name|t
argument_list|,
name|strict
argument_list|)
return|;
block|}
comment|/* else fall through */
default|default:
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* We're looking at an expression.  This can happen with 	   something like:  	    	     template<int I> 	     void foo(S<I>, S<I + 2>);  	   This is a "nondeduced context":  	     [deduct.type] 	    	     The nondeduced contexts are:  	     --A type that is a template-id in which one or more of 	       the template-arguments is an expression that references 	       a template-parameter.    	   In these cases, we assume deduction succeeded, but don't 	   actually infer any unifications.  */
return|return
literal|0
return|;
else|else
name|sorry
argument_list|(
literal|"use of `%s' in template type unification"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called if RESULT is explicitly instantiated, or is a member of an    explicitly instantiated class, or if using -frepo and the    instantiation of RESULT has been assigned to this file.  */
end_comment

begin_function
name|void
name|mark_decl_instantiated
parameter_list|(
name|result
parameter_list|,
name|extern_p
parameter_list|)
name|tree
name|result
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* The TREE_PUBLIC flag for function declarations will have been        set correctly by tsubst.  */
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Always make artificials weak.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|result
argument_list|)
operator|&&
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* For WIN32 we also want to put explicit instantiations in 	 linkonce sections.  */
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
condition|)
name|maybe_make_one_only
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|mark_inline_for_output
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given two function templates PAT1 and PAT2, and explicit template    arguments EXPLICIT_ARGS return:     1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.  */
end_comment

begin_function
name|int
name|more_specialized
parameter_list|(
name|pat1
parameter_list|,
name|pat2
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|pat1
decl_stmt|,
name|pat2
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
name|tree
name|targs
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|targs
operator|=
name|get_bindings_overload
argument_list|(
name|pat1
argument_list|,
name|DECL_RESULT
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|--
name|winner
expr_stmt|;
name|targs
operator|=
name|get_bindings_overload
argument_list|(
name|pat2
argument_list|,
name|DECL_RESULT
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|++
name|winner
expr_stmt|;
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Given two class template specialization list nodes PAT1 and PAT2, return:     1 if PAT1 is more specialized than PAT2 as described in [temp.class.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.  */
end_comment

begin_function
name|int
name|more_specialized_class
parameter_list|(
name|pat1
parameter_list|,
name|pat2
parameter_list|)
name|tree
name|pat1
decl_stmt|,
name|pat2
decl_stmt|;
block|{
name|tree
name|targs
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|--
name|winner
expr_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pat1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|++
name|winner
expr_stmt|;
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Return the template arguments that will produce the function signature    DECL from the function template FN, with the explicit template    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must    also match.  Return NULL_TREE if no satisfactory arguments could be    found.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings_real
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|,
name|check_rettype
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
name|int
name|check_rettype
decl_stmt|;
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_scratch_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
name|tree
name|decl_arg_types
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Substitute the explicit template arguments into the type of DECL.      The call to fn_type_unification will handle substitution into the      FN.  */
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_args
operator|&&
name|uses_template_parms
argument_list|(
name|decl_type
argument_list|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|converted_args
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* We can get here for some illegal specializations.  */
return|return
name|NULL_TREE
return|;
name|converted_args
operator|=
operator|(
name|coerce_template_parms
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|explicit_args
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
comment|/*require_all_arguments=*/
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|converted_args
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|decl_type
operator|=
name|tsubst
argument_list|(
name|decl_type
argument_list|,
name|converted_args
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
block|}
comment|/* If FN is a static member function, adjust the type of DECL      appropriately.  */
name|decl_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|decl_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_arg_types
argument_list|)
expr_stmt|;
name|i
operator|=
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_args
argument_list|,
name|targs
argument_list|,
name|decl_arg_types
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl_type
argument_list|)
argument_list|,
name|DEDUCE_EXACT
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|check_rettype
condition|)
block|{
comment|/* Check to see that the resulting return type is also OK.  */
name|tree
name|t
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|targs
argument_list|,
comment|/*complain=*/
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|targs
return|;
block|}
end_function

begin_comment
comment|/* For most uses, we want to check the return type.  */
end_comment

begin_function
name|tree
name|get_bindings
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
return|return
name|get_bindings_real
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* But for more_specialized, we only care about the parameter types.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings_overload
parameter_list|(
name|fn
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
return|return
name|get_bindings_real
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost template arguments that, when applied to a    template specialization whose innermost template parameters are    TPARMS, and whose specialization arguments are ARGS, yield the    ARGS.       For example, suppose we have:       template<class T, class U> struct S {};      template<class T> struct S<T*, int> {};     Then, suppose we want to get `S<double*, int>'.  The TPARMS will be    {T}, the PARMS will be {T*, int} and the ARGS will be {double*,    int}.  The resulting vector will be {double}, indicating that `T'    is bound to `double'.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_bindings
parameter_list|(
name|tparms
parameter_list|,
name|parms
parameter_list|,
name|args
parameter_list|)
name|tree
name|tparms
decl_stmt|,
name|parms
decl_stmt|,
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|tree
name|vec
init|=
name|make_temp_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|args
operator|=
name|innermost_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|vec
argument_list|,
name|parms
argument_list|,
name|args
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|vec
return|;
block|}
end_function

begin_comment
comment|/* In INSTANTIATIONS is a list of<INSTANTIATION, TEMPLATE> pairs.    Pick the most specialized template, and return the corresponding    instantiation, or if there is no corresponding instantiation, the    template itself.  EXPLICIT_ARGS is any template arguments explicity    mentioned in a template-id.  If there is no most specialized    tempalte, error_mark_node is returned.  If there are no templates    at all, NULL_TREE is returned.  */
end_comment

begin_function
name|tree
name|most_specialized_instantiation
parameter_list|(
name|instantiations
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|instantiations
decl_stmt|;
name|tree
name|explicit_args
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|,
name|champ
decl_stmt|;
name|int
name|fate
decl_stmt|;
if|if
condition|(
operator|!
name|instantiations
condition|)
return|return
name|NULL_TREE
return|;
name|champ
operator|=
name|instantiations
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|instantiations
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
block|}
name|champ
operator|=
name|fn
expr_stmt|;
block|}
block|}
for|for
control|(
name|fn
operator|=
name|instantiations
init|;
name|fn
operator|&&
name|fn
operator|!=
name|champ
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|TREE_PURPOSE
argument_list|(
name|champ
argument_list|)
condition|?
name|TREE_PURPOSE
argument_list|(
name|champ
argument_list|)
else|:
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the list of templates in FNS that can    produce an instantiation matching DECL, given the explicit template    arguments EXPLICIT_ARGS.  */
end_comment

begin_function
specifier|static
name|tree
name|most_specialized
parameter_list|(
name|fns
parameter_list|,
name|decl
parameter_list|,
name|explicit_args
parameter_list|)
name|tree
name|fns
decl_stmt|,
name|decl
decl_stmt|,
name|explicit_args
decl_stmt|;
block|{
name|tree
name|candidates
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|candidate
init|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|args
operator|=
name|get_bindings
argument_list|(
name|candidate
argument_list|,
name|decl
argument_list|,
name|explicit_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|candidates
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|candidate
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
block|}
return|return
name|most_specialized_instantiation
argument_list|(
name|candidates
argument_list|,
name|explicit_args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a specialization of some template, return the most    general such template.  For example, given:       template<class T> struct S { template<class U> void f(U); };     if TMPL is `template<class U> void S<int>::f(U)' this will return    the full template.  This function will not trace past partial    specializations, however.  For example, given in addition:       template<class T> struct S<T*> { template<class U> void f(U); };     if TMPL is `template<class U> void S<int*>::f(U)' this will return    `template<class T> template<class U> S<T*>::f(U)'.  */
end_comment

begin_function
specifier|static
name|tree
name|most_general_template
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the class template specializations    of TMPL which can produce an instantiation matching ARGS, or    error_mark_node if the choice is ambiguous.  */
end_comment

begin_function
specifier|static
name|tree
name|most_specialized_class
parameter_list|(
name|tmpl
parameter_list|,
name|args
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|champ
decl_stmt|;
name|int
name|fate
decl_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|spec_args
init|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec_args
condition|)
block|{
name|list
operator|=
name|decl_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|list
expr_stmt|;
name|champ
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|error_mark_node
return|;
block|}
name|champ
operator|=
name|t
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
operator|&&
name|t
operator|!=
name|champ
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* called from the parser.  */
end_comment

begin_function
name|void
name|do_decl_instantiation
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|storage
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of non-template `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* There is an asymmetry here in the way VAR_DECLs and 	 FUNCTION_DECLs are handled by grokdeclarator.  In the case of 	 the latter, the DECL we get back will be marked as a 	 template instantiation, and the appropriate 	 DECL_TEMPLATE_INFO will be set up.  This does not happen for 	 VAR_DECLs so we do the lookup here.  Probably, grokdeclarator 	 should handle VAR_DECLs as it currently handles 	 FUNCTION_DECLs.  */
name|result
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"no matching template for `%D' found"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|result
operator|=
name|decl
expr_stmt|;
comment|/* Check for various error cases.  Note that if the explicit      instantiation is legal the RESULT will currently be marked as an      *implicit* instantiation; DECL_EXPLICIT_INSTANTIATION is not set      until we get here.  */
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall both explicitly instantiate and explicitly 	 specialize a template.  */
name|cp_pedwarn
argument_list|(
literal|"explicit instantiation of `%#D' after"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"explicit specialization here"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall explicitly instantiate any template more 	 than once.    	 We check DECL_INTERFACE_KNOWN so as not to complain when the 	 first instantiation was `extern' and the second is not, and 	 EXTERN_P for the opposite case.  */
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|extern_p
operator|&&
operator|!
name|flag_use_repository
condition|)
name|cp_pedwarn
argument_list|(
literal|"duplicate explicit instantiation of `%#D'"
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* If we've already instantiated the template, just return now.  */
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"no matching template for `%D' found"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"explicit instantiation of non-template `%#D'"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids the use of `extern' on explicit instantiations"
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|mark_decl_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mark_class_instantiated
parameter_list|(
name|t
parameter_list|,
name|extern_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|extern_p
decl_stmt|;
block|{
name|SET_CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|extern_p
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|extern_p
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|extern_p
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|do_type_instantiation
parameter_list|(
name|t
parameter_list|,
name|storage
parameter_list|)
name|tree
name|t
decl_stmt|,
name|storage
decl_stmt|;
block|{
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
name|int
name|nomem_p
init|=
literal|0
decl_stmt|;
name|int
name|static_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of non-template type `%T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* With -fexternal-templates, explicit instantiations are treated the same      as implicit ones.  */
if|if
condition|(
name|flag_external_templates
condition|)
return|return;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"explicit instantiation of `%#T' before definition of template"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|storage
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids the use of `%s' on explicit instantiations"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|storage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
condition|)
name|nomem_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|extern_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
condition|)
name|static_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"storage class `%D' applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall both explicitly instantiate and explicitly 	 specialize a template.  */
name|cp_error
argument_list|(
literal|"explicit instantiation of `%#T' after"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"explicit specialization here"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall explicitly instantiate any template more 	 than once.             If CLASSTYPE_INTERFACE_ONLY, then the first explicit 	 instantiation was `extern', and if EXTERN_P then the second 	 is.  Both cases are OK.  */
if|if
condition|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|extern_p
operator|&&
operator|!
name|flag_use_repository
condition|)
name|cp_pedwarn
argument_list|(
literal|"duplicate explicit instantiation of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we've already instantiated the template, just return now.  */
if|if
condition|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
return|return;
block|}
name|mark_class_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nomem_p
condition|)
return|return;
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* In contrast to implicit instantiation, where only the        declarations, and not the definitions, of members are        instantiated, we have here:           [temp.explicit]  	 The explicit instantiation of a class template specialization 	 implies the instantiation of all of its members not 	 previously explicitly specialized in the translation unit 	 containing the explicit instantiation.           Of course, we can't instantiate member template classes, since        we don't have any arguments for them.  Note that the standard        is unclear on whether the instatiation of the members are        *explicit* instantiations or not.  We choose to be generous,        and not set DECL_EXPLICIT_INSTANTIATION.  Therefore, we allow        the explicit instantiation of a class where some of the members        have no definition in the current translation unit.  */
if|if
condition|(
operator|!
name|static_p
condition|)
for|for
control|(
name|tmp
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|mark_decl_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|mark_decl_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
name|repo_template_instantiated
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|do_type_instantiation
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a function DECL, which is a specialization of TMPL, modify    DECL to be a re-instantiation of TMPL with the same template    arguments.  TMPL should be the template into which tsubst'ing    should occur for DECL, not the most general template.     One reason for doing this is a scenario like this:       template<class T>      void f(const T&, int i);       void g() { f(3, 7); }       template<class T>      void f(const T& t, const int i) { }     Note that when the template is first instantiated, with    instantiate_template, the resulting DECL will have no name for the    first parameter, and the wrong type for the second.  So, when we go    to instantiate the DECL, we regenerate it.  */
end_comment

begin_function
specifier|static
name|void
name|regenerate_decl_from_template
parameter_list|(
name|decl
parameter_list|,
name|tmpl
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
name|args
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|tree
name|new_decl
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|int
name|unregistered
decl_stmt|;
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Unregister the specialization so that when we tsubst we will not      just return DECL.  We don't have to unregister DECL from TMPL      because if would only be registered there if it were a partial      instantiation of a specialization, which it isn't: it's a full      instantiation.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|unregistered
operator|=
name|unregister_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
comment|/* If the DECL was not unregistered then something peculiar is      happening: we created a specialization but did not call      register_specialization for it.  */
name|my_friendly_assert
argument_list|(
name|unregistered
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
comment|/* Make sure that we can see identifiers, and compute access        correctly, for the class members used in the declaration of        this static variable.  */
name|pushclass
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Do the substitution to get the new declaration.  */
name|new_decl
operator|=
name|tsubst
argument_list|(
name|code_pattern
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Set up DECL_INITIAL, since tsubst doesn't.  */
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop the class context we pushed above.  */
name|popclass
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Convince duplicate_decls to use the DECL_ARGUMENTS from the 	 new decl.  */
name|DECL_INITIAL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* And don't complain about a duplicate definition.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* The immediate parent of the new template is still whatever it was      before, even though tsubst sets DECL_TI_TEMPLATE up as the most      general template.  We also reset the DECL_ASSEMBLER_NAME since      tsubst always calculates the name as if the function in question      were really a template instance, and sometimes, with friend      functions, this is not so.  See tsubst_friend_function for      details.  */
name|DECL_TI_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Call duplicate decls to merge the old and new declarations.  */
name|duplicate_decls
argument_list|(
name|new_decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Now, re-register the specialization.  */
name|register_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce the definition of D, a _DECL generated from a template.  */
end_comment

begin_function
name|tree
name|instantiate_decl
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|DECL_TI_ARGS
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|td
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|int
name|nested
init|=
name|in_function_p
argument_list|()
decl_stmt|;
name|int
name|pattern_defined
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|input_filename
decl_stmt|;
comment|/* This function should only be used to instantiate templates for      functions and static member variables.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|d
argument_list|)
condition|)
comment|/* D has already been instantiated.  It might seem reasonable to        check whether or not D is an explict instantiation, and, if so,        stop here.  But when an explicit instantiation is deferred        until the end of the compilation, DECL_EXPLICIT_INSTANTIATION        is set, even though we still need to do the instantiation.  */
return|return
name|d
return|;
comment|/* If we already have a specialization of this declaration, then      there's no reason to instantiate it.  Note that      retrieve_specialization gives us both instantiations and      specializations, so we must explicitly check      DECL_TEMPLATE_SPECIALIZATION.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
return|return
name|spec
return|;
comment|/* This needs to happen before any tsubsting.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
return|;
comment|/* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern      for the instantiation.  This is not always the most general      template.  Consider, for example:          template<class T> 	struct S { template<class U> void f(); 	           template<> void f<int>(); };       and an instantiation of S<double>::f<int>.  We want TD to be the      specialization S<T>::f<int>, not the more general S<T>::f<U>.  */
name|td
operator|=
name|tmpl
expr_stmt|;
for|for
control|(
name|td
operator|=
name|tmpl
init|;
comment|/* An instantiation cannot have a definition, so we need a 	  more general template.  */
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|td
argument_list|)
comment|/* We must also deal with friend templates.  Given:  	      template<class T> struct S {  		template<class U> friend void f() {}; 	      }; 	  	    S<int>::f<U> say, is not an instantiation of S<T>::f<U>, 	    so far as the language is concerned, but that's still 	    where we get the pattern for the instantiation from.  On 	    ther hand, if the definition comes outside the class, say:   	      template<class T> struct S {  	        template<class U> friend void f();               }; 	      template<class U> friend void f() {}  	    we don't need to look any further.  That's what the check for 	    DECL_INITIAL is for.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
argument_list|)
operator|)
condition|;
control|)
block|{
comment|/* The present template, TD, should not be a definition.  If it 	 were a definition, we should be using it!  Note that we 	 cannot restructure the loop to just keep going until we find 	 a template with a definition, since that might go too far if 	 a specialization was declared, but not defined.  */
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fetch the more general template.  */
name|td
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|pattern_defined
operator|=
operator|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
else|else
name|pattern_defined
operator|=
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_defined
condition|)
block|{
name|repo_template_used
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_external_templates
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
if|if
condition|(
name|interface_unknown
condition|)
name|warn_if_unknown_interface
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|code_pattern
argument_list|)
condition|)
block|{
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
else|else
name|warn_if_unknown_interface
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|at_eof
condition|)
name|import_export_decl
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* Reject all external templates except inline functions.  */
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|d
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|d
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* We need to set up DECL_INITIAL regardless of pattern_defined if 	 the variable is a static const initialized in the class body.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pattern_defined
operator|||
operator|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|d
argument_list|)
operator|&&
name|nested
operator|)
operator|&&
operator|!
name|at_eof
operator|)
condition|)
block|{
comment|/* Defer all templates except inline functions used in another          function.  We restore the source position here because it's used          by add_pending_template.  */
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|at_eof
operator|&&
operator|!
name|pattern_defined
operator|&&
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|d
argument_list|)
condition|)
comment|/* [temp.explicit]  	   The definition of a non-exported function template, a 	   non-exported member function template, or a non-exported 	   member function or static data member of a class template 	   shall be present in every translation unit in which it is 	   explicitly instantiated.  */
name|cp_error
argument_list|(
literal|"explicit instantiation of `%D' but no definition available"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|add_pending_template
argument_list|(
name|d
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We're now committed to instantiating this template.  Mark it as      instantiated so that recursive calls to instantiate_decl do not      try to instantiate it again.  */
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Regenerate the declaration in case the template has been modified      by a subsequent redeclaration.  */
name|regenerate_decl_from_template
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* We already set the file and line above.  Reset them now in case      they changed as a result of calling regenerate_decl_from_template.  */
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|DECL_IN_AGGR_P
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|t
init|=
name|DECL_SAVED_TREE
argument_list|(
name|code_pattern
argument_list|)
decl_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RETURN_INIT
condition|)
block|{
name|store_return_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CTOR_INITIALIZER
condition|)
block|{
name|current_member_init_list
operator|=
name|tsubst_expr_values
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|tsubst_expr_values
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|setup_vtbl_ptr
argument_list|()
expr_stmt|;
comment|/* Always keep the BLOCK node associated with the outermost 	 pair of curly braces of a function.  These are needed 	 for correct operation of dwarfout.c.  */
name|keep_next_level
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPOUND_STMT
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|tsubst_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
name|nested
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|lineno
operator|=
name|line
expr_stmt|;
name|input_filename
operator|=
name|file
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Run through the list of templates that we wish we could    instantiate, and instantiate any we can.  */
end_comment

begin_function
name|int
name|instantiate_pending_templates
parameter_list|()
block|{
name|tree
modifier|*
name|t
decl_stmt|;
name|int
name|instantiated_something
init|=
literal|0
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
do|do
block|{
name|reconsider
operator|=
literal|0
expr_stmt|;
name|t
operator|=
operator|&
name|pending_templates
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|tree
name|srcloc
init|=
name|TREE_PURPOSE
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
name|tree
name|instantiation
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
name|input_filename
operator|=
name|SRCLOC_FILE
argument_list|(
name|srcloc
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|SRCLOC_LINE
argument_list|(
name|srcloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|instantiation
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiate_class_template
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|instantiation
argument_list|)
condition|)
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|instantiation
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiated_something
operator|=
literal|1
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|instantiation
argument_list|)
condition|)
comment|/* If INSTANTIATION has been instantiated, then we don't 		   need to consider it again in the future.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|instantiation
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiation
operator|=
name|instantiate_decl
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiated_something
operator|=
literal|1
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|instantiation
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
comment|/* If INSTANTIATION has been instantiated, then we don't 		   need to consider it again in the future.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|template_tail
operator|=
name|t
expr_stmt|;
comment|/* Go through the things that are template instantiations if we are 	 using guiding declarations.  */
name|t
operator|=
operator|&
name|maybe_templates
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|tree
name|template
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|fn
operator|=
name|TREE_VALUE
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* If the FN is already defined, then it was either already 	       instantiated or, even though guiding declarations were 	       allowed, a non-template definition was provided.  */
empty_stmt|;
else|else
block|{
name|template
operator|=
name|TREE_PURPOSE
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
name|args
operator|=
name|get_bindings
argument_list|(
name|template
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn
operator|=
name|instantiate_template
argument_list|(
name|template
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|instantiate_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Remove this entry from the chain.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
name|maybe_template_tail
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
return|return
name|instantiated_something
return|;
block|}
end_function

begin_comment
comment|/* Substitute ARGVEC into T, which is a TREE_LIST.  In particular, it    is an initializer list: the TREE_PURPOSEs are DECLs, and the    TREE_VALUEs are initializer values.  Used by instantiate_decl.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_expr_values
parameter_list|(
name|t
parameter_list|,
name|argvec
parameter_list|)
name|tree
name|t
decl_stmt|,
name|argvec
decl_stmt|;
block|{
name|tree
name|first
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|p
init|=
operator|&
name|first
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|pur
init|=
name|tsubst_copy
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|tsubst_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
name|build_tree_list
argument_list|(
name|pur
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_decl_stmt
name|tree
name|last_tree
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|add_tree
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|last_tree
operator|=
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|begin_tree
parameter_list|()
block|{
name|saved_trees
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|last_tree
argument_list|,
name|saved_trees
argument_list|)
expr_stmt|;
name|last_tree
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_tree
parameter_list|()
block|{
name|my_friendly_assert
argument_list|(
name|saved_trees
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_tree
operator|=
name|TREE_VALUE
argument_list|(
name|saved_trees
argument_list|)
expr_stmt|;
name|saved_trees
operator|=
name|TREE_CHAIN
argument_list|(
name|saved_trees
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* D is an undefined function declaration in the presence of templates with    the same name, listed in FNS.  If one of them can produce D as an    instantiation, remember this so we can instantiate it at EOF if D has    not been defined by that time.  */
end_comment

begin_function
name|void
name|add_maybe_template
parameter_list|(
name|d
parameter_list|,
name|fns
parameter_list|)
name|tree
name|d
decl_stmt|,
name|fns
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|DECL_MAYBE_TEMPLATE
argument_list|(
name|d
argument_list|)
condition|)
return|return;
name|t
operator|=
name|most_specialized
argument_list|(
name|fns
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"ambiguous template instantiation for `%D'"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|maybe_template_tail
operator|=
name|perm_tree_cons
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|maybe_template_tail
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|maybe_template_tail
argument_list|)
expr_stmt|;
name|DECL_MAYBE_TEMPLATE
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */
end_comment

begin_function
specifier|static
name|void
name|set_current_access_from_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|current_access_specifier
operator|=
name|access_private_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|current_access_specifier
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|current_access_specifier
operator|=
name|access_public_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instantiate an enumerated type.  TAG is the template type, NEWTAG    is the instantiation (which should have been created with    start_enum) and ARGS are the template arguments to use.  */
end_comment

begin_function
specifier|static
name|void
name|tsubst_enum
parameter_list|(
name|tag
parameter_list|,
name|newtag
parameter_list|,
name|args
parameter_list|)
name|tree
name|tag
decl_stmt|;
name|tree
name|newtag
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|tree
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|TYPE_VALUES
argument_list|(
name|tag
argument_list|)
init|;
name|e
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
name|tree
name|value
decl_stmt|;
name|tree
name|elt
decl_stmt|;
comment|/* Note that in a template enum, the TREE_VALUE is the 	 CONST_DECL, not the corresponding INTEGER_CST.  */
name|value
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Give this enumeration constant the correct access.  */
name|set_current_access_from_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actually build the enumerator itself.  */
name|elt
operator|=
name|build_enumerator
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|e
argument_list|)
argument_list|,
name|value
argument_list|,
name|newtag
argument_list|)
expr_stmt|;
comment|/* We save the enumerators we have built so far in the 	 TYPE_VALUES so that if the enumeration constants for 	 subsequent enumerators involve those for previous ones, 	 tsubst_copy will be able to find them.  */
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|newtag
argument_list|)
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|newtag
argument_list|)
operator|=
name|elt
expr_stmt|;
block|}
name|finish_enum
argument_list|(
name|newtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the DECL_ASSEMBLER_NAME for DECL, which is a FUNCTION_DECL that    is either an instantiation or specialization of a template    function.  */
end_comment

begin_function
specifier|static
name|void
name|set_mangled_name_for_template_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|saved_namespace
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn_type
decl_stmt|;
name|tree
name|ret_type
decl_stmt|;
name|tree
name|parm_types
decl_stmt|;
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|int
name|parm_depth
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The names of template functions must be mangled so as to indicate      what template is being specialized with what template arguments.      For example, each of the following three functions must get      different mangled names:         void f(int);                          template<> void f<7>(int);        template<> void f<8>(int);  */
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|uses_template_parms
argument_list|(
name|targs
argument_list|)
condition|)
comment|/* This DECL is for a partial instantiation.  There's no need to        mangle the name of such an entity.  */
return|return;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|tparms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|parm_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|tparms
argument_list|)
expr_stmt|;
comment|/* There should be as many levels of arguments as there are levels      of parameters.  */
name|my_friendly_assert
argument_list|(
name|parm_depth
operator|==
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We now compute the PARMS and RET_TYPE to give to      build_decl_overload_real.  The PARMS and RET_TYPE are the      parameter and return types of the template, after all but the      innermost template arguments have been substituted, not the      parameter and return types of the function DECL.  For example,      given:         template<class T> T f(T);       both PARMS and RET_TYPE should be `T' even if DECL is `int f(int)'.        A more subtle example is:         template<class T> struct S { template<class U> void f(T, U); }       Here, if DECL is `void S<int>::f(int, double)', PARMS should be      {int, U}.  Thus, the args that we want to subsitute into the      return and parameter type for the function are those in TARGS,      with the innermost level omitted.  */
name|fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm_depth
operator|==
literal|1
condition|)
comment|/* No substitution is necessary.  */
empty_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|tree
name|partial_args
decl_stmt|;
comment|/* Replace the innermost level of the TARGS with NULL_TREEs to 	 let tsubst know not to subsitute for those parameters.  */
name|partial_args
operator|=
name|make_temp_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|partial_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|partial_args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
argument_list|,
name|make_temp_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, do the (partial) substitution to figure out the 	 appropriate function type.  */
name|fn_type
operator|=
name|tsubst
argument_list|(
name|fn_type
argument_list|,
name|partial_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|tsubst
argument_list|(
name|context
argument_list|,
name|partial_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Substitute into the template parameters to obtain the real 	 innermost set of parameters.  This step is important if the 	 innermost set of template parameters contains value 	 parameters whose types depend on outer template parameters.  */
name|TREE_VEC_LENGTH
argument_list|(
name|partial_args
argument_list|)
operator|--
expr_stmt|;
name|tparms
operator|=
name|tsubst_template_parms
argument_list|(
name|tparms
argument_list|,
name|partial_args
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now, get the innermost parameters and arguments, and figure out      the parameter and return types.  */
name|tparms
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tparms
argument_list|)
expr_stmt|;
name|targs
operator|=
name|innermost_args
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|ret_type
operator|=
name|TREE_TYPE
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
name|parm_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fn_type
argument_list|)
expr_stmt|;
comment|/* For a static member function, we generate a fake `this' pointer,      for the purposes of mangling.  This indicates of which class the      function is a member.  Because of:         [class.static]          There shall not be a static and a nonstatic member function        with the same name and the same parameter types       we don't have to worry that this will result in a clash with a      non-static member function.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|parm_types
operator|=
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|context
argument_list|)
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
comment|/* There should be the same number of template parameters as      template arguments.  */
name|my_friendly_assert
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the template is in a namespace, we need to put that into the      mangled name. Unfortunately, build_decl_overload_real does not      get the decl to mangle, so it relies on the current      namespace. Therefore, we set that here temporarily. */
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|980702
argument_list|)
expr_stmt|;
name|saved_namespace
operator|=
name|current_namespace
expr_stmt|;
name|current_namespace
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Actually set the DCL_ASSEMBLER_NAME.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_decl_overload_real
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|parm_types
argument_list|,
name|ret_type
argument_list|,
name|tparms
argument_list|,
name|targs
argument_list|,
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|+
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the previously active namespace.  */
name|current_namespace
operator|=
name|saved_namespace
expr_stmt|;
block|}
end_function

end_unit

