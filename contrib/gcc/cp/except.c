begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle exceptional things in C++.    Copyright (C) 1989, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Michael Tiemann<tiemann@cygnus.com>    Rewritten by Mike Stump<mrs@cygnus.com>, based upon an    initial re-implementation courtesy Tad Hunt.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_decl_stmt
name|tree
name|protect_list
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern void (*interim_eh_hook
end_extern

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rtx
name|expand_builtin_return_addr
name|PROTO
argument_list|(
operator|(
expr|enum
name|built_in_function
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds the fndecl for __builtin_return_address () */
end_comment

begin_decl_stmt
name|tree
name|builtin_return_address_fndecl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|throw_fndecl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|doing_eh
parameter_list|(
name|do_warn
parameter_list|)
name|int
name|do_warn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_handle_exceptions
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|do_warn
condition|)
block|{
name|error
argument_list|(
literal|"exception handling disabled, use -fhandle-exceptions to enable."
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* NO GNEWS IS GOOD GNEWS WITH GARRY GNUS: This version is much closer to supporting exception handling as per ANSI C++ working draft. It is a complete rewrite of all the EH stuff that was here before 	Shortcomings: 		1. Throw specifications of functions still don't work. 	Cool Things: 		1. Destructors are called properly :-) 		2. No overhead for the non-exception thrown case. 		3. Fixing shortcoming 1 is simple. 			-Tad Hunt	(tad@mail.csh.rit.edu)  */
end_comment

begin_comment
comment|/* A couple of backend routines from m88k.c */
end_comment

begin_comment
comment|/* used to cache a call to __builtin_return_address () */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BuiltinReturnAddress
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* XXX - Tad: for EH */
end_comment

begin_comment
comment|/* output an exception table entry */
end_comment

begin_function
specifier|static
name|void
name|output_exception_table_entry
parameter_list|(
name|file
parameter_list|,
name|start_label
parameter_list|,
name|end_label
parameter_list|,
name|eh_label
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|start_label
decl_stmt|,
name|end_label
decl_stmt|,
name|eh_label
decl_stmt|;
block|{
name|char
name|label
index|[
literal|100
index|]
decl_stmt|;
name|assemble_integer
argument_list|(
name|start_label
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|end_label
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|eh_label
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* blank line */
block|}
end_function

begin_function
specifier|static
name|void
name|easy_expand_asm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|expand_asm
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is the startup, and finish stuff per exception table. */
end_comment

begin_comment
comment|/* XXX - Tad: exception handling section */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXCEPT_SECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|EXCEPT_SECTION_ASM_OP
value|"section\t.gcc_except_table,\"a\",@progbits"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_endif
unit|typedef struct {     void *start_protect;     void *end_protect;     void *exception_handler;  } exception_table;
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* on machines which support it, the exception table lives in another section, 	but it needs a label so we can reference it...  This sets up that     label! */
end_comment

begin_endif
unit|asm (EXCEPT_SECTION_ASM_OP); exception_table __EXCEPTION_TABLE__[1] = { (void*)0, (void*)0, (void*)0 }; asm (TEXT_SECTION_ASM_OP);
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* we need to know where the end of the exception table is... so this     is how we do it! */
end_comment

begin_endif
unit|asm (EXCEPT_SECTION_ASM_OP); exception_table __EXCEPTION_END__[1] = { (void*)-1, (void*)-1, (void*)-1 }; asm (TEXT_SECTION_ASM_OP);
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exception_section
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXCEPTION_SECTION_FUNCTION
name|EXCEPTION_SECTION_FUNCTION
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".gcc_except_table"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_pic
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
if|#
directive|if
name|defined
argument_list|(
name|TARGET_POWERPC
argument_list|)
comment|/* are we on a __rs6000? */
name|data_section
argument_list|()
expr_stmt|;
else|#
directive|else
name|readonly_data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* from: my-cp-except.c */
end_comment

begin_comment
comment|/* VI: ":set ts=4" */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<stdio.h>
include|*/
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ======================================================================    Briefly the algorithm works like this:       When a constructor or start of a try block is encountered,      push_eh_entry (&eh_stack) is called.  Push_eh_entry () creates a      new entry in the unwind protection stack and returns a label to      output to start the protection for that block.       When a destructor or end try block is encountered, pop_eh_entry      (&eh_stack) is called.  Pop_eh_entry () returns the ehEntry it      created when push_eh_entry () was called.  The ehEntry structure      contains three things at this point.  The start protect label,      the end protect label, and the exception handler label.  The end      protect label should be output before the call to the destructor      (if any). If it was a destructor, then its parse tree is stored      in the finalization variable in the ehEntry structure.  Otherwise      the finalization variable is set to NULL to reflect the fact that      is the the end of a try block.  Next, this modified ehEntry node      is enqueued in the finalizations queue by calling      enqueue_eh_entry (&queue,entry).  	+---------------------------------------------------------------+ 	|XXX: Will need modification to deal with partially		| 	|			constructed arrays of objects		| 	|								| 	|	Basically, this consists of keeping track of how many	| 	|	of the objects have been constructed already (this	| 	|	should be in a register though, so that shouldn't be a	| 	|	problem.						| 	+---------------------------------------------------------------+       When a catch block is encountered, there is a lot of work to be      done.       Since we don't want to generate the catch block inline with the      regular flow of the function, we need to have some way of doing      so.  Luckily, we can use sequences to defer the catch sections.      When the start of a catch block is encountered, we start the      sequence.  After the catch block is generated, we end the      sequence.       Next we must insure that when the catch block is executed, all      finalizations for the matching try block have been completed.  If      any of those finalizations throw an exception, we must call      terminate according to the ARM (section r.15.6.1).  What this      means is that we need to dequeue and emit finalizations for each      entry in the ehQueue until we get to an entry with a NULL      finalization field.  For any of the finalization entries, if it      is not a call to terminate (), we must protect it by giving it      another start label, end label, and exception handler label,      setting its finalization tree to be a call to terminate (), and      enqueue'ing this new ehEntry to be output at an outer level.      Finally, after all that is done, we can get around to outputting      the catch block which basically wraps all the "catch (...) {...}"      statements in a big if/then/else construct that matches the      correct block to call.            ===================================================================== */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|emit_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|gen_nop
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local globals for function calls    ====================================================================== */
end_comment

begin_comment
comment|/* used to cache "terminate ()", "unexpected ()", "set_terminate ()", and    "set_unexpected ()" after default_conversion. (lib-except.c)  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|Terminate
decl_stmt|,
name|Unexpected
decl_stmt|,
name|SetTerminate
decl_stmt|,
name|SetUnexpected
decl_stmt|,
name|CatchMatch
decl_stmt|,
name|Throw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to cache __find_first_exception_table_match ()    for throw (lib-except.c)  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|FirstExceptionMatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to cache a call to __unwind_function () (lib-except.c)  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|Unwind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds a ready to emit call to "terminate ()".  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|TerminateFunctionCall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ====================================================================== */
end_comment

begin_comment
comment|/* data structures for my various quick and dirty stacks and queues    Eventually, most of this should go away, because I think it can be    integrated with stuff already built into the compiler.  */
end_comment

begin_comment
comment|/* =================================================================== */
end_comment

begin_struct
struct|struct
name|labelNode
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|labelNode
modifier|*
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* this is the most important structure here.  Basically this is how I store    an exception table entry internally. */
end_comment

begin_struct
struct|struct
name|ehEntry
block|{
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|end_label
decl_stmt|;
name|rtx
name|exception_handler_label
decl_stmt|;
name|tree
name|finalization
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ehNode
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|struct
name|ehNode
modifier|*
name|chain
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ehStack
block|{
name|struct
name|ehNode
modifier|*
name|top
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ehQueue
block|{
name|struct
name|ehNode
modifier|*
name|head
decl_stmt|;
name|struct
name|ehNode
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* local globals - these local globals are for storing data necessary for    generating the exception table and code in the correct order.     ========================================================================= */
end_comment

begin_comment
comment|/* Holds the pc for doing "throw" */
end_comment

begin_decl_stmt
name|tree
name|saved_pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the type of the thing being thrown. */
end_comment

begin_decl_stmt
name|tree
name|saved_throw_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the value being thrown.  */
end_comment

begin_decl_stmt
name|tree
name|saved_throw_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|throw_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|catch_clauses
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|first_catch_label
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehStack
name|ehstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehQueue
name|ehqueue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehQueue
name|eh_table_output_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|labelNode
modifier|*
name|false_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|labelNode
modifier|*
name|caught_return_label_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ehEntry
modifier|*
name|pop_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehStack
operator|*
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enqueue_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehQueue
operator|*
name|queue
operator|,
expr|struct
name|ehEntry
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|push_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehStack
operator|*
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehEntry
modifier|*
name|dequeue_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehQueue
operator|*
name|queue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_eh_queue
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehQueue
operator|*
name|queue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_eh_stack
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehStack
operator|*
name|stack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_label_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|labelNode
operator|*
operator|*
name|labelstack
operator|,
name|rtx
name|label
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|pop_label_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|labelNode
operator|*
operator|*
name|labelstack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|top_label_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|labelNode
operator|*
operator|*
name|labelstack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ehEntry
modifier|*
name|copy_eh_entry
name|PROTO
argument_list|(
operator|(
expr|struct
name|ehEntry
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All my cheesy stack/queue/misc data structure handling routines     ========================================================================= */
end_comment

begin_function
specifier|static
name|void
name|push_label_entry
parameter_list|(
name|labelstack
parameter_list|,
name|label
parameter_list|)
name|struct
name|labelNode
modifier|*
modifier|*
name|labelstack
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|struct
name|labelNode
modifier|*
name|newnode
init|=
operator|(
expr|struct
name|labelNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|labelNode
argument_list|)
argument_list|)
decl_stmt|;
name|newnode
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|newnode
operator|->
name|chain
operator|=
operator|*
name|labelstack
expr_stmt|;
operator|*
name|labelstack
operator|=
name|newnode
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|pop_label_entry
parameter_list|(
name|labelstack
parameter_list|)
name|struct
name|labelNode
modifier|*
modifier|*
name|labelstack
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
name|struct
name|labelNode
modifier|*
name|tempnode
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|labelstack
condition|)
return|return
name|NULL_RTX
return|;
name|tempnode
operator|=
operator|*
name|labelstack
expr_stmt|;
name|label
operator|=
name|tempnode
operator|->
name|label
expr_stmt|;
operator|*
name|labelstack
operator|=
operator|(
operator|*
name|labelstack
operator|)
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|top_label_entry
parameter_list|(
name|labelstack
parameter_list|)
name|struct
name|labelNode
modifier|*
modifier|*
name|labelstack
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|labelstack
condition|)
return|return
name|NULL_RTX
return|;
return|return
operator|(
operator|*
name|labelstack
operator|)
operator|->
name|label
return|;
block|}
end_function

begin_comment
comment|/* Push to permanent obstack for rtl generation.    One level only!  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
modifier|*
name|saved_rtl_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_rtl_perm
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
name|saved_rtl_obstack
operator|=
name|rtl_obstack
expr_stmt|;
name|rtl_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop back to normal rtl handling.  */
end_comment

begin_function
specifier|static
name|void
name|pop_rtl_from_perm
parameter_list|()
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
name|rtl_obstack
operator|=
name|saved_rtl_obstack
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|push_eh_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|ehStack
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|node
init|=
operator|(
expr|struct
name|ehNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehNode
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|ehEntry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehEntry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stack
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|entry
operator|->
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|->
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|->
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|->
name|start_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|->
name|end_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|finalization
operator|=
name|NULL_TREE
expr_stmt|;
name|entry
operator|->
name|context
operator|=
name|current_function_decl
expr_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|stack
operator|->
name|top
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|node
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|start_label
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ehEntry
modifier|*
name|pop_eh_entry
parameter_list|(
name|stack
parameter_list|)
name|struct
name|ehStack
modifier|*
name|stack
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|tempnode
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|tempentry
decl_stmt|;
if|if
condition|(
name|stack
operator|&&
operator|(
name|tempnode
operator|=
name|stack
operator|->
name|top
operator|)
condition|)
block|{
name|tempentry
operator|=
name|tempnode
operator|->
name|entry
expr_stmt|;
name|stack
operator|->
name|top
operator|=
name|stack
operator|->
name|top
operator|->
name|chain
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|tempentry
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ehEntry
modifier|*
name|copy_eh_entry
parameter_list|(
name|entry
parameter_list|)
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|ehEntry
modifier|*
name|newentry
decl_stmt|;
name|newentry
operator|=
operator|(
expr|struct
name|ehEntry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehEntry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|newentry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ehEntry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newentry
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enqueue_eh_entry
parameter_list|(
name|queue
parameter_list|,
name|entry
parameter_list|)
name|struct
name|ehQueue
modifier|*
name|queue
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|node
init|=
operator|(
expr|struct
name|ehNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ehNode
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|node
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|queue
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
name|queue
operator|->
name|head
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|->
name|tail
operator|->
name|chain
operator|=
name|node
expr_stmt|;
block|}
name|queue
operator|->
name|tail
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ehEntry
modifier|*
name|dequeue_eh_entry
parameter_list|(
name|queue
parameter_list|)
name|struct
name|ehQueue
modifier|*
name|queue
decl_stmt|;
block|{
name|struct
name|ehNode
modifier|*
name|tempnode
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|tempentry
decl_stmt|;
if|if
condition|(
name|queue
operator|->
name|head
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tempnode
operator|=
name|queue
operator|->
name|head
expr_stmt|;
name|queue
operator|->
name|head
operator|=
name|queue
operator|->
name|head
operator|->
name|chain
expr_stmt|;
name|tempentry
operator|=
name|tempnode
operator|->
name|entry
expr_stmt|;
name|free
argument_list|(
name|tempnode
argument_list|)
expr_stmt|;
return|return
name|tempentry
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_eh_queue
parameter_list|(
name|queue
parameter_list|)
name|struct
name|ehQueue
modifier|*
name|queue
decl_stmt|;
block|{
name|queue
operator|->
name|head
operator|=
name|queue
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_eh_stack
parameter_list|(
name|stack
parameter_list|)
name|struct
name|ehStack
modifier|*
name|stack
decl_stmt|;
block|{
name|stack
operator|->
name|top
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cheesyness to save some typing. returns the return value rtx */
end_comment

begin_function
name|rtx
name|do_function_call
parameter_list|(
name|func
parameter_list|,
name|params
parameter_list|,
name|return_type
parameter_list|)
name|tree
name|func
decl_stmt|,
name|params
decl_stmt|,
name|return_type
decl_stmt|;
block|{
name|tree
name|func_call
decl_stmt|;
name|func_call
operator|=
name|build_function_call
argument_list|(
name|func
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|expand_call
argument_list|(
name|func_call
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|!=
name|NULL_TREE
condition|)
return|return
name|hard_function_value
argument_list|(
name|return_type
argument_list|,
name|func_call
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_internal_throw
parameter_list|(
name|pc
parameter_list|)
name|rtx
name|pc
decl_stmt|;
block|{
name|tree
name|params
decl_stmt|;
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|saved_pc
argument_list|)
argument_list|,
name|pc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMP_TO_THROW
name|emit_indirect_jump
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__throw"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|do_function_call
argument_list|(
name|Throw
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|throw_used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|void
name|lang_interim_eh
parameter_list|(
name|finalization
parameter_list|)
name|tree
name|finalization
decl_stmt|;
block|{
if|if
condition|(
name|finalization
condition|)
name|end_protect
argument_list|(
name|finalization
argument_list|)
expr_stmt|;
else|else
name|start_protect
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|tree
name|auto_function
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|built_in_function
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sets up all the global eh stuff that needs to be initialized at the    start of compilation.     This includes: 		- Setting up all the function call trees 		- Initializing the ehqueue 		- Initializing the eh_table_output_queue 		- Initializing the ehstack */
end_comment

begin_function
name|void
name|init_exception_processing
parameter_list|()
block|{
specifier|extern
name|tree
name|define_function
parameter_list|()
function_decl|;
name|tree
name|unexpected_fndecl
decl_stmt|,
name|terminate_fndecl
decl_stmt|;
name|tree
name|set_unexpected_fndecl
decl_stmt|,
name|set_terminate_fndecl
decl_stmt|;
name|tree
name|catch_match_fndecl
decl_stmt|;
name|tree
name|find_first_exception_match_fndecl
decl_stmt|;
name|tree
name|unwind_fndecl
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
name|tree
name|d
decl_stmt|;
comment|/* void (*)() */
name|tree
name|PFV
init|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
decl_stmt|;
comment|/* arg list for the build_function_type call for set_terminate () and      set_unexpected () */
name|tree
name|pfvlist
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|PFV
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
comment|/* void (*pfvtype (void (*) ()))() */
name|tree
name|pfvtype
init|=
name|build_function_type
argument_list|(
name|PFV
argument_list|,
name|pfvlist
argument_list|)
decl_stmt|;
comment|/* void vtype () */
name|tree
name|vtype
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|set_terminate_fndecl
operator|=
name|auto_function
argument_list|(
name|get_identifier
argument_list|(
literal|"set_terminate"
argument_list|)
argument_list|,
name|pfvtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|set_unexpected_fndecl
operator|=
name|auto_function
argument_list|(
name|get_identifier
argument_list|(
literal|"set_unexpected"
argument_list|)
argument_list|,
name|pfvtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|unexpected_fndecl
operator|=
name|auto_function
argument_list|(
name|get_identifier
argument_list|(
literal|"unexpected"
argument_list|)
argument_list|,
name|vtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|terminate_fndecl
operator|=
name|auto_function
argument_list|(
name|get_identifier
argument_list|(
literal|"terminate"
argument_list|)
argument_list|,
name|vtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|interim_eh_hook
operator|=
name|lang_interim_eh
expr_stmt|;
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|catch_match_fndecl
operator|=
name|define_function
argument_list|(
name|flag_rtti
condition|?
literal|"__throw_type_match_rtti"
else|:
literal|"__throw_type_match"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|find_first_exception_match_fndecl
operator|=
name|define_function
argument_list|(
literal|"__find_first_exception_table_match"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unwind_fndecl
operator|=
name|define_function
argument_list|(
literal|"__unwind_function"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|throw_fndecl
operator|=
name|define_function
argument_list|(
literal|"__throw"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|throw_fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|throw_fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Unexpected
operator|=
name|default_conversion
argument_list|(
name|unexpected_fndecl
argument_list|)
expr_stmt|;
name|Terminate
operator|=
name|default_conversion
argument_list|(
name|terminate_fndecl
argument_list|)
expr_stmt|;
name|SetTerminate
operator|=
name|default_conversion
argument_list|(
name|set_terminate_fndecl
argument_list|)
expr_stmt|;
name|SetUnexpected
operator|=
name|default_conversion
argument_list|(
name|set_unexpected_fndecl
argument_list|)
expr_stmt|;
name|CatchMatch
operator|=
name|default_conversion
argument_list|(
name|catch_match_fndecl
argument_list|)
expr_stmt|;
name|FirstExceptionMatch
operator|=
name|default_conversion
argument_list|(
name|find_first_exception_match_fndecl
argument_list|)
expr_stmt|;
name|Unwind
operator|=
name|default_conversion
argument_list|(
name|unwind_fndecl
argument_list|)
expr_stmt|;
name|Throw
operator|=
name|default_conversion
argument_list|(
name|throw_fndecl
argument_list|)
expr_stmt|;
name|BuiltinReturnAddress
operator|=
name|default_conversion
argument_list|(
name|builtin_return_address_fndecl
argument_list|)
expr_stmt|;
name|TerminateFunctionCall
operator|=
name|build_function_call
argument_list|(
name|Terminate
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
name|new_eh_queue
argument_list|(
operator|&
name|ehqueue
argument_list|)
expr_stmt|;
name|new_eh_queue
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|)
expr_stmt|;
name|new_eh_stack
argument_list|(
operator|&
name|ehstack
argument_list|)
expr_stmt|;
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|d
operator|=
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"__eh_pc"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|start_decl
argument_list|(
name|d
argument_list|,
name|declspecs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|saved_pc
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__eh_pc"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|d
operator|=
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"__eh_type"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|start_decl
argument_list|(
name|d
argument_list|,
name|declspecs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|saved_throw_type
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__eh_type"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|declspecs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|d
operator|=
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"__eh_value"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|start_decl
argument_list|(
name|d
argument_list|,
name|declspecs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|saved_throw_value
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__eh_value"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to begin a block of unwind protection (ie: when an object is    constructed) */
end_comment

begin_function
name|void
name|start_protect
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|emit_label
argument_list|(
name|push_eh_entry
argument_list|(
operator|&
name|ehstack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to end a block of unwind protection.  the finalization tree is    the finalization which needs to be run in order to cleanly unwind through    this level of protection. (ie: call this when a scope is exited)*/
end_comment

begin_function
name|void
name|end_protect
parameter_list|(
name|finalization
parameter_list|)
name|tree
name|finalization
decl_stmt|;
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|entry
operator|=
name|pop_eh_entry
argument_list|(
operator|&
name|ehstack
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|end_label
argument_list|)
expr_stmt|;
comment|/* Put in something that takes up space, as otherwise the end      address for the EH region could have the exact same address as      the outer region, causing us to miss the fact that resuming      exception handling with this PC value would be inside the outer      region.  */
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|entry
operator|->
name|finalization
operator|=
name|finalization
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this on start of a try block. */
end_comment

begin_function
name|void
name|expand_start_try_stmts
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|start_protect
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_end_try_stmts
parameter_list|()
block|{
name|end_protect
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to start processing of all the catch blocks. */
end_comment

begin_function
name|void
name|expand_start_all_catch
parameter_list|()
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* The label for the exception handling block we will save.  This is      Lresume, in the documention.  */
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Put in something that takes up space, as otherwise the end      address for the EH region could have the exact same address as      the outer region, causing us to miss the fact that resuming      exception handling with this PC value would be inside the outer      region.  */
name|emit_insn
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|push_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Start a new sequence for all the catch blocks.  We will add this      to the gloabl sequence catch_clauses, when we have completed all      the handlers in this handler-seq.  */
name|start_sequence
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When we get down to the matching entry, stop.  */
if|if
condition|(
name|entry
operator|->
name|finalization
operator|==
name|integer_zero_node
condition|)
break|break;
comment|/* The below can be optimized away, and we could just fall into the 	 next EH handler, if we are certain they are nested.  */
comment|/* Code to throw out to outer context, if we fall off end of the 	 handler.  */
name|expand_internal_throw
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|entry
operator|->
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* call this to end processing of all the catch blocks. */
end_comment

begin_function
name|void
name|expand_end_all_catch
parameter_list|()
block|{
name|rtx
name|new_catch_clause
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* Code to throw out to outer context, if we fall off end of catch      handlers.  This is rethrow (Lresume, same id, same obj); in the      documentation.  */
name|expand_internal_throw
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|top_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we have the complete catch sequence.  */
name|new_catch_clause
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* this level of catch blocks is done, so set up the successful catch jump      label for the next layer of catch blocks. */
name|pop_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
expr_stmt|;
comment|/* Add the new sequence of catchs to the main one for this      function.  */
name|push_to_sequence
argument_list|(
name|catch_clauses
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|new_catch_clause
argument_list|)
expr_stmt|;
name|catch_clauses
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Here we fall through into the continuation code.  */
block|}
end_function

begin_comment
comment|/* Build a type value for use at runtime for a type that is matched    against by the exception handling system.  */
end_comment

begin_function
specifier|static
name|tree
name|build_eh_type_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|typestring
decl_stmt|;
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* peel back references, so they match. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers. */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rtti
condition|)
block|{
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|get_typeid
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
name|typestring
operator|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|typestring
argument_list|)
operator|+
literal|1
argument_list|,
name|typestring
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a type value for use at runtime for a exp that is thrown or    matched against by the exception handling system.  */
end_comment

begin_function
specifier|static
name|tree
name|build_eh_type
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|flag_rtti
condition|)
block|{
name|exp
operator|=
name|build_typeid
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|build_eh_type_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* call this to start a catch block. Typename is the typename, and identifier    is the variable to place the object in or NULL if the variable doesn't    matter.  If typename is NULL, that means its a "catch (...)" or catch    everything.  In that case we don't need to do any type checking.    (ie: it ends up as the "else" clause rather than an "else if" clause) */
end_comment

begin_function
name|void
name|expand_start_catch_block
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
block|{
name|rtx
name|false_label_rtx
decl_stmt|;
name|rtx
name|protect_label_rtx
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|init
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* Create a binding level for the parm.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|false_label_rtx
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* This is saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|protect_label_rtx
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|push_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|,
name|false_label_rtx
argument_list|)
expr_stmt|;
name|push_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|,
name|protect_label_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
condition|)
block|{
name|tree
name|exp
decl_stmt|;
name|rtx
name|call_rtx
decl_stmt|,
name|return_value_rtx
decl_stmt|;
name|tree
name|init_type
decl_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|CATCHPARM
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"invalid catch parameter"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Figure out the type that the initializer is. */
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
name|init_type
operator|=
name|build_reference_type
argument_list|(
name|init_type
argument_list|)
expr_stmt|;
name|exp
operator|=
name|saved_throw_value
expr_stmt|;
name|exp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_eh_type_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|saved_throw_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call
argument_list|(
name|CatchMatch
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|call_rtx
operator|=
name|expand_call
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|CatchMatch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|return_value_rtx
operator|=
name|hard_function_value
argument_list|(
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* did the throw type match function return TRUE? */
name|emit_cmp_insn
argument_list|(
name|return_value_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|return_value_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if it returned FALSE, jump over the catch block, else fall into it */
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|false_label_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_from_reference
argument_list|(
name|save_expr
argument_list|(
name|make_tree
argument_list|(
name|init_type
argument_list|,
name|call_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we need the below two lines? */
comment|/* Let `cp_finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fall into the catch all section. */
block|}
comment|/* This is the starting of something to protect.  */
name|emit_label
argument_list|(
name|protect_label_rtx
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this is called from expand_exception_blocks and    expand_end_catch_block to expand the toplevel finalizations for a    function.  We return the first label emitted, if any, otherwise    return NULL_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|expand_leftover_cleanups
parameter_list|()
block|{
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|rtx
name|first_label
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|ehqueue
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|first_label
condition|)
name|first_label
operator|=
name|entry
operator|->
name|exception_handler_label
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|->
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The below can be optimized away, and we could just fall into the 	 next EH handler, if we are certain they are nested.  */
comment|/* Code to throw out to outer context, if we fall off end of the 	 handler.  */
name|expand_internal_throw
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|entry
operator|->
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* leftover try block, opps.  */
if|if
condition|(
name|entry
operator|->
name|finalization
operator|==
name|integer_zero_node
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|first_label
return|;
block|}
end_function

begin_comment
comment|/* Call this to end a catch block.  Its responsible for emitting the    code to handle jumping back to the correct place, and for emitting    the label to jump to if this catch block didn't match.  */
end_comment

begin_function
name|void
name|expand_end_catch_block
parameter_list|()
block|{
name|rtx
name|start_protect_label_rtx
decl_stmt|;
name|rtx
name|end_protect_label_rtx
decl_stmt|;
name|tree
name|decls
decl_stmt|;
name|struct
name|ehEntry
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* fall to outside the try statement when done executing handler and      we fall off end of handler.  This is jump Lresume in the      documentation.  */
name|emit_jump
argument_list|(
name|top_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We end the rethrow protection region as soon as we hit a label. */
name|end_protect_label_rtx
operator|=
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
comment|/* Code to throw out to outer context, if we get a throw from within      our catch handler. */
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|entry
operator|.
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
comment|/* This label is Lhandler in the documentation.  */
name|emit_label
argument_list|(
name|entry
operator|.
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_internal_throw
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|top_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No associated finalization.  */
name|entry
operator|.
name|finalization
operator|=
name|NULL_TREE
expr_stmt|;
name|entry
operator|.
name|context
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|end_protect_label_rtx
operator|==
name|NULL_RTX
condition|)
name|end_protect_label_rtx
operator|=
name|entry
operator|.
name|exception_handler_label
expr_stmt|;
comment|/* Because we are emitted out of line, we have to protect this. */
comment|/* label for the start of the protection region.  */
name|start_protect_label_rtx
operator|=
name|pop_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|)
expr_stmt|;
comment|/* Cleanup the EH parameter.  */
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* label we emit to jump to if this catch block didn't match. */
comment|/* This the closing } in the `if (eq) {' of the documentation.  */
name|emit_label
argument_list|(
name|pop_label_entry
argument_list|(
operator|&
name|false_label_stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because we are reordered out of line, we have to protect this. */
name|entry
operator|.
name|start_label
operator|=
name|start_protect_label_rtx
expr_stmt|;
name|entry
operator|.
name|end_label
operator|=
name|end_protect_label_rtx
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|.
name|start_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|.
name|end_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|.
name|exception_handler_label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* These set up a call to throw the caught exception into the outer      context.  */
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unwind the stack. */
end_comment

begin_function
specifier|static
name|void
name|do_unwind
parameter_list|(
name|inner_throw_label
parameter_list|)
name|rtx
name|inner_throw_label
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|SPARC_STACK_ALIGN
argument_list|)
comment|/* was sparc */
name|tree
name|fcall
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|rtx
name|return_val_rtx
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* call to  __builtin_return_address () */
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_function_call
argument_list|(
name|BuiltinReturnAddress
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|return_val_rtx
operator|=
name|expand_expr
argument_list|(
name|fcall
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In the return, the new pc is pc+8, as the value coming in is      really the address of the call insn, not the next insn.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|inner_throw_label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|plus_constant
argument_list|(
name|temp
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|easy_expand_asm
argument_list|(
literal|"ret"
argument_list|)
expr_stmt|;
name|easy_expand_asm
argument_list|(
literal|"restore"
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ARM_FRAME_RTX
argument_list|)
comment|/* was __arm */
if|if
condition|(
name|flag_omit_frame_pointer
condition|)
name|sorry
argument_list|(
literal|"this implementation of exception handling requires a frame pointer"
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|12
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TARGET_88000
argument_list|)
comment|/* was m88k */
name|rtx
name|temp_frame
init|=
name|frame_pointer_rtx
decl_stmt|;
name|temp_frame
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|temp_frame
argument_list|)
expr_stmt|;
name|temp_frame
operator|=
name|copy_to_reg
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|temp_frame
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hopefully this will successfully pop the frame! */
name|emit_move_insn
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|temp_frame
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
name|m88k_debugger_offset
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode, 						   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));    emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);    emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode, 						     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_88000
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ARM_FRAME_RTX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SPARC_STACK_ALIGN
argument_list|)
name|tree
name|fcall
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|rtx
name|return_val_rtx
decl_stmt|;
comment|/* call to  __builtin_return_address () */
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_function_call
argument_list|(
name|BuiltinReturnAddress
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|return_val_rtx
operator|=
name|expand_expr
argument_list|(
name|fcall
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I would like to do this here, but doesn't seem to work. */
block|emit_move_insn (return_val_rtx, inner_throw_label);
comment|/* So, for now, just pass throw label to stack unwinder. */
endif|#
directive|endif
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|inner_throw_label
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|do_function_call
argument_list|(
name|Unwind
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|Unwind
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* is called from expand_exception_blocks () to generate the code in a function    to "throw" if anything in the function needs to perform a throw.     expands "throw" as the following pseudo code:  	throw: 		eh = find_first_exception_match (saved_pc); 	    if (!eh) goto gotta_rethrow_it; 		goto eh;  	gotta_rethrow_it: 		saved_pc = __builtin_return_address (0); 		pop_to_previous_level (); 		goto throw;   */
end_comment

begin_function
name|void
name|expand_builtin_throw
parameter_list|()
block|{
name|tree
name|fcall
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|rtx
name|return_val_rtx
decl_stmt|;
name|rtx
name|gotta_rethrow_it
decl_stmt|;
name|rtx
name|gotta_call_terminate
decl_stmt|;
name|rtx
name|unwind_and_throw
decl_stmt|;
name|rtx
name|goto_unwind_and_throw
decl_stmt|;
name|rtx
name|top_of_loop
decl_stmt|;
name|rtx
name|unwind_first
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|throw_used
condition|)
return|return;
name|params
operator|=
name|void_list_node
expr_stmt|;
name|t
operator|=
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|get_identifier
argument_list|(
literal|"__throw"
argument_list|)
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gotta_rethrow_it
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|gotta_call_terminate
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|unwind_and_throw
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|goto_unwind_and_throw
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|top_of_loop
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|unwind_first
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|unwind_first
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|top_of_loop
argument_list|)
expr_stmt|;
comment|/* search for an exception handler for the saved_pc */
name|return_val_rtx
operator|=
name|do_function_call
argument_list|(
name|FirstExceptionMatch
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|saved_pc
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|FirstExceptionMatch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* did we find one? */
name|emit_cmp_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|return_val_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if not, jump to gotta_rethrow_it */
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|gotta_rethrow_it
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we found it, so jump to it */
name|emit_indirect_jump
argument_list|(
name|return_val_rtx
argument_list|)
expr_stmt|;
comment|/* code to deal with unwinding and looking for it again */
name|emit_label
argument_list|(
name|gotta_rethrow_it
argument_list|)
expr_stmt|;
comment|/* call to  __builtin_return_address () */
if|#
directive|if
name|defined
argument_list|(
name|ARM_FRAME_RTX
argument_list|)
comment|/* was __arm */
comment|/* This replaces a 'call' to __builtin_return_address */
name|return_val_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fcall
operator|=
name|build_function_call
argument_list|(
name|BuiltinReturnAddress
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|return_val_rtx
operator|=
name|expand_expr
argument_list|(
name|fcall
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* did __builtin_return_address () return a valid address? */
name|emit_cmp_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|return_val_rtx
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_beq
argument_list|(
name|gotta_call_terminate
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ARM_FRAME_RTX
argument_list|)
comment|/* was __arm */
comment|/* On the ARM, '__builtin_return_address',  must have 4      subtracted from it. */
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|return_val_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are generating code for an ARM2/ARM3 machine or for an ARM6 in 26 bit      mode, the condition codes must be masked out of the return value, or else      they will confuse BuiltinReturnAddress.  This does not apply to ARM6 and      later processors when running in 32 bit mode. */
if|if
condition|(
operator|!
name|TARGET_6
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|Pmode
argument_list|,
name|return_val_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|Pmode
argument_list|,
name|return_val_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|0x03fffffc
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPARC_STACK_ALIGN
argument_list|)
comment|/* was sparc */
comment|/* On the SPARC, __builtin_return_address is already -8, no need to      subtract any more from it. */
name|return_val_rtx
operator|=
name|plus_constant
argument_list|(
name|return_val_rtx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* yes it did */
name|t
operator|=
name|build_modify_expr
argument_list|(
name|saved_pc
argument_list|,
name|NOP_EXPR
argument_list|,
name|make_tree
argument_list|(
name|ptr_type_node
argument_list|,
name|return_val_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_unwind
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|top_of_loop
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|top_of_loop
argument_list|)
expr_stmt|;
comment|/* no it didn't --> therefore we need to call terminate */
name|emit_label
argument_list|(
name|gotta_call_terminate
argument_list|)
expr_stmt|;
name|do_function_call
argument_list|(
name|Terminate
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|Terminate
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|rtx
name|ret_val
decl_stmt|,
name|return_val_rtx
decl_stmt|;
name|emit_label
argument_list|(
name|unwind_first
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|expand_builtin_return_addr
argument_list|(
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
literal|0
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
comment|/* Set it up so that we continue inside, at the top of the loop.  */
name|emit_move_insn
argument_list|(
name|ret_val
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|top_of_loop
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NORMAL_RETURN_ADDR_OFFSET
name|return_val_rtx
operator|=
name|plus_constant
argument_list|(
name|ret_val
argument_list|,
operator|-
name|NORMAL_RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val_rtx
operator|!=
name|ret_val
condition|)
name|emit_move_insn
argument_list|(
name|ret_val
argument_list|,
name|return_val_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fall into epilogue to unwind prologue. */
block|}
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_start_eh_spec
parameter_list|()
block|{
name|start_protect
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expand_end_eh_spec
parameter_list|(
name|raises
parameter_list|)
name|tree
name|raises
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|,
name|second_try
decl_stmt|;
name|rtx
name|check
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|cont
decl_stmt|;
name|rtx
name|ret
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|flag
init|=
name|gen_reg_rtx
argument_list|(
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|end
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|expr
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|cont
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ret
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|cont
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cont
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|make_tree
argument_list|(
name|integer_type_node
argument_list|,
name|flag
argument_list|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|do_function_call
argument_list|(
name|Terminate
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|Terminate
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|second_try
operator|=
name|expr
expr_stmt|;
name|expr
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|cont
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ret
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|cont
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cont
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|make_tree
argument_list|(
name|integer_type_node
argument_list|,
name|flag
argument_list|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|start_protect
argument_list|()
expr_stmt|;
name|do_function_call
argument_list|(
name|Unexpected
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|Unexpected
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|end_protect
argument_list|(
name|second_try
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|cont
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
while|while
condition|(
name|raises
condition|)
block|{
name|tree
name|exp
decl_stmt|;
name|tree
name|match_type
init|=
name|TREE_VALUE
argument_list|(
name|raises
argument_list|)
decl_stmt|;
if|if
condition|(
name|match_type
condition|)
block|{
comment|/* check TREE_VALUE (raises) here */
name|exp
operator|=
name|saved_throw_value
expr_stmt|;
name|exp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_eh_type_type
argument_list|(
name|match_type
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|saved_throw_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call
argument_list|(
name|CatchMatch
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|CatchMatch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|jumpif
argument_list|(
name|exp
argument_list|,
name|cont
argument_list|)
expr_stmt|;
block|}
name|raises
operator|=
name|TREE_CHAIN
argument_list|(
name|raises
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|flag
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|cont
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|end_protect
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called to expand all the toplevel exception handling    finalization for a function.  It should only be called once per    function.  */
end_comment

begin_function
name|void
name|expand_exception_blocks
parameter_list|()
block|{
specifier|static
name|rtx
name|funcend
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|funcend
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_jump
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
comment|/* expand_null_return (); */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Add all the catch clauses here.  */
name|emit_insns
argument_list|(
name|catch_clauses
argument_list|)
expr_stmt|;
name|catch_clauses
operator|=
name|NULL_RTX
expr_stmt|;
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Do this after we expand leftover cleanups, so that the end_protect      that expand_end_eh_spec does will match the right start_protect,      and make sure it comes out before the terminate protected region.  */
if|if
condition|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_end_eh_spec
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_to_sequence
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Now expand any new ones.  */
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|insns
condition|)
block|{
name|struct
name|ehEntry
name|entry
decl_stmt|;
comment|/* These are saved for the exception table.  */
name|push_rtl_perm
argument_list|()
expr_stmt|;
name|entry
operator|.
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|.
name|end_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|.
name|exception_handler_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|entry
operator|.
name|finalization
operator|=
name|TerminateFunctionCall
expr_stmt|;
name|entry
operator|.
name|context
operator|=
name|current_function_decl
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|Terminate
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pop_rtl_from_perm
argument_list|()
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|.
name|start_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|.
name|end_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|entry
operator|.
name|exception_handler_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|.
name|start_label
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|enqueue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|,
name|copy_eh_entry
argument_list|(
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|.
name|exception_handler_label
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|entry
operator|.
name|finalization
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|entry
operator|.
name|end_label
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
block|{
comment|/* Mark the end of the stack unwinder.  */
name|rtx
name|unwind_insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|end_eh_unwinder
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
name|unwind_insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|unwind_insns
condition|)
block|{
name|insns
operator|=
name|unwind_insns
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_label
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
comment|/* Only if we had previous insns do we want to emit the jump around      them.  If there weren't any, then insns will remain NULL_RTX.  */
if|if
condition|(
name|insns
condition|)
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* call this to expand a throw statement.  This follows the following    algorithm:  	1. Allocate space to save the current PC onto the stack. 	2. Generate and emit a label and save its address into the 		newly allocated stack space since we can't save the pc directly. 	3. If this is the first call to throw in this function: 		generate a label for the throw block 	4. jump to the throw block label.  */
end_comment

begin_function
name|void
name|expand_throw
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* This is the label that represents where in the code we were, when      we got an exception.  This needs to be updated when we rethrow an      exception, so that the matching routine knows to search out.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
block|{
name|tree
name|throw_type
decl_stmt|;
name|tree
name|e
decl_stmt|;
comment|/* throw expression */
comment|/* First, decay it. */
name|exp
operator|=
name|decay_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|throw_type
operator|=
name|build_eh_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_reinterpret_cast
argument_list|(
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make a copy of the thrown object.  WP 15.1.5  */
name|exp
operator|=
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"  in thrown expression"
argument_list|)
expr_stmt|;
name|throw_type
operator|=
name|build_eh_type
argument_list|(
name|build_indirect_ref
argument_list|(
name|exp
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|build_modify_expr
argument_list|(
name|saved_throw_type
argument_list|,
name|NOP_EXPR
argument_list|,
name|throw_type
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|e
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_modify_expr
argument_list|(
name|saved_throw_value
argument_list|,
name|NOP_EXPR
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|e
operator|=
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|e
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* rethrow current exception */
comment|/* This part is easy, as we don't have to do anything else.  */
block|}
name|expand_internal_throw
argument_list|(
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_protect_partials
parameter_list|()
block|{
while|while
condition|(
name|protect_list
condition|)
block|{
name|end_protect
argument_list|(
name|TREE_VALUE
argument_list|(
name|protect_list
argument_list|)
argument_list|)
expr_stmt|;
name|protect_list
operator|=
name|TREE_CHAIN
argument_list|(
name|protect_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|might_have_exceptions_p
parameter_list|()
block|{
if|if
condition|(
name|eh_table_output_queue
operator|.
name|head
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output the exception table.  Return the number of handlers.  */
end_comment

begin_function
name|void
name|emit_exception_table
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|struct
name|ehEntry
modifier|*
name|entry
decl_stmt|;
name|tree
name|eh_node_decl
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|exception_section
argument_list|()
expr_stmt|;
comment|/* Beginning marker for table. */
name|assemble_align
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
literal|"__EXCEPTION_TABLE__"
argument_list|)
expr_stmt|;
name|output_exception_table_entry
argument_list|(
name|asm_out_file
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|=
name|dequeue_eh_entry
argument_list|(
operator|&
name|eh_table_output_queue
argument_list|)
condition|)
block|{
name|tree
name|context
init|=
name|entry
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|context
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|context
argument_list|)
condition|)
continue|continue;
name|count
operator|++
expr_stmt|;
name|output_exception_table_entry
argument_list|(
name|asm_out_file
argument_list|,
name|entry
operator|->
name|start_label
argument_list|,
name|entry
operator|->
name|end_label
argument_list|,
name|entry
operator|->
name|exception_handler_label
argument_list|)
expr_stmt|;
block|}
comment|/* Ending marker for table. */
name|assemble_label
argument_list|(
literal|"__EXCEPTION_END__"
argument_list|)
expr_stmt|;
name|output_exception_table_entry
argument_list|(
name|asm_out_file
argument_list|,
name|constm1_rtx
argument_list|,
name|constm1_rtx
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|register_exception_table
parameter_list|()
block|{
name|rtx
name|addr
init|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__EXCEPTION_TABLE__"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MARK_LOCAL_ADDRESS
name|MARK_LOCAL_ADDRESS
argument_list|(
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__register_exceptions"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a throw expression.  */
end_comment

begin_function
name|tree
name|build_throw
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|!=
name|error_mark_node
condition|)
block|{
name|e
operator|=
name|build1
argument_list|(
name|THROW_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_macro
name|start_eh_unwinder
argument_list|()
end_macro

begin_block
block|{
name|start_protect
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|end_eh_unwinder
argument_list|(
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|expr
decl_stmt|;
name|rtx
name|return_val_rtx
decl_stmt|,
name|ret_val
decl_stmt|,
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|expr
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|expand_builtin_return_addr
argument_list|(
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
literal|0
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|return_val_rtx
operator|=
name|copy_to_reg
argument_list|(
name|ret_val
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NORMAL_RETURN_ADDR_OFFSET
name|return_val_rtx
operator|=
name|plus_constant
argument_list|(
name|return_val_rtx
argument_list|,
name|NORMAL_RETURN_ADDR_OFFSET
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|return_val_rtx
operator|=
name|plus_constant
argument_list|(
name|return_val_rtx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|saved_pc
argument_list|)
argument_list|,
name|return_val_rtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMP_TO_THROW
name|emit_move_insn
argument_list|(
name|ret_val
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__throw"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ret_val
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|Pmode
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NORMAL_RETURN_ADDR_OFFSET
name|return_val_rtx
operator|=
name|plus_constant
argument_list|(
name|ret_val
argument_list|,
operator|-
name|NORMAL_RETURN_ADDR_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val_rtx
operator|!=
name|ret_val
condition|)
name|emit_move_insn
argument_list|(
name|ret_val
argument_list|,
name|return_val_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_jump
argument_list|(
name|end
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|JUMP_TO_THROW
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|do_function_call
argument_list|(
name|Throw
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|end_protect
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

