begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle exceptional things in C++.    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001  Free Software Foundation, Inc.    Contributed by Michael Tiemann<tiemann@cygnus.com>    Rewritten by Mike Stump<mrs@cygnus.com>, based upon an    initial re-implementation courtesy Tad Hunt.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|push_eh_cleanup
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|prepare_eh_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_eh_type_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|do_begin_catch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dtor_nothrow
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|do_end_catch
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_eh_cleanup
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|decl_is_java_type
name|PARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
name|int
name|err
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_handler_parm
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|do_allocate_exception
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|complete_ptr_ref_or_void_ptr_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|is_admissible_throw_operand
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_convert_eh
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_handlers_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|cp_protect_cleanup_actions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Sets up all the global eh stuff that needs to be initialized at the    start of compilation.  */
end_comment

begin_function
name|void
name|init_exception_processing
parameter_list|()
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* void std::terminate (); */
name|push_namespace
argument_list|(
name|std_identifier
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|terminate_node
operator|=
name|build_cp_library_fn_ptr
argument_list|(
literal|"terminate"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|terminate_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|terminate_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* void __cxa_call_unexpected(void *); */
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|call_unexpected_node
operator|=
name|push_throw_library_fn
argument_list|(
name|get_identifier
argument_list|(
literal|"__cxa_call_unexpected"
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|eh_personality_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"__gxx_personality_sj0"
else|:
literal|"__gxx_personality_v0"
argument_list|)
expr_stmt|;
name|lang_eh_runtime_type
operator|=
name|build_eh_type_type
expr_stmt|;
name|lang_protect_cleanup_actions
operator|=
operator|&
name|cp_protect_cleanup_actions
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns an expression to be executed if an unhandled exception is    propagated out of a cleanup region.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_protect_cleanup_actions
parameter_list|()
block|{
comment|/* [except.terminate]       When the destruction of an object during stack unwinding exits      using an exception ... void terminate(); is called.  */
return|return
name|build_call
argument_list|(
name|terminate_node
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|prepare_eh_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* peel back references, so they match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Build the address of a typeinfo decl for use in the runtime    matching field of the exception model.   */
end_comment

begin_function
specifier|static
name|tree
name|build_eh_type_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
if|if
condition|(
name|decl_is_java_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
condition|)
name|exp
operator|=
name|build_java_class_ref
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|exp
operator|=
name|get_tinfo_decl
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_function
name|tree
name|build_exc_ptr
parameter_list|()
block|{
return|return
name|build
argument_list|(
name|EXC_PTR_EXPR
argument_list|,
name|ptr_type_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build up a call to __cxa_begin_catch, to tell the runtime that the    exception has been handled.  */
end_comment

begin_function
specifier|static
name|tree
name|do_begin_catch
parameter_list|()
block|{
name|tree
name|fn
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_begin_catch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void* __cxa_begin_catch (void *).  */
name|tree
name|tmp
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|fn
operator|=
name|push_library_fn
argument_list|(
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_exc_ptr
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if cleaning up an exception of type TYPE (which can be    NULL_TREE for a ... handler) will not throw an exception.  */
end_comment

begin_function
specifier|static
name|int
name|dtor_nothrow
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|fn
operator|=
name|lookup_member
argument_list|(
name|type
argument_list|,
name|dtor_identifier
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build up a call to __cxa_end_catch, to destroy the exception object    for the current catch block if no others are currently using it.  */
end_comment

begin_function
specifier|static
name|tree
name|do_end_catch
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|,
name|cleanup
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_end_catch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void __cxa_end_catch ().  */
name|fn
operator|=
name|push_void_library_fn
argument_list|(
name|fn
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
comment|/* This can throw if the destructor for the exception throws.  */
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|cleanup
argument_list|)
operator|=
name|dtor_nothrow
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|cleanup
return|;
block|}
end_function

begin_comment
comment|/* This routine creates the cleanup for the current exception.  */
end_comment

begin_function
specifier|static
name|void
name|push_eh_cleanup
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|do_end_catch
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero value if DECL is a Java type suitable for catch or    throw.  */
end_comment

begin_function
specifier|static
name|bool
name|decl_is_java_type
parameter_list|(
name|decl
parameter_list|,
name|err
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|err
decl_stmt|;
block|{
name|bool
name|r
init|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Can't throw a reference.  */
name|error
argument_list|(
literal|"type `%T' is disallowed in Java `throw' or `catch'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
condition|)
block|{
name|tree
name|jthrow_node
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
literal|"jthrowable"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|jthrow_node
operator|==
name|NULL_TREE
condition|)
name|fatal_error
argument_list|(
literal|"call to Java `catch' or `throw' with `jthrowable' undefined"
argument_list|)
expr_stmt|;
name|jthrow_node
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|jthrow_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|jthrow_node
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Thrown object must be a Throwable.  */
name|error
argument_list|(
literal|"type `%T' is not derived from `java::lang::Throwable'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Select the personality routine to be used for exception handling,    or issue an error if we need two different ones in the same    translation unit.    ??? At present eh_personality_libfunc is set to    __gxx_personality_(sj|v)0 in init_exception_processing - should it    be done here instead?  */
end_comment

begin_function
name|void
name|choose_personality_routine
parameter_list|(
name|lang
parameter_list|)
name|enum
name|languages
name|lang
decl_stmt|;
block|{
specifier|static
enum|enum
block|{
name|chose_none
block|,
name|chose_cpp
block|,
name|chose_java
block|,
name|gave_error
block|}
name|state
enum|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|gave_error
case|:
return|return;
case|case
name|chose_cpp
case|:
if|if
condition|(
name|lang
operator|!=
name|lang_cplusplus
condition|)
goto|goto
name|give_error
goto|;
return|return;
case|case
name|chose_java
case|:
if|if
condition|(
name|lang
operator|!=
name|lang_java
condition|)
goto|goto
name|give_error
goto|;
return|return;
case|case
name|chose_none
case|:
empty_stmt|;
comment|/* proceed to language selection */
block|}
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
name|lang_cplusplus
case|:
name|state
operator|=
name|chose_cpp
expr_stmt|;
break|break;
case|case
name|lang_java
case|:
name|state
operator|=
name|chose_java
expr_stmt|;
name|eh_personality_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"__gcj_personality_sj0"
else|:
literal|"__gcj_personality_v0"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
name|give_error
label|:
name|error
argument_list|(
literal|"mixing C++ and Java catches in a single translation unit"
argument_list|)
expr_stmt|;
name|state
operator|=
name|gave_error
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the catch parameter DECL.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_handler_parm
parameter_list|(
name|decl
parameter_list|,
name|exp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|init
decl_stmt|;
name|tree
name|init_type
decl_stmt|;
comment|/* Make sure we mark the catch param as used, otherwise we'll get a      warning about an unused ((anonymous)).  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Figure out the type that the initializer is.  Pointers are returned      adjusted by value from __cxa_begin_catch.  Others are returned by       reference.  */
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_PTR_P
argument_list|(
name|init_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
name|init_type
operator|=
name|build_reference_type
argument_list|(
name|init_type
argument_list|)
expr_stmt|;
name|choose_personality_routine
argument_list|(
name|decl_is_java_type
argument_list|(
name|init_type
argument_list|,
literal|0
argument_list|)
condition|?
name|lang_java
else|:
name|lang_cplusplus
argument_list|)
expr_stmt|;
comment|/* Since pointers are passed by value, initialize a reference to      pointer catch parm with the address of the temporary.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_PTR_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|init_type
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ocp_convert
argument_list|(
name|init_type
argument_list|,
name|exp
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If the constructor for the catch parm exits via an exception, we      must call terminate.  See eh23.C.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Generate the copy constructor call directly so we can wrap it. 	 See also expand_default_init.  */
name|init
operator|=
name|ocp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|build1
argument_list|(
name|MUST_NOT_THROW_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* Let `cp_finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|start_decl_1
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
operator||
name|DIRECT_BIND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to start a catch block.  DECL is the catch parameter.  */
end_comment

begin_function
name|tree
name|expand_start_catch_block
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|exp
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|bool
name|is_java
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Make sure this declaration is reasonable.  */
if|if
condition|(
name|decl
operator|&&
operator|!
name|complete_ptr_ref_or_void_ptr_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|type
operator|=
name|prepare_eh_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|NULL_TREE
expr_stmt|;
name|is_java
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|decl_is_java_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Java only passes object via pointer and doesn't require 	     adjusting.  The java object is immediately before the 	     generic exception header.  */
name|init
operator|=
name|build_exc_ptr
argument_list|()
expr_stmt|;
name|init
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_indirect_ref
argument_list|(
name|init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|is_java
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* C++ requires that we call __cxa_begin_catch to get the 	     pointer to the actual object.  */
name|init
operator|=
name|do_begin_catch
argument_list|()
expr_stmt|;
block|}
name|exp
operator|=
name|create_temporary_var
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|exp
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|exp
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_expr_stmt
argument_list|(
name|do_begin_catch
argument_list|()
argument_list|)
expr_stmt|;
comment|/* C++ requires that we call __cxa_end_catch at the end of      processing the exception.  */
if|if
condition|(
operator|!
name|is_java
condition|)
name|push_eh_cleanup
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|initialize_handler_parm
argument_list|(
name|decl
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Call this to end a catch block.  Its responsible for emitting the    code to handle jumping back to the correct place, and for emitting    the label to jump to if this catch block didn't match.  */
end_comment

begin_function
name|void
name|expand_end_catch_block
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* The exception being handled is rethrown if control reaches the end of      a handler of the function-try-block of a constructor or destructor.  */
if|if
condition|(
name|in_function_try_handler
operator|&&
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|)
name|finish_expr_stmt
argument_list|(
name|build_throw
argument_list|(
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|begin_eh_spec_block
parameter_list|()
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|EH_SPEC_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|finish_eh_spec_block
parameter_list|(
name|raw_raises
parameter_list|,
name|eh_spec_block
parameter_list|)
name|tree
name|raw_raises
decl_stmt|;
name|tree
name|eh_spec_block
decl_stmt|;
block|{
name|tree
name|raises
decl_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|eh_spec_block
argument_list|,
name|EH_SPEC_STMTS
argument_list|(
name|eh_spec_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Strip cv quals, etc, from the specification types.  */
for|for
control|(
name|raises
operator|=
name|NULL_TREE
init|;
name|raw_raises
operator|&&
name|TREE_VALUE
argument_list|(
name|raw_raises
argument_list|)
condition|;
name|raw_raises
operator|=
name|TREE_CHAIN
argument_list|(
name|raw_raises
argument_list|)
control|)
name|raises
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|prepare_eh_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|raw_raises
argument_list|)
argument_list|)
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|EH_SPEC_RAISES
argument_list|(
name|eh_spec_block
argument_list|)
operator|=
name|raises
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a buffer for an exception object of type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|do_allocate_exception
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_allocate_exception"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void *__cxa_allocate_exception(size_t).  */
name|tree
name|tmp
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|c_size_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|fn
operator|=
name|push_library_fn
argument_list|(
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Call __cxa_free_exception from a cleanup.  This is never invoked    directly.  */
end_comment

begin_comment
unit|static tree do_free_exception (ptr)      tree ptr; {   tree fn;    fn = get_identifier ("__cxa_free_exception");   if (IDENTIFIER_GLOBAL_VALUE (fn))     fn = IDENTIFIER_GLOBAL_VALUE (fn);   else     {
comment|/* Declare void __cxa_free_exception (void *).  */
end_comment

begin_endif
unit|fn = push_void_library_fn (fn, tree_cons (NULL_TREE, ptr_type_node, 						void_list_node));     }    return build_function_call (fn, tree_cons (NULL_TREE, ptr, NULL_TREE)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build a throw expression.  */
end_comment

begin_function
name|tree
name|build_throw
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|THROW_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|exp
operator|==
name|null_node
condition|)
name|warning
argument_list|(
literal|"throwing NULL, which has integral, not pointer type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|is_admissible_throw_operand
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|exp
operator|&&
name|decl_is_java_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"_Jv_Throw"
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void _Jv_Throw (void *).  */
name|tree
name|tmp
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
condition|)
block|{
name|tree
name|throw_type
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|tree
name|stmt_expr
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|tree
name|object
decl_stmt|,
name|ptr
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__cxa_throw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The CLEANUP_TYPE is the internal type of a destructor.  */
if|if
condition|(
name|cleanup_type
operator|==
name|NULL_TREE
condition|)
block|{
name|tmp
operator|=
name|void_list_node
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cleanup_type
operator|=
name|build_pointer_type
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Declare void __cxa_throw (void*, void*, void (*)(void*)).  */
comment|/* ??? Second argument is supposed to be "std::type_info*".  */
name|tmp
operator|=
name|void_list_node
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup_type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|begin_init_stmts
argument_list|(
operator|&
name|stmt_expr
argument_list|,
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
comment|/* throw expression */
comment|/* First, decay it.  */
name|exp
operator|=
name|decay_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* OK, this is kind of wacky.  The standard says that we call 	 terminate when the exception handling mechanism, after 	 completing evaluation of the expression to be thrown but 	 before the exception is caught (_except.throw_), calls a 	 user function that exits via an uncaught exception.  	 So we have to protect the actual initialization of the 	 exception object with terminate(), but evaluate the 	 expression first.  Since there could be temps in the 	 expression, we need to handle that, too.  We also expand 	 the call to __cxa_allocate_exception first (which doesn't 	 matter, since it can't throw).  */
name|my_friendly_assert
argument_list|(
name|stmts_are_full_exprs_p
argument_list|()
operator|==
literal|1
argument_list|,
literal|19990926
argument_list|)
expr_stmt|;
comment|/* Store the throw expression into a temp.  This can be less 	 efficient than storing it into the allocated space directly, but 	 if we allocated the space first we would have to deal with 	 cleaning it up if evaluating this expression throws.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|create_temporary_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|tmp
argument_list|)
operator|=
name|exp
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|tmp
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|exp
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Allocate the space for the exception.  */
name|ptr
operator|=
name|create_temporary_var
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|ptr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|do_allocate_exception
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_modify_expr
argument_list|(
name|ptr
argument_list|,
name|INIT_EXPR
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|object
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|object
operator|=
name|build_indirect_ref
argument_list|(
name|object
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_modify_expr
argument_list|(
name|object
argument_list|,
name|INIT_EXPR
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"  in thrown expression"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|MUST_NOT_THROW_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|throw_type
operator|=
name|build_eh_type_type
argument_list|(
name|prepare_eh_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
condition|)
block|{
name|cleanup
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|,
name|complete_dtor_identifier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|TREE_VALUE
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|mark_addressable
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Pretend it's a normal function.  */
name|cleanup
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|cleanup_type
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cleanup
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cleanup
argument_list|)
operator|=
name|cleanup_type
expr_stmt|;
block|}
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|throw_type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* ??? Indicate that this function call throws throw_type.  */
name|finish_expr_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|finish_init_stmts
argument_list|(
name|stmt_expr
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Rethrow current exception.  */
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"__cxa_rethrow"
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void __cxa_rethrow (void).  */
name|fn
operator|=
name|push_throw_library_fn
argument_list|(
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|build1
argument_list|(
name|THROW_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Make sure TYPE is complete, pointer to complete, reference to    complete, or pointer to cv void. Issue diagnostic on failure.    Return the zero on failure and non-zero on success. FROM can be    the expr or decl from whence TYPE came, if available.  */
end_comment

begin_function
specifier|static
name|int
name|complete_ptr_ref_or_void_ptr_p
parameter_list|(
name|type
parameter_list|,
name|from
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|from
decl_stmt|;
block|{
name|int
name|is_ptr
decl_stmt|;
comment|/* Check complete.  */
name|type
operator|=
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
literal|0
return|;
comment|/* Or a pointer or ref to one, or cv void *.  */
name|is_ptr
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
expr_stmt|;
if|if
condition|(
name|is_ptr
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|core
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_ptr
operator|&&
name|VOID_TYPE_P
argument_list|(
name|core
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|core
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return truth-value if EXPRESSION is admissible in throw-expression,    i.e. if it is not of incomplete type or a pointer/reference to such    a type or of an abstract class type.  */
end_comment

begin_function
specifier|static
name|bool
name|is_admissible_throw_operand
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* 15.1/4 [...] The type of the throw-expression shall not be an             incomplete type, or a pointer or a reference to an incomplete             type, other than void*, const void*, volatile void*, or             const volatile void*.  Except for these restriction and the             restrictions on type matching mentioned in 15.3, the operand             of throw is treated exactly as a function argument in a call             (5.2.2) or the operand of a return statement.  */
if|if
condition|(
operator|!
name|complete_ptr_ref_or_void_ptr_p
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* 10.4/3 An abstract class shall not be used as a parameter type,             as a function return type or as type of an explicit             conversion.  */
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"expression '%E' of abstract class type '%T' cannot be used in throw-expression"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if FN is a declaration of a standard C library    function which is known not to throw.     [lib.res.on.exception.handling]: None of the functions from the    Standard C library shall report an error by throwing an    exception, unless it calls a program-supplied function that    throws an exception.  */
end_comment

begin_include
include|#
directive|include
file|"cfns.h"
end_include

begin_function
name|int
name|nothrow_libfn_p
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
comment|/* Can't be a C library function.  */
return|return
literal|0
return|;
name|id
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|libc_name_p
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|id
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if an exception of type FROM will be caught by a    handler for type TO, as per [except.handle].  */
end_comment

begin_function
specifier|static
name|int
name|can_convert_eh
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|1
return|;
comment|/* else fall through */
block|}
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|to
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|from
argument_list|)
operator|&&
name|PUBLICLY_UNIQUELY_DERIVED_P
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether any of HANDLERS are shadowed by another handler accepting    TYPE.  Note that the shadowing may not be complete; even if an exception    of type B would be caught by a handler for A, there could be a derived    class C for which A is an ambiguous base but B is not, so the handler    for B would catch an exception of type C.  */
end_comment

begin_function
specifier|static
name|void
name|check_handlers_1
parameter_list|(
name|master
parameter_list|,
name|handlers
parameter_list|)
name|tree
name|master
decl_stmt|;
name|tree
name|handlers
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|master
argument_list|)
decl_stmt|;
name|tree
name|handler
decl_stmt|;
for|for
control|(
name|handler
operator|=
name|handlers
init|;
name|handler
condition|;
name|handler
operator|=
name|TREE_CHAIN
argument_list|(
name|handler
argument_list|)
control|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|handler
argument_list|)
operator|&&
name|can_convert_eh
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|handler
argument_list|)
argument_list|)
condition|)
block|{
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"exception of type `%T' will be caught"
argument_list|,
name|TREE_TYPE
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"   by earlier handler for `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a chain of HANDLERs, make sure that they're OK.  */
end_comment

begin_function
name|void
name|check_handlers
parameter_list|(
name|handlers
parameter_list|)
name|tree
name|handlers
decl_stmt|;
block|{
name|tree
name|handler
decl_stmt|;
name|int
name|save_line
init|=
name|lineno
decl_stmt|;
for|for
control|(
name|handler
operator|=
name|handlers
init|;
name|handler
condition|;
name|handler
operator|=
name|TREE_CHAIN
argument_list|(
name|handler
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|handler
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* No more handlers; nothing to shadow.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|handler
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"`...' handler must be the last handler for its try block"
argument_list|)
expr_stmt|;
block|}
else|else
name|check_handlers_1
argument_list|(
name|handler
argument_list|,
name|TREE_CHAIN
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lineno
operator|=
name|save_line
expr_stmt|;
block|}
end_function

end_unit

