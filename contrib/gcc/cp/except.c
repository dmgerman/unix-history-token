begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle exceptional things in C++.    Copyright (C) 1989, 92-97, 1998, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann<tiemann@cygnus.com>    Rewritten by Mike Stump<mrs@cygnus.com>, based upon an    initial re-implementation courtesy Tad Hunt.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"eh-common.h"
end_include

begin_decl_stmt
name|rtx
name|expand_builtin_return_addr
name|PROTO
argument_list|(
operator|(
expr|enum
name|built_in_function
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the fndecl for __builtin_return_address.  */
end_comment

begin_decl_stmt
name|tree
name|builtin_return_address_fndecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A couple of backend routines from m88k.c */
end_comment

begin_decl_stmt
specifier|static
name|void
name|push_eh_cleanup
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_eh_type_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_eh_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_end_eh_spec
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|call_eh_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_eh_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_eh_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_eh_value
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static tree get_eh_type PROTO((void)); static tree get_eh_caught PROTO((void)); static tree get_eh_handlers PROTO((void));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|do_pop_exception
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_start_catch_block
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_eh_type_type_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_terminate_handler
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|alloc_eh_object
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is the startup, and finish stuff per exception table.  */
end_comment

begin_comment
comment|/* XXX - Tad: exception handling section */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXCEPT_SECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|EXCEPT_SECTION_ASM_OP
value|"section\t.gcc_except_table,\"a\",@progbits"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* on machines which support it, the exception table lives in another section, 	but it needs a label so we can reference it...  This sets up that     label! */
end_comment

begin_endif
unit|asm (EXCEPT_SECTION_ASM_OP); exception_table __EXCEPTION_TABLE__[1] = { (void*)0, (void*)0, (void*)0 }; asm (TEXT_SECTION_ASM_OP);
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCEPT_SECTION_ASM_OP
end_ifdef

begin_comment
comment|/* we need to know where the end of the exception table is... so this     is how we do it! */
end_comment

begin_endif
unit|asm (EXCEPT_SECTION_ASM_OP); exception_table __EXCEPTION_END__[1] = { (void*)-1, (void*)-1, (void*)-1 }; asm (TEXT_SECTION_ASM_OP);
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCEPT_SECTION_ASM_OP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* ======================================================================    Briefly the algorithm works like this:       When a constructor or start of a try block is encountered,      push_eh_entry (&eh_stack) is called.  Push_eh_entry () creates a      new entry in the unwind protection stack and returns a label to      output to start the protection for that block.       When a destructor or end try block is encountered, pop_eh_entry      (&eh_stack) is called.  Pop_eh_entry () returns the eh_entry it      created when push_eh_entry () was called.  The eh_entry structure      contains three things at this point.  The start protect label,      the end protect label, and the exception handler label.  The end      protect label should be output before the call to the destructor      (if any). If it was a destructor, then its parse tree is stored      in the finalization variable in the eh_entry structure.  Otherwise      the finalization variable is set to NULL to reflect the fact that      it is the end of a try block.  Next, this modified eh_entry node      is enqueued in the finalizations queue by calling      enqueue_eh_entry (&queue,entry).  	+---------------------------------------------------------------+ 	|XXX: Will need modification to deal with partially		| 	|			constructed arrays of objects		| 	|								| 	|	Basically, this consists of keeping track of how many	| 	|	of the objects have been constructed already (this	| 	|	should be in a register though, so that shouldn't be a	| 	|	problem.						| 	+---------------------------------------------------------------+       When a catch block is encountered, there is a lot of work to be      done.       Since we don't want to generate the catch block inline with the      regular flow of the function, we need to have some way of doing      so.  Luckily, we can use sequences to defer the catch sections.      When the start of a catch block is encountered, we start the      sequence.  After the catch block is generated, we end the      sequence.       Next we must insure that when the catch block is executed, all      finalizations for the matching try block have been completed.  If      any of those finalizations throw an exception, we must call      terminate according to the ARM (section r.15.6.1).  What this      means is that we need to dequeue and emit finalizations for each      entry in the eh_queue until we get to an entry with a NULL      finalization field.  For any of the finalization entries, if it      is not a call to terminate (), we must protect it by giving it      another start label, end label, and exception handler label,      setting its finalization tree to be a call to terminate (), and      enqueue'ing this new eh_entry to be output at an outer level.      Finally, after all that is done, we can get around to outputting      the catch block which basically wraps all the "catch (...) {...}"      statements in a big if/then/else construct that matches the      correct block to call.            ===================================================================== */
end_comment

begin_comment
comment|/* local globals for function calls    ====================================================================== */
end_comment

begin_comment
comment|/* Used to cache "terminate" and "__throw_type_match*".  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|Terminate
decl_stmt|,
name|CatchMatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to cache __find_first_exception_table_match for throw.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|FirstExceptionMatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to cache a call to __unwind_function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|Unwind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ====================================================================== */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* local globals - these local globals are for storing data necessary for    generating the exception table and code in the correct order.     ========================================================================= */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|catch_clauses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|const_ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* sets up all the global eh stuff that needs to be initialized at the    start of compilation.     This includes: 		- Setting up all the function call trees.  */
end_comment

begin_function
name|void
name|init_exception_processing
parameter_list|()
block|{
comment|/* void vtype () */
name|tree
name|vtype
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_honor_std
condition|)
name|push_namespace
argument_list|(
name|get_identifier
argument_list|(
literal|"std"
argument_list|)
argument_list|)
expr_stmt|;
name|Terminate
operator|=
name|auto_function
argument_list|(
name|get_identifier
argument_list|(
literal|"terminate"
argument_list|)
argument_list|,
name|vtype
argument_list|,
name|NOT_BUILT_IN
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|Terminate
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_honor_std
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|set_exception_lang_code
argument_list|(
name|EH_LANG_C_plus_plus
argument_list|)
expr_stmt|;
name|set_exception_version_code
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CatchMatch
operator|=
name|builtin_function
argument_list|(
name|flag_rtti
condition|?
literal|"__throw_type_match_rtti"
else|:
literal|"__throw_type_match"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|FirstExceptionMatch
operator|=
name|builtin_function
argument_list|(
literal|"__find_first_exception_table_match"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|Unwind
operator|=
name|builtin_function
argument_list|(
literal|"__unwind_function"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
comment|/* If we use setjmp/longjmp EH, arrange for all cleanup actions to      be protected with __terminate.  */
name|protect_cleanup_actions_with_terminate
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve a pointer to the cp_eh_info node for the current exception.  */
end_comment

begin_function
specifier|static
name|tree
name|call_eh_info
parameter_list|()
block|{
name|tree
name|fn
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__start_cp_handler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|t1
decl_stmt|,
name|t
decl_stmt|,
name|fields
index|[
literal|7
index|]
decl_stmt|;
comment|/* Declare cp_eh_info * __start_cp_handler (void), 	 as defined in exception.cc. */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* struct cp_eh_info.  This must match exception.cc.  Note that this 	 type is not pushed anywhere.  */
name|t1
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"handler_label"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"dynamic_handler_chain"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"info"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"table_index"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
comment|/* N.B.: The fourth field LEN is expected to be 	 the number of fields - 1, not the total number of fields.  */
name|finish_builtin_type
argument_list|(
name|t1
argument_list|,
literal|"eh_context"
argument_list|,
name|fields
argument_list|,
literal|3
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t1
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"match_function"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"language"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
comment|/* N.B.: The fourth field LEN is expected to be 	 the number of fields - 1, not the total number of fields.  */
name|finish_builtin_type
argument_list|(
name|t1
argument_list|,
literal|"__eh_info"
argument_list|,
name|fields
argument_list|,
literal|2
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"eh_info"
argument_list|)
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|fields
index|[
literal|1
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"value"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|2
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"type"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|3
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"cleanup"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|4
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"caught"
argument_list|)
argument_list|,
name|boolean_type_node
argument_list|)
expr_stmt|;
name|fields
index|[
literal|5
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"next"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fields
index|[
literal|6
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"handlers"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
comment|/* N.B.: The fourth field LEN is expected to be 	 the number of fields - 1, not the total number of fields.  */
name|finish_builtin_type
argument_list|(
name|t
argument_list|,
literal|"cp_eh_info"
argument_list|,
name|fields
argument_list|,
literal|6
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* And now the function.  */
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|t
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a pointer to the cp_eh_info node for the current exception    and save it in the current binding level.  */
end_comment

begin_function
specifier|static
name|void
name|push_eh_info
parameter_list|()
block|{
name|tree
name|decl
decl_stmt|,
name|fn
init|=
name|call_eh_info
argument_list|()
decl_stmt|;
comment|/* Remember the pointer to the current exception info; it won't change      during this catch block.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__exception_info"
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|fn
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a reference to the cp_eh_info node for the current exception.  */
end_comment

begin_function
specifier|static
name|tree
name|get_eh_info
parameter_list|()
block|{
comment|/* Look for the pointer pushed in push_eh_info.  */
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__exception_info"
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|t
argument_list|,
name|NULL_PTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a reference to the current exception object.  */
end_comment

begin_function
specifier|static
name|tree
name|get_eh_value
parameter_list|()
block|{
return|return
name|build_component_ref
argument_list|(
name|get_eh_info
argument_list|()
argument_list|,
name|get_identifier
argument_list|(
literal|"value"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a reference to the current exception type.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static tree get_eh_type () {   return build_component_ref (get_eh_info (), get_identifier ("type"), 			      NULL_TREE, 0); }
comment|/* Returns a reference to whether or not the current exception    has been caught.  */
end_comment

begin_comment
unit|static tree get_eh_caught () {   return build_component_ref (get_eh_info (), get_identifier ("caught"), 			      NULL_TREE, 0); }
comment|/* Returns a reference to whether or not the current exception    has been caught.  */
end_comment

begin_endif
unit|static tree get_eh_handlers () {   return build_component_ref (get_eh_info (), get_identifier ("handlers"), 			      NULL_TREE, 0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build a type value for use at runtime for a type that is matched    against by the exception handling system.  */
end_comment

begin_function
specifier|static
name|tree
name|build_eh_type_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|typestring
decl_stmt|;
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* peel back references, so they match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rtti
condition|)
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|get_typeid_1
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
name|typestring
operator|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|typestring
argument_list|)
operator|+
literal|1
argument_list|,
name|typestring
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build the address of a runtime type for use in the runtime matching    field of the new exception model */
end_comment

begin_function
specifier|static
name|tree
name|build_eh_type_type_ref
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|typestring
decl_stmt|;
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* peel back references, so they match.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Peel off cv qualifiers.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_rtti
condition|)
block|{
name|exp
operator|=
name|get_tinfo_fn
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_inline_for_output
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typestring
operator|=
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|typestring
argument_list|)
operator|+
literal|1
argument_list|,
name|typestring
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
operator|(
name|exp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build a type value for use at runtime for a exp that is thrown or    matched against by the exception handling system.  */
end_comment

begin_function
specifier|static
name|tree
name|build_eh_type
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|flag_rtti
condition|)
block|{
name|exp
operator|=
name|build_typeid
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|build_eh_type_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This routine is called to mark all the symbols representing runtime    type functions in the exception table as haveing been referenced.    This will make sure code is emitted for them. Called from finish_file. */
end_comment

begin_function
name|void
name|mark_all_runtime_matches
parameter_list|()
block|{
name|int
name|x
decl_stmt|,
name|num
decl_stmt|;
name|void
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|num
operator|=
name|find_all_handler_type_matches
argument_list|(
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|ptr
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|exp
operator|=
operator|(
name|tree
operator|)
name|ptr
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build up a call to __cp_pop_exception, to destroy the exception object    for the current catch block.  HANDLER is either true or false, telling    the library whether or not it is being called from an exception handler;    if it is, it avoids destroying the object on rethrow.  */
end_comment

begin_function
specifier|static
name|tree
name|do_pop_exception
parameter_list|()
block|{
name|tree
name|fn
decl_stmt|,
name|cleanup
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__cp_pop_exception"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void __cp_pop_exception (void *), 	 as defined in exception.cc. */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Arrange to do a dynamically scoped cleanup upon exit from this region.  */
name|cleanup
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"__exception_info"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cleanup
return|;
block|}
end_function

begin_comment
comment|/* This routine creates the cleanup for the current exception.  */
end_comment

begin_function
specifier|static
name|void
name|push_eh_cleanup
parameter_list|()
block|{
name|int
name|yes
decl_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* All cleanups must last longer than normal.  */
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|do_pop_exception
argument_list|()
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build up a call to terminate on the function obstack, for use as an    exception handler.  */
end_comment

begin_function
specifier|static
name|tree
name|build_terminate_handler
parameter_list|()
block|{
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|tree
name|term
init|=
name|build_function_call
argument_list|(
name|Terminate
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
return|return
name|term
return|;
block|}
end_function

begin_comment
comment|/* Call this to start a catch block. Typename is the typename, and identifier    is the variable to place the object in or NULL if the variable doesn't    matter.  If typename is NULL, that means its a "catch (...)" or catch    everything.  In that case we don't need to do any type checking.    (ie: it ends up as the "else" clause rather than an "else if" clause) */
end_comment

begin_function
name|void
name|expand_start_catch_block
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|declspecs
condition|)
block|{
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|CATCHPARM
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_min_nt
argument_list|(
name|DECL_STMT
argument_list|,
name|copy_to_permanent
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|copy_to_permanent
argument_list|(
name|declspecs
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
name|process_start_catch_block
argument_list|(
name|declspecs
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function performs the expand_start_catch_block functionality for     exceptions implemented in the new style. __throw determines whether    a handler needs to be called or not, so the handler itself has to do    nothing additional. */
end_comment

begin_function
specifier|static
name|void
name|process_start_catch_block
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|init
decl_stmt|;
comment|/* Create a binding level for the eh_info and the exception object      cleanup.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
condition|)
block|{
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|CATCHPARM
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"invalid catch parameter"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
condition|)
name|start_catch_handler
argument_list|(
name|build_eh_type_type_ref
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|start_catch_handler
argument_list|(
name|CATCH_ALL_TYPE
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|push_eh_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|tree
name|exp
decl_stmt|;
name|tree
name|init_type
decl_stmt|;
comment|/* Make sure we mark the catch param as used, otherwise we'll get 	 a warning about an unused ((anonymous)).  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Figure out the type that the initializer is.  */
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
name|init_type
operator|=
name|build_reference_type
argument_list|(
name|init_type
argument_list|)
expr_stmt|;
name|exp
operator|=
name|get_eh_value
argument_list|()
expr_stmt|;
comment|/* Since pointers are passed by value, initialize a reference to 	 pointer catch parm with the address of the value slot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init_type
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|exp
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ocp_convert
argument_list|(
name|init_type
argument_list|,
name|exp
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|push_eh_cleanup
argument_list|()
expr_stmt|;
comment|/* Create a binding level for the parm.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* If the constructor for the catch parm exits via an exception, we          must call terminate.  See eh23.C.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Generate the copy constructor call directly so we can wrap it. 	     See also expand_default_init.  */
name|init
operator|=
name|ocp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|init
argument_list|,
name|build_terminate_handler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Let `cp_finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|start_decl_1
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
operator||
name|DIRECT_BIND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|push_eh_cleanup
argument_list|()
expr_stmt|;
comment|/* Create a binding level for the parm.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall into the catch all section.  */
block|}
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to end a catch block.  Its responsible for emitting the    code to handle jumping back to the correct place, and for emitting    the label to jump to if this catch block didn't match.  */
end_comment

begin_function
name|void
name|expand_end_catch_block
parameter_list|()
block|{
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
comment|/* Cleanup the EH parameter.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|kept_level_p
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cleanup the EH object.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
name|kept_level_p
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall to outside the try statement when done executing handler and      we fall off end of handler.  This is jump Lresume in the      documentation.  */
name|expand_goto
argument_list|(
name|top_label_entry
argument_list|(
operator|&
name|caught_return_label_stack
argument_list|)
argument_list|)
expr_stmt|;
name|end_catch_handler
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An exception spec is implemented more or less like:     try {      function body;    } catch (...) {      void *p[] = { typeid(raises) };      __check_eh_spec (p, count);    }     __check_eh_spec in exception.cc handles all the details.  */
end_comment

begin_function
name|void
name|expand_start_eh_spec
parameter_list|()
block|{
name|expand_start_try_stmts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_end_eh_spec
parameter_list|(
name|raises
parameter_list|)
name|tree
name|raises
decl_stmt|;
block|{
name|tree
name|tmp
decl_stmt|,
name|fn
decl_stmt|,
name|decl
decl_stmt|,
name|types
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|expand_start_all_catch
argument_list|()
expr_stmt|;
name|expand_start_catch_block
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Build up an array of type_infos.  */
for|for
control|(
init|;
name|raises
operator|&&
name|TREE_VALUE
argument_list|(
name|raises
argument_list|)
condition|;
name|raises
operator|=
name|TREE_CHAIN
argument_list|(
name|raises
argument_list|)
control|)
block|{
name|types
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_eh_type_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|raises
argument_list|)
argument_list|)
argument_list|,
name|types
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
name|types
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|types
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can't pass the CONSTRUCTOR directly, so stick it in a variable.  */
name|tmp
operator|=
name|build_cplus_array_type
argument_list|(
name|const_ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|types
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|types
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|decay_conversion
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__check_eh_spec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|tmp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|expand_end_catch_block
argument_list|()
expr_stmt|;
name|expand_end_all_catch
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called to expand all the toplevel exception handling    finalization for a function.  It should only be called once per    function.  */
end_comment

begin_function
name|void
name|expand_exception_blocks
parameter_list|()
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|push_to_sequence
argument_list|(
name|catch_clauses
argument_list|)
expr_stmt|;
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|catch_clauses
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Do this after we expand leftover cleanups, so that the      expand_eh_region_end that expand_end_eh_spec does will match the      right expand_eh_region_start, and make sure it comes out before      the terminate protected region.  */
if|if
condition|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
block|{
name|expand_end_eh_spec
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|push_to_sequence
argument_list|(
name|catch_clauses
argument_list|)
expr_stmt|;
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|catch_clauses
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|catch_clauses
condition|)
block|{
name|rtx
name|funcend
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_jump
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
comment|/* We cannot protect n regions this way if we must flow into the 	 EH region through the top of the region, as we have to with 	 the setjmp/longjmp approach.  */
if|if
condition|(
name|exceptions_via_longjmp
operator|==
literal|0
condition|)
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|catch_clauses
argument_list|)
expr_stmt|;
name|catch_clauses
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|exceptions_via_longjmp
operator|==
literal|0
condition|)
name|expand_eh_region_end
argument_list|(
name|build_terminate_handler
argument_list|()
argument_list|)
expr_stmt|;
name|expand_leftover_cleanups
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|funcend
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|start_anon_func
parameter_list|()
block|{
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|old_interface_unknown
init|=
name|interface_unknown
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|tree
name|params
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|push_cp_function_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* No need to mangle this.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|params
operator|=
name|void_list_node
expr_stmt|;
comment|/* tcf stands for throw clean function.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__tcf_%d"
argument_list|,
name|counter
operator|++
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_call_declarator
argument_list|(
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|old_interface_unknown
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
return|return
name|current_function_decl
return|;
block|}
end_function

begin_function
name|void
name|end_anon_func
parameter_list|()
block|{
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_cp_function_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a buffer for an exception object of type TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|alloc_eh_object
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|,
name|exp
decl_stmt|;
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__eh_alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare __eh_alloc (size_t), as defined in exception.cc.  */
name|tree
name|tmp
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Expand a throw statement.  This follows the following    algorithm:  	1. Allocate space to save the current PC onto the stack. 	2. Generate and emit a label and save its address into the 		newly allocated stack space since we can't save the pc directly. 	3. If this is the first call to throw in this function: 		generate a label for the throw block 	4. jump to the throw block label.  */
end_comment

begin_function
name|void
name|expand_throw
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
specifier|static
name|tree
name|cleanup_type
decl_stmt|;
if|if
condition|(
operator|!
name|doing_eh
argument_list|(
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
name|exp
condition|)
block|{
name|tree
name|throw_type
decl_stmt|;
name|tree
name|cleanup
init|=
name|NULL_TREE
decl_stmt|,
name|e
decl_stmt|;
comment|/* throw expression */
comment|/* First, decay it.  */
name|exp
operator|=
name|decay_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* cleanup_type is void (*)(void *, int), 	 the internal type of a destructor. */
if|if
condition|(
name|cleanup_type
operator|==
name|NULL_TREE
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup_type
operator|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|throw_type
operator|=
name|build_eh_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|object
decl_stmt|,
name|ptr
decl_stmt|;
comment|/* OK, this is kind of wacky.  The WP says that we call 	     terminate  	     when the exception handling mechanism, after completing 	     evaluation of the expression to be thrown but before the 	     exception is caught (_except.throw_), calls a user function 	     that exits via an uncaught exception.  	     So we have to protect the actual initialization of the 	     exception object with terminate(), but evaluate the expression 	     first.  We also expand the call to __eh_alloc 	     first.  Since there could be temps in the expression, we need 	     to handle that, too.  */
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Unfortunately, this doesn't work.  */
block|preexpand_calls (exp);
else|#
directive|else
comment|/* Store the throw expression into a temp.  This can be less 	     efficient than storing it into the allocated space directly, but 	     oh well.  To do this efficiently we would need to insinuate 	     ourselves into expand_call.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RTL
argument_list|(
name|temp
argument_list|)
operator|=
name|assign_temp
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|temp
argument_list|)
operator|=
name|exp
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|temp
argument_list|,
name|exp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|exp
operator|=
name|temp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Allocate the space for the exception.  */
name|ptr
operator|=
name|save_expr
argument_list|(
name|alloc_eh_object
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|ptr
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|object
operator|=
name|build_indirect_ref
argument_list|(
name|ptr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_modify_expr
argument_list|(
name|object
argument_list|,
name|INIT_EXPR
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"  in thrown expression"
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_eh_region_end
argument_list|(
name|build_terminate_handler
argument_list|()
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|throw_type
operator|=
name|build_eh_type
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
condition|)
block|{
name|cleanup
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|,
name|dtor_identifier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|TREE_VALUE
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|mark_addressable
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Pretend it's a normal function.  */
name|cleanup
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|cleanup_type
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|ptr
expr_stmt|;
block|}
comment|/* Cast EXP to `void *' so that it will match the prototype for 	 __cp_push_exception.  */
name|exp
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup
operator|==
name|NULL_TREE
condition|)
block|{
name|cleanup
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cleanup
argument_list|)
operator|=
name|cleanup_type
expr_stmt|;
block|}
name|fn
operator|=
name|get_identifier
argument_list|(
literal|"__cp_push_exception"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare __cp_push_exception (void*, void*, void (*)(void*, int)), 	     as defined in exception.cc.  */
name|tree
name|tmp
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup_type
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|e
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|throw_type
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|e
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* rethrow current exception; note that it's no longer caught.  */
name|tree
name|fn
init|=
name|get_identifier
argument_list|(
literal|"__uncatch_exception"
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Declare void __uncatch_exception (void) 	     as defined in exception.cc. */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|fn
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
name|expand_internal_throw
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a throw expression.  */
end_comment

begin_function
name|tree
name|build_throw
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|e
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|THROW_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|e
argument_list|)
return|;
if|if
condition|(
name|e
operator|==
name|null_node
condition|)
name|cp_warning
argument_list|(
literal|"throwing NULL, which has integral, not pointer type"
argument_list|)
expr_stmt|;
name|e
operator|=
name|build1
argument_list|(
name|THROW_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

end_unit

