begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform the semantic phase of parsing, i.e., the process of    building tree structure, checking semantic consistency, and    building RTL.  These routines are used both during actual parsing    and during the instantiation of template functions.      Copyright (C) 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005 Free Software Foundation, Inc.    Written by Mark Mitchell (mmitchell@usa.net) based on code found    formerly in parse.y and pt.c.       This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.        GCC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.        You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_comment
comment|/* There routines provide a modular interface to perform many parsing    operations.  They may therefore be used during actual parsing, or    during template instantiation, which may be regarded as a    degenerate form of parsing.  Since the current g++ parser is    lacking in several respects, and will be reimplemented, we are    attempting to move most code that is not directly related to    parsing into this file; that will make implementing the new parser    much easier since it will be able to make use of these routines.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|maybe_convert_cond
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|simplify_aggr_init_exprs_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_associated_thunks
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genrtl_try_block
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genrtl_eh_spec_block
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|genrtl_handler
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_expand_stmt
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Finish processing the COND, the SUBSTMT condition for STMT.  */
end_comment

begin_define
define|#
directive|define
name|FINISH_COND
parameter_list|(
name|COND
parameter_list|,
name|STMT
parameter_list|,
name|SUBSTMT
parameter_list|)
define|\
value|do {							\     if (last_tree != (STMT))				\       {							\         RECHAIN_STMTS (STMT, SUBSTMT);			\         if (!processing_template_decl)			\           {						\ 	    (COND) = build_tree_list (SUBSTMT, COND);	\ 	    (SUBSTMT) = (COND);				\           }						\       }							\     else						\       (SUBSTMT) = (COND);				\   } while (0)
end_define

begin_comment
comment|/* Deferred Access Checking Overview    ---------------------------------     Most C++ expressions and declarations require access checking    to be performed during parsing.  However, in several cases,    this has to be treated differently.     For member declarations, access checking has to be deferred    until more information about the declaration is known.  For    example:       class A {          typedef int X;        public:          X f();      };       A::X A::f();      A::X g();     When we are parsing the function return type `A::X', we don't    really know if this is allowed until we parse the function name.     Furthermore, some contexts require that access checking is    never performed at all.  These include class heads, and template    instantiations.     Typical use of access checking functions is described here:        1. When we enter a context that requires certain access checking       mode, the function `push_deferring_access_checks' is called with       DEFERRING argument specifying the desired mode.  Access checking       may be performed immediately (dk_no_deferred), deferred       (dk_deferred), or not performed (dk_no_check).     2. When a declaration such as a type, or a variable, is encountered,       the function `perform_or_defer_access_check' is called.  It       maintains a TREE_LIST of all deferred checks.     3. The global `current_class_type' or `current_function_decl' is then       setup by the parser.  `enforce_access' relies on these information       to check access.     4. Upon exiting the context mentioned in step 1,       `perform_deferred_access_checks' is called to check all declaration       stored in the TREE_LIST.   `pop_deferring_access_checks' is then       called to restore the previous access checking mode.        In case of parsing error, we simply call `pop_deferring_access_checks'       without `perform_deferred_access_checks'.  */
end_comment

begin_comment
comment|/* Data for deferred access checking.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|deferred_access
operator|*
name|deferred_access_stack
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|deferred_access
operator|*
name|deferred_access_free_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save the current deferred access states and start deferred    access checking iff DEFER_P is true.  */
end_comment

begin_function
name|void
name|push_deferring_access_checks
parameter_list|(
name|deferring_kind
name|deferring
parameter_list|)
block|{
name|deferred_access
modifier|*
name|d
decl_stmt|;
comment|/* For context like template instantiation, access checking      disabling applies to all nested context.  */
if|if
condition|(
name|deferred_access_stack
operator|&&
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_no_check
condition|)
name|deferring
operator|=
name|dk_no_check
expr_stmt|;
comment|/* Recycle previously used free store if available.  */
if|if
condition|(
name|deferred_access_free_list
condition|)
block|{
name|d
operator|=
name|deferred_access_free_list
expr_stmt|;
name|deferred_access_free_list
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
else|else
name|d
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|deferred_access
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|deferred_access_stack
expr_stmt|;
name|d
operator|->
name|deferred_access_checks
operator|=
name|NULL_TREE
expr_stmt|;
name|d
operator|->
name|deferring_access_checks_kind
operator|=
name|deferring
expr_stmt|;
name|deferred_access_stack
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume deferring access checks again after we stopped doing    this previously.  */
end_comment

begin_function
name|void
name|resume_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_no_deferred
condition|)
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|=
name|dk_deferred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring access checks.  */
end_comment

begin_function
name|void
name|stop_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_deferred
condition|)
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|=
name|dk_no_deferred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard the current deferred access checks and restore the    previous states.  */
end_comment

begin_function
name|void
name|pop_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
name|deferred_access
modifier|*
name|d
init|=
name|deferred_access_stack
decl_stmt|;
name|deferred_access_stack
operator|=
name|d
operator|->
name|next
expr_stmt|;
comment|/* Remove references to access checks TREE_LIST.  */
name|d
operator|->
name|deferred_access_checks
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Store in free list for later use.  */
name|d
operator|->
name|next
operator|=
name|deferred_access_free_list
expr_stmt|;
name|deferred_access_free_list
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a TREE_LIST representing the deferred checks.      The TREE_PURPOSE of each node is the type through which the     access occurred; the TREE_VALUE is the declaration named.    */
end_comment

begin_function
name|tree
name|get_deferred_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|deferred_access_stack
operator|->
name|deferred_access_checks
return|;
block|}
end_function

begin_comment
comment|/* Take current deferred checks and combine with the    previous states if we also defer checks previously.    Otherwise perform checks now.  */
end_comment

begin_function
name|void
name|pop_to_parent_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|deferred_check
init|=
name|get_deferred_access_checks
argument_list|()
decl_stmt|;
name|deferred_access
modifier|*
name|d1
init|=
name|deferred_access_stack
decl_stmt|;
name|deferred_access
modifier|*
name|d2
init|=
name|deferred_access_stack
operator|->
name|next
decl_stmt|;
name|deferred_access
modifier|*
name|d3
init|=
name|deferred_access_stack
operator|->
name|next
operator|->
name|next
decl_stmt|;
comment|/* Temporary swap the order of the top two states, just to make      sure the garbage collector will not reclaim the memory during       processing below.  */
name|deferred_access_stack
operator|=
name|d2
expr_stmt|;
name|d2
operator|->
name|next
operator|=
name|d1
expr_stmt|;
name|d1
operator|->
name|next
operator|=
name|d3
expr_stmt|;
for|for
control|(
init|;
name|deferred_check
condition|;
name|deferred_check
operator|=
name|TREE_CHAIN
argument_list|(
name|deferred_check
argument_list|)
control|)
comment|/* Perform deferred check if required.  */
name|perform_or_defer_access_check
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|deferred_check
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|deferred_check
argument_list|)
argument_list|)
expr_stmt|;
name|deferred_access_stack
operator|=
name|d1
expr_stmt|;
name|d1
operator|->
name|next
operator|=
name|d2
expr_stmt|;
name|d2
operator|->
name|next
operator|=
name|d3
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform the deferred access checks.     After performing the checks, we still have to keep the list    `deferred_access_stack->deferred_access_checks' since we may want    to check access for them again later in a different context.    For example:       class A {        typedef int X;        static X a;      };      A::X A::a, x;	// No error for `A::a', error for `x'     We have to perform deferred access of `A::X', first with `A::a',    next with `x'.  */
end_comment

begin_function
name|void
name|perform_deferred_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|deferred_check
decl_stmt|;
for|for
control|(
name|deferred_check
operator|=
name|deferred_access_stack
operator|->
name|deferred_access_checks
init|;
name|deferred_check
condition|;
name|deferred_check
operator|=
name|TREE_CHAIN
argument_list|(
name|deferred_check
argument_list|)
control|)
comment|/* Check access.  */
name|enforce_access
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|deferred_check
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|deferred_check
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Defer checking the accessibility of DECL, when looked up in    BINFO.  */
end_comment

begin_function
name|void
name|perform_or_defer_access_check
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|check
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|20030623
argument_list|)
expr_stmt|;
comment|/* If we are not supposed to defer access checks, just check now.  */
if|if
condition|(
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_no_deferred
condition|)
block|{
name|enforce_access
argument_list|(
name|binfo
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Exit if we are in a context that no access checking is performed.  */
elseif|else
if|if
condition|(
name|deferred_access_stack
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_no_check
condition|)
return|return;
comment|/* See if we are already going to perform this check.  */
for|for
control|(
name|check
operator|=
name|deferred_access_stack
operator|->
name|deferred_access_checks
init|;
name|check
condition|;
name|check
operator|=
name|TREE_CHAIN
argument_list|(
name|check
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|check
argument_list|)
operator|==
name|decl
operator|&&
name|TREE_PURPOSE
argument_list|(
name|check
argument_list|)
operator|==
name|binfo
condition|)
return|return;
comment|/* If not, record the check.  */
name|deferred_access_stack
operator|->
name|deferred_access_checks
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|decl
argument_list|,
name|deferred_access_stack
operator|->
name|deferred_access_checks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the current statement is a full expression,    i.e. temporaries created during that statement should be destroyed    at the end of the statement.  */
end_comment

begin_function
name|int
name|stmts_are_full_exprs_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
return|;
block|}
end_function

begin_comment
comment|/* Returns the stmt_tree (if any) to which statements are currently    being added.  If there is no active statement-tree, NULL is    returned.  */
end_comment

begin_function
name|stmt_tree
name|current_stmt_tree
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cfun
condition|?
operator|&
name|cfun
operator|->
name|language
operator|->
name|base
operator|.
name|x_stmt_tree
else|:
operator|&
name|scope_chain
operator|->
name|x_stmt_tree
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if TYPE is an anonymous union or struct type.  We have to use a    flag for this because "A union for which objects or pointers are    declared is not an anonymous union" [class.union].  */
end_comment

begin_function
name|int
name|anon_aggr_type_p
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
return|return
name|ANON_AGGR_TYPE_P
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a scope.  */
end_comment

begin_function
name|tree
name|do_poplevel
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
block|{
name|tree
name|scope_stmts
init|=
name|NULL_TREE
decl_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* This needs to come after the poplevel so that partial scopes 	     are properly nested.  */
name|scope_stmts
operator|=
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|0
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|scope_stmts
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_VALUE
argument_list|(
name|scope_stmts
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
block|}
block|}
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Begin a new scope.  */
end_comment

begin_function
name|void
name|do_pushlevel
parameter_list|(
name|scope_kind
name|sk
parameter_list|)
block|{
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
name|begin_scope
argument_list|(
name|sk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a goto-statement.  */
end_comment

begin_function
name|tree
name|finish_goto_stmt
parameter_list|(
name|tree
name|destination
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|destination
operator|=
name|lookup_label
argument_list|(
name|destination
argument_list|)
expr_stmt|;
comment|/* We warn about unused labels with -Wunused.  That means we have to      mark the used labels as used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|TREE_USED
argument_list|(
name|destination
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* The DESTINATION is being used as an rvalue.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|destination
operator|=
name|decay_conversion
argument_list|(
name|destination
argument_list|)
expr_stmt|;
comment|/* We don't inline calls to functions with computed gotos. 	 Those functions are typically up to some funny business, 	 and may be depending on the labels being at particular 	 addresses, or some such.  */
name|DECL_UNINLINABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|check_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|GOTO_STMT
argument_list|,
name|destination
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* COND is the condition-expression for an if, while, etc.,    statement.  Convert it to a boolean value, if appropriate.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_convert_cond
parameter_list|(
name|tree
name|cond
parameter_list|)
block|{
comment|/* Empty conditions remain empty.  */
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Wait until we instantiate templates before doing conversion.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|cond
return|;
comment|/* Do the conversion.  */
name|cond
operator|=
name|convert_from_reference
argument_list|(
name|cond
argument_list|)
expr_stmt|;
return|return
name|condition_conversion
argument_list|(
name|cond
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression-statement, whose EXPRESSION is as indicated.  */
end_comment

begin_function
name|tree
name|finish_expr_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expr
operator|=
name|convert_to_void
argument_list|(
name|expr
argument_list|,
literal|"statement"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
name|convert_to_void
argument_list|(
name|build_non_dependent_expr
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|"statement"
argument_list|)
expr_stmt|;
name|r
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin an if-statement.  Returns a newly created IF_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_if_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|IF_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_if_stmt_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|if_stmt
parameter_list|)
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|if_stmt
argument_list|,
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the then-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|tree
name|finish_then_clause
parameter_list|(
name|tree
name|if_stmt
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|if_stmt
return|;
block|}
end_function

begin_comment
comment|/* Begin the else-clause of an if-statement.  */
end_comment

begin_function
name|void
name|begin_else_clause
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Finish the else-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_else_clause
parameter_list|(
name|tree
name|if_stmt
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an if-statement.  */
end_comment

begin_function
name|void
name|finish_if_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|finish_stmt
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a while-statement.  Returns a newly created WHILE_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_while_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|WHILE_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of a while-statement, which may be given by    WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|while_stmt
parameter_list|)
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Don't mess with condition decls in a template.  */
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|while_stmt
argument_list|,
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getdecls
argument_list|()
operator|==
name|NULL_TREE
condition|)
comment|/* It was a simple condition; install it.  */
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
else|else
block|{
comment|/* If there was a declaration in the condition, we can't leave it 	 there; transform 	    while (A x = 42) { } 	 to 	    while (true) { A x = 42; if (!x) break; }  */
name|tree
name|if_stmt
decl_stmt|;
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
operator|=
name|boolean_true_node
expr_stmt|;
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|cond
operator|=
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|cond
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_break_stmt
argument_list|()
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a while-statement, which may be given by WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt
parameter_list|(
name|tree
name|while_stmt
parameter_list|)
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|while_stmt
argument_list|,
name|WHILE_BODY
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a do-statement.  Returns a newly created DO_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_do_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|DO_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the body of a do-statement, which may be given by DO_STMT.  */
end_comment

begin_function
name|void
name|finish_do_body
parameter_list|(
name|tree
name|do_stmt
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|do_stmt
argument_list|,
name|DO_BODY
argument_list|(
name|do_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a do-statement, which may be given by DO_STMT, and whose    COND is as indicated.  */
end_comment

begin_function
name|void
name|finish_do_stmt
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|do_stmt
parameter_list|)
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|DO_COND
argument_list|(
name|do_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a return-statement.  The EXPRESSION returned, if any, is as    indicated.  */
end_comment

begin_function
name|tree
name|finish_return_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|expr
operator|=
name|check_return_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Similarly, all destructors must run destructors for 	     base-classes before returning.  So, all returns in a 	     destructor get sent to the DTOR_LABEL; finish_function emits 	     code to return a value there.  */
return|return
name|finish_goto_stmt
argument_list|(
name|dtor_label
argument_list|)
return|;
block|}
block|}
name|r
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|RETURN_STMT
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|begin_for_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|FOR_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|NEW_FOR_SCOPE_P
argument_list|(
name|r
argument_list|)
operator|=
name|flag_new_for_scope
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|NEW_FOR_SCOPE_P
argument_list|(
name|r
argument_list|)
condition|)
name|do_pushlevel
argument_list|(
name|sk_for
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the for-init-statement of a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_init_stmt
parameter_list|(
name|tree
name|for_stmt
parameter_list|)
block|{
if|if
condition|(
name|last_tree
operator|!=
name|for_stmt
condition|)
name|RECHAIN_STMTS
argument_list|(
name|for_stmt
argument_list|,
name|FOR_INIT_STMT
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the COND of a for-statement, which may be given by    FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|for_stmt
parameter_list|)
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* Don't mess with condition decls in a template.  */
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|for_stmt
argument_list|,
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|getdecls
argument_list|()
operator|==
name|NULL_TREE
condition|)
comment|/* It was a simple condition; install it.  */
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
else|else
block|{
comment|/* If there was a declaration in the condition, we can't leave it 	 there; transform 	    for (; A x = 42;) { } 	 to 	    for (;;) { A x = 42; if (!x) break; }  */
name|tree
name|if_stmt
decl_stmt|;
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|cond
operator|=
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|cond
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_break_stmt
argument_list|()
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the increment-EXPRESSION in a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|for_stmt
parameter_list|)
block|{
comment|/* If EXPR is an overloaded function, issue an error; there is no      context available to use to perform overload resolution.  */
if|if
condition|(
name|expr
operator|&&
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_error
argument_list|(
name|expr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|FOR_EXPR
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a for-statement, which may be given by    FOR_STMT.  The increment-EXPR for the loop must be    provided.  */
end_comment

begin_function
name|void
name|finish_for_stmt
parameter_list|(
name|tree
name|for_stmt
parameter_list|)
block|{
comment|/* Pop the scope for the body of the loop.  */
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|for_stmt
argument_list|,
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEW_FOR_SCOPE_P
argument_list|(
name|for_stmt
argument_list|)
condition|)
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a break-statement.  */
end_comment

begin_function
name|tree
name|finish_break_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|add_stmt
argument_list|(
name|build_break_stmt
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a continue-statement.  */
end_comment

begin_function
name|tree
name|finish_continue_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|add_stmt
argument_list|(
name|build_continue_stmt
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a switch-statement.  Returns a new SWITCH_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_switch_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|SWITCH_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the cond of a switch-statement.  */
end_comment

begin_function
name|void
name|finish_switch_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|switch_stmt
parameter_list|)
block|{
name|tree
name|orig_type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|index
decl_stmt|;
comment|/* Convert the condition to an integer or enumeration type.  */
name|cond
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|cond
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|cond
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|orig_type
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* [stmt.switch]  	     Integral promotions are performed.  */
name|cond
operator|=
name|perform_integral_promotions
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|!=
name|error_mark_node
condition|)
block|{
name|index
operator|=
name|get_unwidened
argument_list|(
name|cond
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	     because if we did, int_fits_type_p would do the wrong thing 	     when checking case values for being in range, 	     and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|cond
operator|=
name|index
expr_stmt|;
block|}
block|}
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|switch_stmt
argument_list|,
name|SWITCH_COND
argument_list|(
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|SWITCH_TYPE
argument_list|(
name|switch_stmt
argument_list|)
operator|=
name|orig_type
expr_stmt|;
name|push_switch
argument_list|(
name|switch_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a switch-statement, which may be given by    SWITCH_STMT.  The COND to switch on is indicated.  */
end_comment

begin_function
name|void
name|finish_switch_stmt
parameter_list|(
name|tree
name|switch_stmt
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|switch_stmt
argument_list|,
name|SWITCH_BODY
argument_list|(
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pop_switch
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a TRY_BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|genrtl_try_block
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|CLEANUP_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_eh_region_end_cleanup
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|emit_line_note
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expand_start_all_catch
argument_list|()
expr_stmt|;
name|in_function_try_handler
operator|=
literal|1
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|in_function_try_handler
operator|=
literal|0
expr_stmt|;
name|expand_end_all_catch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|expand_start_all_catch
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_all_catch
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is an EH_SPEC_BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|genrtl_eh_spec_block
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|EH_SPEC_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_eh_region_end_allowed
argument_list|(
name|EH_SPEC_RAISES
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_call
argument_list|(
name|call_unexpected_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_exc_ptr
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a try-block.  Returns a newly-created TRY_BLOCK if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_try_block
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|TRY_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|tree
name|begin_function_try_block
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|TRY_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|FN_TRY_BLOCK_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a try-block, which may be given by TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_try_block
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a cleanup try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_cleanup_try_block
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an implicitly generated try-block, with a cleanup is given    by CLEANUP.  */
end_comment

begin_function
name|void
name|finish_cleanup
parameter_list|(
name|tree
name|cleanup
parameter_list|,
name|tree
name|try_block
parameter_list|)
block|{
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
operator|=
name|cleanup
expr_stmt|;
name|CLEANUP_P
argument_list|(
name|try_block
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|void
name|finish_function_try_block
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|try_block
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|try_block
argument_list|)
argument_list|)
operator|==
name|CTOR_INITIALIZER
condition|)
block|{
comment|/* Chain the compound statement after the CTOR_INITIALIZER.  */
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|try_block
argument_list|)
argument_list|)
operator|=
name|last_tree
expr_stmt|;
comment|/* And make the CTOR_INITIALIZER the body of the try-block.  */
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|in_function_try_handler
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler-sequence for a try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_handler_sequence
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|check_handlers
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|void
name|finish_function_handler_sequence
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|in_function_try_handler
operator|=
literal|0
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|check_handlers
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a HANDLER.  */
end_comment

begin_function
specifier|static
name|void
name|genrtl_handler
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_start_catch
argument_list|(
name|HANDLER_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_end_catch
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a handler.  Returns a HANDLER if appropriate.  */
end_comment

begin_function
name|tree
name|begin_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|HANDLER
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Create a binding level for the eh_info and the exception object      cleanup.  */
name|do_pushlevel
argument_list|(
name|sk_catch
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the handler-parameters for a handler, which may be given by    HANDLER.  DECL is the declaration for the catch parameter, or NULL    if this is a `catch (...)' clause.  */
end_comment

begin_function
name|void
name|finish_handler_parms
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|handler
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|push_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|handler
argument_list|,
name|HANDLER_PARMS
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|type
operator|=
name|expand_start_catch_block
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|HANDLER_TYPE
argument_list|(
name|handler
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|type
condition|)
name|mark_used
argument_list|(
name|eh_type_info
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler, which may be given by HANDLER.  The BLOCKs are    the return value from the matching call to finish_handler_parms.  */
end_comment

begin_function
name|void
name|finish_handler
parameter_list|(
name|tree
name|handler
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_end_catch_block
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|handler
argument_list|,
name|HANDLER_BODY
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a compound-statement.  If HAS_NO_SCOPE is true, the    compound-statement does not define a scope.  Returns a new    COMPOUND_STMT.  */
end_comment

begin_function
name|tree
name|begin_compound_stmt
parameter_list|(
name|bool
name|has_no_scope
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|int
name|is_try
init|=
literal|0
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_tree
operator|&&
name|TREE_CODE
argument_list|(
name|last_tree
argument_list|)
operator|==
name|TRY_BLOCK
condition|)
name|is_try
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_no_scope
condition|)
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|has_no_scope
condition|)
name|do_pushlevel
argument_list|(
name|is_try
condition|?
name|sk_try
else|:
name|sk_block
argument_list|)
expr_stmt|;
else|else
comment|/* Normally, we try hard to keep the BLOCK for a        statement-expression.  But, if it's a statement-expression with        a scopeless block, there's nothing to keep, and we don't want        to accidentally keep a block *inside* the scopeless block.  */
name|keep_next_level
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a compound-statement, which is given by COMPOUND_STMT.  */
end_comment

begin_function
name|tree
name|finish_compound_stmt
parameter_list|(
name|tree
name|compound_stmt
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|compound_stmt
argument_list|)
condition|)
name|r
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|r
operator|=
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|compound_stmt
argument_list|,
name|COMPOUND_BODY
argument_list|(
name|compound_stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When we call finish_stmt we will lose LAST_EXPR_TYPE.  But, since      the precise purpose of that variable is store the type of the      last expression statement within the last compound statement, we      preserve the value.  */
name|t
operator|=
name|last_expr_type
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
name|last_expr_type
operator|=
name|t
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish an asm-statement, whose components are a CV_QUALIFIER, a    STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some    CLOBBERS.  */
end_comment

begin_function
name|tree
name|finish_asm_stmt
parameter_list|(
name|tree
name|cv_qualifier
parameter_list|,
name|tree
name|string
parameter_list|,
name|tree
name|output_operands
parameter_list|,
name|tree
name|input_operands
parameter_list|,
name|tree
name|clobbers
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|cv_qualifier
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ninputs
decl_stmt|;
name|int
name|noutputs
decl_stmt|;
for|for
control|(
name|t
operator|=
name|input_operands
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|converted_operand
init|=
name|decay_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the type of the operand hasn't been determined (e.g., 	     because it involves an overloaded function), then issue 	     an error message.  There's no context available to 	     resolve the overloading.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|converted_operand
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
name|error
argument_list|(
literal|"type of asm operand `%E' could not be determined"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|converted_operand
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|converted_operand
expr_stmt|;
block|}
name|ninputs
operator|=
name|list_length
argument_list|(
name|input_operands
argument_list|)
expr_stmt|;
name|noutputs
operator|=
name|list_length
argument_list|(
name|output_operands
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t
operator|=
name|output_operands
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|bool
name|allows_mem
decl_stmt|;
name|bool
name|allows_reg
decl_stmt|;
name|bool
name|is_inout
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|tree
name|operand
decl_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operand
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
block|{
comment|/* By marking this operand as erroneous, we will not try 		 to process this operand again in expand_asm_operands.  */
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
comment|/* If the operand is a DECL that is going to end up in 	     memory, assume it is addressable.  This is a bit more 	     conservative than it would ideally be; the exact test is 	     buried deep in expand_asm_operands and depends on the 	     DECL_RTL for the OPERAND -- which we don't have at this 	     point.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|DECL_P
argument_list|(
name|operand
argument_list|)
condition|)
name|cxx_mark_addressable
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|=
name|build_stmt
argument_list|(
name|ASM_STMT
argument_list|,
name|cv_qualifier
argument_list|,
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a label with the indicated NAME.  */
end_comment

begin_function
name|tree
name|finish_label_stmt
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|define_label
argument_list|(
name|input_location
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_STMT
argument_list|,
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a series of declarations for local labels.  G++ allows users    to declare "local" labels, i.e., labels with scope.  This extension    is useful when writing code involving statement-expressions.  */
end_comment

begin_function
name|void
name|finish_label_decl
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|declare_local_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When DECL goes out of scope, make sure that CLEANUP is executed.  */
end_comment

begin_function
name|void
name|finish_decl_cleanup
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|cleanup
parameter_list|)
block|{
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|decl
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the current scope exits with an exception, run CLEANUP.  */
end_comment

begin_function
name|void
name|finish_eh_cleanup
parameter_list|(
name|tree
name|cleanup
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
decl_stmt|;
name|CLEANUP_EH_ONLY
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The MEM_INITS is a list of mem-initializers, in reverse of the    order they were written by the user.  Each node is as for    emit_mem_initializers.  */
end_comment

begin_function
name|void
name|finish_mem_initializers
parameter_list|(
name|tree
name|mem_inits
parameter_list|)
block|{
comment|/* Reorder the MEM_INITS so that they are in the order they appeared      in the source program.  */
name|mem_inits
operator|=
name|nreverse
argument_list|(
name|mem_inits
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|add_stmt
argument_list|(
name|build_min_nt
argument_list|(
name|CTOR_INITIALIZER
argument_list|,
name|mem_inits
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_mem_initializers
argument_list|(
name|mem_inits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the stack of SCOPE_STMTs for the current function.  */
end_comment

begin_function
name|tree
modifier|*
name|current_scope_stmt_stack
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|cfun
operator|->
name|language
operator|->
name|base
operator|.
name|x_scope_stmt_stack
return|;
block|}
end_function

begin_comment
comment|/* Finish a parenthesized expression EXPR.  */
end_comment

begin_function
name|tree
name|finish_parenthesized_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* This inhibits warnings in c_common_truthvalue_conversion.  */
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|,
name|ERROR_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
comment|/* [expr.unary.op]/3 The qualified id of a pointer-to-member must not be        enclosed in parentheses.  */
name|PTRMEM_OK_P
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Finish a reference to a non-static data member (DECL) that is not    preceded by `.' or `->'.  */
end_comment

begin_function
name|tree
name|finish_non_static_data_member
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|object
parameter_list|,
name|tree
name|qualifying_scope
parameter_list|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|20020909
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|cp_error_at
argument_list|(
literal|"invalid use of member `%D' in static member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error_at
argument_list|(
literal|"invalid use of non-static data member `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"from this location"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|qualifying_scope
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Set the cv qualifiers.  */
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_ref
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|quals
operator||=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
return|return
name|build_min
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|object
argument_list|,
name|decl
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|access_type
init|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|tree
name|lookup_context
init|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|lookup_context
argument_list|,
name|access_type
argument_list|)
condition|)
block|{
name|access_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|access_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|access_type
operator|&&
name|DECL_P
argument_list|(
name|access_type
argument_list|)
condition|)
name|access_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|access_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access_type
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"object missing in reference to `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"from this location"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If PROCESSING_TEMPLATE_DECL is nonzero here, then 	 QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF 	 for now.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|SCOPE_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|qualifying_scope
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|access_type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If the data member was named `C::M', convert `*this' to `C' 	 first.  */
if|if
condition|(
name|qualifying_scope
condition|)
block|{
name|tree
name|binfo
init|=
name|NULL_TREE
decl_stmt|;
name|object
operator|=
name|build_scoped_ref
argument_list|(
name|object
argument_list|,
name|qualifying_scope
argument_list|,
operator|&
name|binfo
argument_list|)
expr_stmt|;
block|}
return|return
name|build_class_member_access_expr
argument_list|(
name|object
argument_list|,
name|decl
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* DECL was the declaration to which a qualified-id resolved.  Issue    an error message if it is not accessible.  If OBJECT_TYPE is    non-NULL, we have just seen `x->' or `x.' and OBJECT_TYPE is the    type of `*x', or `x', respectively.  If the DECL was named as    `A::B' then NESTED_NAME_SPECIFIER is `A'.  */
end_comment

begin_function
name|void
name|check_accessibility_of_qualified_id
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|object_type
parameter_list|,
name|tree
name|nested_name_specifier
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|qualifying_type
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Determine the SCOPE of DECL.  */
name|scope
operator|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the SCOPE is not a type, then DECL is not a member.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
return|return;
comment|/* Compute the scope through which DECL is being accessed.  */
if|if
condition|(
name|object_type
comment|/* OBJECT_TYPE might not be a class type; consider:  	   class A { typedef int I; }; 	   I *p; 	   p->A::I::~I();           In this case, we will have "A::I" as the DECL, but "I" as the 	 OBJECT_TYPE.  */
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|scope
argument_list|,
name|object_type
argument_list|)
condition|)
comment|/* If we are processing a `->' or `.' expression, use the type of the        left-hand side.  */
name|qualifying_type
operator|=
name|object_type
expr_stmt|;
elseif|else
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
comment|/* If the reference is to a non-static member of the 	 current class, treat it as if it were referenced through 	 `this'.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|current_class_ptr
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|scope
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|qualifying_type
operator|=
name|current_class_type
expr_stmt|;
comment|/* Otherwise, use the type indicated by the 	 nested-name-specifier.  */
else|else
name|qualifying_type
operator|=
name|nested_name_specifier
expr_stmt|;
block|}
else|else
comment|/* Otherwise, the name must be from the current class or one of        its bases.  */
name|qualifying_type
operator|=
name|currently_open_derived_class
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifying_type
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|qualifying_type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXPR is the result of a qualified-id.  The QUALIFYING_CLASS was the    class named to the left of the "::" operator.  DONE is true if this    expression is a complete postfix-expression; it is false if this    expression is followed by '->', '[', '(', etc.  ADDRESS_P is true    iff this expression is the operand of '&'.  */
end_comment

begin_function
name|tree
name|finish_qualified_id_expr
parameter_list|(
name|tree
name|qualifying_class
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|done
parameter_list|,
name|bool
name|address_p
parameter_list|)
block|{
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If EXPR occurs as the operand of '&', use special handling that      permits a pointer-to-member.  */
if|if
condition|(
name|address_p
operator|&&
name|done
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_offset_ref
argument_list|(
name|qualifying_class
argument_list|,
name|expr
argument_list|,
comment|/*address_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|expr
operator|=
name|finish_non_static_data_member
argument_list|(
name|expr
argument_list|,
name|current_class_ref
argument_list|,
name|qualifying_class
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|expr
argument_list|)
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|fns
decl_stmt|;
comment|/* See if any of the functions are non-static members.  */
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If so, the expression may be relative to the current 	 class.  */
if|if
condition|(
operator|!
name|shared_member_p
argument_list|(
name|fns
argument_list|)
operator|&&
name|current_class_type
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|qualifying_class
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|expr
operator|=
operator|(
name|build_class_member_access_expr
argument_list|(
name|maybe_dummy_object
argument_list|(
name|qualifying_class
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|expr
argument_list|,
name|BASELINK_ACCESS_BINFO
argument_list|(
name|expr
argument_list|)
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|done
condition|)
comment|/* The expression is a qualified name whose address is not 	   being taken.  */
name|expr
operator|=
name|build_offset_ref
argument_list|(
name|qualifying_class
argument_list|,
name|expr
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Begin a statement-expression.  The value returned must be passed to    finish_stmt_expr.  */
end_comment

begin_function
name|tree
name|begin_stmt_expr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If we're outside a function, we won't have a statement-tree to      work with.  But, if we see a statement-expression we need to      create one.  */
if|if
condition|(
operator|!
name|cfun
operator|&&
operator|!
name|last_tree
condition|)
name|begin_stmt_tree
argument_list|(
operator|&
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
name|keep_next_level
argument_list|(
name|true
argument_list|)
expr_stmt|;
return|return
name|last_tree
return|;
block|}
end_function

begin_comment
comment|/* Process the final expression of a statement expression. EXPR can be    NULL, if the final expression is empty.  Build up a TARGET_EXPR so    that the result value can be safely returned to the enclosing    expression.  */
end_comment

begin_function
name|tree
name|finish_stmt_expr_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|void_type_node
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|expr
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|require_complete_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Build a TARGET_EXPR for this aggregate.  finish_stmt_expr 	     will then pull it apart so the lifetime of the target is 	     within the scope of the expression containing this statement 	     expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
name|expr
operator|=
name|build_target_expr_with_type
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Copy construct.  */
name|expr
operator|=
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|TARGET_EXPR
argument_list|,
literal|20030729
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
block|{
name|result
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
comment|/* Remember the last expression so that finish_stmt_expr can pull it      apart.  */
name|last_expr_type
operator|=
name|result
condition|?
name|result
else|:
name|void_type_node
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a statement-expression.  EXPR should be the value returned    by the previous begin_stmt_expr.  Returns an expression    representing the statement-expression.  */
end_comment

begin_function
name|tree
name|finish_stmt_expr
parameter_list|(
name|tree
name|rtl_expr
parameter_list|,
name|bool
name|has_no_scope
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|result_stmt
init|=
name|last_expr_type
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|last_expr_type
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|result_stmt
operator|==
name|void_type_node
condition|)
block|{
name|type
operator|=
name|void_type_node
expr_stmt|;
name|result_stmt
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|result_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_min
argument_list|(
name|STMT_EXPR
argument_list|,
name|type
argument_list|,
name|last_tree
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|STMT_EXPR_NO_SCOPE
argument_list|(
name|result
argument_list|)
operator|=
name|has_no_scope
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Remove the compound statement from the tree structure; it is      now saved in the STMT_EXPR.  */
name|last_tree
operator|=
name|rtl_expr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If we created a statement-tree for this statement-expression,      remove it now.  */
if|if
condition|(
operator|!
name|cfun
operator|&&
name|TREE_CHAIN
argument_list|(
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|finish_stmt_tree
argument_list|(
operator|&
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Pull out the TARGET_EXPR that is the final expression. Put 	 the target's init_expr as the final expression and then put 	 the statement expression itself as the target's init 	 expr. Finally, return the target expression.  */
name|tree
name|last_expr
init|=
name|EXPR_STMT_EXPR
argument_list|(
name|result_stmt
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|last_expr
argument_list|)
operator|==
name|TARGET_EXPR
argument_list|,
literal|20030729
argument_list|)
expr_stmt|;
name|EXPR_STMT_EXPR
argument_list|(
name|result_stmt
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|last_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|last_expr
argument_list|,
literal|1
argument_list|)
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|last_expr
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Perform Koenig lookup.  FN is the postfix-expression representing    the function (or functions) to call; ARGS are the arguments to the    call.  Returns the functions to be considered by overload    resolution.  */
end_comment

begin_function
name|tree
name|perform_koenig_lookup
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|tree
name|identifier
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|functions
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Find the name of the overloaded function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|identifier
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|functions
operator|=
name|fn
expr_stmt|;
name|identifier
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|functions
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|functions
operator|=
name|fn
expr_stmt|;
name|identifier
operator|=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* A call to a namespace-scope function using an unqualified name.       Do Koenig lookup -- unless any of the arguments are      type-dependent.  */
if|if
condition|(
operator|!
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|fn
operator|=
name|lookup_arg_dependent
argument_list|(
name|identifier
argument_list|,
name|functions
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
comment|/* The unqualified name could not be resolved.  */
name|fn
operator|=
name|unqualified_fn_lookup_error
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
else|else
name|fn
operator|=
name|identifier
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Generate an expression for `FN (ARGS)'.     If DISALLOW_VIRTUAL is true, the call to FN will be not generated    as a virtual call, even if FN is virtual.  (This flag is set when    encountering an expression where the function name is explicitly    qualified.  For example a call to `X::f' never generates a virtual    call.)     Returns code for the call.  */
end_comment

begin_function
name|tree
name|finish_call_expr
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|,
name|bool
name|disallow_virtual
parameter_list|,
name|bool
name|koenig_p
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|orig_fn
decl_stmt|;
name|tree
name|orig_args
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
operator|||
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* ARGS should be a list of arguments.  */
name|my_friendly_assert
argument_list|(
operator|!
name|args
operator|||
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|20020712
argument_list|)
expr_stmt|;
name|orig_fn
operator|=
name|fn
expr_stmt|;
name|orig_args
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
operator|||
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|KOENIG_LOOKUP_P
argument_list|(
name|result
argument_list|)
operator|=
name|koenig_p
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|PSEUDO_DTOR_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|!=
name|unknown_type_node
condition|)
name|fn
operator|=
name|build_non_dependent_expr
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_non_dependent_args
argument_list|(
name|orig_args
argument_list|)
expr_stmt|;
block|}
comment|/* A reference to a member function will appear as an overloaded      function (rather than a BASELINK) if an unqualified name was used      to refer to it.  */
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|f
init|=
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|f
operator|=
name|TREE_OPERAND
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|f
operator|=
name|get_first_fn
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|currently_open_derived_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_baselink
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|,
comment|/*optype=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|object
decl_stmt|;
comment|/* A call to a member function.  From [over.call.func]:  	   If the keyword this is in scope and refers to the class of 	   that member function, or a derived class thereof, then the 	   function call is transformed into a qualified function call 	   using (*this) as the postfix-expression to the left of the 	   . operator.... [Otherwise] a contrived object of type T 	   becomes the implied object argument.            This paragraph is unclear about this situation:  	  struct A { void f(); }; 	  struct B : public A {}; 	  struct C : public A { void g() { B::f(); }};  	In particular, for `B::f', this paragraph does not make clear 	whether "the class of that member function" refers to `A' or  	to `B'.  We believe it refers to `B'.  */
if|if
condition|(
name|current_class_type
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BASELINK_ACCESS_BINFO
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|&&
name|current_class_ref
condition|)
name|object
operator|=
name|maybe_dummy_object
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BASELINK_ACCESS_BINFO
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|representative_fn
decl_stmt|;
name|representative_fn
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|representative_fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|representative_fn
operator|=
name|TREE_OPERAND
argument_list|(
name|representative_fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|representative_fn
operator|=
name|get_first_fn
argument_list|(
name|representative_fn
argument_list|)
expr_stmt|;
name|object
operator|=
name|build_dummy_object
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|representative_fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|object
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|orig_fn
argument_list|,
name|orig_args
argument_list|)
return|;
name|object
operator|=
name|build_non_dependent_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_new_method_call
argument_list|(
name|object
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|disallow_virtual
condition|?
name|LOOKUP_NONVIRTUAL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* A call to a namespace-scope function.  */
name|result
operator|=
name|build_new_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|PSEUDO_DTOR_EXPR
condition|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"arguments to destructor are not allowed"
argument_list|)
expr_stmt|;
comment|/* Mark the pseudo-destructor call as having side-effects so 	 that we do not issue warnings about its use.  */
name|result
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
comment|/* If the "function" is really an object of class type, it might        have an overloaded `operator ()'.  */
name|result
operator|=
name|build_new_op
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
comment|/* A call where the function is unknown.  */
name|result
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|orig_fn
argument_list|,
name|orig_args
argument_list|)
expr_stmt|;
name|KOENIG_LOOKUP_P
argument_list|(
name|result
argument_list|)
operator|=
name|koenig_p
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to a postfix increment or decrement or EXPR.  (Which    is indicated by CODE, which should be POSTINCREMENT_EXPR or    POSTDECREMENT_EXPR.)  */
end_comment

begin_function
name|tree
name|finish_increment_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
return|return
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a use of `this'.  Returns an expression for `this'.  */
end_comment

begin_function
name|tree
name|finish_this_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|current_class_ptr
condition|)
block|{
name|result
operator|=
name|current_class_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`this' is unavailable for static member functions"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current_function_decl
condition|)
name|error
argument_list|(
literal|"invalid use of `this' in non-member function"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of `this' at top level"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a pseudo-destructor expression.  If SCOPE is NULL, the    expression was of the form `OBJECT.~DESTRUCTOR' where DESTRUCTOR is    the TYPE for the type given.  If SCOPE is non-NULL, the expression    was of the form `OBJECT.SCOPE::~DESTRUCTOR'.  */
end_comment

begin_function
name|tree
name|finish_pseudo_destructor_expr
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|destructor
parameter_list|)
block|{
if|if
condition|(
name|destructor
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
name|TYPE_P
argument_list|(
name|destructor
argument_list|)
argument_list|,
literal|20010905
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"invalid qualifying scope in pseudo-destructor name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [expr.pseudo] says both:             The type designated by the pseudo-destructor-name shall be 	   the same as the object type.           and:             The cv-unqualified versions of the object type and of the 	   type designated by the pseudo-destructor-name shall be the 	   same type.           We implement the more generous second sentence, since that is          what most other compilers do.  */
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|,
name|destructor
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%E' is not of type `%T'"
argument_list|,
name|object
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|build
argument_list|(
name|PSEUDO_DTOR_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|object
argument_list|,
name|scope
argument_list|,
name|destructor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression of the form CODE EXPR.  */
end_comment

begin_function
name|tree
name|finish_unary_op_expr
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|result
init|=
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
decl_stmt|;
comment|/* Inside a template, build_x_unary_op does not fold the      expression. So check whether the result is folded before      setting TREE_NEGATED_INT.  */
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|&&
name|INT_CST_LT
argument_list|(
name|result
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|TREE_NEGATED_INT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a compound-literal expression.  TYPE is the type to which    the INITIALIZER_LIST is being cast.  */
end_comment

begin_function
name|tree
name|finish_compound_literal
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|initializer_list
parameter_list|)
block|{
name|tree
name|compound_literal
decl_stmt|;
comment|/* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */
name|compound_literal
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|initializer_list
argument_list|)
expr_stmt|;
comment|/* Mark it as a compound-literal.  */
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|compound_literal
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|TREE_TYPE
argument_list|(
name|compound_literal
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
block|{
comment|/* Check the initialization.  */
name|compound_literal
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|compound_literal
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the TYPE was an array type with an unknown bound, then we can 	 figure out the dimension now.  For example, something like:  	   `(int []) { 2, 3 }'  	 implies that the array has two elements.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|compound_literal
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|compound_literal
return|;
block|}
end_function

begin_comment
comment|/* Return the declaration for the function-name variable indicated by    ID.  */
end_comment

begin_function
name|tree
name|finish_fname
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|fname_decl
argument_list|(
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|decl
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Begin a function definition declared with DECL_SPECS, ATTRIBUTES,    and DECLARATOR.  Returns nonzero if the function-declaration is    valid.  */
end_comment

begin_function
name|int
name|begin_function_definition
parameter_list|(
name|tree
name|decl_specs
parameter_list|,
name|tree
name|attributes
parameter_list|,
name|tree
name|declarator
parameter_list|)
block|{
if|if
condition|(
operator|!
name|start_function
argument_list|(
name|decl_specs
argument_list|,
name|declarator
argument_list|,
name|attributes
argument_list|,
name|SF_DEFAULT
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The things we're about to see are not directly qualified by any      template headers we've seen thus far.  */
name|reset_specialization
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Finish a translation unit.  */
end_comment

begin_function
name|void
name|finish_translation_unit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* In case there were missing closebraces,      get us back to the global binding level.  */
name|pop_everything
argument_list|()
expr_stmt|;
while|while
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Do file scope __FUNCTION__ et al.  */
name|finish_fname_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a template type parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_type_parm
parameter_list|(
name|tree
name|aggr
parameter_list|,
name|tree
name|identifier
parameter_list|)
block|{
if|if
condition|(
name|aggr
operator|!=
name|class_type_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"template type parameters must use the keyword `class' or `typename'"
argument_list|)
expr_stmt|;
name|aggr
operator|=
name|class_type_node
expr_stmt|;
block|}
return|return
name|build_tree_list
argument_list|(
name|aggr
argument_list|,
name|identifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a template template parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_template_parm
parameter_list|(
name|tree
name|aggr
parameter_list|,
name|tree
name|identifier
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|current_template_parms
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|end_template_decl
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
literal|20010110
argument_list|)
expr_stmt|;
return|return
name|finish_template_type_parm
argument_list|(
name|aggr
argument_list|,
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGUMENT is the default-argument value for a template template    parameter.  If ARGUMENT is invalid, issue error messages and return    the ERROR_MARK_NODE.  Otherwise, ARGUMENT itself is returned.  */
end_comment

begin_function
name|tree
name|check_template_template_default_arg
parameter_list|(
name|tree
name|argument
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|UNBOUND_CLASS_TEMPLATE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|argument
argument_list|)
decl_stmt|;
comment|/* Try to emit a slightly smarter error message if we detect 	     that the user is using a template instantiation.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of type `%T' as a default value for a "
literal|"template template-parameter"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of `%D' as a default value for a template "
literal|"template-parameter"
argument_list|,
name|argument
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid default argument for a template template parameter"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|argument
return|;
block|}
end_function

begin_comment
comment|/* Finish a parameter list, indicated by PARMS.  If ELLIPSIS is    nonzero, the parameter list was terminated by a `...'.  */
end_comment

begin_function
name|tree
name|finish_parmlist
parameter_list|(
name|tree
name|parms
parameter_list|,
name|int
name|ellipsis
parameter_list|)
block|{
if|if
condition|(
name|parms
condition|)
block|{
comment|/* We mark the PARMS as a parmlist so that declarator processing can          disambiguate certain constructs.  */
name|TREE_PARMLIST
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We do not append void_list_node here, but leave it to grokparms          to do that.  */
name|PARMLIST_ELLIPSIS_P
argument_list|(
name|parms
argument_list|)
operator|=
name|ellipsis
expr_stmt|;
block|}
return|return
name|parms
return|;
block|}
end_function

begin_comment
comment|/* Begin a class definition, as indicated by T.  */
end_comment

begin_function
name|tree
name|begin_class_definition
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_parmlist
condition|)
block|{
name|error
argument_list|(
literal|"definition of `%#T' inside template parameter list"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* A non-implicit typename comes from code like:         template<typename T> struct A {          template<typename U> struct A<T>::B ...       This is erroneous.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid definition of qualified type `%T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|make_anon_name
argument_list|()
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this type was already complete, and we see another definition,      that's an error.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previous definition of `%#T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Update the location of the decl.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|input_location
expr_stmt|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_pack_struct
condition|)
block|{
name|tree
name|v
decl_stmt|;
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even though the type is being defined for the first time 	 here, there might have been a forward declaration, so there 	 might be cv-qualified variants of T.  */
for|for
control|(
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
name|TYPE_PACKED
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Reset the interface data, at the earliest possible      moment, as it might have been set via a class foo;      before.  */
if|if
condition|(
operator|!
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
block|}
name|reset_specialization
argument_list|()
expr_stmt|;
comment|/* Make a declaration for this class in its own scope.  */
name|build_self_reference
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Finish the member declaration given by DECL.  */
end_comment

begin_function
name|void
name|finish_member_declaration
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
comment|/* The COMPONENT was a friend, not a member, and so there's        nothing for us to do.  */
return|return;
comment|/* We should see only one DECL at a time.  */
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up access control for DECL.  */
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_private_node
operator|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_protected_node
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|TREE_PRIVATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the DECL as a member of the current class.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* [dcl.link]       A C language linkage is ignored for the names of class members      and the member function type of class member functions.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|decl
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
comment|/* Put functions on the TYPE_METHODS list and everything else on the      TYPE_FIELDS list.  Note that these are built up in reverse order.      We reverse them (to obtain declaration order) in finish_struct.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We also need to add this function to the 	 CLASSTYPE_METHOD_VEC.  */
name|add_method
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enter the DECL into the scope of the class.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields 	 go at the beginning.  The reason is that lookup_field_1 	 searches the list in order, and we want a field name to 	 override a type name so that the "struct stat hack" will 	 work.  In particular:  	   struct S { enum E { }; int E } s; 	   s.E = 3;  	 is valid.  In addition, the FIELD_DECLs must be maintained in 	 declaration order so that class layout works as expected. 	 However, we don't need that order until class layout, so we 	 save a little time by putting FIELD_DECLs on in reverse order 	 here, and then reversing them in finish_struct_1.  (We could 	 also keep a pointer to the correct insertion points in the 	 list.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish processing the declaration of a member class template    TYPES whose template parameters are given by PARMS.  */
end_comment

begin_function
name|tree
name|finish_member_class_template
parameter_list|(
name|tree
name|types
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* If there are declared, but undefined, partial specializations      mixed in with the typespecs they will not yet have passed through      maybe_process_partial_specialization, so we do that here.  */
for|for
control|(
name|t
operator|=
name|types
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
name|maybe_process_partial_specialization
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|grok_x_components
argument_list|(
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
comment|/* The component was in fact a friend declaration.  We avoid        finish_member_template_decl performing certain checks by        unsetting TYPES.  */
name|types
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_member_template_decl
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* As with other component type declarations, we do      not store the new DECL on the list of      component_decls.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Finish processing a complete template declaration.  The PARMS are    the template parameters.  */
end_comment

begin_function
name|void
name|finish_template_decl
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
if|if
condition|(
name|parms
condition|)
name|end_template_decl
argument_list|()
expr_stmt|;
else|else
name|end_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing a template-id (which names a type) of the form    NAME< ARGS>.  Return the TYPE_DECL for the type named by the    template-id.  If ENTERING_SCOPE is nonzero we are about to enter    the scope of template-id indicated.  */
end_comment

begin_function
name|tree
name|finish_template_type
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|entering_scope
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|lookup_template_class
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|entering_scope
argument_list|,
name|tf_error
operator||
name|tf_warning
operator||
name|tf_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Finish processing a BASE_CLASS with the indicated ACCESS_SPECIFIER.    Return a TREE_LIST containing the ACCESS_SPECIFIER and the    BASE_CLASS, or NULL_TREE if an error occurred.  The    ACCESS_SPECIFIER is one of    access_{default,public,protected_private}[_virtual]_node.*/
end_comment

begin_function
name|tree
name|finish_base_specifier
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|access
parameter_list|,
name|bool
name|virtual_p
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"invalid base-class specification"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cp_type_quals
argument_list|(
name|base
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"base class `%T' has cv qualifiers"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_tree_list
argument_list|(
name|access
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|TREE_VIA_VIRTUAL
argument_list|(
name|result
argument_list|)
operator|=
name|virtual_p
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Called when multiple declarators are processed.  If that is not    permitted in this context, an error is issued.  */
end_comment

begin_function
name|void
name|check_multiple_declarators
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* [temp]            In a template-declaration, explicit specialization, or explicit      instantiation the init-declarator-list in the declaration shall      contain at most one declarator.         We don't just use PROCESSING_TEMPLATE_DECL for the first      condition since that would disallow the perfectly valid code,       like `template<class T> struct S { int i, j; };'.  */
if|if
condition|(
name|at_function_scope_p
argument_list|()
condition|)
comment|/* It's OK to write `template<class T> void f() { int i, j;}'.  */
return|return;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
operator|||
name|processing_explicit_instantiation
operator|||
name|processing_specialization
condition|)
name|error
argument_list|(
literal|"multiple declarators in template declaration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue a diagnostic that NAME cannot be found in SCOPE.  */
end_comment

begin_function
name|void
name|qualified_name_lookup_error
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"incomplete type `%T' used in nested name specifier"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%D' is not a member of `%T'"
argument_list|,
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|!=
name|global_namespace
condition|)
name|error
argument_list|(
literal|"`%D' is not a member of `%D'"
argument_list|,
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`::%D' has not been declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ID_EXPRESSION is a representation of parsed, but unprocessed,    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,    if non-NULL, is the type or namespace used to explicitly qualify    ID_EXPRESSION.  DECL is the entity to which that name has been    resolved.       *CONSTANT_EXPRESSION_P is true if we are presently parsing a    constant-expression.  In that case, *NON_CONSTANT_EXPRESSION_P will    be set to true if this expression isn't permitted in a    constant-expression, but it is otherwise not set by this function.    *ALLOW_NON_CONSTANT_EXPRESSION_P is true if we are parsing a    constant-expression, but a non-constant expression is also    permissible.     If an error occurs, and it is the kind of error that might cause    the parser to abort a tentative parse, *ERROR_MSG is filled in.  It    is the caller's responsibility to issue the message.  *ERROR_MSG    will be a string with static storage duration, so the caller need    not "free" it.     Return an expression for the entity, after issuing appropriate    diagnostics.  This function is also responsible for transforming a    reference to a non-static member into a COMPONENT_REF that makes    the use of "this" explicit.       Upon return, *IDK will be filled in appropriately.  */
end_comment

begin_function
name|tree
name|finish_id_expression
parameter_list|(
name|tree
name|id_expression
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|cp_id_kind
modifier|*
name|idk
parameter_list|,
name|tree
modifier|*
name|qualifying_class
parameter_list|,
name|bool
name|integral_constant_expression_p
parameter_list|,
name|bool
name|allow_non_integral_constant_expression_p
parameter_list|,
name|bool
modifier|*
name|non_integral_constant_expression_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error_msg
parameter_list|)
block|{
comment|/* Initialize the output parameters.  */
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
operator|*
name|error_msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|id_expression
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If we have a template-id, then no further lookup is      required.  If the template-id was for a template-class, we      will sometimes have a TYPE_DECL at this point.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
empty_stmt|;
comment|/* Look up the name.  */
else|else
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Name lookup failed.  */
if|if
condition|(
name|scope
operator|&&
operator|(
operator|!
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|||
operator|(
operator|!
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|id_expression
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|id_expression
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* If the qualifying type is non-dependent (and the name 		 does not name a conversion operator to a dependent 		 type), issue an error.  */
name|qualified_name_lookup_error
argument_list|(
name|scope
argument_list|,
name|id_expression
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scope
condition|)
block|{
comment|/* It may be resolved via Koenig lookup.  */
operator|*
name|idk
operator|=
name|CP_ID_KIND_UNQUALIFIED
expr_stmt|;
return|return
name|id_expression
return|;
block|}
else|else
name|decl
operator|=
name|id_expression
expr_stmt|;
block|}
comment|/* If DECL is a variable that would be out of scope under 	 ANSI/ISO rules, but in scope in the ARM, name lookup 	 will succeed.  Issue a diagnostic here.  */
else|else
name|decl
operator|=
name|check_for_out_of_scope_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Remember that the name was used in the definition of 	 the current class so that we can check later to see if 	 the meaning would have been different after the class 	 was entirely defined.  */
if|if
condition|(
operator|!
name|scope
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|id_expression
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If we didn't find anything, or what we found was a type,      then this wasn't really an id-expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|*
name|error_msg
operator|=
literal|"missing template arguments"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
operator|*
name|error_msg
operator|=
literal|"expected primary-expression"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the name resolved to a template parameter, there is no      need to look it up again later.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
name|decl
operator|=
name|TEMPLATE_PARM_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|integral_constant_expression_p
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allow_non_integral_constant_expression_p
condition|)
name|error
argument_list|(
literal|"template parameter `%D' of type `%T' is not allowed in "
literal|"an integral constant expression because it is not of "
literal|"integral or enumeration type"
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
block|}
comment|/* Similarly, we resolve enumeration constants to their       underlying values.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
else|else
block|{
name|bool
name|dependent_p
decl_stmt|;
comment|/* If the declaration was explicitly qualified indicate 	 that.  The semantics of `A::f(3)' are different than 	 `f(3)' if `f' is virtual.  */
operator|*
name|idk
operator|=
operator|(
name|scope
condition|?
name|CP_ID_KIND_QUALIFIED
else|:
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|?
name|CP_ID_KIND_TEMPLATE_ID
else|:
name|CP_ID_KIND_UNQUALIFIED
operator|)
operator|)
expr_stmt|;
comment|/* [temp.dep.expr]  	 An id-expression is type-dependent if it contains an 	 identifier that was declared with a dependent type.  	 The standard is not very specific about an id-expression that 	 names a set of overloaded functions.  What if some of them 	 have dependent types and some of them do not?  Presumably, 	 such a name should be treated as a dependent name.  */
comment|/* Assume the name is not dependent.  */
name|dependent_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
comment|/* No names are dependent outside a template.  */
empty_stmt|;
comment|/* A template-id where the name of the template was not resolved 	 is definitely dependent.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
name|dependent_p
operator|=
name|true
expr_stmt|;
comment|/* For anything except an overloaded function, just check its 	 type.  */
elseif|else
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a set of overloaded functions, check each of the 	 functions.  */
else|else
block|{
name|tree
name|fns
init|=
name|decl
decl_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* For a template-id, check to see if the template 	     arguments are dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|dependent_p
operator|=
name|any_dependent_template_arguments_p
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* The functions are those referred to by the 		 template-id.  */
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no dependent template arguments, go through 	     the overloaded functions.  */
while|while
condition|(
name|fns
operator|&&
operator|!
name|dependent_p
condition|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
comment|/* Member functions of dependent classes are 		 dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
condition|)
name|dependent_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|dependent_template_p
argument_list|(
name|fn
argument_list|)
condition|)
name|dependent_p
operator|=
name|true
expr_stmt|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the name was dependent on a template parameter, we will 	 resolve the name at instantiation time.  */
if|if
condition|(
name|dependent_p
condition|)
block|{
comment|/* Create a SCOPE_REF for qualified names, if the scope is 	     dependent.  */
if|if
condition|(
name|scope
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
operator|*
name|qualifying_class
operator|=
name|scope
expr_stmt|;
comment|/* Since this name was dependent, the expression isn't 		 constant -- yet.  No error is issued because it might 		 be constant when things are instantiated.  */
if|if
condition|(
name|integral_constant_expression_p
condition|)
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|scope
argument_list|,
name|id_expression
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|SCOPE_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|scope
argument_list|,
name|id_expression
argument_list|)
return|;
else|else
return|return
name|decl
return|;
block|}
comment|/* A TEMPLATE_ID already contains all the information we 	     need.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
return|return
name|id_expression
return|;
comment|/* Since this name was dependent, the expression isn't 	     constant -- yet.  No error is issued because it might be 	     constant when things are instantiated.  */
if|if
condition|(
name|integral_constant_expression_p
condition|)
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
operator|*
name|idk
operator|=
name|CP_ID_KIND_UNQUALIFIED_DEPENDENT
expr_stmt|;
comment|/* If we found a variable, then name lookup during the 	     instantiation will always resolve to the same VAR_DECL 	     (or an instantiation thereof).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
return|return
name|decl
return|;
comment|/* The same is true for FIELD_DECL, but we also need to 	     make sure that the syntax is correct.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Since SCOPE is NULL here, this is an unqualified name. 		 Access checking has been performed during name lookup 		 already.  Turn off checking to avoid duplicate errors.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|decl
operator|=
name|finish_non_static_data_member
argument_list|(
name|decl
argument_list|,
name|current_class_ref
argument_list|,
comment|/*qualifying_scope=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
return|return
name|id_expression
return|;
block|}
comment|/* Only certain kinds of names are allowed in constant        expression.  Enumerators and template parameters         have already been handled above.  */
if|if
condition|(
name|integral_constant_expression_p
operator|&&
operator|!
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allow_non_integral_constant_expression_p
condition|)
block|{
name|error
argument_list|(
literal|"`%D' cannot appear in a constant-expression"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"use of namespace `%D' as expression"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use of class template `%T' as expression"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Ambiguous reference to base members.  */
name|error
argument_list|(
literal|"request for member `%D' is ambiguous in "
literal|"multiple inheritance lattice"
argument_list|,
name|id_expression
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Mark variable-like entities as used.  Functions are similarly 	 marked either below or after overload resolution.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
condition|)
block|{
name|decl
operator|=
operator|(
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|current_class_type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|)
operator|*
name|qualifying_class
operator|=
name|scope
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|decl
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|decl
operator|=
name|build
argument_list|(
name|SCOPE_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|scope
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Since SCOPE is NULL here, this is an unqualified name. 	     Access checking has been performed during name lookup 	     already.  Turn off checking to avoid duplicate errors.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|decl
operator|=
name|finish_non_static_data_member
argument_list|(
name|decl
argument_list|,
name|current_class_ref
argument_list|,
comment|/*qualifying_scope=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|first_fn
init|=
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first_fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|first_fn
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|first_fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|mark_used
argument_list|(
name|first_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first_fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|first_fn
argument_list|)
operator|&&
operator|!
name|shared_member_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* A set of member functions.  */
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|first_fn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|finish_class_member_access_expr
argument_list|(
name|decl
argument_list|,
name|id_expression
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use of %s from containing function"
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|?
literal|"`auto' variable"
else|:
literal|"parameter"
operator|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  `%#D' declared here"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|path
operator|=
name|currently_open_derived_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|path
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|decl
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Resolve references to variables of anonymous unions 	 into COMPONENT_REFs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ALIAS_DECL
condition|)
name|decl
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Implement the __typeof keyword: Return the type of EXPR, suitable for    use as a type-specifier.  */
end_comment

begin_function
name|tree
name|finish_typeof
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|type
operator|=
name|make_aggr_type
argument_list|(
name|TYPEOF_TYPE
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|expr
expr_stmt|;
return|return
name|type
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|unknown_type_node
condition|)
block|{
name|error
argument_list|(
literal|"type of `%E' is unknown"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the statement T, and its substatements, and any    other statements at its nesting level.  */
end_comment

begin_function
specifier|static
name|void
name|cp_expand_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TRY_BLOCK
case|:
name|genrtl_try_block
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_SPEC_BLOCK
case|:
name|genrtl_eh_spec_block
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|HANDLER
case|:
name|genrtl_handler
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_STMT
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Called from expand_body via walk_tree.  Replace all AGGR_INIT_EXPRs    will equivalent CALL_EXPRs.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_aggr_init_exprs_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't need to walk into types; there's nothing in a type that      needs simplification.  (And, furthermore, there are places we      actively don't want to go.  For example, we don't want to wander      into the default arguments for a FUNCTION_DECL that appears in a      CALL_EXPR.)  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Only AGGR_INIT_EXPRs are interesting.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|simplify_aggr_init_expr
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Replace the AGGR_INIT_EXPR at *TP with an equivalent CALL_EXPR.  This    function is broken out from the above for the benefit of the tree-ssa    project.  */
end_comment

begin_function
name|void
name|simplify_aggr_init_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|tree
name|aggr_init_expr
init|=
operator|*
name|tp
decl_stmt|;
comment|/* Form an appropriate CALL_EXPR.  */
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|slot
init|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|aggr_init_expr
argument_list|)
decl_stmt|;
name|tree
name|call_expr
decl_stmt|;
enum|enum
name|style_t
block|{
name|ctor
block|,
name|arg
block|,
name|pcc
block|}
name|style
enum|;
if|if
condition|(
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|aggr_init_expr
argument_list|)
condition|)
name|style
operator|=
name|ctor
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
elseif|else
if|if
condition|(
literal|1
condition|)
name|style
operator|=
name|pcc
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
condition|)
name|style
operator|=
name|arg
expr_stmt|;
else|else
comment|/* We shouldn't build an AGGR_INIT_EXPR if we don't need any special        handling.  See build_cplus_new.  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|ctor
operator|||
name|style
operator|==
name|arg
condition|)
block|{
comment|/* Pass the address of the slot.  If this is a constructor, we 	 replace the first argument; otherwise, we tack on a new one.  */
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|ctor
condition|)
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cxx_mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|arg
condition|)
block|{
comment|/* The return type might have different cv-quals from the slot.  */
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|arg
condition|)
comment|/* Tell the backend that we've added our return slot to the argument        list.  */
name|CALL_EXPR_HAS_RETURN_SLOT_ADDR
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|style
operator|==
name|pcc
condition|)
block|{
comment|/* If we're using the non-reentrant PCC calling convention, then we 	 need to copy the returned value out of the static buffer into the 	 SLOT.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build_aggr_init
argument_list|(
name|slot
argument_list|,
name|call_expr
argument_list|,
name|DIRECT_BIND
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
comment|/* We want to use the value of the initialized location as the      result.  */
name|call_expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|call_expr
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* Replace the AGGR_INIT_EXPR with the CALL_EXPR.  */
name|TREE_CHAIN
argument_list|(
name|call_expr
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|aggr_init_expr
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|call_expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit all thunks to FN that should be emitted when FN is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|emit_associated_thunks
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
comment|/* When we use vcall offsets, we emit thunks with the virtual      functions to which they thunk. The whole point of vcall offsets      is so that you can know statically the entire set of thunks that      will ever be needed for a given virtual function, thereby      enabling you to output all the thunks with the function itself.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|thunk
decl_stmt|;
for|for
control|(
name|thunk
operator|=
name|DECL_THUNKS
argument_list|(
name|fn
argument_list|)
init|;
name|thunk
condition|;
name|thunk
operator|=
name|TREE_CHAIN
argument_list|(
name|thunk
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|use_thunk
argument_list|(
name|thunk
argument_list|,
comment|/*emit_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RESULT_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
name|use_thunk
argument_list|(
name|probe
argument_list|,
comment|/*emit_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
argument_list|,
literal|20031023
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL for FN.  */
end_comment

begin_function
name|void
name|expand_body
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|saved_function
decl_stmt|;
comment|/* Compute the appropriate object-file linkage for inline      functions.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|import_export_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If FN is external, then there's no point in generating RTL for      it.  This situation can arise with an inline function under      `-fexternal-templates'; we instantiate the function, even though      we're not planning on emitting it, in case we get a chance to      inline it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
condition|)
return|return;
comment|/* ??? When is this needed?  */
name|saved_function
operator|=
name|current_function_decl
expr_stmt|;
comment|/* Emit any thunks that should be emitted at the same time as FN.  */
name|emit_associated_thunks
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|optimize_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|tree_rest_of_compilation
argument_list|(
name|fn
argument_list|,
name|function_depth
operator|>
literal|1
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|saved_function
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If this is a clone, go through the other clones now and mark          their parameters used.  We have to do that here, as we don't          know whether any particular clone will be expanded, and          therefore cannot pick one arbitrarily.  */
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|probe
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|probe
argument_list|)
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
name|tree
name|parms
decl_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|probe
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
name|TREE_USED
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL for FN.  */
end_comment

begin_function
name|void
name|expand_or_defer_fn
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
comment|/* When the parser calls us after finishing the body of a template      function, we don't really want to expand the body.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* Normally, collection only occurs in rest_of_compilation.  So, 	 if we don't collect here, we never collect junk generated 	 during the processing of templates until we hit a 	 non-template function.  */
name|ggc_collect
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|simplify_aggr_init_exprs_r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a constructor or destructor body, we have to clone      it.  */
if|if
condition|(
name|maybe_clone_body
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* We don't want to process FN again, so pretend we've written 	 it out, even though we haven't.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* There's no reason to do any of the work here if we're only doing      semantic analysis; this code just generates RTL.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
comment|/* Compute the appropriate object-file linkage for inline functions.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|import_export_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If this function is marked with the constructor attribute, add it      to the list of functions to be called along with constructors      from static duration objects.  */
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fn
argument_list|)
condition|)
name|static_ctors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
comment|/* If this function is marked with the destructor attribute, add it      to the list of functions to be called along with destructors from      static duration objects.  */
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fn
argument_list|)
condition|)
name|static_dtors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
name|function_depth
operator|++
expr_stmt|;
comment|/* Expand or defer, at the whim of the compilation unit manager.  */
name|cgraph_finalize_function
argument_list|(
name|fn
argument_list|,
name|function_depth
operator|>
literal|1
argument_list|)
expr_stmt|;
name|function_depth
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for walk_tree, used by finish_function to override all    the RETURN_STMTs and pertinent CLEANUP_STMTs for the named return    value optimization.  */
end_comment

begin_function
name|tree
name|nullify_returns_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|nrv
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
comment|/* No need to walk into types.  There wouldn't be any need to walk into      non-statements, except that we have to consider STMT_EXPRs.  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|RETURN_STMT
condition|)
name|RETURN_STMT_EXPR
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|CLEANUP_STMT
operator|&&
name|CLEANUP_DECL
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|nrv
condition|)
name|CLEANUP_EH_ONLY
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Replace the DECL_STMT for the NRV with an initialization of the      RESULT_DECL, if needed.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|DECL_STMT
operator|&&
name|DECL_STMT_DECL
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|nrv
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|nrv
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|nrv
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|init
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|nrv
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|nrv
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|init
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|STMT_LINENO
argument_list|(
name|init
argument_list|)
operator|=
name|STMT_LINENO
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|init
expr_stmt|;
block|}
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Start generating the RTL for FN.  */
end_comment

begin_function
name|void
name|cxx_expand_function_start
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Give our named return value the same RTL as our RESULT_DECL.  */
if|if
condition|(
name|current_function_return_value
condition|)
name|COPY_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|,
name|current_function_return_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform initialization related to this module.  */
end_comment

begin_function
name|void
name|init_cp_semantics
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_expand_stmt
operator|=
name|cp_expand_stmt
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-semantics.h"
end_include

end_unit

