begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform the semantic phase of parsing, i.e., the process of    building tree structure, checking semantic consistency, and    building RTL.  These routines are used both during actual parsing    and during the instantiation of template functions.      Copyright (C) 1998, 1999 Free Software Foundation, Inc.    Written by Mark Mitchell (mmitchell@usa.net) based on code found    formerly in parse.y and pt.c.       This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.        GNU CC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.        You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* There routines provide a modular interface to perform many parsing    operations.  They may therefore be used during actual parsing, or    during template instantiation, which may be regarded as a    degenerate form of parsing.  Since the current g++ parser is    lacking in several respects, and will be reimplemented, we are    attempting to move most code that is not directly related to    parsing into this file; that will make implementing the new parser    much easier since it will be able to make use of these routines.  */
end_comment

begin_comment
comment|/* When parsing a template, LAST_TREE contains the last statement    parsed.  These are chained together through the TREE_CHAIN field,    but often need to be re-organized since the parse is performed    bottom-up.  This macro makes LAST_TREE the indicated SUBSTMT of    STMT.  */
end_comment

begin_define
define|#
directive|define
name|RECHAIN_STMTS
parameter_list|(
name|stmt
parameter_list|,
name|substmt
parameter_list|,
name|last
parameter_list|)
define|\
value|do {						\     substmt = last;			        \     TREE_CHAIN (stmt) = NULL_TREE;		\     last_tree = stmt;				\   } while (0)
end_define

begin_define
define|#
directive|define
name|RECHAIN_STMTS_FROM_LAST
parameter_list|(
name|stmt
parameter_list|,
name|substmt
parameter_list|)
define|\
value|RECHAIN_STMTS (stmt, substmt, last_tree)
end_define

begin_define
define|#
directive|define
name|RECHAIN_STMTS_FROM_CHAIN
parameter_list|(
name|stmt
parameter_list|,
name|substmt
parameter_list|)
define|\
value|RECHAIN_STMTS (stmt, substmt, TREE_CHAIN (stmt))
end_define

begin_comment
comment|/* Finish an expression-statement, whose EXPRESSION is as indicated.  */
end_comment

begin_function
name|void
name|finish_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Do default conversion if safe and possibly important, 	     in case within ({...}).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|cplus_expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|clear_momentary
argument_list|()
expr_stmt|;
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an if-statement.  Returns a newly created IF_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_if_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build_min_nt
argument_list|(
name|IF_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|NULL_TREE
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_if_stmt_cond
parameter_list|(
name|cond
parameter_list|,
name|if_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|if_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|last_tree
operator|!=
name|if_stmt
condition|)
name|RECHAIN_STMTS_FROM_LAST
argument_list|(
name|if_stmt
argument_list|,
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|condition_conversion
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the then-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|tree
name|finish_then_clause
parameter_list|(
name|if_stmt
parameter_list|)
name|tree
name|if_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|if_stmt
argument_list|,
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|last_tree
operator|=
name|if_stmt
expr_stmt|;
return|return
name|if_stmt
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Begin the else-clause of an if-statement.  */
end_comment

begin_function
name|void
name|begin_else_clause
parameter_list|()
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_start_else
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the else-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_else_clause
parameter_list|(
name|if_stmt
parameter_list|)
name|tree
name|if_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|if_stmt
argument_list|,
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finsh an if-statement.  */
end_comment

begin_function
name|void
name|finish_if_stmt
parameter_list|()
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a while-statement.  Returns a newly created WHILE_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_while_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build_min_nt
argument_list|(
name|WHILE_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_nop
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_loop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|do_pushlevel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of an if-statement, which may be given by    WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt_cond
parameter_list|(
name|cond
parameter_list|,
name|while_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|while_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|last_tree
operator|!=
name|while_stmt
condition|)
name|RECHAIN_STMTS_FROM_LAST
argument_list|(
name|while_stmt
argument_list|,
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|while_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|condition_conversion
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If COND wasn't a declaration, clear out the      block we made for it and start a new one here so the      optimization in expand_end_loop will work.  */
if|if
condition|(
name|getdecls
argument_list|()
operator|==
name|NULL_TREE
condition|)
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a while-statement, which may be given by WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt
parameter_list|(
name|while_stmt
parameter_list|)
name|tree
name|while_stmt
decl_stmt|;
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|while_stmt
argument_list|,
name|WHILE_BODY
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_end_loop
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a do-statement.  Returns a newly created DO_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_do_stmt
parameter_list|()
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|r
init|=
name|build_min_nt
argument_list|(
name|DO_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
name|emit_nop
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the body of a do-statement, which may be given by DO_STMT.  */
end_comment

begin_function
name|void
name|finish_do_body
parameter_list|(
name|do_stmt
parameter_list|)
name|tree
name|do_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|do_stmt
argument_list|,
name|DO_BODY
argument_list|(
name|do_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a do-statement, which may be given by DO_STMT, and whose    COND is as indicated.  */
end_comment

begin_function
name|void
name|finish_do_stmt
parameter_list|(
name|cond
parameter_list|,
name|do_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|do_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|DO_COND
argument_list|(
name|do_stmt
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|cond
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|condition_conversion
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
name|clear_momentary
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a return-statement.  The EXPRESSION returned, if any, is as    indicated.  */
end_comment

begin_function
name|void
name|finish_return_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|c_expand_return
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|begin_for_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build_min_nt
argument_list|(
name|FOR_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|flag_new_for_scope
operator|>
literal|0
condition|)
block|{
name|do_pushlevel
argument_list|()
expr_stmt|;
name|note_level_for_for
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the for-init-statement of a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_init_stmt
parameter_list|(
name|for_stmt
parameter_list|)
name|tree
name|for_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|last_tree
operator|!=
name|for_stmt
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|for_stmt
argument_list|,
name|FOR_INIT_STMT
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_nop
argument_list|()
expr_stmt|;
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|do_pushlevel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the COND of a for-statement, which may be given by    FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_cond
parameter_list|(
name|cond
parameter_list|,
name|for_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|for_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|last_tree
operator|!=
name|for_stmt
condition|)
name|RECHAIN_STMTS_FROM_LAST
argument_list|(
name|for_stmt
argument_list|,
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|copy_to_permanent
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|condition_conversion
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the cond wasn't a declaration, clear out the      block we made for it and start a new one here so the      optimization in expand_end_loop will work.  */
if|if
condition|(
name|getdecls
argument_list|()
operator|==
name|NULL_TREE
condition|)
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the increment-EXPRESSION in a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_expr
parameter_list|(
name|expr
parameter_list|,
name|for_stmt
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|for_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|FOR_EXPR
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
comment|/* Don't let the tree nodes for EXPR be discarded      by clear_momentary during the parsing of the next stmt.  */
name|push_momentary
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a for-statement, which may be given by    FOR_STMT.  The increment-EXPR for the loop must be    provided.  */
end_comment

begin_function
name|void
name|finish_for_stmt
parameter_list|(
name|expr
parameter_list|,
name|for_stmt
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|for_stmt
decl_stmt|;
block|{
comment|/* Pop the scope for the body of the loop.  */
name|do_poplevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|for_stmt
argument_list|,
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
if|if
condition|(
name|expr
condition|)
name|cplus_expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expand_end_loop
argument_list|()
expr_stmt|;
block|}
name|pop_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_new_for_scope
operator|>
literal|0
condition|)
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a break-statement.  */
end_comment

begin_function
name|void
name|finish_break_stmt
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|BREAK_STMT
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|expand_exit_something
argument_list|()
condition|)
name|cp_error
argument_list|(
literal|"break statement not within loop or switch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a continue-statement.  */
end_comment

begin_function
name|void
name|finish_continue_stmt
parameter_list|()
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|CONTINUE_STMT
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|expand_continue_loop
argument_list|(
literal|0
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"continue statement not within a loop"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a switch-statement.  */
end_comment

begin_function
name|void
name|begin_switch_stmt
parameter_list|()
block|{
name|do_pushlevel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the cond of a switch-statement.  Returns a new    SWITCH_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|finish_switch_cond
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build_min_nt
argument_list|(
name|SWITCH_STMT
argument_list|,
name|cond
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cond
operator|!=
name|error_mark_node
condition|)
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|c_expand_start_case
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* The code is in error, but we don't want expand_end_case to          crash. */
name|c_expand_start_case
argument_list|(
name|boolean_false_node
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|push_switch
argument_list|()
expr_stmt|;
comment|/* Don't let the tree nodes for COND be discarded by      clear_momentary during the parsing of the next stmt.  */
name|push_momentary
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the body of a switch-statement, which may be given by    SWITCH_STMT.  The COND to switch on is indicated.  */
end_comment

begin_function
name|void
name|finish_switch_stmt
parameter_list|(
name|cond
parameter_list|,
name|switch_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|switch_stmt
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|switch_stmt
argument_list|,
name|SWITCH_BODY
argument_list|(
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_end_case
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|pop_switch
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a case-label.  */
end_comment

begin_function
name|void
name|finish_case_label
parameter_list|(
name|low_value
parameter_list|,
name|high_value
parameter_list|)
name|tree
name|low_value
decl_stmt|;
name|tree
name|high_value
decl_stmt|;
block|{
name|do_case
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a goto-statement.  */
end_comment

begin_function
name|void
name|finish_goto_stmt
parameter_list|(
name|destination
parameter_list|)
name|tree
name|destination
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|GOTO_STMT
argument_list|,
name|destination
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|destination
argument_list|)
decl_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_goto
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_computed_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin a try-block.  Returns a newly-created TRY_BLOCK if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_try_block
parameter_list|()
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|r
init|=
name|build_min_nt
argument_list|(
name|TRY_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_start_try_stmts
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a try-block, which may be given by TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_try_block
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_LAST
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|expand_start_all_catch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a handler-sequence for a try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_handler_sequence
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|try_block
argument_list|,
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|expand_end_all_catch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin a handler.  Returns a HANDLER if appropriate.  */
end_comment

begin_function
name|tree
name|begin_handler
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build_min_nt
argument_list|(
name|HANDLER
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|NULL_TREE
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the handler-parameters for a handler, which may be given by    HANDLER.  */
end_comment

begin_function
name|void
name|finish_handler_parms
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|handler
argument_list|,
name|HANDLER_PARMS
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler, which may be given by HANDLER.  */
end_comment

begin_function
name|void
name|finish_handler
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|handler
argument_list|,
name|HANDLER_BODY
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expand_end_catch_block
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a compound-statement.  If HAS_NO_SCOPE is non-zero, the    compound-statement does not define a scope.  Returns a new    COMPOUND_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|begin_compound_stmt
parameter_list|(
name|has_no_scope
parameter_list|)
name|int
name|has_no_scope
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build_min_nt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_no_scope
condition|)
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|has_no_scope
condition|)
name|do_pushlevel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a compound-statement, which may be given by COMPOUND_STMT.    If HAS_NO_SCOPE is non-zero, the compound statement does not define    a scope.  */
end_comment

begin_function
name|tree
name|finish_compound_stmt
parameter_list|(
name|has_no_scope
parameter_list|,
name|compound_stmt
parameter_list|)
name|int
name|has_no_scope
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|has_no_scope
condition|)
name|r
operator|=
name|do_poplevel
argument_list|()
expr_stmt|;
else|else
name|r
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|RECHAIN_STMTS_FROM_CHAIN
argument_list|(
name|compound_stmt
argument_list|,
name|COMPOUND_BODY
argument_list|(
name|compound_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish an asm-statement, whose components are a CV_QUALIFIER, a    STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some    CLOBBERS.  */
end_comment

begin_function
name|void
name|finish_asm_stmt
parameter_list|(
name|cv_qualifier
parameter_list|,
name|string
parameter_list|,
name|output_operands
parameter_list|,
name|input_operands
parameter_list|,
name|clobbers
parameter_list|)
name|tree
name|cv_qualifier
decl_stmt|;
name|tree
name|string
decl_stmt|;
name|tree
name|output_operands
decl_stmt|;
name|tree
name|input_operands
decl_stmt|;
name|tree
name|clobbers
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|string
argument_list|)
condition|)
name|string
operator|=
name|combine_strings
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|r
init|=
name|build_min_nt
argument_list|(
name|ASM_STMT
argument_list|,
name|cv_qualifier
argument_list|,
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|)
decl_stmt|;
name|add_tree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_operands
operator|!=
name|NULL_TREE
operator|||
name|input_operands
operator|!=
name|NULL_TREE
operator|||
name|clobbers
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|cp_warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|input_operands
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|decay_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|c_expand_asm_operands
argument_list|(
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|,
name|cv_qualifier
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't warn about redundant specification of 'volatile' here.  */
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|cp_warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|expand_asm
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a parenthesized expression EXPR.  */
end_comment

begin_function
name|tree
name|finish_parenthesized_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* This inhibits warnings in truthvalue_conversion.  */
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|,
name|ERROR_MARK
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Begin a statement-expression.  The value returned must be passed to    finish_stmt_expr.  */
end_comment

begin_function
name|tree
name|begin_stmt_expr
parameter_list|()
block|{
name|keep_next_level
argument_list|()
expr_stmt|;
comment|/* If we're processing_template_decl, then the upcoming compound      statement will be chained onto the tree structure, starting at      last_tree.  We return last_tree so that we can later unhook the      compound statement.  */
return|return
name|processing_template_decl
condition|?
name|last_tree
else|:
name|expand_start_stmt_expr
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Finish a statement-expression.  RTL_EXPR should be the value    returned by the previous begin_stmt_expr; EXPR is the    statement-expression.  Returns an expression representing the    statement-expression.  */
end_comment

begin_function
name|tree
name|finish_stmt_expr
parameter_list|(
name|rtl_expr
parameter_list|,
name|expr
parameter_list|)
name|tree
name|rtl_expr
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|rtl_expr
operator|=
name|expand_end_stmt_expr
argument_list|(
name|rtl_expr
argument_list|)
expr_stmt|;
comment|/* The statements have side effects, so the group does.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|rtl_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
comment|/* Make a BIND_EXPR for the BLOCK already made.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|result
operator|=
name|build_min_nt
argument_list|(
name|BIND_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|last_tree
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|build
argument_list|(
name|BIND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rtl_expr
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|rtl_expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* Remove the block from the tree at this point. 	 It gets put back at the proper place 	 when the BIND_EXPR is expanded.  */
name|delete_block
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* Remove the compound statement from the tree structure; it is 	 now saved in the BIND_EXPR.  */
name|last_tree
operator|=
name|rtl_expr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to FN with ARGS.  Returns a representation of the    call.  */
end_comment

begin_function
name|tree
name|finish_call_expr
parameter_list|(
name|fn
parameter_list|,
name|args
parameter_list|,
name|koenig
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|koenig
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|koenig
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|fn
operator|=
name|build_x_unary_op
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
name|fn
operator|=
name|do_identifier
argument_list|(
name|fn
argument_list|,
literal|2
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_x_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|current_class_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
operator|!
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|result
operator|=
name|require_complete_type
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to a postfix increment or decrement or EXPR.  (Which    is indicated by CODE, which should be POSTINCREMENT_EXPR or    POSTDECREMENT_EXPR.)  */
end_comment

begin_function
name|tree
name|finish_increment_expr
parameter_list|(
name|expr
parameter_list|,
name|code
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
comment|/* If we get an OFFSET_REF, turn it into what it really means (e.g.,      a COMPONENT_REF).  This way if we've got, say, a reference to a      static member that's being operated on, we don't end up trying to      find a member operator for the class it's in.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a use of `this'.  Returns an expression for `this'.  */
end_comment

begin_function
name|tree
name|finish_this_expr
parameter_list|()
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|current_class_ptr
condition|)
block|{
ifdef|#
directive|ifdef
name|WARNING_ABOUT_CCD
name|TREE_USED
argument_list|(
name|current_class_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|current_class_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`this' is unavailable for static member functions"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current_function_decl
condition|)
name|error
argument_list|(
literal|"invalid use of `this' in non-member function"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of `this' at top level"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a member function call using OBJECT and ARGS as arguments to    FN.  Returns an expression for the call.  */
end_comment

begin_function
name|tree
name|finish_object_call_expr
parameter_list|(
name|fn
parameter_list|,
name|object
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|object
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* This is a future direction of this code, but because      build_x_function_call cannot always undo what is done in      build_component_ref entirely yet, we cannot do this.  */
block|tree real_fn = build_component_ref (object, fn, NULL_TREE, 1);   return finish_call_expr (real_fn, args);
else|#
directive|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* This can happen on code like:  	   class X; 	   template<class T> void f(T t) { 	     t.X(); 	   }    	   We just grab the underlying IDENTIFIER.  */
name|fn
operator|=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"calling type `%T' like a method"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|build_method_call
argument_list|(
name|object
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Finish a qualified member function call using OBJECT and ARGS as    arguments to FN.  Returns an expressino for the call.  */
end_comment

begin_function
name|tree
name|finish_qualified_object_call_expr
parameter_list|(
name|fn
parameter_list|,
name|object
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|object
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"signature name in scope resolution ignored"
argument_list|)
expr_stmt|;
return|return
name|finish_object_call_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|object
argument_list|,
name|args
argument_list|)
return|;
block|}
else|else
return|return
name|build_scoped_method_call
argument_list|(
name|object
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a pseudo-destructor call expression of OBJECT, with SCOPE    being the scope, if any, of DESTRUCTOR.  Returns an expression for    the call.  */
end_comment

begin_function
name|tree
name|finish_pseudo_destructor_call_expr
parameter_list|(
name|object
parameter_list|,
name|scope
parameter_list|,
name|destructor
parameter_list|)
name|tree
name|object
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|destructor
decl_stmt|;
block|{
if|if
condition|(
name|scope
operator|&&
name|scope
operator|!=
name|destructor
condition|)
name|cp_error
argument_list|(
literal|"destructor specifier `%T::~%T()' must have matching names"
argument_list|,
name|scope
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scope
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|destructor
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|destructor
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|cp_error
argument_list|(
literal|"`%E' is not of type `%T'"
argument_list|,
name|object
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|object
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to a globally qualified member function FN using    ARGS.  Returns an expression for the call.  */
end_comment

begin_function
name|tree
name|finish_qualified_call_expr
parameter_list|(
name|fn
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|copy_to_permanent
argument_list|(
name|fn
argument_list|)
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
else|else
return|return
name|build_member_call
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression taking the address of LABEL.  Returns an    expression for the address.  */
end_comment

begin_function
name|tree
name|finish_label_address_expr
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|label
operator|=
name|lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL_TREE
condition|)
name|result
operator|=
name|null_pointer_node
expr_stmt|;
else|else
block|{
name|TREE_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression of the form CODE EXPR.  */
end_comment

begin_function
name|tree
name|finish_unary_op_expr
parameter_list|(
name|code
parameter_list|,
name|expr
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|TREE_NEGATED_INT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish an id-expression.  */
end_comment

begin_function
name|tree
name|finish_id_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|expr
operator|=
name|do_identifier
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Begin a new-placement.  */
end_comment

begin_function
name|int
name|begin_new_placement
parameter_list|()
block|{
comment|/* The arguments to a placement new might be passed to a      deallocation function, in the event that the allocation throws an      exception.  Since we don't expand exception handlers until the      end of a function, we must make sure the arguments stay around      that long.  */
return|return
name|suspend_momentary
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Finish a new-placement.  The ARGS are the placement arguments.  The    COOKIE is the value returned by the previous call to    begin_new_placement.  */
end_comment

begin_function
name|tree
name|finish_new_placement
parameter_list|(
name|args
parameter_list|,
name|cookie
parameter_list|)
name|tree
name|args
decl_stmt|;
name|int
name|cookie
decl_stmt|;
block|{
name|resume_momentary
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Begin a function defniition declared with DECL_SPECS and    DECLARATOR.  Returns non-zero if the function-declaration is    legal.  */
end_comment

begin_function
name|int
name|begin_function_definition
parameter_list|(
name|decl_specs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|decl_specs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|decl_specs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_function
argument_list|(
name|specs
argument_list|,
name|declarator
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|reinit_parse_for_function
argument_list|()
expr_stmt|;
comment|/* The things we're about to see are not directly qualified by any      template headers we've seen thus far.  */
name|reset_specialization
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Begin a constructor declarator of the form `SCOPE::NAME'.  Returns    a SCOPE_REF.  */
end_comment

begin_function
name|tree
name|begin_constructor_declarator
parameter_list|(
name|scope
parameter_list|,
name|name
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_parse_node
argument_list|(
name|SCOPE_REF
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|enter_scope_of
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish an init-declarator.  Returns a DECL.  */
end_comment

begin_function
name|tree
name|finish_declarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|attributes
parameter_list|,
name|prefix_attributes
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|prefix_attributes
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
return|return
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|initialized
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a translation unit.  */
end_comment

begin_function
name|void
name|finish_translation_unit
parameter_list|()
block|{
comment|/* In case there were missing closebraces,      get us back to the global binding level.  */
while|while
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
name|finish_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a template type parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_type_parm
parameter_list|(
name|aggr
parameter_list|,
name|identifier
parameter_list|)
name|tree
name|aggr
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
block|{
if|if
condition|(
name|aggr
operator|==
name|signature_type_node
condition|)
name|sorry
argument_list|(
literal|"signature as template type parameter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aggr
operator|!=
name|class_type_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"template type parameters must use the keyword `class' or `typename'"
argument_list|)
expr_stmt|;
name|aggr
operator|=
name|class_type_node
expr_stmt|;
block|}
return|return
name|build_tree_list
argument_list|(
name|aggr
argument_list|,
name|identifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a template template parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_template_parm
parameter_list|(
name|aggr
parameter_list|,
name|identifier
parameter_list|)
name|tree
name|aggr
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|current_template_parms
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|end_template_decl
argument_list|()
expr_stmt|;
return|return
name|finish_template_type_parm
argument_list|(
name|aggr
argument_list|,
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a parameter list, indicated by PARMS.  If ELLIPSIS is    non-zero, the parameter list was terminated by a `...'.  */
end_comment

begin_function
name|tree
name|finish_parmlist
parameter_list|(
name|parms
parameter_list|,
name|ellipsis
parameter_list|)
name|tree
name|parms
decl_stmt|;
name|int
name|ellipsis
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ellipsis
condition|)
name|chainon
argument_list|(
name|parms
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
comment|/* We mark the PARMS as a parmlist so that declarator processing can      disambiguate certain constructs.  */
if|if
condition|(
name|parms
operator|!=
name|NULL_TREE
condition|)
name|TREE_PARMLIST
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|parms
return|;
block|}
end_function

begin_comment
comment|/* Begin a class definition, as indicated by T.  */
end_comment

begin_function
name|tree
name|begin_class_definition
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|make_anon_name
argument_list|()
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* In a definition of a member class template, we will get here with an      implicit typename, a TYPENAME_TYPE with a type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we generated a partial instantiation of this type, but now      we're seeing a real definition, we're actually looking at a      partial specialization.  Consider:         template<class T, class U>        struct Y {};         template<class T>        struct X {};         template<class T, class U>        void f()        { 	 typename X<Y<T, U>>::A a;        }         template<class T, class U>        struct X<Y<T, U>>        {        };       We have to undo the effects of the previous partial      instantiation.  */
if|if
condition|(
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pedantic
condition|)
block|{
comment|/* Unfortunately, when we're not in pedantic mode, we 	     attempt to actually fill in some of the fields of the 	     partial instantiation, in order to support the implicit 	     typename extension.  Clear those fields now, in 	     preparation for the definition here.  The fields cleared 	     here must match those set in instantiate_class_template. 	     Look for a comment mentioning begin_class_definition 	     there.  */
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* This isn't a partial instantiation any more.  */
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this type was already complete, and we see another definition,      that's an error.  */
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
name|duplicate_tag_error
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_lang_type
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Reset the interface data, at the earliest possible      moment, as it might have been set via a class foo;      before.  */
comment|/* Don't change signatures.  */
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|needs_writing
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
block|}
comment|/* Record how to set the access of this class's 	 virtual functions.  If write_virtuals == 3, then 	 inline virtuals are ``extern inline''.  */
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
name|needs_writing
operator|=
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|needs_writing
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
operator|=
name|needs_writing
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|tmp = TYPE_IDENTIFIER ($<ttype>0);   if (tmp&& IDENTIFIER_TEMPLATE (tmp))     overload_template_name (tmp, 1);
endif|#
directive|endif
name|reset_specialization
argument_list|()
expr_stmt|;
comment|/* In case this is a local class within a template      function, we save the current tree structure so      that we can get it back later.  */
name|begin_tree
argument_list|()
expr_stmt|;
comment|/* Make a declaration for this class in its own scope.  */
name|build_self_reference
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Finish the member declaration given by DECL.  */
end_comment

begin_function
name|void
name|finish_member_declaration
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
comment|/* The COMPONENT was a friend, not a member, and so there's        nothing for us to do.  */
return|return;
comment|/* We should see only one DECL at a time.  */
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up access control for DECL.  */
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_private_node
operator|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_protected_node
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|TREE_PRIVATE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the DECL as a member of the current class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Historically, DECL_CONTEXT was not set for a FUNCTION_DECL in        finish_struct.  Presumably it is already set as the function is        parsed.  Perhaps DECL_CLASS_CONTEXT is already set, too?  */
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
else|else
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* Put functions on the TYPE_METHODS list and everything else on the      TYPE_FIELDS list.  Note that these are built up in reverse order.      We reverse them (to obtain declaration order) in finish_struct.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We also need to add this function to the 	 CLASSTYPE_METHOD_VEC.  */
name|add_method
argument_list|(
name|current_class_type
argument_list|,
literal|0
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
comment|/* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields 	 go at the beginning.  The reason is that lookup_field_1 	 searches the list in order, and we want a field name to 	 override a type name so that the "struct stat hack" will 	 work.  In particular:  	   struct S { enum E { }; int E } s; 	   s.E = 3;  	 is legal.  In addition, the FIELD_DECLs must be maintained in 	 declaration order so that class layout works as expected. 	 However, we don't need that order until class layout, so we 	 save a little time by putting FIELD_DECLs on in reverse order 	 here, and then reversing them in finish_struct_1.  (We could 	 also keep a pointer to the correct insertion points in the 	 list.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Enter the DECL into the scope of the class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|USING_DECL
condition|)
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a class definition T with the indicate ATTRIBUTES.  If SEMI,    the definition is immediately followed by a semicolon.  Returns the    type.  */
end_comment

begin_function
name|tree
name|finish_class_definition
parameter_list|(
name|t
parameter_list|,
name|attributes
parameter_list|,
name|semi
parameter_list|,
name|pop_scope_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|int
name|semi
decl_stmt|;
name|int
name|pop_scope_p
decl_stmt|;
block|{
comment|/* finish_struct nukes this anyway; if finish_exception does too,      then it can go.  */
if|if
condition|(
name|semi
condition|)
name|note_got_semicolon
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we got any attributes in class_head, xref_tag will stick them in      TREE_TYPE of the type.  Grab them now.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
empty_stmt|;
else|else
block|{
name|t
operator|=
name|finish_struct
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|,
name|semi
argument_list|)
expr_stmt|;
if|if
condition|(
name|semi
condition|)
name|note_got_semicolon
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|semi
condition|)
name|check_for_missing_semicolon
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_scope_p
condition|)
name|pop_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_scope
argument_list|()
operator|==
name|current_function_decl
condition|)
name|do_pending_defargs
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Finish processing the default argument expressions cached during    the processing of a class definition.  */
end_comment

begin_function
name|void
name|begin_inline_definitions
parameter_list|()
block|{
if|if
condition|(
name|pending_inlines
operator|&&
name|current_scope
argument_list|()
operator|==
name|current_function_decl
condition|)
name|do_pending_inlines
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing the inline function definitions cached during the    processing of a class definition.  */
end_comment

begin_function
name|void
name|finish_inline_definitions
parameter_list|()
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|clear_inline_text_obstack
argument_list|()
expr_stmt|;
comment|/* Undo the begin_tree in begin_class_definition.  */
name|end_tree
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing the declaration of a member class template    TYPES whose template parameters are given by PARMS.  */
end_comment

begin_function
name|tree
name|finish_member_class_template
parameter_list|(
name|types
parameter_list|)
name|tree
name|types
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* If there are declared, but undefined, partial specializations      mixed in with the typespecs they will not yet have passed through      maybe_process_partial_specialization, so we do that here.  */
for|for
control|(
name|t
operator|=
name|types
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
name|maybe_process_partial_specialization
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|note_list_got_semicolon
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|grok_x_components
argument_list|(
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
comment|/* The component was in fact a friend declaration.  We avoid        finish_member_template_decl performing certain checks by        unsetting TYPES.  */
name|types
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_member_template_decl
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* As with other component type declarations, we do      not store the new DECL on the list of      component_decls.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Finish processsing a complete template declaration.  The PARMS are    the template parameters.  */
end_comment

begin_function
name|void
name|finish_template_decl
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
if|if
condition|(
name|parms
condition|)
name|end_template_decl
argument_list|()
expr_stmt|;
else|else
name|end_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing a a template-id (which names a type) of the form    NAME< ARGS>.  Return the TYPE_DECL for the type named by the    template-id.  If ENTERING_SCOPE is non-zero we are about to enter    the scope of template-id indicated.  */
end_comment

begin_function
name|tree
name|finish_template_type
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|,
name|entering_scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|entering_scope
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|lookup_template_class
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|entering_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* SR is a SCOPE_REF node.  Enter the scope of SR, whether it is a    namespace scope or a class scope.  */
end_comment

begin_function
name|void
name|enter_scope_of
parameter_list|(
name|sr
parameter_list|)
name|tree
name|sr
decl_stmt|;
block|{
name|tree
name|scope
init|=
name|TREE_OPERAND
argument_list|(
name|sr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|push_decl_namespace
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|sr
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|!=
name|current_class_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
comment|/* In a declarator for a template class member, the scope will 	     get here as an implicit typename, a TYPENAME_TYPE with a type.  */
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|sr
argument_list|,
literal|0
argument_list|)
operator|=
name|scope
expr_stmt|;
block|}
name|push_nested_class
argument_list|(
name|scope
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|sr
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish processing a BASE_CLASS with the indicated ACCESS_SPECIFIER.    Return a TREE_LIST containing the ACCESS_SPECIFIER and the    BASE_CLASS, or NULL_TREE if an error occurred.  The    ACCESSS_SPECIFIER is one of    access_{default,public,protected_private}[_virtual]_node.*/
end_comment

begin_function
name|tree
name|finish_base_specifier
parameter_list|(
name|access_specifier
parameter_list|,
name|base_class
parameter_list|,
name|current_aggr_is_signature
parameter_list|)
name|tree
name|access_specifier
decl_stmt|;
name|tree
name|base_class
decl_stmt|;
name|int
name|current_aggr_is_signature
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|base_class
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"invalid base class"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|base_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_aggr_is_signature
operator|&&
name|access_specifier
condition|)
name|error
argument_list|(
literal|"access and source specifiers not allowed in signature"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|current_aggr_is_signature
operator|&&
operator|(
operator|!
name|type
operator|)
operator|&&
operator|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"class name not allowed as base signature"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_aggr_is_signature
condition|)
block|{
name|sorry
argument_list|(
literal|"signature inheritance, base type `%s' ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|access_specifier
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_tree_list
argument_list|(
name|access_public_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|&&
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"signature name not allowed as base class"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|result
operator|=
name|build_tree_list
argument_list|(
name|access_specifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Called when multiple declarators are processed.  If that is not    premitted in this context, an error is issued.  */
end_comment

begin_function
name|void
name|check_multiple_declarators
parameter_list|()
block|{
comment|/* [temp]            In a template-declaration, explicit specialization, or explicit      instantiation the init-declarator-list in the declaration shall      contain at most one declarator.         We don't just use PROCESSING_TEMPLATE_DECL for the first      condition since that would disallow the perfectly legal code,       like `template<class T> struct S { int i, j; };'.  */
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* It's OK to write `template<class T> void f() { int i, j;}'.  */
return|return;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
operator|||
name|processing_explicit_instantiation
operator|||
name|processing_specialization
condition|)
name|cp_error
argument_list|(
literal|"multiple declarators in template declaration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|finish_typeof
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|t
operator|=
name|make_lang_type
argument_list|(
name|TYPEOF_TYPE
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|expr
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

end_unit

