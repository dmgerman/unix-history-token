begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform the semantic phase of parsing, i.e., the process of    building tree structure, checking semantic consistency, and    building RTL.  These routines are used both during actual parsing    and during the instantiation of template functions.      Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Mark Mitchell (mmitchell@usa.net) based on code found    formerly in parse.y and pt.c.       This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.        GNU CC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.        You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* There routines provide a modular interface to perform many parsing    operations.  They may therefore be used during actual parsing, or    during template instantiation, which may be regarded as a    degenerate form of parsing.  Since the current g++ parser is    lacking in several respects, and will be reimplemented, we are    attempting to move most code that is not directly related to    parsing into this file; that will make implementing the new parser    much easier since it will be able to make use of these routines.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|maybe_convert_cond
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|simplify_aggr_init_exprs_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|deferred_type_access_control
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_associated_thunks
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_try_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_eh_spec_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_handler
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_ctor_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_subobject
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_named_return_value
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_expand_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_start_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|genrtl_finish_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|clear_decl_rtl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Finish processing the COND, the SUBSTMT condition for STMT.  */
end_comment

begin_define
define|#
directive|define
name|FINISH_COND
parameter_list|(
name|COND
parameter_list|,
name|STMT
parameter_list|,
name|SUBSTMT
parameter_list|)
define|\
value|do {							\     if (last_tree != (STMT))				\       {							\         RECHAIN_STMTS (STMT, SUBSTMT);			\         if (!processing_template_decl)			\           {						\ 	    (COND) = build_tree_list (SUBSTMT, COND);	\ 	    (SUBSTMT) = (COND);				\           }						\       }							\     else						\       (SUBSTMT) = (COND);				\   } while (0)
end_define

begin_comment
comment|/* Returns non-zero if the current statement is a full expression,    i.e. temporaries created during that statement should be destroyed    at the end of the statement.  */
end_comment

begin_function
name|int
name|stmts_are_full_exprs_p
parameter_list|()
block|{
return|return
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
return|;
block|}
end_function

begin_comment
comment|/* Returns the stmt_tree (if any) to which statements are currently    being added.  If there is no active statement-tree, NULL is    returned.  */
end_comment

begin_function
name|stmt_tree
name|current_stmt_tree
parameter_list|()
block|{
return|return
operator|(
name|cfun
condition|?
operator|&
name|cfun
operator|->
name|language
operator|->
name|x_stmt_tree
else|:
operator|&
name|scope_chain
operator|->
name|x_stmt_tree
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if TYPE is an anonymous union or struct type.  We have to use a    flag for this because "A union for which objects or pointers are    declared is not an anonymous union" [class.union].  */
end_comment

begin_function
name|int
name|anon_aggr_type_p
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
return|return
operator|(
name|CLASS_TYPE_P
argument_list|(
name|node
argument_list|)
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|->
name|anon_aggr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a scope.  */
end_comment

begin_function
name|tree
name|do_poplevel
parameter_list|()
block|{
name|tree
name|block
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
block|{
name|tree
name|scope_stmts
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|scope_stmts
operator|=
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|0
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|scope_stmts
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
name|SCOPE_STMT_BLOCK
argument_list|(
name|TREE_VALUE
argument_list|(
name|scope_stmts
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
block|}
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Begin a new scope.  */
end_comment

begin_function
name|void
name|do_pushlevel
parameter_list|()
block|{
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|add_scope_stmt
argument_list|(
comment|/*begin_p=*/
literal|1
argument_list|,
comment|/*partial_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a goto-statement.  */
end_comment

begin_function
name|tree
name|finish_goto_stmt
parameter_list|(
name|destination
parameter_list|)
name|tree
name|destination
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|destination
operator|=
name|lookup_label
argument_list|(
name|destination
argument_list|)
expr_stmt|;
comment|/* We warn about unused labels with -Wunused.  That means we have to      mark the used labels as used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|TREE_USED
argument_list|(
name|destination
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
comment|/* We don't inline calls to functions with computed gotos.        Those functions are typically up to some funny business,        and may be depending on the labels being at particular        addresses, or some such.  */
name|DECL_UNINLINABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|check_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|GOTO_STMT
argument_list|,
name|destination
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* COND is the condition-expression for an if, while, etc.,    statement.  Convert it to a boolean value, if appropriate.  */
end_comment

begin_function
name|tree
name|maybe_convert_cond
parameter_list|(
name|cond
parameter_list|)
name|tree
name|cond
decl_stmt|;
block|{
comment|/* Empty conditions remain empty.  */
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Wait until we instantiate templates before doing conversion.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|cond
return|;
comment|/* Do the conversion.  */
name|cond
operator|=
name|convert_from_reference
argument_list|(
name|cond
argument_list|)
expr_stmt|;
return|return
name|condition_conversion
argument_list|(
name|cond
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression-statement, whose EXPRESSION is as indicated.  */
end_comment

begin_function
name|tree
name|finish_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
operator|!
operator|(
name|stmts_are_full_exprs_p
argument_list|()
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expr
operator|=
name|convert_to_void
argument_list|(
name|expr
argument_list|,
literal|"statement"
argument_list|)
expr_stmt|;
name|r
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
comment|/* This was an expression-statement, so we save the type of the      expression.  */
name|last_expr_type
operator|=
name|expr
condition|?
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin an if-statement.  Returns a newly created IF_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_if_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|IF_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_if_stmt_cond
parameter_list|(
name|cond
parameter_list|,
name|if_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|if_stmt
decl_stmt|;
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|if_stmt
argument_list|,
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the then-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|tree
name|finish_then_clause
parameter_list|(
name|if_stmt
parameter_list|)
name|tree
name|if_stmt
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|last_tree
operator|=
name|if_stmt
expr_stmt|;
return|return
name|if_stmt
return|;
block|}
end_function

begin_comment
comment|/* Begin the else-clause of an if-statement.  */
end_comment

begin_function
name|void
name|begin_else_clause
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Finish the else-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_else_clause
parameter_list|(
name|if_stmt
parameter_list|)
name|tree
name|if_stmt
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an if-statement.  */
end_comment

begin_function
name|void
name|finish_if_stmt
parameter_list|()
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_out_block
parameter_list|()
block|{
comment|/* If COND wasn't a declaration, clear out the      block we made for it and start a new one here so the      optimization in expand_end_loop will work.  */
if|if
condition|(
name|getdecls
argument_list|()
operator|==
name|NULL_TREE
condition|)
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin a while-statement.  Returns a newly created WHILE_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_while_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|WHILE_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of a while-statement, which may be given by    WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt_cond
parameter_list|(
name|cond
parameter_list|,
name|while_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|while_stmt
decl_stmt|;
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|while_stmt
argument_list|,
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|clear_out_block
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a while-statement, which may be given by WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt
parameter_list|(
name|while_stmt
parameter_list|)
name|tree
name|while_stmt
decl_stmt|;
block|{
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|while_stmt
argument_list|,
name|WHILE_BODY
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a do-statement.  Returns a newly created DO_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_do_stmt
parameter_list|()
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|DO_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the body of a do-statement, which may be given by DO_STMT.  */
end_comment

begin_function
name|void
name|finish_do_body
parameter_list|(
name|do_stmt
parameter_list|)
name|tree
name|do_stmt
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|do_stmt
argument_list|,
name|DO_BODY
argument_list|(
name|do_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a do-statement, which may be given by DO_STMT, and whose    COND is as indicated.  */
end_comment

begin_function
name|void
name|finish_do_stmt
parameter_list|(
name|cond
parameter_list|,
name|do_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|do_stmt
decl_stmt|;
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|DO_COND
argument_list|(
name|do_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a return-statement.  The EXPRESSION returned, if any, is as    indicated.  */
end_comment

begin_function
name|tree
name|finish_return_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expr
operator|=
name|check_return_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Similarly, all destructors must run destructors for 	     base-classes before returning.  So, all returns in a 	     destructor get sent to the DTOR_LABEL; finish_function emits 	     code to return a value there.  */
return|return
name|finish_goto_stmt
argument_list|(
name|dtor_label
argument_list|)
return|;
block|}
block|}
name|r
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|RETURN_STMT
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|begin_for_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|FOR_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|NEW_FOR_SCOPE_P
argument_list|(
name|r
argument_list|)
operator|=
name|flag_new_for_scope
operator|>
literal|0
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEW_FOR_SCOPE_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|do_pushlevel
argument_list|()
expr_stmt|;
name|note_level_for_for
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the for-init-statement of a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_init_stmt
parameter_list|(
name|for_stmt
parameter_list|)
name|tree
name|for_stmt
decl_stmt|;
block|{
if|if
condition|(
name|last_tree
operator|!=
name|for_stmt
condition|)
name|RECHAIN_STMTS
argument_list|(
name|for_stmt
argument_list|,
name|FOR_INIT_STMT
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the COND of a for-statement, which may be given by    FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_cond
parameter_list|(
name|cond
parameter_list|,
name|for_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|for_stmt
decl_stmt|;
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|for_stmt
argument_list|,
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|clear_out_block
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the increment-EXPRESSION in a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_expr
parameter_list|(
name|expr
parameter_list|,
name|for_stmt
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|for_stmt
decl_stmt|;
block|{
name|FOR_EXPR
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a for-statement, which may be given by    FOR_STMT.  The increment-EXPR for the loop must be    provided.  */
end_comment

begin_function
name|void
name|finish_for_stmt
parameter_list|(
name|for_stmt
parameter_list|)
name|tree
name|for_stmt
decl_stmt|;
block|{
comment|/* Pop the scope for the body of the loop.  */
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|for_stmt
argument_list|,
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEW_FOR_SCOPE_P
argument_list|(
name|for_stmt
argument_list|)
condition|)
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a break-statement.  */
end_comment

begin_function
name|tree
name|finish_break_stmt
parameter_list|()
block|{
return|return
name|add_stmt
argument_list|(
name|build_break_stmt
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a continue-statement.  */
end_comment

begin_function
name|tree
name|finish_continue_stmt
parameter_list|()
block|{
return|return
name|add_stmt
argument_list|(
name|build_continue_stmt
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a switch-statement.  Returns a new SWITCH_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_switch_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|SWITCH_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|do_pushlevel
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the cond of a switch-statement.  */
end_comment

begin_function
name|void
name|finish_switch_cond
parameter_list|(
name|cond
parameter_list|,
name|switch_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|tree
name|switch_stmt
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|index
decl_stmt|;
comment|/* Convert the condition to an integer or enumeration type.  */
name|cond
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|cond
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|!=
name|error_mark_node
condition|)
block|{
name|cond
operator|=
name|default_conversion
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|index
operator|=
name|get_unwidened
argument_list|(
name|cond
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	 because if we did, int_fits_type_p would do the wrong thing 	 when checking case values for being in range, 	 and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|cond
operator|=
name|index
expr_stmt|;
block|}
name|FINISH_COND
argument_list|(
name|cond
argument_list|,
name|switch_stmt
argument_list|,
name|SWITCH_COND
argument_list|(
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|push_switch
argument_list|(
name|switch_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a switch-statement, which may be given by    SWITCH_STMT.  The COND to switch on is indicated.  */
end_comment

begin_function
name|void
name|finish_switch_stmt
parameter_list|(
name|switch_stmt
parameter_list|)
name|tree
name|switch_stmt
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|switch_stmt
argument_list|,
name|SWITCH_BODY
argument_list|(
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pop_switch
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a TRY_BLOCK. */
end_comment

begin_function
specifier|static
name|void
name|genrtl_try_block
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|CLEANUP_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_eh_region_end_cleanup
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|emit_line_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|expand_start_all_catch
argument_list|()
expr_stmt|;
name|in_function_try_handler
operator|=
literal|1
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|in_function_try_handler
operator|=
literal|0
expr_stmt|;
name|expand_end_all_catch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|expand_start_all_catch
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_all_catch
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is an EH_SPEC_BLOCK. */
end_comment

begin_function
specifier|static
name|void
name|genrtl_eh_spec_block
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|expand_stmt
argument_list|(
name|EH_SPEC_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_eh_region_end_allowed
argument_list|(
name|EH_SPEC_RAISES
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_call
argument_list|(
name|call_unexpected_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_exc_ptr
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a try-block.  Returns a newly-created TRY_BLOCK if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_try_block
parameter_list|()
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|TRY_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|tree
name|begin_function_try_block
parameter_list|()
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|TRY_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|FN_TRY_BLOCK_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a try-block, which may be given by TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_try_block
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a cleanup try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_cleanup_try_block
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an implicitly generated try-block, with a cleanup is given    by CLEANUP.  */
end_comment

begin_function
name|void
name|finish_cleanup
parameter_list|(
name|cleanup
parameter_list|,
name|try_block
parameter_list|)
name|tree
name|cleanup
decl_stmt|;
name|tree
name|try_block
decl_stmt|;
block|{
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
operator|=
name|cleanup
expr_stmt|;
name|CLEANUP_P
argument_list|(
name|try_block
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|void
name|finish_function_try_block
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|try_block
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|try_block
argument_list|)
argument_list|)
operator|==
name|CTOR_INITIALIZER
condition|)
block|{
comment|/* Chain the compound statement after the CTOR_INITIALIZER.  */
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|try_block
argument_list|)
argument_list|)
operator|=
name|last_tree
expr_stmt|;
comment|/* And make the CTOR_INITIALIZER the body of the try-block.  */
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|in_function_try_handler
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler-sequence for a try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_handler_sequence
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|check_handlers
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|void
name|finish_function_handler_sequence
parameter_list|(
name|try_block
parameter_list|)
name|tree
name|try_block
decl_stmt|;
block|{
name|in_function_try_handler
operator|=
literal|0
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|try_block
argument_list|,
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|check_handlers
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a HANDLER. */
end_comment

begin_function
specifier|static
name|void
name|genrtl_handler
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|genrtl_do_pushlevel
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_start_catch
argument_list|(
name|HANDLER_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_stmt
argument_list|(
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_end_catch
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a handler.  Returns a HANDLER if appropriate.  */
end_comment

begin_function
name|tree
name|begin_handler
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|HANDLER
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Create a binding level for the eh_info and the exception object      cleanup.  */
name|do_pushlevel
argument_list|()
expr_stmt|;
name|note_level_for_catch
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the handler-parameters for a handler, which may be given by    HANDLER.  DECL is the declaration for the catch parameter, or NULL    if this is a `catch (...)' clause.  */
end_comment

begin_function
name|void
name|finish_handler_parms
parameter_list|(
name|decl
parameter_list|,
name|handler
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|handler
decl_stmt|;
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|push_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|handler
argument_list|,
name|HANDLER_PARMS
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|type
operator|=
name|expand_start_catch_block
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|HANDLER_TYPE
argument_list|(
name|handler
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler, which may be given by HANDLER.  The BLOCKs are    the return value from the matching call to finish_handler_parms.  */
end_comment

begin_function
name|void
name|finish_handler
parameter_list|(
name|handler
parameter_list|)
name|tree
name|handler
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_end_catch_block
argument_list|()
expr_stmt|;
name|do_poplevel
argument_list|()
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|handler
argument_list|,
name|HANDLER_BODY
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for T, which is a CTOR_STMT. */
end_comment

begin_function
specifier|static
name|void
name|genrtl_ctor_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|CTOR_BEGIN_P
argument_list|(
name|t
argument_list|)
condition|)
name|begin_protect_partials
argument_list|()
expr_stmt|;
else|else
comment|/* After this point, any exceptions will cause the        destructor to be executed, so we no longer need to worry        about destroying the various subobjects ourselves.  */
name|end_protect_partials
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a compound-statement.  If HAS_NO_SCOPE is non-zero, the    compound-statement does not define a scope.  Returns a new    COMPOUND_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|begin_compound_stmt
parameter_list|(
name|has_no_scope
parameter_list|)
name|int
name|has_no_scope
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
name|int
name|is_try
init|=
literal|0
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_tree
operator|&&
name|TREE_CODE
argument_list|(
name|last_tree
argument_list|)
operator|==
name|TRY_BLOCK
condition|)
name|is_try
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_no_scope
condition|)
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|has_no_scope
condition|)
block|{
name|do_pushlevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_try
condition|)
name|note_level_for_try
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Normally, we try hard to keep the BLOCK for a        statement-expression.  But, if it's a statement-expression with        a scopeless block, there's nothing to keep, and we don't want        to accidentally keep a block *inside* the scopeless block.  */
name|keep_next_level
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a compound-statement, which may be given by COMPOUND_STMT.    If HAS_NO_SCOPE is non-zero, the compound statement does not define    a scope.  */
end_comment

begin_function
name|tree
name|finish_compound_stmt
parameter_list|(
name|has_no_scope
parameter_list|,
name|compound_stmt
parameter_list|)
name|int
name|has_no_scope
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|has_no_scope
condition|)
name|r
operator|=
name|do_poplevel
argument_list|()
expr_stmt|;
else|else
name|r
operator|=
name|NULL_TREE
expr_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|compound_stmt
argument_list|,
name|COMPOUND_BODY
argument_list|(
name|compound_stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When we call finish_stmt we will lose LAST_EXPR_TYPE.  But, since      the precise purpose of that variable is store the type of the      last expression statement within the last compound statement, we      preserve the value.  */
name|t
operator|=
name|last_expr_type
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
name|last_expr_type
operator|=
name|t
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish an asm-statement, whose components are a CV_QUALIFIER, a    STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some    CLOBBERS.  */
end_comment

begin_function
name|tree
name|finish_asm_stmt
parameter_list|(
name|cv_qualifier
parameter_list|,
name|string
parameter_list|,
name|output_operands
parameter_list|,
name|input_operands
parameter_list|,
name|clobbers
parameter_list|)
name|tree
name|cv_qualifier
decl_stmt|;
name|tree
name|string
decl_stmt|;
name|tree
name|output_operands
decl_stmt|;
name|tree
name|input_operands
decl_stmt|;
name|tree
name|clobbers
decl_stmt|;
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|string
argument_list|)
condition|)
name|string
operator|=
name|combine_strings
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv_qualifier
operator|!=
name|NULL_TREE
operator|&&
name|cv_qualifier
operator|!=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
name|warning
argument_list|(
literal|"%s qualifier ignored on asm"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cv_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|cv_qualifier
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ninputs
decl_stmt|;
name|int
name|noutputs
decl_stmt|;
for|for
control|(
name|t
operator|=
name|input_operands
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|converted_operand
init|=
name|decay_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the type of the operand hasn't been determined (e.g., 	     because it involves an overloaded function), then issue 	     an error message.  There's no context available to 	     resolve the overloading.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|converted_operand
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
name|error
argument_list|(
literal|"type of asm operand `%E' could not be determined"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|converted_operand
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|converted_operand
expr_stmt|;
block|}
name|ninputs
operator|=
name|list_length
argument_list|(
name|input_operands
argument_list|)
expr_stmt|;
name|noutputs
operator|=
name|list_length
argument_list|(
name|output_operands
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t
operator|=
name|output_operands
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|bool
name|allows_mem
decl_stmt|;
name|bool
name|allows_reg
decl_stmt|;
name|bool
name|is_inout
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|tree
name|operand
decl_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operand
operator|=
name|TREE_VALUE
argument_list|(
name|output_operands
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
block|{
comment|/* By marking the type as erroneous, we will not try to 		 process this operand again in expand_asm_operands.  */
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
comment|/* If the operand is a DECL that is going to end up in 	     memory, assume it is addressable.  This is a bit more 	     conservative than it would ideally be; the exact test is 	     buried deep in expand_asm_operands and depends on the 	     DECL_RTL for the OPERAND -- which we don't have at this 	     point.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|DECL_P
argument_list|(
name|operand
argument_list|)
condition|)
name|mark_addressable
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|=
name|build_stmt
argument_list|(
name|ASM_STMT
argument_list|,
name|cv_qualifier
argument_list|,
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a label with the indicated NAME.  */
end_comment

begin_function
name|void
name|finish_label_stmt
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|define_label
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_STMT
argument_list|,
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a series of declarations for local labels.  G++ allows users    to declare "local" labels, i.e., labels with scope.  This extension    is useful when writing code involving statement-expressions.  */
end_comment

begin_function
name|void
name|finish_label_decl
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|declare_local_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a SUBOBJECT. */
end_comment

begin_function
specifier|static
name|void
name|genrtl_subobject
parameter_list|(
name|cleanup
parameter_list|)
name|tree
name|cleanup
decl_stmt|;
block|{
name|add_partial_entry
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're in a constructor, and have just constructed a a subobject of    *THIS.  CLEANUP is code to run if an exception is thrown before the    end of the current function is reached.   */
end_comment

begin_function
name|void
name|finish_subobject
parameter_list|(
name|cleanup
parameter_list|)
name|tree
name|cleanup
decl_stmt|;
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|SUBOBJECT
argument_list|,
name|cleanup
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When DECL goes out of scope, make sure that CLEANUP is executed.  */
end_comment

begin_function
name|void
name|finish_decl_cleanup
parameter_list|(
name|decl
parameter_list|,
name|cleanup
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
block|{
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|decl
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for a RETURN_INIT. */
end_comment

begin_function
specifier|static
name|void
name|genrtl_named_return_value
parameter_list|()
block|{
name|tree
name|decl
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
comment|/* If this named return value comes in a register, put it in a      pseudo-register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Note that the mode of the old DECL_RTL may be wider than the 	 mode of DECL_RESULT, depending on the calling conventions for 	 the processor.  For example, on the Alpha, a 32-bit integer 	 is returned in a DImode register -- the DECL_RESULT has 	 SImode but the DECL_RTL for the DECL_RESULT has DImode.  So, 	 here, we use the mode the back-end has already assigned for 	 the return value.  */
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
name|put_var_into_stack
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind a name and initialization to the return value of    the current function.  */
end_comment

begin_function
name|void
name|finish_named_return_value
parameter_list|(
name|return_id
parameter_list|,
name|init
parameter_list|)
name|tree
name|return_id
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
comment|/* Give this error as many times as there are occurrences, so that      users can use Emacs compilation buffers to find and fix all such      places.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ does not permit named return values"
argument_list|)
expr_stmt|;
name|cp_deprecated
argument_list|(
literal|"the named return value extension"
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_id
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|return_id
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"return identifier `%D' already in place"
argument_list|,
name|return_id
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Can't let this happen for constructors.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't redefine default return value for constructors"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have a named return value, put that in our scope as well.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Let `cp_finish_decl' know that this initializer is ok.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|doing_semantic_analysis_p
argument_list|()
condition|)
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|RETURN_INIT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|RETURN_INIT
argument_list|,
name|return_id
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't use tree-inlining for functions with named return values.      That doesn't work properly because we don't do any translation of      the RETURN_INITs when they are copied.  */
name|DECL_UNINLINABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The INIT_LIST is a list of mem-initializers, in the order they were    written by the user.  The TREE_VALUE of each node is a list of    initializers for a particular subobject.  The TREE_PURPOSE is a    FIELD_DECL is the initializer is for a non-static data member, and    a class type if the initializer is for a base class.  */
end_comment

begin_function
name|void
name|finish_mem_initializers
parameter_list|(
name|init_list
parameter_list|)
name|tree
name|init_list
decl_stmt|;
block|{
name|tree
name|member_init_list
decl_stmt|;
name|tree
name|base_init_list
decl_stmt|;
name|tree
name|last_base_warned_about
decl_stmt|;
name|tree
name|next
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|last_base_warned_about
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|init
operator|=
name|init_list
init|;
name|init
condition|;
name|init
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|=
name|member_init_list
expr_stmt|;
name|member_init_list
operator|=
name|init
expr_stmt|;
comment|/* We're running through the initializers from right to left 	     as we process them here.  So, if we see a data member 	     initializer after we see a base initializer, that 	     actually means that the base initializer preceded the 	     data member initializer.  */
if|if
condition|(
name|warn_reorder
operator|&&
name|last_base_warned_about
operator|!=
name|base_init_list
condition|)
block|{
name|tree
name|base
decl_stmt|;
for|for
control|(
name|base
operator|=
name|base_init_list
init|;
name|base
operator|!=
name|last_base_warned_about
condition|;
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|base
argument_list|)
control|)
block|{
name|warning
argument_list|(
literal|"base initializer for `%T'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"   will be re-ordered to precede member initializations"
argument_list|)
expr_stmt|;
block|}
name|last_base_warned_about
operator|=
name|base_init_list
expr_stmt|;
block|}
block|}
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|=
name|base_init_list
expr_stmt|;
name|base_init_list
operator|=
name|init
expr_stmt|;
block|}
block|}
if|if
condition|(
name|processing_template_decl
condition|)
name|add_stmt
argument_list|(
name|build_min_nt
argument_list|(
name|CTOR_INITIALIZER
argument_list|,
name|member_init_list
argument_list|,
name|base_init_list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_base_init
argument_list|(
name|member_init_list
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the stack of SCOPE_STMTs for the current function.  */
end_comment

begin_function
name|tree
modifier|*
name|current_scope_stmt_stack
parameter_list|()
block|{
return|return
operator|&
name|cfun
operator|->
name|language
operator|->
name|x_scope_stmt_stack
return|;
block|}
end_function

begin_comment
comment|/* Finish a parenthesized expression EXPR.  */
end_comment

begin_function
name|tree
name|finish_parenthesized_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* This inhibits warnings in truthvalue_conversion.  */
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|,
name|ERROR_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
comment|/* [expr.unary.op]/3 The qualified id of a pointer-to-member must not be        enclosed in parentheses.  */
name|PTRMEM_OK_P
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Begin a statement-expression.  The value returned must be passed to    finish_stmt_expr.  */
end_comment

begin_function
name|tree
name|begin_stmt_expr
parameter_list|()
block|{
comment|/* If we're outside a function, we won't have a statement-tree to      work with.  But, if we see a statement-expression we need to      create one.  */
if|if
condition|(
operator|!
name|cfun
operator|&&
operator|!
name|last_tree
condition|)
name|begin_stmt_tree
argument_list|(
operator|&
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
name|keep_next_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we're building a statement tree, then the upcoming compound      statement will be chained onto the tree structure, starting at      last_tree.  We return last_tree so that we can later unhook the      compound statement.  */
return|return
name|last_tree
return|;
block|}
end_function

begin_comment
comment|/* Used when beginning a statement-expression outside function scope.    For example, when handling a file-scope initializer, we use this    function.  */
end_comment

begin_function
name|tree
name|begin_global_stmt_expr
parameter_list|()
block|{
if|if
condition|(
operator|!
name|cfun
operator|&&
operator|!
name|last_tree
condition|)
name|begin_stmt_tree
argument_list|(
operator|&
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
name|keep_next_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_tree
operator|!=
name|NULL_TREE
operator|)
condition|?
name|last_tree
else|:
name|expand_start_stmt_expr
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Finish the STMT_EXPR last begun with begin_global_stmt_expr.  */
end_comment

begin_function
name|tree
name|finish_global_stmt_expr
parameter_list|(
name|stmt_expr
parameter_list|)
name|tree
name|stmt_expr
decl_stmt|;
block|{
name|stmt_expr
operator|=
name|expand_end_stmt_expr
argument_list|(
name|stmt_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|&&
name|TREE_CHAIN
argument_list|(
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|finish_stmt_tree
argument_list|(
operator|&
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_comment
comment|/* Finish a statement-expression.  RTL_EXPR should be the value    returned by the previous begin_stmt_expr; EXPR is the    statement-expression.  Returns an expression representing the    statement-expression.  */
end_comment

begin_function
name|tree
name|finish_stmt_expr
parameter_list|(
name|rtl_expr
parameter_list|)
name|tree
name|rtl_expr
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
comment|/* If the last thing in the statement-expression was not an      expression-statement, then it has type `void'.  */
if|if
condition|(
operator|!
name|last_expr_type
condition|)
name|last_expr_type
operator|=
name|void_type_node
expr_stmt|;
name|result
operator|=
name|build_min
argument_list|(
name|STMT_EXPR
argument_list|,
name|last_expr_type
argument_list|,
name|last_tree
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Remove the compound statement from the tree structure; it is      now saved in the STMT_EXPR.  */
name|last_tree
operator|=
name|rtl_expr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last_tree
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If we created a statement-tree for this statement-expression,      remove it now.  */
if|if
condition|(
operator|!
name|cfun
operator|&&
name|TREE_CHAIN
argument_list|(
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|finish_stmt_tree
argument_list|(
operator|&
name|scope_chain
operator|->
name|x_saved_tree
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to FN with ARGS.  Returns a representation of the    call.  */
end_comment

begin_function
name|tree
name|finish_call_expr
parameter_list|(
name|fn
parameter_list|,
name|args
parameter_list|,
name|koenig
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|koenig
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|koenig
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|fn
operator|=
name|build_x_unary_op
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
name|fn
operator|=
name|do_identifier
argument_list|(
name|fn
argument_list|,
literal|2
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_x_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|current_class_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
operator|!
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|result
operator|=
name|require_complete_type
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to a postfix increment or decrement or EXPR.  (Which    is indicated by CODE, which should be POSTINCREMENT_EXPR or    POSTDECREMENT_EXPR.)  */
end_comment

begin_function
name|tree
name|finish_increment_expr
parameter_list|(
name|expr
parameter_list|,
name|code
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
comment|/* If we get an OFFSET_REF, turn it into what it really means (e.g.,      a COMPONENT_REF).  This way if we've got, say, a reference to a      static member that's being operated on, we don't end up trying to      find a member operator for the class it's in.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a use of `this'.  Returns an expression for `this'.  */
end_comment

begin_function
name|tree
name|finish_this_expr
parameter_list|()
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|current_class_ptr
condition|)
block|{
name|result
operator|=
name|current_class_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`this' is unavailable for static member functions"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current_function_decl
condition|)
name|error
argument_list|(
literal|"invalid use of `this' in non-member function"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of `this' at top level"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a member function call using OBJECT and ARGS as arguments to    FN.  Returns an expression for the call.  */
end_comment

begin_function
name|tree
name|finish_object_call_expr
parameter_list|(
name|fn
parameter_list|,
name|object
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|object
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* This is a future direction of this code, but because      build_x_function_call cannot always undo what is done in      build_component_ref entirely yet, we cannot do this.  */
block|tree real_fn = build_component_ref (object, fn, NULL_TREE, 1);   return finish_call_expr (real_fn, args);
else|#
directive|else
if|if
condition|(
name|DECL_DECLARES_TYPE_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* This can happen on code like:  	   class X; 	   template<class T> void f(T t) { 	     t.X(); 	   }    	   We just grab the underlying IDENTIFIER.  */
name|fn
operator|=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"calling type `%T' like a method"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|build_method_call
argument_list|(
name|object
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Finish a qualified member function call using OBJECT and ARGS as    arguments to FN.  Returns an expression for the call.  */
end_comment

begin_function
name|tree
name|finish_qualified_object_call_expr
parameter_list|(
name|fn
parameter_list|,
name|object
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|object
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
return|return
name|build_scoped_method_call
argument_list|(
name|object
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a pseudo-destructor call expression of OBJECT, with SCOPE    being the scope, if any, of DESTRUCTOR.  Returns an expression for    the call.  */
end_comment

begin_function
name|tree
name|finish_pseudo_destructor_call_expr
parameter_list|(
name|object
parameter_list|,
name|scope
parameter_list|,
name|destructor
parameter_list|)
name|tree
name|object
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|destructor
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|PSEUDO_DTOR_EXPR
argument_list|,
name|object
argument_list|,
name|scope
argument_list|,
name|destructor
argument_list|)
return|;
if|if
condition|(
name|scope
operator|&&
name|scope
operator|!=
name|destructor
condition|)
name|error
argument_list|(
literal|"destructor specifier `%T::~%T()' must have matching names"
argument_list|,
name|scope
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scope
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|destructor
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|destructor
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"`%E' is not of type `%T'"
argument_list|,
name|object
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|object
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to a globally qualified member function FN using    ARGS.  Returns an expression for the call.  */
end_comment

begin_function
name|tree
name|finish_qualified_call_expr
parameter_list|(
name|fn
parameter_list|,
name|args
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
else|else
return|return
name|build_member_call
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression of the form CODE EXPR.  */
end_comment

begin_function
name|tree
name|finish_unary_op_expr
parameter_list|(
name|code
parameter_list|,
name|expr
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
decl_stmt|;
comment|/* Inside a template, build_x_unary_op does not fold the      expression. So check whether the result is folded before      setting TREE_NEGATED_INT.  */
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|&&
name|INT_CST_LT
argument_list|(
name|result
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|TREE_NEGATED_INT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish an id-expression.  */
end_comment

begin_function
name|tree
name|finish_id_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|expr
operator|=
name|do_identifier
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|error_mark_node
condition|)
name|expr
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|tree
name|current_type_lookups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform deferred access control for types used in the type of a    declaration.  */
end_comment

begin_function
specifier|static
name|void
name|deferred_type_access_control
parameter_list|()
block|{
name|tree
name|lookup
init|=
name|type_lookups
decl_stmt|;
if|if
condition|(
name|lookup
operator|==
name|error_mark_node
condition|)
return|return;
for|for
control|(
init|;
name|lookup
condition|;
name|lookup
operator|=
name|TREE_CHAIN
argument_list|(
name|lookup
argument_list|)
control|)
name|enforce_access
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|lookup
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|lookup
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decl_type_access_control
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|save_fn
decl_stmt|;
if|if
condition|(
name|type_lookups
operator|==
name|error_mark_node
condition|)
return|return;
name|save_fn
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|current_function_decl
operator|=
name|decl
expr_stmt|;
name|deferred_type_access_control
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|save_fn
expr_stmt|;
comment|/* Now strip away the checks for the current declarator; they were      added to type_lookups after typed_declspecs saved the copy that      ended up in current_type_lookups.  */
name|type_lookups
operator|=
name|current_type_lookups
expr_stmt|;
name|current_type_lookups
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the lookups, if we're doing deferred access control.  */
end_comment

begin_function
name|void
name|save_type_access_control
parameter_list|(
name|lookups
parameter_list|)
name|tree
name|lookups
decl_stmt|;
block|{
if|if
condition|(
name|type_lookups
operator|!=
name|error_mark_node
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|current_type_lookups
argument_list|,
literal|20010301
argument_list|)
expr_stmt|;
name|current_type_lookups
operator|=
name|lookups
expr_stmt|;
block|}
else|else
name|my_friendly_assert
argument_list|(
operator|!
name|lookups
operator|||
name|lookups
operator|==
name|error_mark_node
argument_list|,
literal|20010301
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set things up so that the next deferred access control will succeed.    This is needed for friend declarations see grokdeclarator for details.  */
end_comment

begin_function
name|void
name|skip_type_access_control
parameter_list|()
block|{
name|type_lookups
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the deferred access control.  */
end_comment

begin_function
name|void
name|reset_type_access_control
parameter_list|()
block|{
name|type_lookups
operator|=
name|NULL_TREE
expr_stmt|;
name|current_type_lookups
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a function definition declared with DECL_SPECS and    DECLARATOR.  Returns non-zero if the function-declaration is    legal.  */
end_comment

begin_function
name|int
name|begin_function_definition
parameter_list|(
name|decl_specs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|decl_specs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|decl_specs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_function
argument_list|(
name|specs
argument_list|,
name|declarator
argument_list|,
name|attrs
argument_list|,
name|SF_DEFAULT
argument_list|)
condition|)
return|return
literal|0
return|;
name|deferred_type_access_control
argument_list|()
expr_stmt|;
name|type_lookups
operator|=
name|error_mark_node
expr_stmt|;
comment|/* The things we're about to see are not directly qualified by any      template headers we've seen thus far.  */
name|reset_specialization
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Begin a constructor declarator of the form `SCOPE::NAME'.  Returns    a SCOPE_REF.  */
end_comment

begin_function
name|tree
name|begin_constructor_declarator
parameter_list|(
name|scope
parameter_list|,
name|name
parameter_list|)
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|enter_scope_of
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish an init-declarator.  Returns a DECL.  */
end_comment

begin_function
name|tree
name|finish_declarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|attributes
parameter_list|,
name|prefix_attributes
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|prefix_attributes
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
return|return
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|initialized
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a translation unit.  */
end_comment

begin_function
name|void
name|finish_translation_unit
parameter_list|()
block|{
comment|/* In case there were missing closebraces,      get us back to the global binding level.  */
name|pop_everything
argument_list|()
expr_stmt|;
while|while
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Do file scope __FUNCTION__ et al. */
name|finish_fname_decls
argument_list|()
expr_stmt|;
name|finish_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a template type parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_type_parm
parameter_list|(
name|aggr
parameter_list|,
name|identifier
parameter_list|)
name|tree
name|aggr
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
block|{
if|if
condition|(
name|aggr
operator|!=
name|class_type_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"template type parameters must use the keyword `class' or `typename'"
argument_list|)
expr_stmt|;
name|aggr
operator|=
name|class_type_node
expr_stmt|;
block|}
return|return
name|build_tree_list
argument_list|(
name|aggr
argument_list|,
name|identifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a template template parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_template_parm
parameter_list|(
name|aggr
parameter_list|,
name|identifier
parameter_list|)
name|tree
name|aggr
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|current_template_parms
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|end_template_decl
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
literal|20010110
argument_list|)
expr_stmt|;
return|return
name|finish_template_type_parm
argument_list|(
name|aggr
argument_list|,
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a parameter list, indicated by PARMS.  If ELLIPSIS is    non-zero, the parameter list was terminated by a `...'.  */
end_comment

begin_function
name|tree
name|finish_parmlist
parameter_list|(
name|parms
parameter_list|,
name|ellipsis
parameter_list|)
name|tree
name|parms
decl_stmt|;
name|int
name|ellipsis
decl_stmt|;
block|{
if|if
condition|(
name|parms
condition|)
block|{
comment|/* We mark the PARMS as a parmlist so that declarator processing can          disambiguate certain constructs.  */
name|TREE_PARMLIST
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We do not append void_list_node here, but leave it to grokparms          to do that.  */
name|PARMLIST_ELLIPSIS_P
argument_list|(
name|parms
argument_list|)
operator|=
name|ellipsis
expr_stmt|;
block|}
return|return
name|parms
return|;
block|}
end_function

begin_comment
comment|/* Begin a class definition, as indicated by T.  */
end_comment

begin_function
name|tree
name|begin_class_definition
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check the bases are accessible. */
name|decl_type_access_control
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|reset_type_access_control
argument_list|()
expr_stmt|;
if|if
condition|(
name|processing_template_parmlist
condition|)
block|{
name|error
argument_list|(
literal|"definition of `%#T' inside template parameter list"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* In a definition of a member class template, we will get here with      an implicit typename.  */
if|if
condition|(
name|IMPLICIT_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* A non-implicit typename comes from code like:         template<typename T> struct A {          template<typename U> struct A<T>::B ...       This is erroneous.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid definition of qualified type `%T'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|make_anon_name
argument_list|()
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we generated a partial instantiation of this type, but now      we're seeing a real definition, we're actually looking at a      partial specialization.  Consider:         template<class T, class U>        struct Y {};         template<class T>        struct X {};         template<class T, class U>        void f()        { 	 typename X<Y<T, U>>::A a;        }         template<class T, class U>        struct X<Y<T, U>>        {        };       We have to undo the effects of the previous partial      instantiation.  */
if|if
condition|(
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pedantic
condition|)
block|{
comment|/* Unfortunately, when we're not in pedantic mode, we 	     attempt to actually fill in some of the fields of the 	     partial instantiation, in order to support the implicit 	     typename extension.  Clear those fields now, in 	     preparation for the definition here.  The fields cleared 	     here must match those set in instantiate_class_template. 	     Look for a comment mentioning begin_class_definition 	     there.  */
name|TYPE_BINFO_BASETYPES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_TAGS
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* This isn't a partial instantiation any more.  */
name|PARTIAL_INSTANTIATION_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this type was already complete, and we see another definition,      that's an error.  */
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|duplicate_tag_error
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Update the location of the decl.  */
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
operator|=
name|flag_pack_struct
expr_stmt|;
comment|/* Reset the interface data, at the earliest possible      moment, as it might have been set via a class foo;      before.  */
if|if
condition|(
operator|!
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
block|}
name|reset_specialization
argument_list|()
expr_stmt|;
comment|/* Make a declaration for this class in its own scope.  */
name|build_self_reference
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Finish the member declaration given by DECL.  */
end_comment

begin_function
name|void
name|finish_member_declaration
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
comment|/* The COMPONENT was a friend, not a member, and so there's        nothing for us to do.  */
return|return;
comment|/* We should see only one DECL at a time.  */
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up access control for DECL.  */
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_private_node
operator|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_protected_node
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|TREE_PRIVATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the DECL as a member of the current class.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* [dcl.link]       A C language linkage is ignored for the names of class members      and the member function type of class member functions.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|decl
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
comment|/* Put functions on the TYPE_METHODS list and everything else on the      TYPE_FIELDS list.  Note that these are built up in reverse order.      We reverse them (to obtain declaration order) in finish_struct.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We also need to add this function to the 	 CLASSTYPE_METHOD_VEC.  */
name|add_method
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*error_p=*/
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
comment|/* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields 	 go at the beginning.  The reason is that lookup_field_1 	 searches the list in order, and we want a field name to 	 override a type name so that the "struct stat hack" will 	 work.  In particular:  	   struct S { enum E { }; int E } s; 	   s.E = 3;  	 is legal.  In addition, the FIELD_DECLs must be maintained in 	 declaration order so that class layout works as expected. 	 However, we don't need that order until class layout, so we 	 save a little time by putting FIELD_DECLs on in reverse order 	 here, and then reversing them in finish_struct_1.  (We could 	 also keep a pointer to the correct insertion points in the 	 list.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Enter the DECL into the scope of the class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|USING_DECL
condition|)
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish a class definition T with the indicate ATTRIBUTES.  If SEMI,    the definition is immediately followed by a semicolon.  Returns the    type.  */
end_comment

begin_function
name|tree
name|finish_class_definition
parameter_list|(
name|t
parameter_list|,
name|attributes
parameter_list|,
name|semi
parameter_list|,
name|pop_scope_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|int
name|semi
decl_stmt|;
name|int
name|pop_scope_p
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* finish_struct nukes this anyway; if finish_exception does too,      then it can go.  */
if|if
condition|(
name|semi
condition|)
name|note_got_semicolon
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we got any attributes in class_head, xref_tag will stick them in      TREE_TYPE of the type.  Grab them now.  */
name|attributes
operator|=
name|chainon
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
empty_stmt|;
else|else
block|{
name|t
operator|=
name|finish_struct
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|semi
condition|)
name|note_got_semicolon
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|semi
condition|)
name|check_for_missing_semicolon
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_scope_p
condition|)
name|pop_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
name|type_lookups
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|current_scope
argument_list|()
operator|==
name|current_function_decl
condition|)
name|do_pending_defargs
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Finish processing the default argument expressions cached during    the processing of a class definition.  */
end_comment

begin_function
name|void
name|begin_inline_definitions
parameter_list|()
block|{
if|if
condition|(
name|current_scope
argument_list|()
operator|==
name|current_function_decl
condition|)
name|do_pending_inlines
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing the inline function definitions cached during the    processing of a class definition.  */
end_comment

begin_function
name|void
name|finish_inline_definitions
parameter_list|()
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|clear_inline_text_obstack
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing the declaration of a member class template    TYPES whose template parameters are given by PARMS.  */
end_comment

begin_function
name|tree
name|finish_member_class_template
parameter_list|(
name|types
parameter_list|)
name|tree
name|types
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* If there are declared, but undefined, partial specializations      mixed in with the typespecs they will not yet have passed through      maybe_process_partial_specialization, so we do that here.  */
for|for
control|(
name|t
operator|=
name|types
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
condition|)
name|maybe_process_partial_specialization
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|note_list_got_semicolon
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|grok_x_components
argument_list|(
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
operator|!=
name|current_class_type
condition|)
comment|/* The component was in fact a friend declaration.  We avoid        finish_member_template_decl performing certain checks by        unsetting TYPES.  */
name|types
operator|=
name|NULL_TREE
expr_stmt|;
name|finish_member_template_decl
argument_list|(
name|types
argument_list|)
expr_stmt|;
comment|/* As with other component type declarations, we do      not store the new DECL on the list of      component_decls.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Finish processing a complete template declaration.  The PARMS are    the template parameters.  */
end_comment

begin_function
name|void
name|finish_template_decl
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
if|if
condition|(
name|parms
condition|)
name|end_template_decl
argument_list|()
expr_stmt|;
else|else
name|end_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing a template-id (which names a type) of the form    NAME< ARGS>.  Return the TYPE_DECL for the type named by the    template-id.  If ENTERING_SCOPE is non-zero we are about to enter    the scope of template-id indicated.  */
end_comment

begin_function
name|tree
name|finish_template_type
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|,
name|entering_scope
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|entering_scope
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|lookup_template_class
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|entering_scope
argument_list|,
comment|/*complain=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* SR is a SCOPE_REF node.  Enter the scope of SR, whether it is a    namespace scope or a class scope.  */
end_comment

begin_function
name|void
name|enter_scope_of
parameter_list|(
name|sr
parameter_list|)
name|tree
name|sr
decl_stmt|;
block|{
name|tree
name|scope
init|=
name|TREE_OPERAND
argument_list|(
name|sr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|push_decl_namespace
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|sr
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|!=
name|current_class_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
comment|/* In a declarator for a template class member, the scope will 	     get here as an implicit typename, a TYPENAME_TYPE with a type.  */
name|scope
operator|=
name|TREE_TYPE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|sr
argument_list|,
literal|0
argument_list|)
operator|=
name|scope
expr_stmt|;
block|}
name|push_nested_class
argument_list|(
name|scope
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|sr
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish processing a BASE_CLASS with the indicated ACCESS_SPECIFIER.    Return a TREE_LIST containing the ACCESS_SPECIFIER and the    BASE_CLASS, or NULL_TREE if an error occurred.  The    ACCESS_SPECIFIER is one of    access_{default,public,protected_private}[_virtual]_node.*/
end_comment

begin_function
name|tree
name|finish_base_specifier
parameter_list|(
name|access_specifier
parameter_list|,
name|base_class
parameter_list|)
name|tree
name|access_specifier
decl_stmt|;
name|tree
name|base_class
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|base_class
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cp_type_quals
argument_list|(
name|base_class
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"base class `%T' has cv qualifiers"
argument_list|,
name|base_class
argument_list|)
expr_stmt|;
name|base_class
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|base_class
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_tree_list
argument_list|(
name|access_specifier
argument_list|,
name|base_class
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Called when multiple declarators are processed.  If that is not    premitted in this context, an error is issued.  */
end_comment

begin_function
name|void
name|check_multiple_declarators
parameter_list|()
block|{
comment|/* [temp]            In a template-declaration, explicit specialization, or explicit      instantiation the init-declarator-list in the declaration shall      contain at most one declarator.         We don't just use PROCESSING_TEMPLATE_DECL for the first      condition since that would disallow the perfectly legal code,       like `template<class T> struct S { int i, j; };'.  */
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* It's OK to write `template<class T> void f() { int i, j;}'.  */
return|return;
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
operator|||
name|processing_explicit_instantiation
operator|||
name|processing_specialization
condition|)
name|error
argument_list|(
literal|"multiple declarators in template declaration"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement the __typeof keyword: Return the type of EXPR, suitable for    use as a type-specifier.  */
end_comment

begin_function
name|tree
name|finish_typeof
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TYPEOF_TYPE
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|expr
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the value of the `sizeof' operator.  */
end_comment

begin_function
name|tree
name|finish_sizeof
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|SIZEOF_EXPR
argument_list|,
name|t
argument_list|)
return|;
return|return
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|c_sizeof
argument_list|(
name|t
argument_list|)
else|:
name|expr_sizeof
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of T, measured in bytes.  */
end_comment

begin_function
name|tree
name|finish_alignof
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|ALIGNOF_EXPR
argument_list|,
name|t
argument_list|)
return|;
return|return
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|c_alignof
argument_list|(
name|t
argument_list|)
else|:
name|c_alignof_expr
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the statement T, and its substatements, and any    other statements at its nesting level.  */
end_comment

begin_function
specifier|static
name|void
name|cp_expand_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|CLEANUP_STMT
case|:
name|genrtl_decl_cleanup
argument_list|(
name|CLEANUP_DECL
argument_list|(
name|t
argument_list|)
argument_list|,
name|CLEANUP_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTOR_STMT
case|:
name|genrtl_ctor_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_BLOCK
case|:
name|genrtl_try_block
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_SPEC_BLOCK
case|:
name|genrtl_eh_spec_block
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|HANDLER
case|:
name|genrtl_handler
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBOBJECT
case|:
name|genrtl_subobject
argument_list|(
name|SUBOBJECT_CLEANUP
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_INIT
case|:
name|genrtl_named_return_value
argument_list|()
expr_stmt|;
break|break;
case|case
name|USING_STMT
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Called from expand_body via walk_tree.  Replace all AGGR_INIT_EXPRs    will equivalent CALL_EXPRs.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_aggr_init_exprs_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|aggr_init_expr
decl_stmt|;
name|tree
name|call_expr
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|slot
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|copy_from_buffer_p
decl_stmt|;
name|aggr_init_expr
operator|=
operator|*
name|tp
expr_stmt|;
comment|/* We don't need to walk into types; there's nothing in a type that      needs simplification.  (And, furthermore, there are places we      actively don't want to go.  For example, we don't want to wander      into the default arguments for a FUNCTION_DECL that appears in a      CALL_EXPR.)  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|aggr_init_expr
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Only AGGR_INIT_EXPRs are interesting.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aggr_init_expr
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Form an appropriate CALL_EXPR.  */
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|slot
operator|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|aggr_init_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|aggr_init_expr
argument_list|)
condition|)
block|{
comment|/* Replace the first argument with the address of the third 	 argument to the AGGR_INIT_EXPR.  */
name|mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|slot
argument_list|)
argument_list|)
argument_list|,
name|slot
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|call_expr
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we're using the non-reentrant PCC calling convention, then we      need to copy the returned value out of the static buffer into the      SLOT.  */
name|copy_from_buffer_p
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
operator|!
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|aggr_init_expr
argument_list|)
operator|&&
name|aggregate_value_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|old_ac
init|=
name|flag_access_control
decl_stmt|;
name|flag_access_control
operator|=
literal|0
expr_stmt|;
name|call_expr
operator|=
name|build_aggr_init
argument_list|(
name|slot
argument_list|,
name|call_expr
argument_list|,
name|DIRECT_BIND
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
name|old_ac
expr_stmt|;
name|copy_from_buffer_p
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this AGGR_INIT_EXPR indicates the value returned by a      function, then we want to use the value of the initialized      location as the result.  */
if|if
condition|(
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|aggr_init_expr
argument_list|)
operator|||
name|copy_from_buffer_p
condition|)
block|{
name|call_expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|call_expr
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Replace the AGGR_INIT_EXPR with the CALL_EXPR.  */
name|TREE_CHAIN
argument_list|(
name|call_expr
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|aggr_init_expr
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|call_expr
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Emit all thunks to FN that should be emitted when FN is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|emit_associated_thunks
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
comment|/* When we use vcall offsets, we emit thunks with the virtual      functions to which they thunk. The whole point of vcall offsets      is so that you can know statically the entire set of thunks that      will ever be needed for a given virtual function, thereby      enabling you to output all the thunks with the function itself.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|v
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
for|for
control|(
name|v
operator|=
name|BINFO_VIRTUALS
argument_list|(
name|binfo
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|BV_FN
argument_list|(
name|v
argument_list|)
operator|==
name|fn
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|BV_DELTA
argument_list|(
name|v
argument_list|)
argument_list|)
operator|||
name|BV_USE_VCALL_INDEX_P
argument_list|(
name|v
argument_list|)
operator|)
condition|)
block|{
name|tree
name|thunk
decl_stmt|;
name|tree
name|vcall_index
decl_stmt|;
if|if
condition|(
name|BV_USE_VCALL_INDEX_P
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|vcall_index
operator|=
name|BV_VCALL_INDEX
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|vcall_index
operator|!=
name|NULL_TREE
argument_list|,
literal|20000621
argument_list|)
expr_stmt|;
block|}
else|else
name|vcall_index
operator|=
name|NULL_TREE
expr_stmt|;
name|thunk
operator|=
name|make_thunk
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|vfunc_ptr_type_node
argument_list|,
name|fn
argument_list|)
argument_list|,
name|BV_DELTA
argument_list|(
name|v
argument_list|)
argument_list|,
name|vcall_index
argument_list|)
expr_stmt|;
name|use_thunk
argument_list|(
name|thunk
argument_list|,
comment|/*emit_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL for FN.  */
end_comment

begin_function
name|void
name|expand_body
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|int
name|saved_lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_input_filename
decl_stmt|;
comment|/* When the parser calls us after finishing the body of a template      function, we don't really want to expand the body.  When we're      processing an in-class definition of an inline function,      PROCESSING_TEMPLATE_DECL will no longer be set here, so we have      to look at the function itself.  */
if|if
condition|(
name|processing_template_decl
operator|||
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Normally, collection only occurs in rest_of_compilation.  So, 	 if we don't collect here, we never collect junk generated 	 during the processing of templates until we hit a 	 non-template function.  */
name|ggc_collect
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|simplify_aggr_init_exprs_r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a constructor or destructor body, we have to clone      it.  */
if|if
condition|(
name|maybe_clone_body
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* We don't want to process FN again, so pretend we've written 	 it out, even though we haven't.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* There's no reason to do any of the work here if we're only doing      semantic analysis; this code just generates RTL.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
comment|/* If possible, avoid generating RTL for this function.  Instead,      just record it as an inline function, and wait until end-of-file      to decide whether to write it out or not.  */
if|if
condition|(
comment|/* We have to generate RTL if it's not an inline function.  */
operator|(
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_COMDAT
argument_list|(
name|fn
argument_list|)
operator|)
comment|/* Or if we have to emit code for inline functions anyhow.  */
operator|&&
operator|!
name|flag_keep_inline_functions
comment|/* Or if we actually have a reference to the function.  */
operator|&&
operator|!
name|DECL_NEEDED_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* Set DECL_EXTERNAL so that assemble_external will be called as 	 necessary.  We'll clear it again in finish_file.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Remember this function.  In finish_file we'll decide if 	 we actually need to write this function out.  */
name|defer_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Let the back-end know that this function exists.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compute the appropriate object-file linkage for inline      functions.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|import_export_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If FN is external, then there's no point in generating RTL for      it.  This situation can arise with an inline function under      `-fexternal-templates'; we instantiate the function, even though      we're not planning on emitting it, in case we get a chance to      inline it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
condition|)
return|return;
comment|/* Emit any thunks that should be emitted at the same time as FN.  */
name|emit_associated_thunks
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
comment|/* Optimize the body of the function before expanding it.  */
name|optimize_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_EXPAND
argument_list|)
expr_stmt|;
comment|/* Save the current file name and line number.  When we expand the      body of the function, we'll set LINENO and INPUT_FILENAME so that      error-mesages come out in the right places.  */
name|saved_lineno
operator|=
name|lineno
expr_stmt|;
name|saved_input_filename
operator|=
name|input_filename
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|genrtl_start_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|current_function_is_thunk
operator|=
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Expand the body.  */
name|expand_stmt
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Statements should always be full-expressions at the outermost set      of curly braces for a function.  */
name|my_friendly_assert
argument_list|(
name|stmts_are_full_exprs_p
argument_list|()
argument_list|,
literal|19990831
argument_list|)
expr_stmt|;
comment|/* The outermost statement for a function contains the line number      recorded when we finished processing the function.  */
name|lineno
operator|=
name|STMT_LINENO
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate code for the function.  */
name|genrtl_finish_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If possible, obliterate the body of the function so that it can      be garbage collected.  */
if|if
condition|(
name|dump_enabled_p
argument_list|(
name|TDI_all
argument_list|)
condition|)
comment|/* Keep the body; we're going to dump it.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|&&
name|flag_inline_trees
condition|)
comment|/* We might need the body of this function so that we can expand        it inline somewhere else.  */
empty_stmt|;
else|else
comment|/* We don't need the body; blow it away.  */
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* And restore the current source position.  */
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_EXPAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for walk_tree, used by finish_function to override all    the RETURN_STMTs and pertinent CLEANUP_STMTs for the named return    value optimization.  */
end_comment

begin_function
name|tree
name|nullify_returns_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|tree
name|nrv
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
comment|/* No need to walk into types.  There wouldn't be any need to walk into      non-statements, except that we have to consider STMT_EXPRs.  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|RETURN_STMT
condition|)
name|RETURN_EXPR
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|CLEANUP_STMT
operator|&&
name|CLEANUP_DECL
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|nrv
condition|)
name|CLEANUP_EXPR
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Start generating the RTL for FN.  */
end_comment

begin_function
specifier|static
name|void
name|genrtl_start_function
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
comment|/* Tell everybody what function we're processing.  */
name|current_function_decl
operator|=
name|fn
expr_stmt|;
comment|/* Get the RTL machinery going for this function.  */
name|init_function_start
argument_list|(
name|fn
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let everybody know that we're expanding this function, not doing      semantic analysis.  */
name|expanding_p
operator|=
literal|1
expr_stmt|;
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
comment|/* Let the user know we're compiling this function.  */
name|announce_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Initialize the per-function data.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_PENDING_INLINE_P
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|20000911
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If we already parsed this function, and we're just expanding it 	 now, restore saved state.  */
operator|*
name|cp_function_chain
operator|=
operator|*
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* This function is being processed in whole-function mode; we 	 already did semantic analysis.  */
name|cfun
operator|->
name|x_whole_function_mode_p
operator|=
literal|1
expr_stmt|;
comment|/* If we decided that we didn't want to inline this function, 	 make sure the back-end knows that.  */
if|if
condition|(
operator|!
name|current_function_cannot_inline
condition|)
name|current_function_cannot_inline
operator|=
name|cp_function_chain
operator|->
name|cannot_inline
expr_stmt|;
comment|/* We don't need the saved data anymore.  */
name|free
argument_list|(
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|fn
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tell the cross-reference machinery that we're defining this      function.  */
name|GNU_xref_function
argument_list|(
name|fn
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of how many functions we're presently expanding.  */
operator|++
name|function_depth
expr_stmt|;
comment|/* Create a binding level for the parameters.  */
name|expand_function_start
argument_list|(
name|fn
argument_list|,
comment|/*parms_have_cleanups=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* If this function is `main'.  */
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|fn
argument_list|)
condition|)
name|expand_main_function
argument_list|()
expr_stmt|;
comment|/* Give our named return value the same RTL as our RESULT_DECL.  */
if|if
condition|(
name|current_function_return_value
condition|)
name|COPY_DECL_RTL
argument_list|(
name|DECL_RESULT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|current_function_return_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish generating the RTL for FN.  */
end_comment

begin_function
specifier|static
name|void
name|genrtl_finish_function
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|#
directive|if
literal|0
block|if (write_symbols != NO_DEBUG)     {
comment|/* Keep this code around in case we later want to control debug info 	 based on whether a type is "used".  (jason 1999-11-11) */
block|tree ttype = target_type (fntype);       tree parmdecl;        if (IS_AGGR_TYPE (ttype))
comment|/* Let debugger know it should output info for this type.  */
block|note_debug_info_needed (ttype);        for (parmdecl = DECL_ARGUMENTS (fndecl); parmdecl; parmdecl = TREE_CHAIN (parmdecl)) 	{ 	  ttype = target_type (TREE_TYPE (parmdecl)); 	  if (IS_AGGR_TYPE (ttype))
comment|/* Let debugger know it should output info for this type.  */
block|note_debug_info_needed (ttype); 	}     }
endif|#
directive|endif
comment|/* Clean house because we will need to reorder insns here.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* If we have a named return value, we need to force a return so that      the return register is USEd.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|emit_jump
argument_list|(
name|return_label
argument_list|)
expr_stmt|;
comment|/* We hard-wired immediate_size_expand to zero in start_function.      Expand_function_end will decrement this variable.  So, we set the      variable to one here, so that after the decrement it will remain      zero.  */
name|immediate_size_expand
operator|=
literal|1
expr_stmt|;
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a nested function (like a template instantiation that      we're compiling in the midst of compiling something else), push a      new GC context.  That will keep local variables on the stack from      being collected while we're doing the compilation of this      function.  */
if|if
condition|(
name|function_depth
operator|>
literal|1
condition|)
name|ggc_push_context
argument_list|()
expr_stmt|;
comment|/* There's no need to defer outputting this function any more; we      know we want to output it.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Run the optimizers and output the assembler code for this      function.  */
name|rest_of_compilation
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Undo the call to ggc_push_context above.  */
if|if
condition|(
name|function_depth
operator|>
literal|1
condition|)
name|ggc_pop_context
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Keep this code around in case we later want to control debug info      based on whether a type is "used".  (jason 1999-11-11) */
block|if (ctype&& TREE_ASM_WRITTEN (fn))     note_debug_info_needed (ctype);
endif|#
directive|endif
comment|/* If this function is marked with the constructor attribute, add it      to the list of functions to be called along with constructors      from static duration objects.  */
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fn
argument_list|)
condition|)
name|static_ctors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
comment|/* If this function is marked with the destructor attribute, add it      to the list of functions to be called along with destructors from      static duration objects.  */
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fn
argument_list|)
condition|)
name|static_dtors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
operator|--
name|function_depth
expr_stmt|;
comment|/* In C++, we should never be saving RTL for the function.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_SAVED_INSNS
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|20010903
argument_list|)
expr_stmt|;
comment|/* Since we don't need the RTL for this function anymore, stop      pointing to it.  That's especially important for LABEL_DECLs,      since you can reach all the instructions in the function from the      CODE_LABEL stored in the DECL_RTL for the LABEL_DECL.  Walk the      BLOCK-tree, clearing DECL_RTL for LABEL_DECLs and non-static      local variables.  */
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|clear_decl_rtl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Clear out the RTL for the arguments.  */
for|for
control|(
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|SET_DECL_RTL
argument_list|(
name|t
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_INCOMING_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flag_inline_trees
operator|&&
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|)
condition|)
comment|/* DECL_INITIAL must remain nonzero so we know this was an        actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Let the error reporting routines know that we're outside a      function.  For a nested function, this value is used in      pop_cp_function_context and then reset via pop_function_context.  */
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out the DECL_RTL for the non-static variables in BLOCK and    its sub-blocks.  */
end_comment

begin_function
specifier|static
name|tree
name|clear_decl_rtl
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|nonstatic_local_decl_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
operator|*
name|tp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Perform initialization related to this module.  */
end_comment

begin_function
name|void
name|init_cp_semantics
parameter_list|()
block|{
name|lang_expand_stmt
operator|=
name|cp_expand_stmt
expr_stmt|;
block|}
end_function

end_unit

