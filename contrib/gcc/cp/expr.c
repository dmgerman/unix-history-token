begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert language-specific tree expression to rtl instructions,    for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_function
name|rtx
name|cplus_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|rtx
name|original_target
init|=
name|target
decl_stmt|;
name|int
name|ignore
init|=
name|target
operator|==
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
literal|0
operator|,
name|original_target
operator|=
literal|0
expr_stmt|;
comment|/* No sense saving up arithmetic to be done      if it's all in the wrong mode to form part of an address.      And force_operand won't know whether to sign-extend or zero-extend.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
name|modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
block|{
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference.  	   Cleanups are handled in a language-specific way: they 	   might be run by the called function (true in GNU C++ 	   for parameters with cleanups), or they might be 	   run by the caller, after the call (true in GNU C++ 	   for other cleanup needs).  */
name|tree
name|func
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|,
name|slot
decl_stmt|;
name|tree
name|fn_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|fn_type
argument_list|)
decl_stmt|;
name|tree
name|call_exp
decl_stmt|;
name|rtx
name|call_target
decl_stmt|,
name|return_target
decl_stmt|;
name|int
name|pcc_struct_return
init|=
literal|0
decl_stmt|;
comment|/* The expression `init' wants to initialize what 	   `target' represents.  SLOT holds the slot for TARGET.  */
name|slot
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
comment|/* Should always be called with a target in BLKmode case.  */
name|my_friendly_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
argument_list|,
literal|205
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
argument_list|,
literal|206
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The target the initializer will initialize (CALL_TARGET) 	   must now be directed to initialize the target we are 	   supposed to initialize (TARGET).  The semantics for 	   choosing what CALL_TARGET is is language-specific, 	   as is building the call which will perform the 	   initialization.  It is left here to show the choices that 	   exist for C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't clobber a value that might be part of a default 	       parameter value.  */
name|mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|args
argument_list|)
condition|)
name|args
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|type
operator|=
name|return_type
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
name|pcc_struct_return
operator|=
literal|1
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|call_target
operator|=
name|target
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|call_target
condition|)
block|{
comment|/* Make this a valid memory address now.  The code below assumes 	       that it can compare rtx and make assumptions based on the 	       result.  The assumptions are true only if the address was 	       valid to begin with.  */
name|call_target
operator|=
name|validize_mem
argument_list|(
name|call_target
argument_list|)
expr_stmt|;
block|}
name|call_exp
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|func
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|return_target
operator|=
name|expand_call
argument_list|(
name|call_exp
argument_list|,
name|call_target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_target
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pcc_struct_return
condition|)
block|{
specifier|extern
name|int
name|flag_access_control
decl_stmt|;
name|int
name|old_ac
init|=
name|flag_access_control
decl_stmt|;
name|tree
name|init
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RTL
argument_list|(
name|init
argument_list|)
operator|=
name|return_target
expr_stmt|;
name|flag_access_control
operator|=
literal|0
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|slot
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
name|old_ac
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|init
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
literal|0
argument_list|,
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|init
argument_list|)
operator|=
name|XEXP
argument_list|(
name|return_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|maybe_build_cleanup
argument_list|(
name|convert_from_reference
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
condition|)
name|expand_expr
argument_list|(
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|call_target
operator|=
name|return_target
operator|=
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
name|call_target
operator|=
name|return_target
expr_stmt|;
block|}
if|if
condition|(
name|call_target
operator|!=
name|return_target
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
argument_list|,
literal|317
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|return_target
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|call_target
argument_list|,
name|return_target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|call_target
argument_list|,
name|return_target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|call_target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|my_friendly_abort
argument_list|(
literal|39
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|RTL_EXPR
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
name|call_target
argument_list|)
expr_stmt|;
comment|/* We got back a reference to the type we want.  Now initialize 	       target with that.  */
name|expand_aggr_init
argument_list|(
name|slot
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
return|;
block|}
case|case
name|OFFSET_REF
case|:
block|{
if|#
directive|if
literal|1
return|return
name|expand_expr
argument_list|(
name|default_conversion
argument_list|(
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
else|#
directive|else
comment|/* This is old crusty code, and does not handle all that the 	   resolve_offset_ref function does.  (mrs) */
name|tree
name|base
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
endif|#
directive|endif
block|}
case|case
name|THUNK_DECL
case|:
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|THROW_EXPR
case|:
name|expand_throw
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|UNSAVE_EXPR
case|:
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|unsave_expr_now
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
default|default:
break|break;
block|}
name|my_friendly_abort
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|init_cplus_expand
parameter_list|()
block|{
name|lang_expand_expr
operator|=
name|cplus_expand_expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL had its rtl moved from where callers expect it    to be, fix it up.  RESULT is the nominal rtl for the RESULT_DECL,    which may be a pseudo instead of a hard register.  */
end_comment

begin_function
name|void
name|fixup_result_decl
parameter_list|(
name|decl
parameter_list|,
name|result
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|real_decl_result
expr_stmt|;
block|}
name|store_expr
argument_list|(
name|decl
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero iff DECL is memory-based.  The DECL_RTL of    certain const variables might be a CONST_INT, or a REG    in some cases.  We cannot use `memory_operand' as a test    here because on most RISC machines, a variable's address    is not, by itself, a legitimate address.  */
end_comment

begin_function
name|int
name|decl_in_memory_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
return|;
block|}
end_function

begin_comment
comment|/* Expand this initialization inline and see if it's simple enough that    it can be done at compile-time.  */
end_comment

begin_function
specifier|static
name|tree
name|extract_aggr_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|extract_scalar_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
name|rtx
name|value
decl_stmt|,
name|insns
decl_stmt|,
name|insn
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|init
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|reg_scan
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jump_optimize
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|r
decl_stmt|,
name|to
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|to
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|to
operator|==
name|value
operator|||
operator|(
name|GET_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|SUBREG
operator|&&
name|XEXP
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
operator|==
name|value
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|int
name|extract_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
return|return
literal|0
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|init
operator|=
name|extract_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|extract_scalar_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

