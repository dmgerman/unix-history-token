begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert language-specific tree expression to rtl instructions,    for GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    2000, 2001 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_decl_stmt
specifier|static
name|rtx
name|cplus_expand_expr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook used by output_constant to expand language-specific    constants.  */
end_comment

begin_function
name|tree
name|cplus_expand_constant
parameter_list|(
name|cst
parameter_list|)
name|tree
name|cst
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
condition|)
block|{
case|case
name|PTRMEM_CST
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|member
decl_stmt|;
comment|/* Find the member.  */
name|member
operator|=
name|PTRMEM_CST_MEMBER
argument_list|(
name|cst
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Find the offset for the field.  */
name|tree
name|offset
init|=
name|byte_position
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|cst
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|cst
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|pfn
argument_list|)
expr_stmt|;
name|cst
operator|=
name|build_ptrmemfunc1
argument_list|(
name|type
argument_list|,
name|delta
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* There's nothing to do.  */
break|break;
block|}
return|return
name|cst
return|;
block|}
end_function

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_function
specifier|static
name|rtx
name|cplus_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
comment|/* No sense saving up arithmetic to be done      if it's all in the wrong mode to form part of an address.      And force_operand won't know whether to sign-extend or zero-extend.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
name|modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PTRMEM_CST
case|:
return|return
name|expand_expr
argument_list|(
name|cplus_expand_constant
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|OFFSET_REF
case|:
comment|/* Offset refs should not make it through to here. */
name|abort
argument_list|()
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|THROW_EXPR
case|:
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|MUST_NOT_THROW_EXPR
case|:
name|expand_eh_region_start
argument_list|()
expr_stmt|;
name|ret
operator|=
name|expand_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|expand_eh_region_end_must_not_throw
argument_list|(
name|build_call
argument_list|(
name|terminate_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
case|case
name|EMPTY_CLASS_EXPR
case|:
comment|/* We don't need to generate any code for an empty class.  */
return|return
name|const0_rtx
return|;
default|default:
return|return
name|c_expand_expr
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|init_cplus_expand
parameter_list|()
block|{
name|lang_expand_expr
operator|=
name|cplus_expand_expr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|extract_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|init
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

