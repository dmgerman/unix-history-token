begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert language-specific tree expression to rtl instructions,    for GNU compiler.    Copyright (C) 1988, 92-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static tree extract_aggr_init PROTO((tree, tree)); static tree extract_scalar_init PROTO((tree, tree));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|rtx
name|cplus_expand_expr
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook used by output_constant to expand language-specific    constants.  */
end_comment

begin_function
specifier|static
name|tree
name|cplus_expand_constant
parameter_list|(
name|cst
parameter_list|)
name|tree
name|cst
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
condition|)
block|{
case|case
name|PTRMEM_CST
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|offset
decl_stmt|;
comment|/* Find the member.  */
name|member
operator|=
name|PTRMEM_CST_MEMBER
argument_list|(
name|cst
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Find the offset for the field.  */
name|offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|size_binop
argument_list|(
name|EASY_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|member
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We offset all pointer to data members by 1 so that we 	       can distinguish between a null pointer to data member 	       and the first data member of a structure.  */
name|offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|size_int
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cst
operator|=
name|cp_convert
argument_list|(
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|idx
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|tree
name|delta2
decl_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|cst
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|pfn
argument_list|,
operator|&
name|delta2
argument_list|)
expr_stmt|;
name|cst
operator|=
name|build_ptrmemfunc1
argument_list|(
name|type
argument_list|,
name|delta
argument_list|,
name|idx
argument_list|,
name|pfn
argument_list|,
name|delta2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* There's nothing to do.  */
break|break;
block|}
return|return
name|cst
return|;
block|}
end_function

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_function
specifier|static
name|rtx
name|cplus_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|ignore
init|=
name|target
operator|==
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* No sense saving up arithmetic to be done      if it's all in the wrong mode to form part of an address.      And force_operand won't know whether to sign-extend or zero-extend.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
name|modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AGGR_INIT_EXPR
case|:
block|{
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference.  	   Cleanups are handled in a language-specific way: they 	   might be run by the called function (true in GNU C++ 	   for parameters with cleanups), or they might be 	   run by the caller, after the call (true in GNU C++ 	   for other cleanup needs).  */
name|tree
name|func
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|,
name|slot
decl_stmt|;
name|tree
name|call_exp
decl_stmt|;
name|rtx
name|call_target
decl_stmt|,
name|return_target
decl_stmt|;
name|int
name|pcc_struct_return
init|=
literal|0
decl_stmt|;
comment|/* The expression `init' wants to initialize what 	   `target' represents.  SLOT holds the slot for TARGET.  */
name|slot
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Should always be called with a target.  */
name|my_friendly_assert
argument_list|(
name|target
operator|!=
name|NULL_RTX
argument_list|,
literal|205
argument_list|)
expr_stmt|;
comment|/* The target the initializer will initialize (CALL_TARGET) 	   must now be directed to initialize the target we are 	   supposed to initialize (TARGET).  The semantics for 	   choosing what CALL_TARGET is is language-specific, 	   as is building the call which will perform the 	   initialization.  It is left here to show the choices that 	   exist for C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't clobber a value that might be part of a default 	       parameter value.  */
name|mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|args
argument_list|)
condition|)
name|args
operator|=
name|expr_tree_cons
argument_list|(
literal|0
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|call_target
operator|=
name|target
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|pcc_struct_return
operator|=
literal|1
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|call_exp
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|func
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|call_exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|return_target
operator|=
name|expand_call
argument_list|(
name|call_exp
argument_list|,
name|call_target
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_target
condition|)
comment|/* Trust that the right thing has been done; it's too hard to 	     verify.  */
return|return
name|return_target
return|;
comment|/* If we're suffering under the ancient PCC_STATIC_STRUCT_RETURN 	   calling convention, we need to copy the return value out of 	   the static return buffer into slot.  */
if|if
condition|(
name|pcc_struct_return
condition|)
block|{
specifier|extern
name|int
name|flag_access_control
decl_stmt|;
name|int
name|old_ac
init|=
name|flag_access_control
decl_stmt|;
name|tree
name|init
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_RTL
argument_list|(
name|init
argument_list|)
operator|=
name|XEXP
argument_list|(
name|return_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_from_reference
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
literal|0
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|slot
argument_list|,
name|init
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
name|old_ac
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|init
operator|=
name|maybe_build_cleanup
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
condition|)
name|expand_expr
argument_list|(
name|init
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
return|;
block|}
case|case
name|PTRMEM_CST
case|:
return|return
name|expand_expr
argument_list|(
name|cplus_expand_constant
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|OFFSET_REF
case|:
block|{
return|return
name|expand_expr
argument_list|(
name|default_conversion
argument_list|(
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
case|case
name|THUNK_DECL
case|:
return|return
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
return|;
case|case
name|THROW_EXPR
case|:
name|expand_throw
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|VEC_INIT_EXPR
case|:
return|return
name|expand_expr
argument_list|(
name|expand_vec_init
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
case|case
name|NEW_EXPR
case|:
return|return
name|expand_expr
argument_list|(
name|build_new_1
argument_list|(
name|exp
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
default|default:
break|break;
block|}
name|my_friendly_abort
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|init_cplus_expand
parameter_list|()
block|{
name|lang_expand_expr
operator|=
name|cplus_expand_expr
expr_stmt|;
name|lang_expand_constant
operator|=
name|cplus_expand_constant
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL had its rtl moved from where callers expect it    to be, fix it up.  RESULT is the nominal rtl for the RESULT_DECL,    which may be a pseudo instead of a hard register.  */
end_comment

begin_function
name|void
name|fixup_result_decl
parameter_list|(
name|decl
parameter_list|,
name|result
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|real_decl_result
expr_stmt|;
block|}
name|store_expr
argument_list|(
name|decl
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Expand this initialization inline and see if it's simple enough that    it can be done at compile-time.  */
end_comment

begin_endif
unit|static tree extract_aggr_init (decl, init)      tree decl, init; {   return 0; }  static tree extract_scalar_init (decl, init)      tree decl, init; {   rtx value, insns, insn;   extern struct obstack temporary_obstack;   tree t = NULL_TREE;    push_obstacks (&temporary_obstack,&temporary_obstack);   start_sequence ();   value = expand_expr (init, NULL_RTX, VOIDmode, 0);   insns = get_insns ();   end_sequence ();   reg_scan (insns, max_reg_num (), 0);   jump_optimize (insns, 0, 0, 1);   pop_obstacks ();    for (insn = insns; insn; insn = NEXT_INSN (insn))     {       rtx r, to;        if (GET_CODE (insn) == NOTE) 	continue;       else if (GET_CODE (insn) != INSN) 	return 0;        r = PATTERN (insn);       if (GET_CODE (r) != SET) 	return 0;        to = XEXP (r, 0);        if (! (to == value 	     || (GET_CODE (to) == SUBREG&& XEXP (to, 0) == value))) 	return 0;        r = XEXP (r, 1);        switch (GET_CODE (r)) 	{ 	case CONST_INT: 	  t = build_int_2 (XEXP (r, 0), 0); 	  break; 	default: 	  return 0; 	}     }    return t;  }
endif|#
directive|endif
end_endif

begin_function
name|int
name|extract_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|init
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
if|#
directive|if
literal|0
block|if (IS_AGGR_TYPE (TREE_TYPE (decl))       || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)     init = extract_aggr_init (decl, init);   else     init = extract_scalar_init (decl, init);    if (init == NULL_TREE)     return 0;    DECL_INITIAL (decl) = init;   return 1;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|do_case
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|tree
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|tree
name|value1
init|=
name|NULL_TREE
decl_stmt|,
name|value2
init|=
name|NULL_TREE
decl_stmt|,
name|label
decl_stmt|;
if|if
condition|(
name|start
operator|!=
name|NULL_TREE
operator|&&
name|TREE_TYPE
argument_list|(
name|start
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|start
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"pointers are not permitted as case values"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids range expressions in switch statement"
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|CASE_LABEL
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|start
condition|)
name|value1
operator|=
name|check_cp_case_value
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
name|value2
operator|=
name|check_cp_case_value
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value1
operator|!=
name|error_mark_node
operator|&&
name|value2
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|duplicate
decl_stmt|;
name|int
name|success
decl_stmt|;
if|if
condition|(
name|end
condition|)
name|success
operator|=
name|pushcase_range
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|,
name|convert_and_check
argument_list|,
name|label
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|start
condition|)
name|success
operator|=
name|pushcase
argument_list|(
name|value1
argument_list|,
name|convert_and_check
argument_list|,
name|label
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|pushcase
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
name|label
argument_list|,
operator|&
name|duplicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|end
condition|)
name|error
argument_list|(
literal|"case label not within a switch statement"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|start
condition|)
name|cp_error
argument_list|(
literal|"case label `%E' not within a switch statement"
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"default label not within a switch statement"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|success
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|end
condition|)
block|{
name|error
argument_list|(
literal|"duplicate (or overlapping) case value"
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"this is the first entry overlapping that value"
argument_list|,
name|duplicate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
condition|)
block|{
name|cp_error
argument_list|(
literal|"duplicate case value `%E'"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"previously used here"
argument_list|,
name|duplicate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"multiple default labels in one switch"
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"this is the first default label"
argument_list|,
name|duplicate
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|success
operator|==
literal|3
condition|)
name|warning
argument_list|(
literal|"case value out of range"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|success
operator|==
literal|4
condition|)
name|warning
argument_list|(
literal|"empty range specified"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|success
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|end
condition|)
name|error
argument_list|(
literal|"case label within scope of cleanup or variable array"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|start
condition|)
name|error
argument_list|(
literal|"`default' label within scope of cleanup or variable array"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"case label `%E' within scope of cleanup or variable array"
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
block|}
name|define_case_label
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

