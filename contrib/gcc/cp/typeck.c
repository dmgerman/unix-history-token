begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C++ compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C++ front end.    It contains routines to build C++ expressions given their operands,    including computing the types of the result, C and C++ specific error    checks, and some optimization.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_function_decl
specifier|static
name|tree
name|pfn_from_ptrmemfunc
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|cp_pointer_int_sum
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|rationalize_conditional_expr
parameter_list|(
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_ptr_ttypes_real
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|comp_except_types
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|comp_array_types
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|common_base_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_delta_difference
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|casts_away_constness_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|casts_away_constness
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_warn_about_returning_address_of_local
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_destructor
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)    Returns the error_mark_node if the VALUE does not have    complete type when this function returns.  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|processing_template_decl
operator|||
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|value
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value
return|;
if|if
condition|(
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|value
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Try to complete TYPE, if it is incomplete.  For example, if TYPE is    a template instantiation, do the instantiation.  Returns TYPE,    whether or not it could be completed, unless something goes    horribly wrong, in which case the error_mark_node is returned.  */
end_comment

begin_function
name|tree
name|complete_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
comment|/* Rather than crash, we return something sure to cause an error        at some point.  */
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|needs_constructing
decl_stmt|,
name|has_nontrivial_dtor
decl_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|type
argument_list|)
condition|)
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|needs_constructing
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|has_nontrivial_dtor
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|=
name|needs_constructing
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
name|has_nontrivial_dtor
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
condition|)
name|instantiate_class_template
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Like complete_type, but issue an error if the TYPE cannot be completed.    VALUE is used for informative diagnostics.    Returns NULL_TREE if the type cannot be made complete.  */
end_comment

begin_function
name|tree
name|complete_type_or_else
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* We already issued an error.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_diagnostic
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether type of EXP is instantiated.  */
end_comment

begin_function
name|int
name|type_unknown_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two parameter lists.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     As an optimization, free the space we allocate if the parameter    lists are already common.  */
end_comment

begin_function
specifier|static
name|tree
name|commonparms
parameter_list|(
name|tree
name|p1
parameter_list|,
name|tree
name|p2
parameter_list|)
block|{
name|tree
name|oldargs
init|=
name|p1
decl_stmt|,
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|any_change
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|tree_last
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newargs
operator|==
name|void_list_node
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|!=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|merge_types
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_change
condition|)
return|return
name|oldargs
return|;
return|return
name|newargs
return|;
block|}
end_function

begin_comment
comment|/* Given a type, perhaps copied for a typedef,    find the "original" version of it.  */
end_comment

begin_function
specifier|static
name|tree
name|original_type
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|x
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
break|break;
name|x
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
condition|)
break|break;
name|t
operator|=
name|x
expr_stmt|;
block|}
return|return
name|cp_build_qualified_type
argument_list|(
name|t
argument_list|,
name|quals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* T1 and T2 are arithmetic or enumeration types.  Return the type    that will result from the "usual arithmetic conversions" on T1 and    T2 as described in [expr].  */
end_comment

begin_function
name|tree
name|type_after_usual_arithmetic_conversions
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
init|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* FIXME: Attributes.  */
name|gcc_assert
argument_list|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
comment|/* In what follows, we slightly generalize the rules given in [expr] so      as to deal with `long long' and `complex'.  First, merge the      attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* If one type is complex, form the common type of the non-complex      components, then make that complex.  Use T1 or T2 if it is the      required type.  */
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|subtype1
init|=
name|code1
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
decl_stmt|;
name|tree
name|subtype2
init|=
name|code2
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
else|:
name|t2
decl_stmt|;
name|tree
name|subtype
init|=
name|type_after_usual_arithmetic_conversions
argument_list|(
name|subtype1
argument_list|,
name|subtype2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|build_complex_type
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|if
condition|(
name|code1
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* When we get here we should have two vectors of the same size. 	 Just prefer the unsigned one if present.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Perform the integral promotions.  */
if|if
condition|(
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
name|t1
operator|=
name|type_promotes_to
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|type_promotes_to
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* The types are the same; no need to do anything fancy.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
comment|/* If one is a sizetype, use it so size_binop doesn't blow up.  */
if|if
condition|(
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* If one is unsigned long long, then convert the other to unsigned 	 long long.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* If one is a long long, and the other is an unsigned long, and 	 long long can represent all the values of an unsigned long, then 	 convert to a long long.  Otherwise, convert to an unsigned long 	 long.  Otherwise, if either operand is long long, convert the 	 other to long long.  	 Since we're here, we know the TYPE_PRECISION is the same; 	 therefore converting to long long cannot represent all the values 	 of an unsigned long, so we choose unsigned long long in that 	 case.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
operator|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|t2
argument_list|)
operator|)
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
decl_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Go through the same procedure, but for longs.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
operator|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|t2
argument_list|)
operator|)
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
operator|)
decl_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|double_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|double_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|float_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|float_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|float_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Two floating-point types whose TYPE_MAIN_VARIANTs are none of 	 the standard C++ floating-point types.  Logic earlier in this 	 function has already eliminated the possibility that 	 TYPE_PRECISION (t2) != TYPE_PRECISION (t1), so there's no 	 compelling reason to choose one or the other.  */
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of composite_pointer_type to implement the recursive    case.  See that function for documentation fo the parameters.  */
end_comment

begin_function
specifier|static
name|tree
name|composite_pointer_type_r
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
block|{
name|tree
name|pointee1
decl_stmt|;
name|tree
name|pointee2
decl_stmt|;
name|tree
name|result_type
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Determine the types pointed to by T1 and T2.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|pointee1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|pointee2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pointee1
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|pointee2
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.rel]       Otherwise, the composite pointer type is a pointer type      similar (_conv.qual_) to the type of one of the operands,      with a cv-qualification signature (_conv.qual_) that is the      union of the cv-qualification signatures of the operand      types.  */
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|pointee1
argument_list|,
name|pointee2
argument_list|)
condition|)
name|result_type
operator|=
name|pointee1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|pointee1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|pointee2
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|pointee1
argument_list|)
operator|&&
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|pointee2
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|composite_pointer_type_r
argument_list|(
name|pointee1
argument_list|,
name|pointee2
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|else
block|{
name|pedwarn
argument_list|(
literal|"%s between distinct pointer types %qT and %qT "
literal|"lacks a cast"
argument_list|,
name|location
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
name|result_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|result_type
argument_list|,
operator|(
name|cp_type_quals
argument_list|(
name|pointee1
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|pointee2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If the original types were pointers to members, so is the      result.  */
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%s between distinct pointer types %qT and %qT "
literal|"lacks a cast"
argument_list|,
name|location
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_ptrmem_type
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|result_type
argument_list|)
expr_stmt|;
block|}
else|else
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|result_type
argument_list|,
name|attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the composite pointer type (see [expr.rel]) for T1 and T2.    ARG1 and ARG2 are the values with those types.  The LOCATION is a    string describing the current location, in case an error occurs.     This routine also implements the computation of a common type for    pointers-to-members as per [expr.eq].  */
end_comment

begin_function
name|tree
name|composite_pointer_type
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|,
specifier|const
name|char
modifier|*
name|location
parameter_list|)
block|{
name|tree
name|class1
decl_stmt|;
name|tree
name|class2
decl_stmt|;
comment|/* [expr.rel]       If one operand is a null pointer constant, the composite pointer      type is the type of the other operand.  */
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|t1
return|;
comment|/* We have:         [expr.rel]         If one of the operands has type "pointer to cv1 void*", then        the other has type "pointer to cv2T", and the composite pointer        type is "pointer to cv12 void", where cv12 is the union of cv1        and cv2.      If either type is a pointer to void, make sure it is T1.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
name|t1
operator|=
name|t2
expr_stmt|;
name|t2
operator|=
name|t
expr_stmt|;
block|}
comment|/* Now, if T1 is a pointer to void, merge the qualifiers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|attributes
decl_stmt|;
name|tree
name|result_type
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_PTRFN_P
argument_list|(
name|t2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids %s between pointer of type %<void *%> "
literal|"and pointer-to-function"
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
operator|(
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|result_type
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|objc_compare_types
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
operator|-
literal|3
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|t1
return|;
block|}
comment|/* [expr.eq] permits the application of a pointer conversion to      bring the pointers to a common type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|class1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|class2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|class1
argument_list|,
name|class2
argument_list|)
condition|)
name|t2
operator|=
operator|(
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|class1
argument_list|,
name|TYPE_QUALS
argument_list|(
name|class2
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|class2
argument_list|,
name|class1
argument_list|)
condition|)
name|t1
operator|=
operator|(
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|class2
argument_list|,
name|TYPE_QUALS
argument_list|(
name|class1
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"%s between distinct pointer types %qT and %qT "
literal|"lacks a cast"
argument_list|,
name|location
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* [expr.eq] permits the application of a pointer-to-member      conversion to change the class type of one of the types.  */
elseif|else
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|class1
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|class2
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|class1
argument_list|,
name|class2
argument_list|)
condition|)
name|t1
operator|=
name|build_ptrmem_type
argument_list|(
name|class2
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|class2
argument_list|,
name|class1
argument_list|)
condition|)
name|t2
operator|=
name|build_ptrmem_type
argument_list|(
name|class1
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"%s between distinct pointer-to-member types %qT and %qT "
literal|"lacks a cast"
argument_list|,
name|location
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|composite_pointer_type_r
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|location
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the merged type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This just combines attributes and default arguments; any other    differences would cause the two types to compare unalike.  */
end_comment

begin_function
name|tree
name|merge_types
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|original_type
argument_list|(
name|t1
argument_list|)
operator|==
name|original_type
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type.  */
block|{
name|tree
name|target
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|t1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_reference_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
name|t1
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
block|{
name|int
name|quals
decl_stmt|;
name|tree
name|pointee
decl_stmt|;
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|pointee
operator|=
name|merge_types
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_ptrmem_type
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|pointee
argument_list|)
expr_stmt|;
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
name|t1
argument_list|,
name|quals
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
name|t1
operator|=
name|build_cplus_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|raises
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|p2
condition|)
return|return
name|cp_build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|p1
condition|)
return|return
name|cp_build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|p1
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|cp_build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|commonparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|METHOD_TYPE
case|:
block|{
comment|/* Get this value the long way, since TYPE_METHOD_BASETYPE 	   is just the main variant of this.  */
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|t3
decl_stmt|;
comment|/* If this was a member function type, get back to the 	   original type of type member function (i.e., without 	   the class instance variable up front.  */
name|t1
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|merge_types
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|t3
operator|=
name|build_method_type_directly
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|t3
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t3
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_exception_variant
argument_list|(
name|t3
argument_list|,
name|raises
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYPENAME_TYPE
case|:
comment|/* There is no need to merge attributes into a TYPENAME_TYPE. 	 When the type is instantiated it will have whatever 	 attributes result from the instantiation.  */
return|return
name|t1
return|;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|attributes
argument_list|)
condition|)
return|return
name|t1
return|;
elseif|else
if|if
condition|(
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
argument_list|,
name|attributes
argument_list|)
condition|)
return|return
name|t2
return|;
else|else
return|return
name|cp_build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This is the type for the result of most arithmetic operations    if the operands have the given two types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
comment|/* If one type is nonsense, bail.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
operator|||
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|||
name|code1
operator|==
name|ENUMERAL_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|||
name|code2
operator|==
name|ENUMERAL_TYPE
operator|||
name|code2
operator|==
name|VECTOR_TYPE
operator|)
condition|)
return|return
name|type_after_usual_arithmetic_conversions
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTR_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
return|return
name|composite_pointer_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|,
literal|"conversion"
argument_list|)
return|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two exception specifier types for exactness or subsetness, if    allowed. Returns false for mismatch, true for match (same, or    derived and !exact).     [except.spec] "If a class X ... objects of class X or any class publicly    and unambiguously derived from X. Similarly, if a pointer type Y * ...    exceptions of type Y * or that are pointers to any type publicly and    unambiguously derived from Y. Otherwise a function only allows exceptions    that have the same type ..."    This does not mention cv qualifiers and is different to what throw    [except.throw] and catch [except.catch] will do. They will ignore the    top level cv qualifiers, and allow qualifiers in the pointer to class    example.     We implement the letter of the standard.  */
end_comment

begin_function
specifier|static
name|bool
name|comp_except_types
parameter_list|(
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|,
name|bool
name|exact
parameter_list|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|cp_type_quals
argument_list|(
name|a
argument_list|)
operator|||
name|cp_type_quals
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|a
operator|=
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|TREE_TYPE
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_type_quals
argument_list|(
name|a
argument_list|)
operator|||
name|cp_type_quals
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|PUBLICLY_UNIQUELY_DERIVED_P
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE1 and TYPE2 are equivalent exception specifiers.    If EXACT is false, T2 can be stricter than T1 (according to 15.4/7),    otherwise it must be exact. Exception lists are unordered, but    we've already filtered out duplicates. Most lists will be in order,    we should try to make use of that.  */
end_comment

begin_function
name|bool
name|comp_except_specs
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|bool
name|exact
parameter_list|)
block|{
name|tree
name|probe
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|true
return|;
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
comment|/* T1 is ...  */
return|return
name|t2
operator|==
name|NULL_TREE
operator|||
operator|!
name|exact
return|;
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
condition|)
comment|/* t1 is EMPTY */
return|return
name|t2
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
comment|/* T2 is ...  */
return|return
name|false
return|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
condition|)
comment|/* T2 is EMPTY, T1 is not */
return|return
operator|!
name|exact
return|;
comment|/* Neither set is ... or EMPTY, make sure each part of T2 is in T1.      Count how many we find, to determine exactness. For exact matching and      ordered T1, T2, this is an O(n) operation, otherwise its worst case is      O(nm).  */
for|for
control|(
name|base
operator|=
name|t1
init|;
name|t2
operator|!=
name|NULL_TREE
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
for|for
control|(
name|probe
operator|=
name|base
init|;
name|probe
operator|!=
name|NULL_TREE
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|TREE_VALUE
argument_list|(
name|probe
argument_list|)
decl_stmt|;
name|tree
name|b
init|=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp_except_types
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|exact
argument_list|)
condition|)
block|{
if|if
condition|(
name|probe
operator|==
name|base
operator|&&
name|exact
condition|)
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|probe
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
block|}
return|return
operator|!
name|exact
operator|||
name|base
operator|==
name|NULL_TREE
operator|||
name|length
operator|==
name|list_length
argument_list|(
name|t1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the array types T1 and T2.  ALLOW_REDECLARATION is true if    [] can match [size].  */
end_comment

begin_function
specifier|static
name|bool
name|comp_array_types
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|bool
name|allow_redeclaration
parameter_list|)
block|{
name|tree
name|d1
decl_stmt|;
name|tree
name|d2
decl_stmt|;
name|tree
name|max1
decl_stmt|,
name|max2
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|true
return|;
comment|/* The type of the array elements must be the same.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|d1
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|==
name|d2
condition|)
return|return
name|true
return|;
comment|/* If one of the arrays is dimensionless, and the other has a      dimension, they are of different types.  However, it is valid to      write:         extern int a[];        int a[3];       by [basic.link]:         declarations for an array object can specify        array types that differ by the presence or absence of a major        array bound (_dcl.array_).  */
if|if
condition|(
operator|!
name|d1
operator|||
operator|!
name|d2
condition|)
return|return
name|allow_redeclaration
return|;
comment|/* Check that the dimensions are the same.  */
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|max1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|max2
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
operator|!
name|value_dependent_expression_p
argument_list|(
name|max1
argument_list|)
operator|&&
operator|!
name|value_dependent_expression_p
argument_list|(
name|max2
argument_list|)
condition|)
block|{
comment|/* With abi-1 we do not fold non-dependent array bounds, (and 	 consequently mangle them incorrectly).  We must therefore 	 fold them here, to verify the domains have the same 	 value.  */
name|max1
operator|=
name|fold
argument_list|(
name|max1
argument_list|)
expr_stmt|;
name|max2
operator|=
name|fold
argument_list|(
name|max2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|max1
argument_list|,
name|max2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if T1 and T2 are related as allowed by STRICT.  STRICT    is a bitwise-or of the COMPARE_* flags.  */
end_comment

begin_function
name|bool
name|comptypes
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|true
return|;
comment|/* Suppress errors caused by previously reported errors.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
operator|||
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TYPENAME_TYPEs should be resolved if the qualifying scope is the      current instantiation.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|tree
name|resolved
init|=
name|resolve_typename_type
argument_list|(
name|t1
argument_list|,
comment|/*only_current_p=*/
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolved
operator|!=
name|error_mark_node
condition|)
name|t1
operator|=
name|resolved
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|tree
name|resolved
init|=
name|resolve_typename_type
argument_list|(
name|t2
argument_list|,
comment|/*only_current_p=*/
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolved
operator|!=
name|error_mark_node
condition|)
name|t2
operator|=
name|resolved
expr_stmt|;
block|}
comment|/* If either type is the internal version of sizetype, use the      language version.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_ORIG_SIZE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Qualifiers must match.  For array types, we will check when we      recur on the array element types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_FOR_JAVA
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      qualifiers (just above).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Compare the types.  Break out if they could be the same.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
if|if
condition|(
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t2
argument_list|)
operator|||
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
break|break;
comment|/* Don't check inheritance.  */
name|strict
operator|=
name|COMPARE_STRICT
expr_stmt|;
comment|/* Fall through.  */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_TI_TEMPLATE
argument_list|(
name|t2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|)
operator|&&
name|comp_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_TI_ARGS
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|strict
operator|&
name|COMPARE_BASE
operator|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|strict
operator|&
name|COMPARE_DERIVED
operator|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
break|break;
return|return
name|false
return|;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
operator|&
operator|~
name|COMPARE_REDECLARATION
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|t2
argument_list|)
operator|||
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|t2
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
operator|!
name|comp_array_types
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
operator|!
operator|!
operator|(
name|strict
operator|&
name|COMPARE_REDECLARATION
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
if|if
condition|(
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t2
argument_list|)
operator|||
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
if|if
condition|(
operator|!
name|cp_tree_equal
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t2
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/* If we get here, we know that from a target independent POV the      types are the same.  Make sure the target attributes are also      the same.  */
return|return
name|targetm
operator|.
name|comp_type_attributes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */
end_comment

begin_function
name|bool
name|at_least_as_qualified_p
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
name|int
name|q1
init|=
name|cp_type_quals
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|int
name|q2
init|=
name|cp_type_quals
argument_list|(
name|type2
argument_list|)
decl_stmt|;
comment|/* All qualifiers for TYPE2 must also appear in TYPE1.  */
return|return
operator|(
name|q1
operator|&
name|q2
operator|)
operator|==
name|q2
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is more cv-qualified than TYPE2, -1 if TYPE2 is    more cv-qualified that TYPE1, and 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_cv_qualification
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
name|int
name|q1
init|=
name|cp_type_quals
argument_list|(
name|type1
argument_list|)
decl_stmt|;
name|int
name|q2
init|=
name|cp_type_quals
argument_list|(
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|q1
operator|&
name|q2
operator|)
operator|==
name|q2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|q1
operator|&
name|q2
operator|)
operator|==
name|q1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the cv-qualification signature of TYPE1 is a proper    subset of the cv-qualification signature of TYPE2, and the types    are similar.  Returns -1 if the other way 'round, and 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_cv_qual_signature
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
if|if
condition|(
name|comp_ptr_ttypes_real
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes_real
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If two types share a common base type, return that basetype.    If there is not a unique most-derived base type, this function    returns ERROR_MARK_NODE.  */
end_comment

begin_function
specifier|static
name|tree
name|common_base_type
parameter_list|(
name|tree
name|tt1
parameter_list|,
name|tree
name|tt2
parameter_list|)
block|{
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If one is a baseclass of another, that's good enough.  */
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt1
argument_list|,
name|tt2
argument_list|)
condition|)
return|return
name|tt1
return|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt2
argument_list|,
name|tt1
argument_list|)
condition|)
return|return
name|tt2
return|;
comment|/* Otherwise, try to find a unique baseclass of TT1      that is shared by TT2, and follow that down.  */
for|for
control|(
name|i
operator|=
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|tt1
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|BINFO_BASE_BINFO
argument_list|(
name|TYPE_BINFO
argument_list|(
name|tt1
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|basetype
argument_list|,
name|tt2
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Same for TT2.  */
for|for
control|(
name|i
operator|=
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|tt2
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|BINFO_BASE_BINFO
argument_list|(
name|TYPE_BINFO
argument_list|(
name|tt2
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|tt1
argument_list|,
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return true if two parameter type lists PARMS1 and PARMS2 are    equivalent in the sense that functions with those parameter types    can have equivalent types.  The two lists must be equivalent,    element by element.  */
end_comment

begin_function
name|bool
name|compparms
parameter_list|(
name|tree
name|parms1
parameter_list|,
name|tree
name|parms2
parameter_list|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
for|for
control|(
name|t1
operator|=
name|parms1
operator|,
name|t2
operator|=
name|parms2
init|;
name|t1
operator|||
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
comment|/* If one parmlist is shorter than the other, 	 they fail to match.  */
if|if
condition|(
operator|!
name|t1
operator|||
operator|!
name|t2
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a sizeof or alignof expression where the operand is a    type.  */
end_comment

begin_function
name|tree
name|cxx_sizeof_or_alignof_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|tree_code
name|op
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
name|bool
name|dependent_p
decl_stmt|;
name|gcc_assert
argument_list|(
name|op
operator|==
name|SIZEOF_EXPR
operator|||
name|op
operator|==
name|ALIGNOF_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|non_reference
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|complain
operator|&&
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid application of %qs to a member function"
argument_list|,
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|op
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_one_node
expr_stmt|;
block|}
name|dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dependent_p
condition|)
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dependent_p
comment|/* VLA types will have a non-constant size.  In the body of an 	 uninstantiated template, we don't need to try to compute the 	 value, because the sizeof expression is not an integral 	 constant expression in that case.  And, if we do try to 	 compute the value, we'll likely end up with SAVE_EXPRs, which 	 the template substitution machinery does not expect to see.  */
operator|||
operator|(
name|processing_template_decl
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
name|value
operator|=
name|build_min
argument_list|(
name|op
argument_list|,
name|size_type_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
return|return
name|c_sizeof_or_alignof_type
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|op
operator|==
name|SIZEOF_EXPR
argument_list|,
name|complain
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a sizeof expression where the operand is an expression.  */
end_comment

begin_function
specifier|static
name|tree
name|cxx_sizeof_expr
parameter_list|(
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|e
operator|=
name|build_min
argument_list|(
name|SIZEOF_EXPR
argument_list|,
name|size_type_node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid application of %<sizeof%> to a bit-field"
argument_list|)
expr_stmt|;
name|e
operator|=
name|char_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids applying %<sizeof%> to an expression of "
literal|"function type"
argument_list|)
expr_stmt|;
name|e
operator|=
name|char_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_error
argument_list|(
name|e
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|char_type_node
expr_stmt|;
block|}
else|else
name|e
operator|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|cxx_sizeof_or_alignof_type
argument_list|(
name|e
argument_list|,
name|SIZEOF_EXPR
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of E, measured in bytes.  For VAR_DECL's and    FIELD_DECL's return DECL_ALIGN (which can be set from an    "aligned" __attribute__ specification).  */
end_comment

begin_function
specifier|static
name|tree
name|cxx_alignof_expr
parameter_list|(
name|tree
name|e
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|e
operator|=
name|build_min
argument_list|(
name|ALIGNOF_EXPR
argument_list|,
name|size_type_node
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|e
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid application of %<__alignof%> to a bit-field"
argument_list|)
expr_stmt|;
name|t
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids applying %<__alignof%> to an expression of "
literal|"function type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_error
argument_list|(
name|e
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|size_one_node
expr_stmt|;
block|}
else|else
return|return
name|cxx_sizeof_or_alignof_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|,
name|ALIGNOF_EXPR
argument_list|,
name|true
argument_list|)
return|;
return|return
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a sizeof or alignof expression E with code OP where the operand    is an expression.  */
end_comment

begin_function
name|tree
name|cxx_sizeof_or_alignof_expr
parameter_list|(
name|tree
name|e
parameter_list|,
name|enum
name|tree_code
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
name|SIZEOF_EXPR
condition|)
return|return
name|cxx_sizeof_expr
argument_list|(
name|e
argument_list|)
return|;
else|else
return|return
name|cxx_alignof_expr
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* EXPR is being used in a context that is not a function call.    Enforce:       [expr.ref]       The expression can be used only as the left-hand operand of a      member function call.       [expr.mptr.operator]       If the result of .* or ->* is a function, then that result can be      used only as the operand for the function call operator ().     by issuing an error message if appropriate.  Returns true iff EXPR    violates these rules.  */
end_comment

begin_function
name|bool
name|invalid_nonstatic_memfn_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-static member function"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* If EXP is a reference to a bitfield, and the type of EXP does not    match the declared type of the bitfield, return the declared type    of the bitfield.  Otherwise, return NULL_TREE.  */
end_comment

begin_function
name|tree
name|is_bitfield_expr_with_lowered_type
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
if|if
condition|(
operator|!
name|is_bitfield_expr_with_lowered_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|is_bitfield_expr_with_lowered_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|is_bitfield_expr_with_lowered_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
return|return
name|is_bitfield_expr_with_lowered_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
decl_stmt|;
name|field
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
return|;
block|}
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like is_bitfield_with_lowered_type, except that if EXP is not a    bitfield with a lowered type, the type of EXP is returned, rather    than NULL_TREE.  */
end_comment

begin_function
name|tree
name|unlowered_expr_type
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|is_bitfield_expr_with_lowered_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Perform the conversions in [expr] that apply when an lvalue appears    in an rvalue context: the lvalue-to-rvalue, array-to-pointer, and    function-to-pointer conversions.  In addition, manifest constants    are replaced by their values, and bitfield references are converted    to their declared types.     Although the returned value is being used as an rvalue, this    function does not wrap the returned expression in a    NON_LVALUE_EXPR; the caller is expected to be mindful of the fact    that the return value is no longer an lvalue.  */
end_comment

begin_function
name|tree
name|decay_conversion
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_error
argument_list|(
name|exp
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|invalid_nonstatic_memfn_p
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|is_overloaded_fn
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|adr
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|build_nop
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|decay_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|cxx_mark_addressable
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|adr
operator|=
name|build_nop
argument_list|(
name|ptrtype
argument_list|,
name|build_address
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
comment|/* If a bitfield is used in a context where integral promotion      applies, then the caller is expected to have used      default_conversion.  That function promotes bitfields correctly      before calling this function.  At this point, if we have a      bitfield referenced, we may assume that is not subject to      promotion, and that, therefore, the type of the resulting rvalue      is the declared type of the bitfield.  */
name|exp
operator|=
name|convert_bitfield_to_declared_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* We do not call rvalue() here because we do not want to wrap EXP      in a NON_LVALUE_EXPR.  */
comment|/* [basic.lval]       Non-class rvalues always have cv-unqualified types.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|cp_type_quals
argument_list|(
name|type
argument_list|)
condition|)
name|exp
operator|=
name|build_nop
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Perform prepatory conversions, as part of the "usual arithmetic    conversions".  In particular, as per [expr]:       Whenever an lvalue expression appears as an operand of an      operator that expects the rvalue for that operand, the      lvalue-to-rvalue, array-to-pointer, or function-to-pointer      standard conversions are applied to convert the expression to an      rvalue.     In addition, we perform integral promotions here, as those are    applied to both operands to a binary operator before determining    what additional conversions should apply.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
comment|/* Perform the integral promotions first so that bitfield      expressions (which may promote to "int", even if the bitfield is      declared "unsigned") are promoted correctly.  */
if|if
condition|(
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|perform_integral_promotions
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Perform the other conversions.  */
name|exp
operator|=
name|decay_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* EXPR is an expression with an integral or enumeration type.    Perform the integral promotions in [conv.prom], and return the    converted value.  */
end_comment

begin_function
name|tree
name|perform_integral_promotions
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|;
comment|/* [conv.prom]       If the bitfield has an enumerated type, it is treated as any      other value of that type for promotion purposes.  */
name|type
operator|=
name|is_bitfield_expr_with_lowered_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|promoted_type
operator|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|promoted_type
condition|)
name|expr
operator|=
name|cp_convert
argument_list|(
name|promoted_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Take the address of an inline function without setting TREE_ADDRESSABLE    or TREE_USED.  */
end_comment

begin_function
name|tree
name|inline_conversion
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff exp is a STRING_CST or the result of applying    decay_conversion to one.  */
end_comment

begin_function
name|int
name|string_conv_p
parameter_list|(
name|tree
name|totype
parameter_list|,
name|tree
name|exp
parameter_list|,
name|int
name|warn
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|char_type_node
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|wchar_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Make sure that we don't try to convert between char and wchar_t.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Is this a string constant which has decayed to 'const char *'?  */
name|t
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|t
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
block|}
comment|/* This warning is not very useful, as it complains about printf.  */
if|if
condition|(
name|warn
condition|)
name|warning
argument_list|(
name|OPT_Wwrite_strings
argument_list|,
literal|"deprecated conversion from string constant to %qT"
argument_list|,
name|totype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a COND_EXPR, MIN_EXPR, or MAX_EXPR in T, return it in a form that we    can, for example, use as an lvalue.  This code used to be in    unary_complex_lvalue, but we needed it to deal with `a = (d == c) ? b : c'    expressions, where we're dealing with aggregates.  But now it's again only    called from unary_complex_lvalue.  The case (in particular) that led to    this was with CODE == ADDR_EXPR, since it's not an lvalue when we'd    get it there.  */
end_comment

begin_function
specifier|static
name|tree
name|rationalize_conditional_expr
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
comment|/* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that      the first operand is always the one to be used if both operands      are equal, so we know what conditional expression this used to be.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MAX_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* The following code is incorrect if either operand side-effects.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_conditional_expr
argument_list|(
name|build_x_binary_op
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MIN_EXPR
condition|?
name|LE_EXPR
else|:
name|GE_EXPR
operator|)
argument_list|,
name|op0
argument_list|,
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|,
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the TYPE of an anonymous union field inside T, return the    FIELD_DECL for the field.  If not found return NULL_TREE.  Because    anonymous unions can nest, we must also search all anonymous unions    that are directly reachable.  */
end_comment

begin_function
name|tree
name|lookup_anon_field
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
comment|/* If we find it directly, return the field.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|type
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|field
return|;
block|}
comment|/* Otherwise, it could be nested, search harder.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|subfield
init|=
name|lookup_anon_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|subfield
condition|)
return|return
name|subfield
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing OBJECT.MEMBER.  OBJECT is an    expression; MEMBER is a DECL or baselink.  If ACCESS_PATH is    non-NULL, it indicates the path to the base used to name MEMBER.    If PRESERVE_REFERENCE is true, the expression returned will have    REFERENCE_TYPE if the MEMBER does.  Otherwise, the expression    returned will have the type referred to by the reference.     This function does not perform access control; that is either done    earlier by the parser when the name of MEMBER is resolved to MEMBER    itself, or later when overload resolution selects one of the    functions indicated by MEMBER.  */
end_comment

begin_function
name|tree
name|build_class_member_access_expr
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|member
parameter_list|,
name|tree
name|access_path
parameter_list|,
name|bool
name|preserve_reference
parameter_list|)
block|{
name|tree
name|object_type
decl_stmt|;
name|tree
name|member_scope
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|object
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|member
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|member
argument_list|)
operator|||
name|BASELINK_P
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
comment|/* [expr.ref]       The type of the first expression shall be "class object" (of a      complete type).  */
name|object_type
operator|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currently_open_class
argument_list|(
name|object_type
argument_list|)
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|object_type
argument_list|,
name|object
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"request for member %qD in %qE, which is of non-class type %qT"
argument_list|,
name|member
argument_list|,
name|object
argument_list|,
name|object_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* The standard does not seem to actually say that MEMBER must be a      member of OBJECT_TYPE.  However, that is clearly what is      intended.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|member_scope
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|member
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|member
argument_list|)
expr_stmt|;
block|}
else|else
name|member_scope
operator|=
name|BINFO_TYPE
argument_list|(
name|BASELINK_BINFO
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If MEMBER is from an anonymous aggregate, MEMBER_SCOPE will      presently be the anonymous union.  Go outwards until we find a      type related to OBJECT_TYPE.  */
while|while
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|member_scope
argument_list|)
operator|&&
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|member_scope
argument_list|,
name|object_type
argument_list|)
condition|)
name|member_scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|member_scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_scope
operator|||
operator|!
name|DERIVED_FROM_P
argument_list|(
name|member_scope
argument_list|,
name|object_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error
argument_list|(
literal|"invalid use of nonstatic data member %qE"
argument_list|,
name|member
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD is not a member of %qT"
argument_list|,
name|member
argument_list|,
name|object_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Transform `(a, b).x' into `(*(a,&b)).x', `(a ? b : c).x' into      `(*(a ?&b :&c)).x', and so on.  A COND_EXPR is only an lvalue      in the frontend; only _DECLs and _REFs are lvalues in the backend.  */
block|{
name|tree
name|temp
init|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|object
operator|=
name|build_indirect_ref
argument_list|(
name|temp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* In [expr.ref], there is an explicit list of the valid choices for      MEMBER.  We check for each of those cases here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* A static data member.  */
name|result
operator|=
name|member
expr_stmt|;
comment|/* If OBJECT has side-effects, they are supposed to occur.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|object
argument_list|)
condition|)
name|result
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|object
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* A non-static data member.  */
name|bool
name|null_object_p
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|tree
name|member_type
decl_stmt|;
name|null_object_p
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Convert OBJECT to the type of MEMBER.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|object_type
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|member_scope
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
name|base_kind
name|kind
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|access_path
condition|?
name|access_path
else|:
name|object_type
argument_list|,
name|member_scope
argument_list|,
name|ba_unique
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* It is invalid to try to get to a virtual base of a 	     NULL object.  The most common cause is invalid use of 	     offsetof macro.  */
if|if
condition|(
name|null_object_p
operator|&&
name|kind
operator|==
name|bk_via_virtual
condition|)
block|{
name|error
argument_list|(
literal|"invalid access to non-static data member %qD of "
literal|"NULL object"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"(perhaps the %<offsetof%> macro was used incorrectly)"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Convert to the base.  */
name|object
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|object
argument_list|,
name|binfo
argument_list|,
comment|/*nonnull=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* If we found the base successfully then we should be able 	     to convert to it successfully.  */
name|gcc_assert
argument_list|(
name|object
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
comment|/* Complain about other invalid uses of offsetof, even though they will 	 give the right answer.  Note that we complain whether or not they 	 actually used the offsetof macro, since there's no way to know at this 	 point.  So we just give a warning, instead of a pedwarn.  */
comment|/* Do not produce this warning for base class field references, because 	 we know for a fact that didn't come from offsetof.  This does occur 	 in various testsuite cases where a null object is passed where a 	 vtable access is required.  */
if|if
condition|(
name|null_object_p
operator|&&
name|warn_invalid_offsetof
operator|&&
name|CLASSTYPE_NON_POD_P
argument_list|(
name|object_type
argument_list|)
operator|&&
operator|!
name|DECL_FIELD_IS_BASE
argument_list|(
name|member
argument_list|)
operator|&&
operator|!
name|skip_evaluation
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"invalid access to non-static data member %qD of NULL object"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"(perhaps the %<offsetof%> macro was used incorrectly)"
argument_list|)
expr_stmt|;
block|}
comment|/* If MEMBER is from an anonymous aggregate, we have converted 	 OBJECT so that it refers to the class containing the 	 anonymous union.  Generate a reference to the anonymous union 	 itself, and recur to find MEMBER.  */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
argument_list|)
comment|/* When this code is called from build_field_call, the 	     object already has the type of the anonymous union. 	     That is because the COMPONENT_REF was already 	     constructed, and was then disassembled before calling 	     build_field_call.  After the function-call code is 	     cleaned up, this waste can be eliminated.  */
operator|&&
operator|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|anonymous_union
decl_stmt|;
name|anonymous_union
operator|=
name|lookup_anon_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
name|object
operator|=
name|build_class_member_access_expr
argument_list|(
name|object
argument_list|,
name|anonymous_union
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
name|preserve_reference
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the type of the field, as described in [expr.ref].  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|member_type
operator|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|type_quals
operator|=
operator|(
name|cp_type_quals
argument_list|(
name|member_type
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|object_type
argument_list|)
operator|)
expr_stmt|;
comment|/* A field is const (volatile) if the enclosing object, or the 	     field itself, is const (volatile).  But, a mutable field is 	     not const, even within a const object.  */
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|member
argument_list|)
condition|)
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|member_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|member_type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|member_type
argument_list|,
name|object
argument_list|,
name|member
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|result
operator|=
name|fold_if_not_in_template
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Mark the expression const or volatile, as appropriate.  Even 	 though we've dealt with the type above, we still have to mark the 	 expression itself.  */
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
comment|/* The member is a (possibly overloaded) member function.  */
name|tree
name|functions
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* If the MEMBER is exactly one static member function, then we 	 know the type of the expression.  Otherwise, we must wait 	 until overload resolution has been performed.  */
name|functions
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|functions
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Note that we do not convert OBJECT to the BASELINK_BINFO 	 base.  That will happen when the function is called.  */
name|result
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|object
argument_list|,
name|member
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
comment|/* The member is an enumerator.  */
name|result
operator|=
name|member
expr_stmt|;
comment|/* If OBJECT has side-effects, they are supposed to occur.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|object
argument_list|)
condition|)
name|result
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|object
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"invalid use of %qD"
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|preserve_reference
condition|)
comment|/* [expr.ref]         If E2 is declared to have type "reference to T", then ... the        type of E1.E2 is T.  */
name|result
operator|=
name|convert_from_reference
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the destructor denoted by OBJECT.SCOPE::~DTOR_NAME, or, if    SCOPE is NULL, by OBJECT.~DTOR_NAME.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_destructor
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|dtor_name
parameter_list|)
block|{
name|tree
name|object_type
init|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|tree
name|dtor_type
init|=
name|TREE_OPERAND
argument_list|(
name|dtor_name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|scope
operator|&&
operator|!
name|check_dtor_name
argument_list|(
name|scope
argument_list|,
name|dtor_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"qualified type %qT does not match destructor name ~%qT"
argument_list|,
name|scope
argument_list|,
name|dtor_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|dtor_type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|object_type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"the type being destroyed is %qT, but the destructor refers to %qT"
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|object_type
argument_list|)
argument_list|,
name|dtor_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|expr
operator|=
name|lookup_member
argument_list|(
name|dtor_type
argument_list|,
name|complete_dtor_identifier
argument_list|,
comment|/*protect=*/
literal|1
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|(
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|expr
argument_list|,
name|dtor_type
argument_list|,
name|object_type
argument_list|)
operator|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* An expression of the form "A::template B" has been resolved to    DECL.  Issue a diagnostic if B is not a template or template    specialization.  */
end_comment

begin_function
name|void
name|check_template_keyword
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* The standard says:        [temp.names]        If a name prefixed by the keyword template is not a member       template, the program is ill-formed.       DR 228 removed the restriction that the template be a member      template.       DR 96, if accepted would add the further restriction that explicit      template arguments must be provided if the template keyword is      used, but, as of 2005-10-16, that DR is still in "drafting".  If      this DR is accepted, then the semantic checks here can be      simplified, as the entity named must in fact be a template      specialization, rather than, as at present, a set of overloaded      functions containing at least one template function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%qD is not a template"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|fns
decl_stmt|;
name|fns
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
expr_stmt|;
while|while
condition|(
name|fns
condition|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|fn
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
break|break;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fns
condition|)
name|pedwarn
argument_list|(
literal|"%qD is not a template"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function is called by the parser to process a class member    access expression of the form OBJECT.NAME.  NAME is a node used by    the parser to represent a name; it is not yet a DECL.  It may,    however, be a BASELINK where the BASELINK_FUNCTIONS is a    TEMPLATE_ID_EXPR.  Templates must be looked up by the parser, and    there is no reason to do the lookup twice, so the parser keeps the    BASELINK.  TEMPLATE_P is true iff NAME was explicitly declared to    be a template via the use of the "A::template B" syntax.  */
end_comment

begin_function
name|tree
name|finish_class_member_access_expr
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|name
parameter_list|,
name|bool
name|template_p
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|object_type
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|access_path
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|orig_object
init|=
name|object
decl_stmt|;
name|tree
name|orig_name
init|=
name|name
decl_stmt|;
if|if
condition|(
name|object
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If OBJECT is an ObjC class instance, we must obey ObjC access rules.  */
if|if
condition|(
operator|!
name|objc_is_public
argument_list|(
name|object
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|object_type
operator|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
comment|/* If OBJECT_TYPE is dependent, so is OBJECT.NAME.  */
name|dependent_type_p
argument_list|(
name|object_type
argument_list|)
comment|/* If NAME is just an IDENTIFIER_NODE, then the expression 	     is dependent.  */
operator|||
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|IDENTIFIER_NODE
comment|/* If NAME is "f<args>", where either 'f' or 'args' is 	     dependent, then the expression is dependent.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|dependent_template_id_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
comment|/* If NAME is "T::X" where "T" is dependent, then the 	     expression is dependent.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|)
return|;
name|object
operator|=
name|build_non_dependent_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.ref]       The type of the first expression shall be "class object" (of a      complete type).  */
if|if
condition|(
operator|!
name|currently_open_class
argument_list|(
name|object_type
argument_list|)
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|object_type
argument_list|,
name|object
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"request for member %qD in %qE, which is of non-class type %qT"
argument_list|,
name|name
argument_list|,
name|object
argument_list|,
name|object_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|name
argument_list|)
condition|)
comment|/* A member function that has already been looked up.  */
name|member
operator|=
name|name
expr_stmt|;
else|else
block|{
name|bool
name|is_template_id
init|=
name|false
decl_stmt|;
name|tree
name|template_args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|scope
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|is_template_id
operator|=
name|true
expr_stmt|;
name|template_args
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
comment|/* A qualified name.  The qualifying class or namespace `S' 	     has already been looked up; it is either a TYPE or a 	     NAMESPACE_DECL.  */
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If SCOPE is a namespace, then the qualified name does not 	     name a member of OBJECT_TYPE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%<%D::%D%> is not a member of %qT"
argument_list|,
name|scope
argument_list|,
name|name
argument_list|,
name|object_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|gcc_assert
argument_list|(
name|CLASS_TYPE_P
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
argument_list|)
expr_stmt|;
comment|/* Find the base of OBJECT_TYPE corresponding to SCOPE.  */
name|access_path
operator|=
name|lookup_base
argument_list|(
name|object_type
argument_list|,
name|scope
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|access_path
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|access_path
condition|)
block|{
name|error
argument_list|(
literal|"%qT is not a base of %qT"
argument_list|,
name|scope
argument_list|,
name|object_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
name|access_path
operator|=
name|object_type
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|member
operator|=
name|lookup_destructor
argument_list|(
name|object
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Look up the member.  */
name|member
operator|=
name|lookup_member
argument_list|(
name|access_path
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|1
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"%qD has no member named %qE"
argument_list|,
name|object_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|member
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_template_id
condition|)
block|{
name|tree
name|template
init|=
name|member
decl_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|template
argument_list|)
condition|)
name|template
operator|=
name|lookup_template_function
argument_list|(
name|template
argument_list|,
name|template_args
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"%qD is not a member template function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|member
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_p
condition|)
name|check_template_keyword
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_class_member_access_expr
argument_list|(
name|object
argument_list|,
name|member
argument_list|,
name|access_path
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|expr
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_name
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|BASELINK_QUALIFIED_P
argument_list|(
name|member
argument_list|)
operator|=
literal|1
expr_stmt|;
name|orig_name
operator|=
name|member
expr_stmt|;
block|}
return|return
name|build_min_non_dep
argument_list|(
name|COMPONENT_REF
argument_list|,
name|expr
argument_list|,
name|orig_object
argument_list|,
name|orig_name
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return an expression for the MEMBER_NAME field in the internal    representation of PTRMEM, a pointer-to-member function.  (Each    pointer-to-member function type gets its own RECORD_TYPE so it is    more convenient to access the fields by name than by FIELD_DECL.)    This routine converts the NAME to a FIELD_DECL and then creates the    node for the complete expression.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc_access_expr
parameter_list|(
name|tree
name|ptrmem
parameter_list|,
name|tree
name|member_name
parameter_list|)
block|{
name|tree
name|ptrmem_type
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|member_type
decl_stmt|;
comment|/* This code is a stripped down version of      build_class_member_access_expr.  It does not work to use that      routine directly because it expects the object to be of class      type.  */
name|ptrmem_type
operator|=
name|TREE_TYPE
argument_list|(
name|ptrmem
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|ptrmem_type
argument_list|)
argument_list|)
expr_stmt|;
name|member
operator|=
name|lookup_member
argument_list|(
name|ptrmem_type
argument_list|,
name|member_name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
name|member_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|cp_type_quals
argument_list|(
name|ptrmem_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|member_type
argument_list|,
name|ptrmem
argument_list|,
name|member
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.     This function may need to overload OPERATOR_FNNAME.    Must also handle REFERENCE_TYPEs for C++.  */
end_comment

begin_function
name|tree
name|build_x_indirect_ref
parameter_list|(
name|tree
name|expr
parameter_list|,
specifier|const
name|char
modifier|*
name|errorstring
parameter_list|)
block|{
name|tree
name|orig_expr
init|=
name|expr
decl_stmt|;
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|expr
argument_list|)
return|;
name|expr
operator|=
name|build_non_dependent_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|build_new_op
argument_list|(
name|INDIRECT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rval
condition|)
name|rval
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|rval
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|INDIRECT_REF
argument_list|,
name|rval
argument_list|,
name|orig_expr
argument_list|)
return|;
else|else
return|return
name|rval
return|;
block|}
end_function

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|tree
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|errorstring
parameter_list|)
block|{
name|tree
name|pointer
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ptr
operator|==
name|current_class_ptr
condition|)
return|return
name|current_class_ref
return|;
name|pointer
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|ptr
else|:
name|decay_conversion
argument_list|(
name|ptr
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* [expr.unary.op]  	 If the type of the expression is "pointer to T," the type 	 of  the  result  is  "T."  	 We must use the canonical variant because certain parts of 	 the back end, like fold, do pointer comparisons between 	 types.  */
name|tree
name|t
init|=
name|canonical_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
block|{
comment|/* If a warning is issued, mark it to avoid duplicates from 	     the backend.  This only needs to be done at 	     warn_strict_aliasing> 2.  */
if|if
condition|(
name|warn_strict_aliasing
operator|>
literal|2
condition|)
if|if
condition|(
name|strict_aliasing_warning
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* A pointer to incomplete type (other than cv void) can be 	     dereferenced [expr.unary.op]/1  */
name|error
argument_list|(
literal|"%qT is not a pointer-to-object type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|same_type_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* The POINTER was something like `&x'.  We simplify `*&x' to 	   `x'.  */
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|t
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	     so that we get the proper error message if the result is used 	     to assign to.  Also,&* is supposed to be a no-op.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
operator|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
comment|/* `pointer' won't be an error_mark_node if we were given a      pointer to member, so it's cool to check for this here.  */
elseif|else
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of %qs on pointer to member"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pointer
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|errorstring
condition|)
name|error
argument_list|(
literal|"invalid type argument of %qs"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid type argument"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).     If INDEX is of some user-defined type, it must be converted to    integer type.  Otherwise, to make a compatible PLUS_EXPR, it    will inherit the type of the array, which will be some pointer type.  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|tree
name|array
parameter_list|,
name|tree
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If ARRAY is a COMPOUND_EXPR or COND_EXPR, move our reference      inside it.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|1
argument_list|)
argument_list|,
name|idx
argument_list|)
decl_stmt|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|1
argument_list|)
argument_list|,
name|idx
argument_list|)
argument_list|,
name|build_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|2
argument_list|)
argument_list|,
name|idx
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
name|warn_array_subscript_with_type_char
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Apply integral promotions *after* noticing character types. 	 (It is unclear why we do these promotions -- the standard 	 does not say that we should.  In fact, the natural thing would 	 seem to be to convert IDX to ptrdiff_t; we're performing 	 pointer arithmetic.)  */
name|idx
operator|=
name|perform_integral_promotions
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cxx_mark_addressable
argument_list|(
name|array
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|idx
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cxx_mark_addressable
argument_list|(
name|array
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
comment|/* Note in C++ it is valid to subscript a `register' array, since 	 it is valid to take the address of something with that 	 storage specification.  */
if|if
condition|(
name|extra_warnings
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"subscripting array declared %<register%>"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|idx
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are 	 or if the array is..  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold_if_not_in_template
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Resolve a pointer to member function.  INSTANCE is the object    instance to use, if the member points to a virtual member.     This used to avoid checking for virtual functions if basetype    has no virtual functions, according to an earlier ANSI draft.    With the final ISO C++ rules, such an optimization is    incorrect: A pointer to a derived member can be static_cast    to pointer-to-base-member, as long as the dynamic object    later has the right member.  */
end_comment

begin_function
name|tree
name|get_member_function_from_ptrfunc
parameter_list|(
name|tree
modifier|*
name|instance_ptrptr
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|idx
decl_stmt|,
name|delta
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|,
name|vtbl
decl_stmt|,
name|basetype
decl_stmt|;
name|tree
name|fntype
init|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|instance_ptr
init|=
operator|*
name|instance_ptrptr
decl_stmt|;
name|tree
name|instance_save_expr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
comment|/* Extracting the function address from a pmf is only 		 allowed with -Wno-pmf-conversions. It only works for 		 pmf constants.  */
name|e1
operator|=
name|build_addr_func
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|convert
argument_list|(
name|fntype
argument_list|,
name|e1
argument_list|)
expr_stmt|;
return|return
name|e1
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"object missing in use of %qE"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance_ptr
argument_list|)
condition|)
name|instance_ptr
operator|=
name|instance_save_expr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|save_expr
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Start by extracting all the information from the PMF itself.  */
name|e3
operator|=
name|pfn_from_ptrmemfunc
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|function
argument_list|,
name|delta_identifier
argument_list|)
expr_stmt|;
name|idx
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_index_type
argument_list|,
name|e3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
condition|)
block|{
case|case
name|ptrmemfunc_vbit_in_pfn
case|:
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|idx
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|idx
operator|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|idx
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|ptrmemfunc_vbit_in_delta
case|:
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|delta
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_build_binary_op
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|delta
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Convert down to the right base before using the instance.  A 	 special case is that in a pointer to member of class C, C may 	 be incomplete.  In that case, the function will of course be 	 a member of C, and no conversion is required.  In fact, 	 lookup_base will fail in that case, because incomplete 	 classes do not have BINFOs.  */
name|basetype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|instance_ptr
argument_list|,
name|basetype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* ...and then the delta in the PMF.  */
name|instance_ptr
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* Hand back the adjusted 'this' argument to our caller.  */
operator|*
name|instance_ptrptr
operator|=
name|instance_ptr
expr_stmt|;
comment|/* Next extract the vtable pointer from the object.  */
name|vtbl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|vtbl_ptr_type_node
argument_list|)
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|vtbl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Finally, extract the function pointer from the vtable.  */
name|e2
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_indirect_ref
argument_list|(
name|e2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|e2
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|e2
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* When using function descriptors, the address of the 	 vtable entry is treated as a function pointer.  */
if|if
condition|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|)
name|e2
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|e2
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e3
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
expr_stmt|;
comment|/* Make sure this doesn't get evaluated first inside one of the 	 branches of the COND_EXPR.  */
if|if
condition|(
name|instance_save_expr
condition|)
name|e1
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
argument_list|,
name|instance_save_expr
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|function
operator|=
name|e1
expr_stmt|;
block|}
return|return
name|function
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|fntype
decl_stmt|,
name|fndecl
decl_stmt|;
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_method
decl_stmt|;
name|tree
name|original
init|=
name|function
decl_stmt|;
comment|/* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF      expressions, like those used for ObjC messenger dispatches.  */
name|function
operator|=
name|objc_rewrite_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|function
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|pedantic
operator|&&
name|DECL_MAIN_P
argument_list|(
name|function
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids calling %<::main%> from within program"
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|inline_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"must use %<.*%> or %<->*%> to call pointer-to-member "
literal|"function in %<%E (...)%>"
argument_list|,
name|original
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|is_method
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
name|is_method
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE cannot be used as a function"
argument_list|,
name|original
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|coerced_params
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check for errors in format strings and inappropriately      null parameters.  */
name|check_function_arguments
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|coerced_params
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_cxx_call
argument_list|(
name|function
argument_list|,
name|coerced_params
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the actual parameter expressions in the list VALUES    to the types in the list TYPELIST.    If parmdecls is exhausted, or when an element has NULL as its type,    perform the default conversions.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.     Return a list of expressions for the parameters as converted.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.     In C++, unspecified trailing parameters can be filled in with their    default arguments, if such were specified.  Do so here.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|tree
name|typelist
parameter_list|,
name|tree
name|values
parameter_list|,
name|tree
name|fndecl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|called_thing
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Argument passing is always copy-initialization.  */
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|called_thing
operator|=
literal|"constructor"
expr_stmt|;
else|else
name|called_thing
operator|=
literal|"member function"
expr_stmt|;
block|}
else|else
name|called_thing
operator|=
literal|"function"
expr_stmt|;
block|}
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments to %s %q+#D"
argument_list|,
name|called_thing
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
comment|/* In case anybody wants to know if this argument 	     list is valid.  */
if|if
condition|(
name|result
condition|)
name|TREE_TYPE
argument_list|(
name|tree_last
argument_list|(
name|result
argument_list|)
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|val
operator|=
name|decay_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|error
argument_list|(
literal|"parameter %P of %qD has incomplete type %qT"
argument_list|,
name|i
argument_list|,
name|fndecl
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"parameter %P has incomplete type %qT"
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|,
literal|"argument passing"
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|convert_for_arg_passing
argument_list|(
name|type
argument_list|,
name|parmval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parmval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_CONSTANT_P
condition|)
comment|/* Don't do ellipsis conversion for __built_in_constant_p 	       as this will result in spurious warnings for non-POD 	       types.  */
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|convert_arg_to_ellipsis
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|typetail
operator|!=
name|void_list_node
condition|)
block|{
comment|/* See if there are default arguments that can be used.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
argument_list|)
operator|!=
name|DEFAULT_ARG
condition|)
block|{
for|for
control|(
init|;
name|typetail
operator|!=
name|void_list_node
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parmval
init|=
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|parmval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
comment|/* ends with `...'.  */
if|if
condition|(
name|typetail
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to %s %q+#D"
argument_list|,
name|called_thing
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression, after performing default    conversions on the operands.  CODE is the kind of expression to build.  */
end_comment

begin_function
name|tree
name|build_x_binary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|enum
name|tree_code
name|arg1_code
parameter_list|,
name|tree
name|arg2
parameter_list|,
name|enum
name|tree_code
name|arg2_code
parameter_list|,
name|bool
modifier|*
name|overloaded_p
parameter_list|)
block|{
name|tree
name|orig_arg1
decl_stmt|;
name|tree
name|orig_arg2
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|orig_arg1
operator|=
name|arg1
expr_stmt|;
name|orig_arg2
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|arg1
argument_list|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
name|arg1
operator|=
name|build_non_dependent_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|build_non_dependent_expr
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|DOTSTAR_EXPR
condition|)
name|expr
operator|=
name|build_m_component_ref
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_new_op
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|NULL_TREE
argument_list|,
name|overloaded_p
argument_list|)
expr_stmt|;
comment|/* Check for cases such as x+y<<z which users are likely to      misinterpret.  But don't warn about obj<< x + y, since that is a      common idiom for I/O.  */
if|if
condition|(
name|warn_parentheses
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|!
name|error_operand_p
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|error_operand_p
argument_list|(
name|arg2
argument_list|)
operator|&&
operator|(
name|code
operator|!=
name|LSHIFT_EXPR
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
name|warn_about_parentheses
argument_list|(
name|code
argument_list|,
name|arg1_code
argument_list|,
name|arg2_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|expr
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|code
argument_list|,
name|expr
argument_list|,
name|orig_arg1
argument_list|,
name|orig_arg2
argument_list|)
return|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     Note that the operands will never have enumeral types    because either they have just had the default conversions performed    or they have both just been converted to some other type in which    the arithmetic is to be done.     C++: must do special pointer arithmetic when implementing    multiple inheritance, and deal with pointer to member functions.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|orig_op0
parameter_list|,
name|tree
name|orig_op1
parameter_list|,
name|int
name|convert_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_op_diag
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means create the expression with this type, rather than      RESULT_TYPE.  */
name|tree
name|build_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      convert it to this type.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* True if both operands have arithmetic type.  */
name|bool
name|arithmetic_types_p
decl_stmt|;
comment|/* Apply default conversions.  */
name|op0
operator|=
name|orig_op0
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|decay_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|decay_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|default_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* DTRT if one side is an overloaded function, but complain about it.  */
if|if
condition|(
name|type_unknown_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|,
name|tf_none
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"assuming cast to type %qT from overloaded function"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|,
name|tf_none
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"assuming cast to type %qT from overloaded function"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|t
expr_stmt|;
block|}
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|invalid_op_diag
operator|=
name|targetm
operator|.
name|invalid_binary_op
argument_list|(
name|code
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_op_diag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
argument_list|)
return|;
comment|/* In all other cases except pointer - int, the usual arithmetic 	 rules aply.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
name|common
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* The pointer - int case is just like pointer + int; fall 	 through.  */
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|)
operator|&&
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
name|tree
name|ptr_operand
decl_stmt|;
name|tree
name|int_operand
decl_stmt|;
name|ptr_operand
operator|=
operator|(
operator|(
name|code0
operator|==
name|POINTER_TYPE
operator|)
condition|?
name|op0
else|:
name|op1
operator|)
expr_stmt|;
name|int_operand
operator|=
operator|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|)
condition|?
name|op0
else|:
name|op1
operator|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|ptr_operand
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|cp_pointer_int_sum
argument_list|(
name|code
argument_list|,
name|ptr_operand
argument_list|,
name|int_operand
argument_list|)
return|;
block|}
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|||
name|code0
operator|==
name|VECTOR_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
block|{
name|enum
name|tree_code
name|tcode0
init|=
name|code0
decl_stmt|,
name|tcode1
init|=
name|code1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdiv_by_zero
argument_list|,
literal|"division by zero in %<%E / 0%>"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdiv_by_zero
argument_list|,
literal|"division by zero in %<%E / 0.%>"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcode0
operator|==
name|COMPLEX_TYPE
operator|||
name|tcode0
operator|==
name|VECTOR_TYPE
condition|)
name|tcode0
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcode1
operator|==
name|COMPLEX_TYPE
operator|||
name|tcode1
operator|==
name|VECTOR_TYPE
condition|)
name|tcode1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tcode0
operator|==
name|INTEGER_TYPE
operator|&&
name|tcode1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* When dividing two signed integers, we have to promote to int. 	       unless we divide by a constant != -1.  Note that default 	       conversion will have been performed on the operands at this 	       point, so we have to dig out the original type to find out if 	       it was unsigned.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
operator|||
operator|(
name|code0
operator|==
name|VECTOR_TYPE
operator|&&
name|code1
operator|==
name|VECTOR_TYPE
operator|)
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|code1
operator|==
name|INTEGER_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdiv_by_zero
argument_list|,
literal|"division by zero in %<%E %% 0%>"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdiv_by_zero
argument_list|,
literal|"division by zero in %<%E %% 0.%>"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
name|result_type
operator|=
name|boolean_type_node
expr_stmt|;
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%s rotate count is negative"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%s rotate count>= width of type"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
condition|)
name|warning
argument_list|(
name|OPT_Wfloat_equal
argument_list|,
literal|"comparing floating point with == or != is unsafe"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|STRING_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|==
name|STRING_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"comparison with string literal results in unspecified behaviour"
argument_list|)
expr_stmt|;
name|build_type
operator|=
name|boolean_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type0
argument_list|)
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|type1
argument_list|)
operator|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|error
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|error
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|op0
argument_list|,
name|pfn_identifier
argument_list|)
expr_stmt|;
name|op1
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|cp_build_binary_op
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
block|{
comment|/* E will be the final comparison.  */
name|tree
name|e
decl_stmt|;
comment|/* E1 and E2 are for scratch.  */
name|tree
name|e1
decl_stmt|;
name|tree
name|e2
decl_stmt|;
name|tree
name|pfn0
decl_stmt|;
name|tree
name|pfn1
decl_stmt|;
name|tree
name|delta0
decl_stmt|;
name|tree
name|delta1
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|save_expr
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|save_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* We generate:  	     (op0.pfn == op1.pfn&& (!op0.pfn || op0.delta == op1.delta))  	     The reason for the `!op0.pfn' bit is that a NULL 	     pointer-to-member is any member with a zero PFN; the 	     DELTA field is unspecified.  */
name|pfn0
operator|=
name|pfn_from_ptrmemfunc
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|pfn1
operator|=
name|pfn_from_ptrmemfunc
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|delta0
operator|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|op0
argument_list|,
name|delta_identifier
argument_list|)
expr_stmt|;
name|delta1
operator|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|op1
argument_list|,
name|delta_identifier
argument_list|)
expr_stmt|;
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|delta0
argument_list|,
name|delta1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|pfn0
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|pfn0
argument_list|,
name|pfn1
argument_list|)
expr_stmt|;
name|e
operator|=
name|cp_build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e2
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|e
return|;
return|return
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|e
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|type1
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|||
operator|!
name|same_type_p
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|type0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|==
name|STRING_CST
condition|)
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"comparison with string literal results in unspecified behaviour"
argument_list|)
expr_stmt|;
name|build_type
operator|=
name|boolean_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|code0
operator|!=
name|REAL_TYPE
operator|||
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"unordered comparison on non-floating point argument"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|common
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
operator|)
condition|)
name|arithmetic_types_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|arithmetic_types_p
operator|=
literal|0
expr_stmt|;
comment|/* Vector arithmetic is only allowed when both sides are vectors.  */
if|if
condition|(
name|code0
operator|==
name|VECTOR_TYPE
operator|&&
name|code1
operator|==
name|VECTOR_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|||
operator|!
name|same_scalar_type_ignoring_signedness
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
block|{
name|binary_op_error
argument_list|(
name|code
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arithmetic_types_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Determine the RESULT_TYPE, if it is not already known.  */
if|if
condition|(
operator|!
name|result_type
operator|&&
name|arithmetic_types_p
operator|&&
operator|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
operator|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|error
argument_list|(
literal|"invalid operands of types %qT and %qT to binary %qO"
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If we're in a template, the only thing we need to know is the      RESULT_TYPE.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build2
argument_list|(
name|resultcode
argument_list|,
name|build_type
condition|?
name|build_type
else|:
name|result_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
name|arithmetic_types_p
condition|)
block|{
name|int
name|none_complex
init|=
operator|(
name|code0
operator|!=
name|COMPLEX_TYPE
operator|&&
name|code1
operator|!=
name|COMPLEX_TYPE
operator|)
decl_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
operator|&&
name|none_complex
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TYPE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|arg0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|arg1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* We can shorten only if the shift count is less than the 		 number of bits in the smaller type size.  */
operator|&&
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
operator|(
operator|(
operator|(
name|unsigned
operator|)
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|val
argument_list|)
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|short_compare
operator|||
name|code
operator|==
name|MIN_EXPR
operator|||
name|code
operator|==
name|MAX_EXPR
operator|)
operator|&&
name|warn_sign_compare
comment|/* Do not warn until the template is instantiated; we cannot 	     bound the ranges of the arguments until that point.  */
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|int
name|op0_signed
init|=
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op1_signed
init|=
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
comment|/* Check for comparison of different enum types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison between types %q#T and %q#T"
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Give warnings for comparisons between signed and unsigned 	     quantities that may fail.  */
comment|/* Do the checking based on the original operand trees, so that 	     casts will be considered, but default promotions won't be.  */
comment|/* Do not warn if the comparison is being done in a signed type, 	     since the signed type will only be chosen if it can represent 	     all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if both operands are unsigned.  */
elseif|else
if|if
condition|(
name|op0_signed
operator|==
name|op1_signed
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the signed quantity is an unsuffixed 	     integer literal (or some static constant expression 	     involving such literals or a conditional expression 	     involving such literals) and it is non-negative.  */
elseif|else
if|if
condition|(
operator|(
name|op0_signed
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|orig_op0
argument_list|)
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|orig_op1
argument_list|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the comparison is an equality operation, 	     the unsigned quantity is an integral constant and it does 	     not use the most significant bit of result_type.  */
elseif|else
if|if
condition|(
operator|(
name|resultcode
operator|==
name|EQ_EXPR
operator|||
name|resultcode
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|op0_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|orig_op1
argument_list|,
name|c_common_signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|orig_op0
argument_list|,
name|c_common_signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison between signed and unsigned integer expressions"
argument_list|)
expr_stmt|;
comment|/* Warn if two unsigned values are being compared in a size 	     larger than their original size, and one (and only one) is the 	     result of a `~' operator.  This comparison will always fail.  	     Also warn if one operand is a constant, and the constant does not 	     have all bits set that are set in the ~ operand when it is 	     extended.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
operator|^
operator|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
operator|||
name|host_integerp
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|HOST_WIDE_INT
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
comment|/* Issue warnings about peculiar, but valid, uses of NULL.  */
if|if
condition|(
comment|/* It's reasonable to use pointer values as operands of&& 	 and ||, so NULL is no exception.  */
operator|!
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|(
comment|/* If OP0 is NULL and OP1 is not a pointer, or vice versa.  */
operator|(
name|orig_op0
operator|==
name|null_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
comment|/* Or vice versa.  */
operator|||
operator|(
name|orig_op1
operator|==
name|null_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
comment|/* Or, both are NULL and the operation was not a comparison.  */
operator|||
operator|(
name|orig_op0
operator|==
name|null_node
operator|&&
name|orig_op1
operator|==
name|null_node
operator|&&
name|code
operator|!=
name|EQ_EXPR
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|)
operator|)
condition|)
comment|/* Some sort of arithmetic operation involving NULL was        performed.  Note that pointer-difference and pointer-addition        have already been handled above, and so we don't end up here in        that case.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"NULL used in arithmetic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|error_mark_node
operator|||
name|op1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|build_type
operator|==
name|NULL_TREE
condition|)
name|build_type
operator|=
name|result_type
expr_stmt|;
name|result
operator|=
name|build2
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|result
operator|=
name|fold_if_not_in_template
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
name|result
operator|=
name|cp_convert
argument_list|(
name|final_type
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OVERFLOW_P
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW_P
argument_list|(
name|op1
argument_list|)
condition|)
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_pointer_int_sum
parameter_list|(
name|enum
name|tree_code
name|resultcode
parameter_list|,
name|tree
name|ptrop
parameter_list|,
name|tree
name|intop
parameter_list|)
block|{
name|tree
name|res_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
comment|/* pointer_int_sum() uses size_in_bytes() on the TREE_TYPE(res_type)      in certain circumstance (when it's valid to do so).  So we need      to make sure it's complete.  We don't need to check here, if we      can actually complete it at all, as those checks will be done in      pointer_int_sum() anyway.  */
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|res_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pointer_int_sum
argument_list|(
name|resultcode
argument_list|,
name|ptrop
argument_list|,
name|fold_if_not_in_template
argument_list|(
name|intop
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|ptrtype
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrtype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|target_type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer of type %<void *%> in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer to a function in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer to a method in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is a pointer to an incomplete type.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of a pointer to an incomplete type in pointer arithmetic"
argument_list|)
expr_stmt|;
name|op1
operator|=
operator|(
name|TYPE_PTROB_P
argument_list|(
name|ptrtype
argument_list|)
condition|?
name|size_in_bytes
argument_list|(
name|target_type
argument_list|)
else|:
name|integer_one_node
operator|)
expr_stmt|;
comment|/* Do the division.  */
name|result
operator|=
name|build2
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  */
end_comment

begin_function
name|tree
name|build_x_unary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|xarg
parameter_list|)
block|{
name|tree
name|orig_expr
init|=
name|xarg
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|ptrmem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|xarg
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|)
return|;
name|xarg
operator|=
name|build_non_dependent_expr
argument_list|(
name|xarg
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* [expr.unary.op] says:         The address of an object of incomplete type can be taken.       (And is just the ordinary address operator, not an overloaded      "operator&".)  However, if the type is a template      specialization, we must complete the type at this point so that      an overloaded "operator&" will be available if required.  */
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
operator|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|OFFSET_REF
operator|)
operator|)
condition|)
comment|/* Don't look for a function.  */
empty_stmt|;
else|else
name|exp
operator|=
name|build_new_op
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|&&
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
comment|/*  A pointer to member-function can be formed only by saying&X::mf.  */
if|if
condition|(
operator|!
name|flag_ms_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|!=
name|OFFSET_REF
operator|||
operator|!
name|PTRMEM_OK_P
argument_list|(
name|xarg
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|!=
name|OFFSET_REF
operator|||
operator|!
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of %qE to form a pointer-to-member-function"
argument_list|,
name|xarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
name|inform
argument_list|(
literal|"  a qualified-id is required"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"parentheses around %qE cannot be used to form a"
literal|" pointer-to-member-function"
argument_list|,
name|xarg
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|xarg
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|ptrmem
operator|=
name|PTRMEM_OK_P
argument_list|(
name|xarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrmem
operator|&&
operator|!
name|flag_ms_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* A single non-static member, make sure we don't allow a 		 pointer-to-member.  */
name|xarg
operator|=
name|build2
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ovl_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|xarg
argument_list|)
operator|=
name|ptrmem
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"taking address of temporary"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|xarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
operator|&&
name|exp
operator|!=
name|error_mark_node
condition|)
name|exp
operator|=
name|build_min_non_dep
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|orig_expr
argument_list|,
comment|/*For {PRE,POST}{INC,DEC}REMENT_EXPR*/
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|PTRMEM_OK_P
argument_list|(
name|exp
argument_list|)
operator|=
name|ptrmem
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Like c_common_truthvalue_conversion, but handle pointer-to-member    constants, where a null value is represented by an INTEGER_CST of    -1.  */
end_comment

begin_function
name|tree
name|cp_truthvalue_conversion
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */
end_comment

begin_function
name|tree
name|condition_conversion
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|expr
return|;
name|t
operator|=
name|perform_implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_build_cleanup_point_expr
argument_list|(
name|boolean_type_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return an ADDR_EXPR giving the address of T.  This function    attempts no optimizations or simplifications; it is a low-level    primitive.  */
end_comment

begin_function
name|tree
name|build_address
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|cxx_mark_addressable
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return a NOP_EXPR converting EXPR to TYPE.  */
end_comment

begin_function
name|tree
name|build_nop
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* C++: Must handle pointers to members.     Perhaps type instantiation should be extended to handle conversion    from aggregates to types we don't yet know we want?  (Or are those    cases typically errors which should be reported?)     NOCONVERT nonzero suppresses the default promotions    (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|xarg
parameter_list|,
name|int
name|noconvert
parameter_list|)
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_op_diag
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|invalid_op_diag
operator|=
name|targetm
operator|.
name|invalid_unary_op
argument_list|(
operator|(
name|code
operator|==
name|UNARY_PLUS_EXPR
condition|?
name|CONVERT_EXPR
else|:
name|code
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
name|invalid_op_diag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNARY_PLUS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
block|{
name|int
name|flags
init|=
name|WANT_ARITH
operator||
name|WANT_ENUM
decl_stmt|;
comment|/* Unary plus (but not unary minus) is allowed on pointers.  */
if|if
condition|(
name|code
operator|==
name|UNARY_PLUS_EXPR
condition|)
name|flags
operator||=
name|WANT_POINTER
expr_stmt|;
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|flags
argument_list|,
name|arg
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|errstring
operator|=
operator|(
name|code
operator|==
name|NEGATE_EXPR
condition|?
literal|"wrong type argument to unary minus"
else|:
literal|"wrong type argument to unary plus"
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|noconvert
operator|&&
name|CP_INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|arg
operator|=
name|perform_integral_promotions
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Make sure the result is not an lvalue: a unary plus or minus 	       expression is always a rvalue.  */
name|arg
operator|=
name|rvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|code
operator|=
name|CONJ_EXPR
expr_stmt|;
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
operator||
name|WANT_VECTOR
argument_list|,
name|arg
argument_list|,
name|true
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
operator|&&
name|CP_INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|arg
operator|=
name|perform_integral_promotions
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
name|true
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
comment|/* Conjugating a real value is a no-op, but allow it anyway.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
name|true
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to conjugation"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
name|arg
operator|=
name|perform_implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|error_mark_node
condition|)
return|return
name|val
return|;
name|errstring
operator|=
literal|"in argument to unary !"
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|arg
argument_list|)
return|;
block|}
else|else
return|return
name|arg
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|arg
argument_list|)
return|;
block|}
else|else
return|return
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Increment or decrement the real part of the value, 	 and don't change the imaginary part.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real
operator|=
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|real
argument_list|,
literal|1
argument_list|)
argument_list|,
name|imag
argument_list|)
return|;
block|}
comment|/* Report invalid types.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_POINTER
argument_list|,
name|arg
argument_list|,
name|true
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no post-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-decrement operator for type"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"no post-decrement operator for type"
expr_stmt|;
break|break;
block|}
comment|/* Report something read-only.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_error
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|tree
name|inc
decl_stmt|;
name|tree
name|declared_type
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|declared_type
operator|=
name|unlowered_expr_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* ARM $5.2.5 last annotation says this should be forbidden.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids %sing an enum"
argument_list|,
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|type
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot %s a pointer to incomplete type %qT"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|!
name|TYPE_PTROB_P
argument_list|(
name|argtype
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids %sing a pointer of type %qT"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
name|inc
operator|=
name|cxx_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|cp_convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|,
name|compound
decl_stmt|;
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build2
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
name|compound
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Eliminate warning about unused result of + or -.  */
name|TREE_NO_WARNING
argument_list|(
name|compound
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|compound
return|;
block|}
default|default:
break|break;
block|}
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|lv_increment
else|:
name|lv_decrement
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Forbid using -- on `bool'.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|declared_type
argument_list|,
name|boolean_type_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of %<--%> on bool variable %qD"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|val
operator|=
name|boolean_increment
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
name|argtype
operator|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
goto|goto
name|offset_ref
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|DECL_MAIN_P
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* ARM $3.4 */
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking address of function %<::main%>"
argument_list|)
expr_stmt|;
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* We don't need to have `current_class_ptr' wrapped in a 	     NON_LVALUE_EXPR node.  */
if|if
condition|(
name|arg
operator|==
name|current_class_ref
condition|)
return|return
name|current_class_ptr
return|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Don't let this be an lvalue.  */
name|arg
operator|=
name|rvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
comment|/* Uninstantiated types are all functions.  Taking the 	 address of a function is a no-op, so just return the 	 argument.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|||
operator|!
name|IDENTIFIER_OPNAME_P
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* They're trying to take the address of a unique non-static 	     member function.  This is ill-formed (except in MS-land), 	     but let's try to DTRT. 	     Note: We only handle unique functions here because we don't 	     want to complain if there's a static overload; non-unique 	     cases will be handled by instantiate_type.  But we need to 	     handle this case here to allow casts on the resulting PMF. 	     We could defer this in non-MS mode, but it's easier to give 	     a useful error here.  */
comment|/* Inside constant member functions, the `this' pointer 	     contains an extra const qualifier.  TYPE_MAIN_VARIANT 	     is used here to remove this const from the diagnostics 	     and the created OFFSET_REF.  */
name|tree
name|base
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|get_first_fn
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_ms_extensions
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_ref
condition|)
comment|/* An expression like&memfn.  */
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of an unqualified"
literal|" or parenthesized non-static member function to form"
literal|" a pointer to member function.  Say %<&%T::%D%>"
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of a bound member"
literal|" function to form a pointer to member function."
literal|"  Say %<&%T::%D%>"
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|build_offset_ref
argument_list|(
name|base
argument_list|,
name|fn
argument_list|,
comment|/*address_p=*/
name|true
argument_list|)
expr_stmt|;
block|}
name|offset_ref
label|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of a cast to a non-lvalue expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
name|arg
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|OVERLOAD
case|:
name|arg
operator|=
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_REF
case|:
comment|/* Turn a reference to a non-static data member into a 	     pointer-to-member.  */
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|PTRMEM_OK_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot create pointer to reference member %qD"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|build_ptrmem_type
argument_list|(
name|context_for_name_lookup
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_ptrmem_cst
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
default|default:
break|break;
block|}
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_REF
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
name|lv_addressof
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|argtype
operator|!=
name|error_mark_node
condition|)
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
comment|/* In a template, we are processing a non-dependent expression 	 so we can just form an ADDR_EXPR with the correct type.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|val
operator|=
name|build_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|PTRMEM_OK_P
argument_list|(
name|val
argument_list|)
operator|=
name|PTRMEM_OK_P
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|COMPONENT_REF
condition|)
block|{
name|val
operator|=
name|build_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|PTRMEM_OK_P
argument_list|(
name|val
argument_list|)
operator|=
name|PTRMEM_OK_P
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BASELINK
condition|)
block|{
name|tree
name|fn
init|=
name|BASELINK_FUNCTIONS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can only get here with a single static member 	     function.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_address
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Do not lose object's side effects.  */
name|val
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure member %qD"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|object
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|,
name|decl_type_context
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|build_ptrmemfunc_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_ptrmemfunc
argument_list|(
name|argtype
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
comment|/*c_cast_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"%s"
argument_list|,
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return    NULL_TREE.  */
end_comment

begin_function
name|tree
name|unary_complex_lvalue
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
comment|/* Inside a template, making these kinds of adjustments is      pointless; we are only concerned with the type of the      expression.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MAX_EXPR
condition|)
return|return
name|rationalize_conditional_expr
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
return|;
comment|/* Handle (a = b), (++a), and (--a) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
name|tree
name|lvalue
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lvalue
argument_list|)
condition|)
block|{
name|lvalue
operator|=
name|stabilize_reference
argument_list|(
name|lvalue
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|lvalue
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lvalue
argument_list|)
argument_list|,
name|arg
argument_list|,
name|lvalue
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Handle (a = b) used as an "lvalue" for `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|arg
argument_list|,
name|real_result
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|arg
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We permit compiler to make function calls returning      objects of aggregate type look like lvalues.  */
block|{
name|tree
name|targ
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|arg
expr_stmt|;
else|else
name|targ
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|targ
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|build3
argument_list|(
name|SAVE_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Don't let anything else be handled specially.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is true if successful.     C++: we do not allow `current_class_ptr' to be addressable.  */
end_comment

begin_function
name|bool
name|cxx_mark_addressable
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|x
operator|==
name|current_class_ptr
condition|)
block|{
name|error
argument_list|(
literal|"cannot take the address of %<this%>, which is an rvalue expression"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* so compiler doesn't die later.  */
return|return
name|true
return|;
block|}
comment|/* Fall through.  */
case|case
name|VAR_DECL
case|:
comment|/* Caller should not be trying to mark initialized 	   constant fields addressable.  */
name|gcc_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CONST_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of explicit register variable %qD requested"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"address requested for %qD, which is declared %<register%>"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
case|case
name|TARGET_EXPR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cxx_mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_x_conditional_expr
parameter_list|(
name|tree
name|ifexp
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
name|tree
name|orig_ifexp
init|=
name|ifexp
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|;
name|tree
name|orig_op2
init|=
name|op2
decl_stmt|;
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* The standard says that the expression is type-dependent if 	 IFEXP is type-dependent, even though the eventual type of the 	 expression doesn't dependent on IFEXP.  */
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|ifexp
argument_list|)
comment|/* As a GNU extension, the middle operand may be omitted.  */
operator|||
operator|(
name|op1
operator|&&
name|type_dependent_expression_p
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|op2
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|COND_EXPR
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
name|ifexp
operator|=
name|build_non_dependent_expr
argument_list|(
name|ifexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|op1
operator|=
name|build_non_dependent_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|build_non_dependent_expr
argument_list|(
name|op2
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|expr
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|COND_EXPR
argument_list|,
name|expr
argument_list|,
name|orig_ifexp
argument_list|,
name|orig_op1
argument_list|,
name|orig_op2
argument_list|)
return|;
return|return
name|expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_x_compound_expr_from_list
parameter_list|(
name|tree
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|tree
name|expr
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
condition|)
name|pedwarn
argument_list|(
literal|"%s expression list treated as compound expression"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
name|expr
operator|=
name|build_x_compound_expr
argument_list|(
name|expr
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Handle overloading of the ',' operator when needed.  */
end_comment

begin_function
name|tree
name|build_x_compound_expr
parameter_list|(
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|orig_op1
init|=
name|op1
decl_stmt|;
name|tree
name|orig_op2
init|=
name|op2
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|op1
argument_list|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|op2
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
name|op1
operator|=
name|build_non_dependent_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|build_non_dependent_expr
argument_list|(
name|op2
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_new_op
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|build_compound_expr
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|result
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|result
argument_list|,
name|orig_op1
argument_list|,
name|orig_op2
argument_list|)
return|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a compound expression.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|lhs
operator|=
name|convert_to_void
argument_list|(
name|lhs
argument_list|,
literal|"left-hand operand of comma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
operator|||
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
comment|/* If the rhs is a TARGET_EXPR, then build the compound 	 expression inside the target_expr's initializer. This 	 helps the compiler to eliminate unnecessary temporaries.  */
name|tree
name|init
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|init
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|rhs
return|;
block|}
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Issue a diagnostic message if casting from SRC_TYPE to DEST_TYPE    casts away constness.  DIAG_FN gives the function to call if we    need to issue a diagnostic; if it is NULL, no diagnostic will be    issued.  DESCRIPTION explains what operation is taking place.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|check_for_casting_away_constness
argument_list|(
name|tree
name|src_type
argument_list|,
name|tree
name|dest_type
argument_list|,
name|void
argument_list|(
argument|*diag_fn
argument_list|)
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
name|ATTRIBUTE_GCC_CXXDIAG
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
name|description
argument_list|)
block|{
if|if
condition|(
name|diag_fn
operator|&&
name|casts_away_constness
argument_list|(
name|src_type
argument_list|,
name|dest_type
argument_list|)
condition|)
name|diag_fn
argument_list|(
literal|"%s from type %qT to type %qT casts away constness"
argument_list|,
name|description
argument_list|,
name|src_type
argument_list|,
name|dest_type
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Convert EXPR (an expression with pointer-to-member type) to TYPE    (another pointer-to-member type in the same hierarchy) and return    the converted expression.  If ALLOW_INVERSE_P is permitted, a    pointer-to-derived may be converted to pointer-to-base; otherwise,    only the other direction is permitted.  If C_CAST_P is true, this    conversion is taking place as part of a C-style cast.  */
end_comment

begin_function
name|tree
name|convert_ptrmem
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|allow_inverse_p
parameter_list|,
name|bool
name|c_cast_p
parameter_list|)
block|{
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|delta
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
name|expr
operator|=
name|cplus_expand_constant
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|delta
operator|=
name|get_delta_difference
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|allow_inverse_p
argument_list|,
name|c_cast_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|delta
argument_list|)
condition|)
name|expr
operator|=
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_nop
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|expr
argument_list|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
else|else
return|return
name|build_ptrmemfunc
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|,
name|allow_inverse_p
argument_list|,
name|c_cast_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If EXPR is an INTEGER_CST and ORIG is an arithmetic constant, return    a version of EXPR that has TREE_OVERFLOW and/or TREE_CONSTANT_OVERFLOW    set iff they are set in ORIG.  Otherwise, return EXPR unchanged.  */
end_comment

begin_function
specifier|static
name|tree
name|ignore_overflows
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|orig
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|CONSTANT_CLASS_P
argument_list|(
name|orig
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|!=
name|STRING_CST
operator|&&
operator|(
name|TREE_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|!=
name|TREE_OVERFLOW
argument_list|(
name|orig
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|!=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|orig
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_OVERFLOW
argument_list|(
name|orig
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|orig
argument_list|)
condition|)
comment|/* Ensure constant sharing.  */
name|expr
operator|=
name|build_int_cst_wide
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Avoid clobbering a shared constant.  */
name|expr
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Perform a static_cast from EXPR to TYPE.  When C_CAST_P is true,    this static_cast is being attempted as one of the possible casts    allowed by a C-style cast.  (In that case, accessibility of base    classes is not considered, and it is OK to cast away    constness.)  Return the result of the cast.  *VALID_P is set to    indicate whether or not the cast was valid.  */
end_comment

begin_function
specifier|static
name|tree
name|build_static_cast_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|c_cast_p
parameter_list|,
name|bool
modifier|*
name|valid_p
parameter_list|)
block|{
name|tree
name|intype
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|tree
name|orig
decl_stmt|;
name|void
function_decl|(
modifier|*
name|diag_fn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTRIBUTE_GCC_CXXDIAG
parameter_list|(
function_decl|1
operator|,
function_decl|2
block|)
function|;
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assume the cast is valid.  */
end_comment

begin_expr_stmt
operator|*
name|valid_p
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save casted types in the function's used types hash table.  */
end_comment

begin_expr_stmt
name|used_types_insert
argument_list|(
name|type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Determine what to do when casting away constness.  */
end_comment

begin_if
if|if
condition|(
name|c_cast_p
condition|)
block|{
comment|/* C-style casts are allowed to cast away constness.  With 	 WARN_CAST_QUAL, we still want to issue a warning.  */
name|diag_fn
operator|=
name|warn_cast_qual
condition|?
name|warning0
else|:
name|NULL
expr_stmt|;
name|desc
operator|=
literal|"cast"
expr_stmt|;
block|}
else|else
block|{
comment|/* A static_cast may not cast away constness.  */
name|diag_fn
operator|=
name|error
expr_stmt|;
name|desc
operator|=
literal|"static_cast"
expr_stmt|;
block|}
end_if

begin_comment
comment|/* [expr.static.cast]       An lvalue of type "cv1 B", where B is a class type, can be cast      to type "reference to cv2 D", where D is a class derived (clause      _class.derived_) from B, if a valid standard conversion from      "pointer to D" to "pointer to B" exists (_conv.ptr_), cv2 is the      same cv-qualification as, or greater cv-qualification than, cv1,      and B is not a virtual base class of D.  */
end_comment

begin_comment
comment|/* We check this case before checking the validity of "TYPE t =      EXPR;" below because for this case:         struct B {};        struct D : public B { D(const B&); };        extern B& b;        void f() { static_cast<const D&>(b); }       we want to avoid constructing a new D.  The standard is not      completely clear about this issue, but our interpretation is      consistent with other compilers.  */
end_comment

begin_if
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|intype
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|intype
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|can_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|c_cast_p
operator|||
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|intype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|base
decl_stmt|;
comment|/* There is a standard conversion from "D*" to "B*" even if "B" 	 is ambiguous or inaccessible.  If this is really a 	 static_cast, then we check both for inaccessibility and 	 ambiguity.  However, if this is a static_cast being performed 	 because the user wrote a C-style cast, then accessibility is 	 not considered.  */
name|base
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|intype
argument_list|,
name|c_cast_p
condition|?
name|ba_unique
else|:
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Convert from "B*" to "D*".  This function will check that "B" 	 is not a virtual base of "D".  */
name|expr
operator|=
name|build_base_path
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_address
argument_list|(
name|expr
argument_list|)
argument_list|,
name|base
argument_list|,
comment|/*nonnull=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Convert the pointer to a reference -- but then remember that 	 there are no expressions with reference type in C++.  */
return|return
name|convert_from_reference
argument_list|(
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_if

begin_expr_stmt
name|orig
operator|=
name|expr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* [expr.static.cast]       An expression e can be explicitly converted to a type T using a      static_cast of the form static_cast<T>(e) if the declaration T      t(e);" is well-formed, for some invented temporary variable      t.  */
end_comment

begin_expr_stmt
name|result
operator|=
name|perform_direct_initialization_if_possible
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|c_cast_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|result
condition|)
block|{
name|result
operator|=
name|convert_from_reference
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
name|result
operator|=
name|ignore_overflows
argument_list|(
name|result
argument_list|,
name|orig
argument_list|)
expr_stmt|;
comment|/* [expr.static.cast]  	 If T is a reference type, the result is an lvalue; otherwise, 	 the result is an rvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
name|result
operator|=
name|rvalue
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_if

begin_comment
comment|/* [expr.static.cast]       Any expression can be explicitly converted to type cv void.  */
end_comment

begin_if
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|convert_to_void
argument_list|(
name|expr
argument_list|,
comment|/*implicit=*/
name|NULL
argument_list|)
return|;
end_if

begin_comment
comment|/* [expr.static.cast]       The inverse of any standard conversion sequence (clause _conv_),      other than the lvalue-to-rvalue (_conv.lval_), array-to-pointer      (_conv.array_), function-to-pointer (_conv.func_), and boolean      (_conv.bool_) conversions, can be performed explicitly using      static_cast subject to the restriction that the explicit      conversion does not cast away constness (_expr.const.cast_), and      the following additional rules for specific cases:  */
end_comment

begin_comment
comment|/* For reference, the conversions not excluded are: integral      promotions, floating point promotion, integral conversions,      floating point conversions, floating-integral conversions,      pointer conversions, and pointer to member conversions.  */
end_comment

begin_comment
comment|/* DR 128       A value of integral _or enumeration_ type can be explicitly      converted to an enumeration type.  */
end_comment

begin_comment
comment|/* The effect of all that is that any conversion between any two      types which are integral, floating, or enumeration types can be      performed.  */
end_comment

begin_if
if|if
condition|(
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|intype
argument_list|)
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
name|expr
operator|=
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|CONV_C_CAST
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
name|expr
operator|=
name|ignore_overflows
argument_list|(
name|expr
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_if

begin_if
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|intype
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|can_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|c_cast_p
condition|)
name|check_for_casting_away_constness
argument_list|(
name|intype
argument_list|,
name|type
argument_list|,
name|diag_fn
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|base
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|c_cast_p
condition|?
name|ba_unique
else|:
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|build_base_path
argument_list|(
name|MINUS_EXPR
argument_list|,
name|expr
argument_list|,
name|base
argument_list|,
comment|/*nonnull=*/
name|false
argument_list|)
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|c1
decl_stmt|;
name|tree
name|c2
decl_stmt|;
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|c1
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|c2
operator|=
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|t1
operator|=
operator|(
name|build_ptrmem_type
argument_list|(
name|c1
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|t2
operator|=
operator|(
name|build_ptrmem_type
argument_list|(
name|c2
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t1
operator|=
name|intype
expr_stmt|;
name|t2
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|can_convert
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|c_cast_p
condition|)
name|check_for_casting_away_constness
argument_list|(
name|intype
argument_list|,
name|type
argument_list|,
name|diag_fn
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
name|convert_ptrmem
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
comment|/*allow_inverse_p=*/
literal|1
argument_list|,
name|c_cast_p
argument_list|)
return|;
block|}
block|}
end_if

begin_comment
comment|/* [expr.static.cast]       An rvalue of type "pointer to cv void" can be explicitly      converted to a pointer to object type.  A value of type pointer      to object converted to "pointer to cv void" and back to the      original pointer type will have its original value.  */
end_comment

begin_if
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|c_cast_p
condition|)
name|check_for_casting_away_constness
argument_list|(
name|intype
argument_list|,
name|type
argument_list|,
name|diag_fn
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_if

begin_expr_stmt
operator|*
name|valid_p
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|error_mark_node
return|;
end_return

begin_comment
unit|}
comment|/* Return an expression representing static_cast<TYPE>(EXPR).  */
end_comment

begin_macro
unit|tree
name|build_static_cast
argument_list|(
argument|tree type
argument_list|,
argument|tree expr
argument_list|)
end_macro

begin_block
block|{
name|tree
name|result
decl_stmt|;
name|bool
name|valid_p
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|expr
operator|=
name|build_min
argument_list|(
name|STATIC_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* We don't know if it will or will not have side effects.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_static_cast_1
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
comment|/*c_cast_p=*/
name|false
argument_list|,
operator|&
name|valid_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_p
condition|)
return|return
name|result
return|;
name|error
argument_list|(
literal|"invalid static_cast from type %qT to type %qT"
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_block

begin_comment
comment|/* EXPR is an expression with member function or pointer-to-member    function type.  TYPE is a pointer type.  Converting EXPR to TYPE is    not permitted by ISO C++, but we accept it in some modes.  If we    are not in one of those modes, issue a diagnostic.  Return the    converted expression.  */
end_comment

begin_function
name|tree
name|convert_member_func_to_ptr
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|intype
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pmf2ptr
condition|)
name|pedwarn
argument_list|(
literal|"converting from %qT to %qT"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|expr
operator|=
name|build_addr_func
argument_list|(
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
name|expr
operator|=
name|build_address
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_address
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expr
operator|=
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|decl
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a representation for a reinterpret_cast from EXPR to TYPE.    If C_CAST_P is true, this reinterpret cast is being done as part of    a C-style cast.  If VALID_P is non-NULL, *VALID_P is set to    indicate whether or not reinterpret_cast was valid.  */
end_comment

begin_function
specifier|static
name|tree
name|build_reinterpret_cast_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|c_cast_p
parameter_list|,
name|bool
modifier|*
name|valid_p
parameter_list|)
block|{
name|tree
name|intype
decl_stmt|;
comment|/* Assume the cast is invalid.  */
if|if
condition|(
name|valid_p
condition|)
operator|*
name|valid_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Save casted types in the function's used types hash table.  */
name|used_types_insert
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* [expr.reinterpret.cast]      An lvalue expression of type T1 can be cast to the type      "reference to T2" if an expression of type "pointer to T1" can be      explicitly converted to the type "pointer to T2" using a      reinterpret_cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid cast of an rvalue expression of type "
literal|"%qT to type %qT"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Warn about a reinterpret_cast from "A*" to "B&" if "A" and 	 "B" are related class types; the reinterpret_cast does not 	 adjust the pointer.  */
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|intype
argument_list|)
operator|&&
operator|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_DERIVED
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"casting %qT to %qT does not dereference pointer"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|build_reinterpret_cast_1
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|,
name|c_cast_p
argument_list|,
name|valid_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/* As a G++ extension, we consider conversions from member      functions, and pointers to member functions to      pointer-to-function and pointer-to-void types.  If      -Wno-pmf-conversions has not been specified,      convert_member_func_to_ptr will issue an error message.  */
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|convert_member_func_to_ptr
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* If the cast is not to a reference type, the lvalue-to-rvalue,      array-to-pointer, and function-to-pointer conversions are      performed.  */
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* [expr.reinterpret.cast]      A pointer can be converted to any integral type large enough to      hold it.  */
if|if
condition|(
name|CP_INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"cast from %qT to %qT loses precision"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* [expr.reinterpret.cast]      A value of integral or enumeration type can be explicitly      converted to a pointer.  */
elseif|else
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|intype
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRFN_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|sexpr
init|=
name|expr
decl_stmt|;
if|if
condition|(
operator|!
name|c_cast_p
condition|)
name|check_for_casting_away_constness
argument_list|(
name|intype
argument_list|,
name|type
argument_list|,
name|error
argument_list|,
literal|"reinterpret_cast"
argument_list|)
expr_stmt|;
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"cast from %qT to %qT increases required alignment of "
literal|"target type"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* We need to strip nops here, because the frontend likes to 	 create (int *)&a for array-to-pointer decay, instead of&a[0].  */
name|STRIP_NOPS
argument_list|(
name|sexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_strict_aliasing
operator|<=
literal|2
condition|)
name|strict_aliasing_warning
argument_list|(
name|intype
argument_list|,
name|type
argument_list|,
name|sexpr
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|intype
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
comment|/* Only issue a warning, as we have always supported this 	   where possible, and it is necessary in some cases.  DR 195 	   addresses this issue, but as of 2004/10/26 is still in 	   drafting.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ISO C++ forbids casting between pointer-to-function and pointer-to-object"
argument_list|)
expr_stmt|;
return|return
name|fold_if_not_in_template
argument_list|(
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_vector
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|valid_p
condition|)
operator|*
name|valid_p
operator|=
name|false
expr_stmt|;
name|error
argument_list|(
literal|"invalid cast from type %qT to type %qT"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_reinterpret_cast
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|REINTERPRET_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|&&
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* There might turn out to be side effects inside expr.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
block|}
return|return
name|build_reinterpret_cast_1
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
comment|/*c_cast_p=*/
name|false
argument_list|,
comment|/*valid_p=*/
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform a const_cast from EXPR to TYPE.  If the cast is valid,    return an appropriate expression.  Otherwise, return    error_mark_node.  If the cast is not valid, and COMPLAIN is true,    then a diagnostic will be issued.  If VALID_P is non-NULL, we are    performing a C-style cast, its value upon return will indicate    whether or not the conversion succeeded.  */
end_comment

begin_function
specifier|static
name|tree
name|build_const_cast_1
parameter_list|(
name|tree
name|dst_type
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|complain
parameter_list|,
name|bool
modifier|*
name|valid_p
parameter_list|)
block|{
name|tree
name|src_type
decl_stmt|;
name|tree
name|reference_type
decl_stmt|;
comment|/* Callers are responsible for handling error_mark_node as a      destination type.  */
name|gcc_assert
argument_list|(
name|dst_type
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* In a template, callers should be building syntactic      representations of casts, not using this machinery.  */
name|gcc_assert
argument_list|(
operator|!
name|processing_template_decl
argument_list|)
expr_stmt|;
comment|/* Assume the conversion is invalid.  */
if|if
condition|(
name|valid_p
condition|)
operator|*
name|valid_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|dst_type
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
name|dst_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid use of const_cast with type %qT, "
literal|"which is not a pointer, "
literal|"reference, nor a pointer-to-data-member type"
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid use of const_cast with type %qT, which is a pointer "
literal|"or reference to a function type"
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Save casted types in the function's used types hash table.  */
name|used_types_insert
argument_list|(
name|dst_type
argument_list|)
expr_stmt|;
name|src_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Expressions do not really have reference types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|src_type
operator|=
name|TREE_TYPE
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
comment|/* [expr.const.cast]       An lvalue of type T1 can be explicitly converted to an lvalue of      type T2 using the cast const_cast<T2&> (where T1 and T2 are object      types) if a pointer to T1 can be explicitly converted to the type      pointer to T2 using a const_cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dst_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|reference_type
operator|=
name|dst_type
expr_stmt|;
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid const_cast of an rvalue of type %qT to type %qT"
argument_list|,
name|src_type
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|dst_type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|dst_type
argument_list|)
argument_list|)
expr_stmt|;
name|src_type
operator|=
name|build_pointer_type
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reference_type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If the destination type is not a reference type, the 	 lvalue-to-rvalue, array-to-pointer, and function-to-pointer 	 conversions are performed.  */
name|src_type
operator|=
name|type_decays_to
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_PTR_P
argument_list|(
name|src_type
argument_list|)
operator|||
name|TYPE_PTRMEM_P
argument_list|(
name|src_type
argument_list|)
operator|)
operator|&&
name|comp_ptr_ttypes_const
argument_list|(
name|dst_type
argument_list|,
name|src_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|valid_p
condition|)
block|{
operator|*
name|valid_p
operator|=
name|true
expr_stmt|;
comment|/* This cast is actually a C-style cast.  Issue a warning if 	     the user is making a potentially unsafe cast.  */
if|if
condition|(
name|warn_cast_qual
condition|)
name|check_for_casting_away_constness
argument_list|(
name|src_type
argument_list|,
name|dst_type
argument_list|,
name|warning0
argument_list|,
literal|"cast"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reference_type
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_nop
argument_list|(
name|reference_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
else|else
block|{
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an 	     lvalue.  Strip such NOP_EXPRs if VALUE is being used in 	     non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_nop
argument_list|(
name|dst_type
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid const_cast from type %qT to type %qT"
argument_list|,
name|src_type
argument_list|,
name|dst_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_const_cast
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CONST_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|&&
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* There might turn out to be side effects inside expr.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
block|}
return|return
name|build_const_cast_1
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
comment|/*complain=*/
name|true
argument_list|,
comment|/*valid_p=*/
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing an explicit C-style cast to type    TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|value
init|=
name|expr
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|bool
name|valid_p
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CAST_EXPR
argument_list|,
name|type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We don't know if it will or will not have side effects.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
block|}
comment|/* Casts to a (pointer to a) specific ObjC class (or 'id' or      'Class') should always be retained, because this information aids      in method lookup.  */
if|if
condition|(
name|objc_is_object_ptr
argument_list|(
name|type
argument_list|)
operator|&&
name|objc_is_object_ptr
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|build_nop
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Allow casting from T1* to T2[] because Cfront allows it. 	 NIHCL uses it. It is not valid ISO C++ however.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids casting to an array type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ISO C++ forbids casting to an array type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid cast to function type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* A C-style cast can be a const_cast.  */
name|result
operator|=
name|build_const_cast_1
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
comment|/*complain=*/
name|false
argument_list|,
operator|&
name|valid_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_p
condition|)
return|return
name|result
return|;
comment|/* Or a static cast.  */
name|result
operator|=
name|build_static_cast_1
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
comment|/*c_cast_p=*/
name|true
argument_list|,
operator|&
name|valid_p
argument_list|)
expr_stmt|;
comment|/* Or a reinterpret_cast.  */
if|if
condition|(
operator|!
name|valid_p
condition|)
name|result
operator|=
name|build_reinterpret_cast_1
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
comment|/*c_cast_p=*/
name|true
argument_list|,
operator|&
name|valid_p
argument_list|)
expr_stmt|;
comment|/* The static_cast or reinterpret_cast may be followed by a      const_cast.  */
if|if
condition|(
name|valid_p
comment|/* A valid cast may result in errors if, for example, a 	 conversion to am ambiguous base class is required.  */
operator|&&
operator|!
name|error_operand_p
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|tree
name|result_type
decl_stmt|;
comment|/* Non-class rvalues always have cv-unqualified type.  */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|result_type
argument_list|)
condition|)
name|result_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
comment|/* If the type of RESULT does not match TYPE, perform a 	 const_cast to make it match.  If the static_cast or 	 reinterpret_cast succeeded, we will differ by at most 	 cv-qualification, so the follow-on const_cast is guaranteed 	 to succeed.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|non_reference
argument_list|(
name|type
argument_list|)
argument_list|,
name|non_reference
argument_list|(
name|result_type
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_const_cast_1
argument_list|(
name|type
argument_list|,
name|result
argument_list|,
name|false
argument_list|,
operator|&
name|valid_p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|valid_p
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.     C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|enum
name|tree_code
name|modifycode
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
init|=
name|rhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
name|tree
name|olhs
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|plain_assign
init|=
operator|(
name|modifycode
operator|==
name|NOP_EXPR
operator|)
decl_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|error_operand_p
argument_list|(
name|lhs
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle --foo = 5; as these are valid constructs in C++.  */
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|lhs
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newrhs
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|lhs
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
return|;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
comment|/* MIN_EXPR and MAX_EXPR are currently only permitted as lvalues, 	 when neither operand has side-effects.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
name|lv_assign
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|MIN_EXPR
condition|?
name|LE_EXPR
else|:
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
decl_stmt|;
name|tree
name|preeval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rhs
operator|=
name|stabilize_expr
argument_list|(
name|rhs
argument_list|,
operator|&
name|preeval
argument_list|)
expr_stmt|;
comment|/* Check this here to avoid odd errors when trying to convert 	   a throw to the type of the COND_EXPR.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
name|lv_assign
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|cond
operator|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|error_mark_node
condition|)
return|return
name|cond
return|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
if|if
condition|(
name|preeval
condition|)
name|cond
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|preeval
argument_list|,
name|cond
argument_list|)
expr_stmt|;
return|return
name|cond
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
condition|)
comment|/* Call convert to generate an error; see PR 11063.  */
name|rhs
operator|=
name|convert
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|result
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
comment|/* Do the default thing.  */
empty_stmt|;
else|else
block|{
name|result
operator|=
name|build_special_member_call
argument_list|(
name|lhs
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
block|}
else|else
block|{
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* `operator=' is not an inheritable operator.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
comment|/* Do the default thing.  */
empty_stmt|;
else|else
block|{
name|result
operator|=
name|build_new_op
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
name|lhstype
operator|=
name|olhstype
expr_stmt|;
block|}
else|else
block|{
comment|/* A binary op has been requested.  Combine the old LHS 	     value with the RHS producing the value we should actually 	     store into the LHS.  */
name|gcc_assert
argument_list|(
operator|!
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|,
name|REFERENCE_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|cp_build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"  in evaluation of %<%Q(%#T, %#T)%>"
argument_list|,
name|modifycode
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Now it looks like a plain assignment.  */
name|modifycode
operator|=
name|NOP_EXPR
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
block|}
comment|/* The left-hand side must be an lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
name|lv_assign
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Warn about modifying something that is `const'.  Don't warn if      this is initialization.  */
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|lhstype
argument_list|)
comment|/* Functions are not modifiable, even though they are 	     lvalues.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
comment|/* If it's an aggregate and any field is const, then it is 	     effectively const.  */
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|lhstype
argument_list|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member, it has probably been      given type `int'.  Compute the type that would go with the actual      amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower 	 than one, we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Avoid warnings converting integral types back into enums for 	     enum bit fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|olhs
operator|=
name|lhs
expr_stmt|;
block|}
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
block|}
comment|/* Convert new value to destination type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|from_array
decl_stmt|;
if|if
condition|(
operator|!
name|same_or_base_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incompatible types in assignment of %qT to %qT"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Allow array assignment in compiler-generated code.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* This routine is used for both initialization and assignment.              Make sure the diagnostic message differentiates the context.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
name|error
argument_list|(
literal|"array used as initializer"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid array assignment"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|from_array
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
literal|1
operator|+
operator|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|)
else|:
literal|0
expr_stmt|;
return|return
name|build_vec_init
argument_list|(
name|lhs
argument_list|,
name|NULL_TREE
argument_list|,
name|newrhs
argument_list|,
comment|/*explicit_default_init_p=*/
name|false
argument_list|,
name|from_array
argument_list|)
return|;
block|}
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
name|newrhs
operator|=
name|convert_for_initialization
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"initialization"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Avoid warnings on enum bit fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|convert_force
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|lhstype
argument_list|)
condition|)
name|newrhs
operator|=
name|build_cplus_new
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
comment|/* Can't initialize directly from a TARGET_EXPR, since that would 	 cause the lhs to be constructed twice, and possibly result in 	 accidental self-initialization.  So we force the TARGET_EXPR to be 	 expanded without a target.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|newrhs
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|,
name|newrhs
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|flag_objc_gc
condition|)
block|{
name|result
operator|=
name|objc_generate_write_barrier
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
name|result
operator|=
name|build2
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|plain_assign
condition|)
name|TREE_NO_WARNING
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
if|if
condition|(
name|olhs
condition|)
block|{
name|result
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|olhstype
argument_list|,
name|result
argument_list|,
name|olhs
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_x_modify_expr
parameter_list|(
name|tree
name|lhs
parameter_list|,
name|enum
name|tree_code
name|modifycode
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|MODOP_EXPR
argument_list|,
name|lhs
argument_list|,
name|build_min_nt
argument_list|(
name|modifycode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|tree
name|rval
init|=
name|build_new_op
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|modifycode
argument_list|)
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|TREE_NO_WARNING
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
return|return
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get difference in deltas for different pointer to member function    types.  Returns an integer constant of type PTRDIFF_TYPE_NODE.  If    the conversion is invalid, the constant is zero.  If    ALLOW_INVERSE_P is true, then allow reverse conversions as well.    If C_CAST_P is true this conversion is taking place as part of a    C-style cast.     Note that the naming of FROM and TO is kind of backwards; the return    value is what we add to a TO in order to get a FROM.  They are named    this way because we call this function to find out how to convert from    a pointer to member of FROM to a pointer to member of TO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_delta_difference
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|,
name|bool
name|allow_inverse_p
parameter_list|,
name|bool
name|c_cast_p
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
name|base_kind
name|kind
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* Assume no conversion is required.  */
name|result
operator|=
name|integer_zero_node
expr_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|c_cast_p
condition|?
name|ba_unique
else|:
name|ba_check
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|bk_inaccessible
operator|||
name|kind
operator|==
name|bk_ambig
condition|)
name|error
argument_list|(
literal|"   in pointer to member function conversion"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|kind
operator|!=
name|bk_via_virtual
condition|)
name|result
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|virt_binfo
init|=
name|binfo_from_vbase
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
comment|/* This is a reinterpret cast, we choose to do nothing.  */
if|if
condition|(
name|allow_inverse_p
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"pointer to member cast via virtual base %qT"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virt_binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"pointer to member conversion via virtual base %qT"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virt_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
comment|/* Pointer to member of incomplete class is permitted*/
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|allow_inverse_p
condition|)
block|{
name|error_not_base_type
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"   in pointer to member conversion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|binfo
operator|=
name|lookup_base
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|c_cast_p
condition|?
name|ba_unique
else|:
name|ba_check
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|kind
operator|!=
name|bk_via_virtual
condition|)
name|result
operator|=
name|size_diffop
argument_list|(
name|size_zero_node
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This is a reinterpret cast, we choose to do nothing.  */
name|tree
name|virt_binfo
init|=
name|binfo_from_vbase
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"pointer to member cast via virtual base %qT"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virt_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|fold_if_not_in_template
argument_list|(
name|convert_to_integer
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|result
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a constructor for the pointer-to-member-function TYPE using    the other components as specified.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc1
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|delta
parameter_list|,
name|tree
name|pfn
parameter_list|)
block|{
name|tree
name|u
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|delta_field
decl_stmt|;
name|tree
name|pfn_field
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
expr_stmt|;
comment|/* Pull the FIELD_DECLs out of the type.  */
name|pfn_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|delta_field
operator|=
name|TREE_CHAIN
argument_list|(
name|pfn_field
argument_list|)
expr_stmt|;
comment|/* Make sure DELTA has the type we want.  */
name|delta
operator|=
name|convert_and_check
argument_list|(
name|delta_type_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* Finish creating the initializer.  */
name|v
operator|=
name|VEC_alloc
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|pfn_field
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|delta_field
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|u
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|u
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|u
argument_list|)
operator|=
name|TREE_INVARIANT
argument_list|(
name|pfn
argument_list|)
operator|&
name|TREE_INVARIANT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|u
argument_list|)
operator|=
operator|(
name|TREE_CONSTANT
argument_list|(
name|u
argument_list|)
operator|&&
operator|(
name|initializer_constant_valid_p
argument_list|(
name|pfn
argument_list|,
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|initializer_constant_valid_p
argument_list|(
name|delta
argument_list|,
name|TREE_TYPE
argument_list|(
name|delta
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|)
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

begin_comment
comment|/* Build a constructor for a pointer to member function.  It can be    used to initialize global variables, local variable, or used    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we    want to be.     If FORCE is nonzero, then force this conversion, even if    we would rather not do it.  Usually set when using an explicit    cast.  A C-style cast is being processed iff C_CAST_P is true.     Return error_mark_node, if something goes wrong.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|pfn
parameter_list|,
name|int
name|force
parameter_list|,
name|bool
name|c_cast_p
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|pfn_type
decl_stmt|;
name|tree
name|to_type
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|pfn
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|pfn_type
operator|=
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|to_type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Handle multiple conversions of pointer to member functions.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|pfn_type
argument_list|)
condition|)
block|{
name|tree
name|delta
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|npfn
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|can_convert_arg
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|,
name|pfn
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid conversion to type %qT from type %qT"
argument_list|,
name|to_type
argument_list|,
name|pfn_type
argument_list|)
expr_stmt|;
name|n
operator|=
name|get_delta_difference
argument_list|(
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|pfn_type
argument_list|)
argument_list|,
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|force
argument_list|,
name|c_cast_p
argument_list|)
expr_stmt|;
comment|/* We don't have to do any conversion to convert a 	 pointer-to-member to its own type.  But, we don't want to 	 just return a PTRMEM_CST if there's an explicit cast; that 	 cast should make the expression an invalid template argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|!=
name|PTRMEM_CST
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|to_type
argument_list|,
name|pfn_type
argument_list|)
condition|)
return|return
name|pfn
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|build_reinterpret_cast
argument_list|(
name|to_type
argument_list|,
name|pfn
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|pfn
argument_list|)
condition|)
name|pfn
operator|=
name|save_expr
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
comment|/* Obtain the function pointer and the current DELTA.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
name|expand_ptrmemfunc_cst
argument_list|(
name|pfn
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|npfn
argument_list|)
expr_stmt|;
else|else
block|{
name|npfn
operator|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|pfn
argument_list|,
name|pfn_identifier
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build_ptrmemfunc_access_expr
argument_list|(
name|pfn
argument_list|,
name|delta_identifier
argument_list|)
expr_stmt|;
block|}
comment|/* Just adjust the DELTA field.  */
name|gcc_assert
argument_list|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|delta
argument_list|)
argument_list|,
name|ptrdiff_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
operator|==
name|ptrmemfunc_vbit_in_delta
condition|)
name|n
operator|=
name|cp_build_binary_op
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|n
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|delta
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc1
argument_list|(
name|to_type
argument_list|,
name|delta
argument_list|,
name|npfn
argument_list|)
return|;
block|}
comment|/* Handle null pointer to member function conversions.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|pfn
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc1
argument_list|(
name|to_type
argument_list|,
name|integer_zero_node
argument_list|,
name|pfn
argument_list|)
return|;
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|pfn
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|pfn
argument_list|,
name|tf_warning_or_error
argument_list|)
return|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* In a template, we will have preserved the 		 OFFSET_REF.  */
operator|||
operator|(
name|processing_template_decl
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|OFFSET_REF
operator|)
argument_list|)
expr_stmt|;
return|return
name|make_ptrmem_cst
argument_list|(
name|to_type
argument_list|,
name|fn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST    given by CST.     ??? There is no consistency as to the types returned for the above    values.  Some code acts as if it were a sizetype and some as if it were    integer_type_node.  */
end_comment

begin_function
name|void
name|expand_ptrmemfunc_cst
parameter_list|(
name|tree
name|cst
parameter_list|,
name|tree
modifier|*
name|delta
parameter_list|,
name|tree
modifier|*
name|pfn
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|PTRMEM_CST_MEMBER
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|ptr_class
decl_stmt|,
name|fn_class
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* The class that the function belongs to.  */
name|fn_class
operator|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* The class that we're creating a pointer to member of.  */
name|ptr_class
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* First, calculate the adjustment to the function's class.  */
operator|*
name|delta
operator|=
name|get_delta_difference
argument_list|(
name|fn_class
argument_list|,
name|ptr_class
argument_list|,
comment|/*force=*/
literal|0
argument_list|,
comment|/*c_cast_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
operator|*
name|pfn
operator|=
name|convert
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_addr_func
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we're dealing with a virtual function, we have to adjust 'this' 	 again, to point to the base which provides the vtable entry for 	 fn; the call will do the opposite adjustment.  */
name|tree
name|orig_class
init|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_or_else
argument_list|(
name|orig_class
argument_list|,
name|fn_class
argument_list|)
decl_stmt|;
operator|*
name|delta
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|delta
argument_list|)
argument_list|,
operator|*
name|delta
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|fold_if_not_in_template
argument_list|(
operator|*
name|delta
argument_list|)
expr_stmt|;
comment|/* We set PFN to the vtable offset at which the function can be 	 found, plus one (unless ptrmemfunc_vbit_in_delta, in which 	 case delta is shifted left, and then incremented).  */
operator|*
name|pfn
operator|=
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|pfn
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|fold_if_not_in_template
argument_list|(
operator|*
name|pfn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
condition|)
block|{
case|case
name|ptrmemfunc_vbit_in_pfn
case|:
operator|*
name|pfn
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|pfn
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|fold_if_not_in_template
argument_list|(
operator|*
name|pfn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ptrmemfunc_vbit_in_delta
case|:
operator|*
name|delta
operator|=
name|build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|delta
argument_list|)
argument_list|,
operator|*
name|delta
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|fold_if_not_in_template
argument_list|(
operator|*
name|delta
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|delta
argument_list|)
argument_list|,
operator|*
name|delta
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|fold_if_not_in_template
argument_list|(
operator|*
name|delta
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
operator|*
name|pfn
operator|=
name|build_nop
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|*
name|pfn
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|fold_if_not_in_template
argument_list|(
operator|*
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an expression for PFN from the pointer-to-member function    given by T.  */
end_comment

begin_function
specifier|static
name|tree
name|pfn_from_ptrmemfunc
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|t
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|pfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
condition|)
return|return
name|pfn
return|;
block|}
return|return
name|build_ptrmemfunc_access_expr
argument_list|(
name|t
argument_list|,
name|pfn_identifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment to    an lvalue of type TYPE.  ERRTYPE is a string to use in error    messages: "assignment", "return", etc.  If FNDECL is non-NULL, we    are doing the conversion in order to pass the PARMNUMth argument of    FNDECL.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|rhs
parameter_list|,
specifier|const
name|char
modifier|*
name|errtype
parameter_list|,
name|tree
name|fndecl
parameter_list|,
name|int
name|parmnum
parameter_list|)
block|{
name|tree
name|rhstype
decl_stmt|;
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|coder
operator|==
name|VECTOR_TYPE
operator|&&
name|vector_types_convertible_p
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
operator|||
name|rhstype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The RHS of an assignment cannot have void type.  */
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Simplify the RHS if possible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|rhs
operator|=
name|DECL_INITIAL
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|int
name|parmno
decl_stmt|;
name|tree
name|rname
init|=
name|fndecl
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|errtype
argument_list|,
literal|"assignment"
argument_list|)
condition|)
name|parmno
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|errtype
argument_list|,
literal|"initialization"
argument_list|)
condition|)
name|parmno
operator|=
operator|-
literal|2
expr_stmt|;
else|else
block|{
name|tree
name|selector
init|=
name|objc_message_selector
argument_list|()
decl_stmt|;
name|parmno
operator|=
name|parmnum
expr_stmt|;
if|if
condition|(
name|selector
operator|&&
name|parmno
operator|>
literal|1
condition|)
block|{
name|rname
operator|=
name|selector
expr_stmt|;
name|parmno
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objc_compare_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
name|parmno
argument_list|,
name|rname
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* [expr.ass]       The expression is implicitly converted (clause _conv_) to the      cv-unqualified type of the left operand.       We allow bad conversions here because by the time we get to this point      we are committed to doing the conversion.  If we end up doing a bad      conversion, convert_like will complain.  */
if|if
condition|(
operator|!
name|can_convert_arg_bad
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
comment|/* When -Wno-pmf-conversions is use, we just silently allow 	 conversions from pointers-to-members to plain pointers.  If 	 the conversion doesn't work, cp_convert will complain.  */
if|if
condition|(
operator|!
name|warn_pmf2ptr
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|rhstype
argument_list|)
condition|)
name|rhs
operator|=
name|cp_convert
argument_list|(
name|strip_top_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If the right-hand side has unknown type, then it is an 	     overloaded function.  Call instantiate_type to get error 	     messages.  */
if|if
condition|(
name|rhstype
operator|==
name|unknown_type_node
condition|)
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|tf_warning_or_error
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fndecl
condition|)
name|error
argument_list|(
literal|"cannot convert %qT to %qT for argument %qP to %qD"
argument_list|,
name|rhstype
argument_list|,
name|type
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot convert %qT to %qT in %s"
argument_list|,
name|rhstype
argument_list|,
name|type
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|warn_missing_format_attribute
condition|)
block|{
specifier|const
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|codel
operator|==
name|POINTER_TYPE
operator|||
name|codel
operator|==
name|REFERENCE_TYPE
operator|)
operator|&&
name|coder
operator|==
name|codel
operator|&&
name|check_missing_format_attribute
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_format_attribute
argument_list|,
literal|"%s might be a candidate for a format attribute"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
block|}
comment|/* If -Wparentheses, warn about a = b = c when a has type bool and b      does not.  */
if|if
condition|(
name|warn_parentheses
operator|&&
name|type
operator|==
name|boolean_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|rhs
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|boolean_type_node
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|rhs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|perform_implicit_conversion
argument_list|(
name|strip_top_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert RHS to be of type TYPE.    If EXP is nonzero, it is the target of the initialization.    ERRTYPE is a string to use in error messages.     Two major differences between the behavior of    `convert_for_assignment' and `convert_for_initialization'    are that references are bashed in the former, while    copied in the latter, and aggregates are assigned in    the former (operator=) while initialized in the    latter (X(X&)).     If using constructor make sure no conversion operator exists, if one does    exist, an ambiguity exists.     If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */
end_comment

begin_function
name|tree
name|convert_for_initialization
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|errtype
parameter_list|,
name|tree
name|fndecl
parameter_list|,
name|int
name|parmnum
parameter_list|)
block|{
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|rhstype
decl_stmt|;
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|codel
operator|!=
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|rhs
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|rhs
operator|=
name|decay_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* We accept references to incomplete types, so we can      return here before checking if RHS is of complete type.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* This should eventually happen in convert_arguments.  */
name|int
name|savew
init|=
literal|0
decl_stmt|,
name|savee
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fndecl
condition|)
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|rhs
operator|=
name|initialize_reference
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
comment|/*decl=*/
name|NULL_TREE
argument_list|,
comment|/*cleanup=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"in passing argument %P of %q+D"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|error
argument_list|(
literal|"in passing argument %P of %q+D"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
name|exp
operator|=
name|require_complete_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rhstype
operator|=
name|non_reference
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|flags
argument_list|)
return|;
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If RETVAL is the address of, or a reference to, a local variable or    temporary give an appropriate warning.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_warn_about_returning_address_of_local
parameter_list|(
name|tree
name|retval
parameter_list|)
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|whats_returned
init|=
name|retval
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return;
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|AGGR_INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"returning reference to temporary"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|TEMP_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"reference to non-lvalue returned"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|whats_returned
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|whats_returned
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"reference to local variable %q+D returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"address of local variable %q+D returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Check that returning RETVAL from the current function is valid.    Return an expression explicitly showing all conversions required to    change RETVAL into the function return type, and to assign it to    the DECL_RESULT for the function.  Set *NO_WARNING to true if    code reaches end of non-void function warning shouldn't be issued    on this RETURN_EXPR.  */
end_comment

begin_function
name|tree
name|check_return_expr
parameter_list|(
name|tree
name|retval
parameter_list|,
name|bool
modifier|*
name|no_warning
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
comment|/* The type actually returned by the function, after any      promotions.  */
name|tree
name|valtype
decl_stmt|;
name|int
name|fn_returns_value_p
decl_stmt|;
operator|*
name|no_warning
operator|=
name|false
expr_stmt|;
comment|/* A `volatile' function is one that isn't supposed to return, ever.      (This is a G++ extension, used to get better code for functions      that call the `volatile' function.)  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"function declared %<noreturn%> has a %<return%> statement"
argument_list|)
expr_stmt|;
comment|/* Check for various simple errors.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|retval
condition|)
name|error
argument_list|(
literal|"returning a value from a destructor"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|in_function_try_handler
condition|)
comment|/* If a return statement appears in a handler of the 	   function-try-block of a constructor, the program is ill-formed.  */
name|error
argument_list|(
literal|"cannot return from a handler of a function-try-block of a constructor"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
condition|)
comment|/* You can't return a value from a constructor.  */
name|error
argument_list|(
literal|"returning a value from a constructor"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* When no explicit return-value is given in a function with a named      return value, the named return value is used.  */
name|result
operator|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|valtype
operator|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|valtype
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fn_returns_value_p
operator|=
operator|!
name|VOID_TYPE_P
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
operator|&&
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|&&
name|fn_returns_value_p
condition|)
name|retval
operator|=
name|result
expr_stmt|;
comment|/* Check for a return statement with no return value in a function      that's supposed to return a value.  */
if|if
condition|(
operator|!
name|retval
operator|&&
name|fn_returns_value_p
condition|)
block|{
name|pedwarn
argument_list|(
literal|"return-statement with no value, in function returning %qT"
argument_list|,
name|valtype
argument_list|)
expr_stmt|;
comment|/* Clear this, so finish_function won't say that we reach the 	 end of a non-void function (which we don't, we gave a 	 return!).  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
comment|/* And signal caller that TREE_NO_WARNING should be set on the 	 RETURN_EXPR to avoid control reaches end of non-void function 	 warnings in tree-cfg.c.  */
operator|*
name|no_warning
operator|=
name|true
expr_stmt|;
block|}
comment|/* Check for a return statement with a value in a function that      isn't supposed to return a value.  */
elseif|else
if|if
condition|(
name|retval
operator|&&
operator|!
name|fn_returns_value_p
condition|)
block|{
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
condition|)
comment|/* You can return a `void' value from a function of `void' 	   type.  In that case, we have to evaluate the expression for 	   its side-effects.  */
name|finish_expr_stmt
argument_list|(
name|retval
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"return-statement with a value, in function "
literal|"returning 'void'"
argument_list|)
expr_stmt|;
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
comment|/* There's really no value to return, after all.  */
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
comment|/* Remember that this function can sometimes return without a        value.  */
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Remember that this function did return a value.  */
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
comment|/* Check for erroneous operands -- but after giving ourselves a      chance to provide an error about returning a value from a void      function.  */
if|if
condition|(
name|error_operand_p
argument_list|(
name|retval
argument_list|)
condition|)
block|{
name|current_function_return_value
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Only operator new(...) throw(), can return NULL [expr.new/13].  */
if|if
condition|(
operator|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NEW_EXPR
operator|||
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|VEC_NEW_EXPR
operator|)
operator|&&
operator|!
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_check_new
operator|&&
name|null_ptr_cst_p
argument_list|(
name|retval
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<operator new%> must not return NULL unless it is "
literal|"declared %<throw()%> (or -fcheck-new is in effect)"
argument_list|)
expr_stmt|;
comment|/* Effective C++ rule 15.  See also start_function.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
condition|)
block|{
name|bool
name|warn
init|=
name|true
decl_stmt|;
comment|/* The function return type must be a reference to the current 	class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_class_ref
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Returning '*this' is obviously OK.  */
if|if
condition|(
name|retval
operator|==
name|current_class_ref
condition|)
name|warn
operator|=
name|false
expr_stmt|;
comment|/* If we are calling a function whose return type is the same of 	     the current class reference, it is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|warn
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"%<operator=%> should return a reference to %<*this%>"
argument_list|)
expr_stmt|;
block|}
comment|/* The fabled Named Return Value optimization, as per [class.copy]/15:       [...]      For  a function with a class return type, if the expression      in the return statement is the name of a local  object,  and  the  cv-      unqualified  type  of  the  local  object  is the same as the function      return type, an implementation is permitted to omit creating the  tem-      porary  object  to  hold  the function return value [...]       So, if this is a value-returning function that always returns the same      local variable, remember it.       It might be nice to be more flexible, and choose the first suitable      variable even if the function sometimes returns something else, but      then we run the risk of clobbering the variable we chose if the other      returned expression uses the chosen variable somehow.  And people expect      this restriction, anyway.  (jason 2000-11-19)       See finish_function and finalize_nrv for the rest of this optimization.  */
if|if
condition|(
name|fn_returns_value_p
operator|&&
name|flag_elide_constructors
condition|)
block|{
if|if
condition|(
name|retval
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|current_function_return_value
operator|==
name|NULL_TREE
operator|||
name|current_function_return_value
operator|==
name|retval
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|retval
argument_list|)
operator|==
name|current_function_decl
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|retval
argument_list|)
operator|&&
operator|!
name|DECL_ANON_UNION_VAR_P
argument_list|(
name|retval
argument_list|)
operator|&&
operator|(
name|DECL_ALIGN
argument_list|(
name|retval
argument_list|)
operator|>=
name|DECL_ALIGN
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|same_type_p
argument_list|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|)
argument_list|,
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|)
condition|)
name|current_function_return_value
operator|=
name|retval
expr_stmt|;
else|else
name|current_function_return_value
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* We don't need to do any conversions when there's nothing being      returned.  */
if|if
condition|(
operator|!
name|retval
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Do any required conversions.  */
if|if
condition|(
name|retval
operator|==
name|result
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* No conversions are required.  */
empty_stmt|;
else|else
block|{
comment|/* The type the function is declared to return.  */
name|tree
name|functype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The functype's return type will have been set to void, if it 	 was an incomplete type.  Just treat this as 'return;' */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|functype
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* First convert the value to the function's return type, then 	 to the type of return value's location to handle the 	 case that functype is smaller than the valtype.  */
name|retval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|functype
argument_list|,
name|retval
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|,
literal|"return"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|convert
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* If the conversion failed, treat this just like `return;'.  */
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
return|return
name|retval
return|;
comment|/* We can't initialize a register from a AGGR_INIT_EXPR.  */
elseif|else
if|if
condition|(
operator|!
name|current_function_returns_struct
operator|&&
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
name|retval
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|,
name|retval
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|maybe_warn_about_returning_address_of_local
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
comment|/* Actually copy the value returned into the appropriate location.  */
if|if
condition|(
name|retval
operator|&&
name|retval
operator|!=
name|result
condition|)
name|retval
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns nonzero if the pointer-type FROM can be converted to the    pointer-type TO via a qualification conversion.  If CONSTP is -1,    then we return nonzero if the pointers are similar, and the    cv-qualification signature of FROM is a proper subset of that of TO.     If CONSTP is positive, then all outer pointers have been    const-qualified.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_real
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|,
name|int
name|constp
parameter_list|)
block|{
name|bool
name|to_more_cv_qualified
init|=
name|false
decl_stmt|;
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
comment|/* In Objective-C++, some types may have been 'volatilized' by 	     the compiler for EH; when comparing them here, the volatile 	     qualification must be ignored.  */
name|bool
name|objc_quals_match
init|=
name|objc_type_quals_match
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|&&
operator|!
name|objc_quals_match
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|&&
operator|!
name|objc_quals_match
condition|)
block|{
if|if
condition|(
name|constp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|to_more_cv_qualified
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|constp
operator|>
literal|0
condition|)
name|constp
operator|&=
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
operator|(
operator|(
name|constp
operator|>=
literal|0
operator|||
name|to_more_cv_qualified
operator|)
operator|&&
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* When comparing, say, char ** to char const **, this function takes    the 'char *' and 'char const *'.  Do not pass non-pointer/reference    types to this function.  */
end_comment

begin_function
name|int
name|comp_ptr_ttypes
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
return|return
name|comp_ptr_ttypes_real
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if to and from are (possibly multi-level) pointers to the same    type or inheritance-related types, regardless of cv-quals.  */
end_comment

begin_function
name|int
name|ptr_reasonably_similar
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
comment|/* Any target type is similar enough to void.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_DERIVED
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|vector_types_convertible_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|false
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|to
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_DERIVED
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if TO and FROM (both of which are POINTER_TYPEs or    pointer-to-member types) are the same, ignoring cv-qualification at    all levels.  */
end_comment

begin_function
name|bool
name|comp_ptr_ttypes_const
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|same_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the type qualifiers for this type, including the qualifiers on the    elements for an array type.  */
end_comment

begin_function
name|int
name|cp_type_quals
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|TYPE_UNQUALIFIED
return|;
return|return
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the TYPE is const from a C++ perspective: look inside    arrays.  */
end_comment

begin_function
name|bool
name|cp_type_readonly
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the TYPE contains a mutable member.  */
end_comment

begin_function
name|bool
name|cp_has_mutable_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_HAS_MUTABLE
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apply the TYPE_QUALS to the new DECL.  */
end_comment

begin_function
name|void
name|cp_apply_type_quals_to_decl
parameter_list|(
name|int
name|type_quals
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
comment|/* This was an error in C++98 (cv-qualifiers cannot be added to 	 a function type), but DR 295 makes the code well-formed by 	 dropping the extra qualifiers. */
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|bad_type
init|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
decl_stmt|;
name|pedwarn
argument_list|(
literal|"ignoring %qV qualifiers added to function type %qT"
argument_list|,
name|bad_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Avoid setting TREE_READONLY incorrectly.  */
if|if
condition|(
comment|/* If the object has a constructor, the constructor may modify 	 the object.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
comment|/* If the type isn't complete, we don't know yet if it will need 	 constructing.  */
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* If the type has a mutable component, that component might be 	 modified.  */
operator|||
name|TYPE_HAS_MUTABLE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|c_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of casts_away_constness.  Make T1 and T2 point at    exemplar types such that casting T1 to T2 is casting away constness    if and only if there is no implicit conversion from T1 to T2.  */
end_comment

begin_function
specifier|static
name|void
name|casts_away_constness_r
parameter_list|(
name|tree
modifier|*
name|t1
parameter_list|,
name|tree
modifier|*
name|t2
parameter_list|)
block|{
name|int
name|quals1
decl_stmt|;
name|int
name|quals2
decl_stmt|;
comment|/* [expr.const.cast]       For multi-level pointer to members and multi-level mixed pointers      and pointers to members (conv.qual), the "member" aspect of a      pointer to member level is ignored when determining if a const      cv-qualifier has been cast away.  */
comment|/* [expr.const.cast]       For  two  pointer types:  	    X1 is T1cv1,1 * ... cv1,N *   where T1 is not a pointer type 	    X2 is T2cv2,1 * ... cv2,M *   where T2 is not a pointer type 	    K is min(N,M)       casting from X1 to X2 casts away constness if, for a non-pointer      type T there does not exist an implicit conversion (clause      _conv_) from:  	    Tcv1,(N-K+1) * cv1,(N-K+2) * ... cv1,N *       to  	    Tcv2,(M-K+1) * cv2,(M-K+2) * ... cv2,M *.  */
if|if
condition|(
operator|(
operator|!
name|TYPE_PTR_P
argument_list|(
operator|*
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
operator|*
name|t1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TYPE_PTR_P
argument_list|(
operator|*
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
operator|*
name|t2
argument_list|)
operator|)
condition|)
block|{
operator|*
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|cp_type_quals
argument_list|(
operator|*
name|t1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|cp_type_quals
argument_list|(
operator|*
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|quals1
operator|=
name|cp_type_quals
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
name|quals2
operator|=
name|cp_type_quals
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
operator|*
name|t1
argument_list|)
condition|)
operator|*
name|t1
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
else|else
operator|*
name|t1
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
operator|*
name|t2
argument_list|)
condition|)
operator|*
name|t2
operator|=
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
else|else
operator|*
name|t2
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
name|casts_away_constness_r
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
operator|*
name|t1
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
operator|*
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
operator|*
name|t1
argument_list|,
name|quals1
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|cp_build_qualified_type
argument_list|(
operator|*
name|t2
argument_list|,
name|quals2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if casting from TYPE1 to TYPE2 casts away    constness.  */
end_comment

begin_function
specifier|static
name|bool
name|casts_away_constness
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [expr.const.cast]  	 Casting from an lvalue of type T1 to an lvalue of type T2 	 using a reference cast casts away constness if a cast from an 	 rvalue of type "pointer to T1" to the type "pointer to T2" 	 casts away constness.  */
name|t1
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
operator|)
expr_stmt|;
return|return
name|casts_away_constness
argument_list|(
name|build_pointer_type
argument_list|(
name|t1
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|t2
argument_list|)
condition|)
comment|/* [expr.const.cast]         Casting from an rvalue of type "pointer to data member of X        of type T1" to the type "pointer to data member of Y of type        T2" casts away constness if a cast from an rvalue of type        "pointer to T1" to the type "pointer to T2" casts away        constness.  */
return|return
name|casts_away_constness
argument_list|(
name|build_pointer_type
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Casting away constness is only something that makes sense for      pointer or reference types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|false
return|;
comment|/* Top-level qualifiers don't matter.  */
name|t1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|casts_away_constness_r
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_convert
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* If T is a REFERENCE_TYPE return the type to which T refers.    Otherwise, return T itself.  */
end_comment

begin_function
name|tree
name|non_reference
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  USE says    how the lvalue is being used and so selects the error message.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|tree
name|ref
parameter_list|,
name|enum
name|lvalue_use
name|use
parameter_list|)
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|lvalue_error
argument_list|(
name|use
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

end_unit

