begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C++ compiler.    Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C++ front end.    It contains routines to build C++ expressions given their operands,    including computing the types of the result, C and C++ specific error    checks, and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|static
name|tree
name|convert_for_assignment
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pointer_int_sum
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|rationalize_conditional_expr
name|PROTO
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_target_parms
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_ptr_ttypes_real
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_ptr_ttypes_const
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_ptr_ttypes_reinterpret
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_array_types
name|PROTO
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|tree
argument_list|,
name|int
argument_list|)
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|common_base_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static tree convert_sequence PROTO((tree, tree));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|lookup_anon_field
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pointer_diff
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_component_addr
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|qualify_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_delta_difference
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_cv_target_types
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the target type of TYPE, which meas return T for:    T*, T&, T[], T (...), and otherwise, just T.  */
end_comment

begin_function
name|tree
name|target_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)    Returns the error_mark_node if the VALUE does not have    complete type when this function returns.  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|processing_template_decl
operator|||
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|value
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|size_zero_node
operator|&&
operator|!
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|SIGNATURE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|value
return|;
comment|/* If we see X::Y, we build an OFFSET_TYPE which has      not been laid out.  Try to avoid an error by interpreting      it as this->X::Y, if reasonable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|current_class_ref
operator|!=
literal|0
operator|&&
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_ref
condition|)
block|{
name|tree
name|base
decl_stmt|,
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|305
argument_list|)
expr_stmt|;
name|base
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|current_class_ptr
argument_list|)
expr_stmt|;
name|value
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|base
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|value
argument_list|)
return|;
block|}
if|if
condition|(
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|value
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Makes sure EXPR is a complete type when used in a void context, like a    whole expression, or lhs of a comma operator. Issue a diagnostic and    return error_mark_node on failure. This is a little tricky, because some    valid void types look stunningly similar to invalid void types. We err on    the side of caution */
end_comment

begin_function
name|tree
name|require_complete_type_in_void
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|COND_EXPR
case|:
block|{
name|tree
name|op
decl_stmt|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op
operator|=
name|require_complete_type_in_void
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|error_mark_node
condition|)
block|{
name|expr
operator|=
name|op
expr_stmt|;
break|break;
block|}
comment|/* fallthrough */
block|}
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|op
decl_stmt|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
name|require_complete_type_in_void
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|error_mark_node
condition|)
block|{
name|expr
operator|=
name|op
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|op
decl_stmt|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|require_complete_type_in_void
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|error_mark_node
condition|)
block|{
name|expr
operator|=
name|op
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|CALL_EXPR
case|:
comment|/* function call return can be ignored */
case|case
name|RTL_EXPR
case|:
comment|/* RTL nodes have no value */
case|case
name|DELETE_EXPR
case|:
comment|/* delete expressions have no type */
case|case
name|VEC_DELETE_EXPR
case|:
case|case
name|INTEGER_CST
case|:
comment|/* used for null pointer */
case|case
name|EXIT_EXPR
case|:
comment|/* have no return */
case|case
name|LOOP_EXPR
case|:
comment|/* have no return */
case|case
name|BIND_EXPR
case|:
comment|/* have no return */
case|case
name|THROW_EXPR
case|:
comment|/* have no return */
case|case
name|MODIFY_EXPR
case|:
comment|/* sometimes this has a void type, but that's ok */
case|case
name|CONVERT_EXPR
case|:
comment|/* sometimes has a void type */
break|break;
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Calling a function returning a reference has an implicit            dereference applied. We don't want to make that an error. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* else fallthrough */
block|}
default|default:
name|expr
operator|=
name|require_complete_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Try to complete TYPE, if it is incomplete.  For example, if TYPE is    a template instantiation, do the instantiation.  Returns TYPE,    whether or not it could be completed, unless something goes    horribly wrong, in which case the error_mark_node is returned.  */
end_comment

begin_function
name|tree
name|complete_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
comment|/* Rather than crash, we return something sure to cause an error        at some point.  */
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|processing_template_decl
condition|)
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
condition|)
name|instantiate_class_template
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Like complete_type, but issue an error if the TYPE cannot be    completed.  VALUE is used for informative diagnostics.    Returns NULL_TREE if the type cannot be made complete.  */
end_comment

begin_function
name|tree
name|complete_type_or_else
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|{
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* We already issued an error.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|size_zero_node
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether type of EXP is instantiated.  */
end_comment

begin_function
name|int
name|type_unknown_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T is function (or pfn) type.  */
end_comment

begin_function
name|int
name|fntype_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
comment|/* @@ Must do member pointers here.  */
return|return
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|like
argument_list|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two parameter lists.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     As an optimization, free the space we allocate if the parameter    lists are already common.  */
end_comment

begin_function
name|tree
name|commonparms
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|tree
name|oldargs
init|=
name|p1
decl_stmt|,
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|any_change
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|first_obj
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|tree_last
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newargs
operator|==
name|void_list_node
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|!=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|common_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_change
condition|)
block|{
name|obfree
argument_list|(
name|first_obj
argument_list|)
expr_stmt|;
return|return
name|oldargs
return|;
block|}
return|return
name|newargs
return|;
block|}
end_function

begin_comment
comment|/* Given a type, perhaps copied for a typedef,    find the "original" version of it.  */
end_comment

begin_function
name|tree
name|original_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
while|while
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|x
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
break|break;
name|x
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
condition|)
break|break;
name|t
operator|=
name|x
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This is the type for the result of most arithmetic operations    if the operands have the given two types.     We do not deal with enumeral types here because they have already been    converted to integer types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
name|t1
operator|=
name|original_type
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|original_type
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
name|merge_machine_type_attributes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|a1
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|a2
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Either one unset?  Take the set one.  */
if|if
condition|(
operator|!
operator|(
name|attributes
operator|=
name|a1
operator|)
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
comment|/* One that completely contains the other?  Take it.  */
elseif|else
if|if
condition|(
name|a2
operator|&&
operator|!
name|attribute_list_contained
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
condition|)
block|{
if|if
condition|(
name|attribute_list_contained
argument_list|(
name|a2
argument_list|,
name|a1
argument_list|)
condition|)
name|attributes
operator|=
name|a2
expr_stmt|;
else|else
block|{
comment|/* Pick the longest list, and hang on the other list.  */
comment|/* ??? For the moment we punt on the issue of attrs with args.  */
if|if
condition|(
name|list_length
argument_list|(
name|a1
argument_list|)
operator|<
name|list_length
argument_list|(
name|a2
argument_list|)
condition|)
name|attributes
operator|=
name|a2
operator|,
name|a2
operator|=
name|a1
expr_stmt|;
for|for
control|(
init|;
name|a2
condition|;
name|a2
operator|=
name|TREE_CHAIN
argument_list|(
name|a2
argument_list|)
control|)
if|if
condition|(
name|lookup_attribute
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|a2
argument_list|)
argument_list|)
argument_list|,
name|attributes
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|a1
operator|=
name|copy_node
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|a1
argument_list|)
operator|=
name|attributes
expr_stmt|;
name|attributes
operator|=
name|a1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* If one type is complex, form the common type of the non-complex      components, then make that complex.  Use T1 or T2 if it is the      required type.  */
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|subtype1
init|=
name|code1
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
decl_stmt|;
name|tree
name|subtype2
init|=
name|code2
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
else|:
name|t2
decl_stmt|;
name|tree
name|subtype
init|=
name|common_type
argument_list|(
name|subtype1
argument_list|,
name|subtype2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|build_complex_type
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|attributes
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_unsigned_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
name|t1
operator|=
name|long_unsigned_type_node
expr_stmt|;
else|else
name|t1
operator|=
name|long_integer_type_node
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|long_double_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
operator|==
name|long_double_type_node
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
comment|/* This code was turned off; I don't know why.  	 But ANSI C++ specifies doing this with the qualifiers.  	 So I turned it on again.  */
block|{
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|tt2
init|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|tree
name|target
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|b1
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|b2
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|tt2
argument_list|)
expr_stmt|;
name|tt1
operator|=
name|TREE_TYPE
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|tt2
operator|=
name|TREE_TYPE
argument_list|(
name|tt2
argument_list|)
expr_stmt|;
block|}
else|else
name|b1
operator|=
name|b2
operator|=
name|NULL_TREE
expr_stmt|;
name|type_quals
operator|=
operator|(
name|CP_TYPE_QUALS
argument_list|(
name|tt1
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|tt2
argument_list|)
operator|)
expr_stmt|;
name|tt1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|tt2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt1
operator|==
name|tt2
condition|)
name|target
operator|=
name|tt1
expr_stmt|;
elseif|else
if|if
condition|(
name|b1
condition|)
block|{
name|compiler_error
argument_list|(
literal|"common_type called with uncommon member types"
argument_list|)
expr_stmt|;
name|target
operator|=
name|tt1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt1
operator|==
name|void_type_node
operator|||
name|tt2
operator|==
name|void_type_node
condition|)
name|target
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|tt1
operator|==
name|unknown_type_node
condition|)
name|target
operator|=
name|tt2
expr_stmt|;
elseif|else
if|if
condition|(
name|tt2
operator|==
name|unknown_type_node
condition|)
name|target
operator|=
name|tt1
expr_stmt|;
else|else
name|target
operator|=
name|common_type
argument_list|(
name|tt1
argument_list|,
name|tt2
argument_list|)
expr_stmt|;
name|target
operator|=
name|cp_build_qualified_type
argument_list|(
name|target
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|||
operator|(
name|DERIVED_FROM_P
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|&&
name|binfo_or_else
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|)
condition|)
name|target
operator|=
name|build_offset_type
argument_list|(
name|b2
argument_list|,
name|target
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binfo_or_else
argument_list|(
name|b2
argument_list|,
name|b1
argument_list|)
condition|)
name|target
operator|=
name|build_offset_type
argument_list|(
name|b1
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_reference_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
name|t1
operator|=
name|build_cplus_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|raises
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|p2
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|p1
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|p1
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|commonparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|t1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|&&
name|binfo_or_else
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|binfo_or_else
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
else|else
block|{
name|compiler_error
argument_list|(
literal|"common_type called with uncommon aggregate types"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Get this value the long way, since TYPE_METHOD_BASETYPE 	     is just the main variant of this.  */
name|tree
name|basetype
decl_stmt|;
name|tree
name|raises
decl_stmt|,
name|t3
decl_stmt|;
name|tree
name|b1
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|b2
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|||
operator|(
name|DERIVED_FROM_P
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|&&
name|binfo_or_else
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
operator|)
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|binfo_or_else
argument_list|(
name|b2
argument_list|,
name|b1
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|compiler_error
argument_list|(
literal|"common_type called with uncommon method types"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
comment|/* If this was a member function type, get back to the 	     original type of type member function (i.e., without 	     the class instance variable up front.  */
name|t1
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|common_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|t3
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|t3
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t3
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_exception_variant
argument_list|(
name|t3
argument_list|,
name|raises
argument_list|)
expr_stmt|;
block|}
else|else
name|compiler_error
argument_list|(
literal|"common_type called with uncommon method types"
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
comment|/* Pointers to members should now be handled by the POINTER_TYPE 	 case above.  */
name|my_friendly_abort
argument_list|(
literal|990325
argument_list|)
expr_stmt|;
default|default:
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 raise the same exceptions.  */
end_comment

begin_function
name|int
name|compexcepttypes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
return|return
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the array types T1 and T2, using CMP as the type comparison    function for the element types.  STRICT is as for comptypes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|comp_array_types
argument_list|(
name|cmp
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
decl|register
name|int
argument_list|(
operator|*
name|cmp
argument_list|)
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|d1
decl_stmt|;
name|tree
name|d2
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* The type of the array elements must be the same.  */
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
operator|&
operator|~
name|COMPARE_REDECLARATION
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|d1
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|==
name|d2
condition|)
return|return
literal|1
return|;
comment|/* If one of the arrays is dimensionless, and the other has a      dimension, they are of different types.  However, it is legal to      write:         extern int a[];        int a[3];       by [basic.link]:          declarations for an array object can specify        array types that differ by the presence or absence of a major        array bound (_dcl.array_).  */
if|if
condition|(
operator|!
name|d1
operator|||
operator|!
name|d2
condition|)
return|return
name|strict
operator|&
name|COMPARE_REDECLARATION
return|;
comment|/* Check that the dimensions are the same.  */
return|return
operator|(
name|cp_tree_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  STRICT is a bitwise-or of the    COMPARE_* flags.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|type1
decl_stmt|;
specifier|register
name|tree
name|t2
init|=
name|type2
decl_stmt|;
name|int
name|attrval
decl_stmt|,
name|val
decl_stmt|;
name|int
name|orig_strict
init|=
name|strict
decl_stmt|;
comment|/* The special exemption for redeclaring array types without an      array bound only applies at the top level:         extern int (*i)[];        int (*i)[8];       is not legal, for example.  */
name|strict
operator|&=
operator|~
name|COMPARE_REDECLARATION
expr_stmt|;
comment|/* Suppress errors caused by previously reported errors */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* This should never happen.  */
name|my_friendly_assert
argument_list|(
name|t1
operator|!=
name|error_mark_node
argument_list|,
literal|307
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|&
name|COMPARE_RELAXED
condition|)
block|{
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|CP_TYPE_QUALS
argument_list|(
name|t1
argument_list|)
operator|!=
name|CP_TYPE_QUALS
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|==
name|COMPARE_STRICT
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_FOR_JAVA
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      qualifiers (just above).  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ??? COMP_TYPE_ATTRIBUTES is currently useless for variables as each      attribute is its own main variant (`val' will remain 0).  */
ifndef|#
directive|ifndef
name|COMP_TYPE_ATTRIBUTES
define|#
directive|define
name|COMP_TYPE_ATTRIBUTES
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
value|1
endif|#
directive|endif
if|if
condition|(
name|strict
operator|&
name|COMPARE_NO_ATTRIBUTES
condition|)
name|attrval
operator|=
literal|1
expr_stmt|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|attrval
operator|=
name|COMP_TYPE_ATTRIBUTES
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
if|if
condition|(
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t2
argument_list|)
operator|||
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Don't check inheritance.  */
name|strict
operator|=
name|COMPARE_STRICT
expr_stmt|;
comment|/* fall through */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_TI_TEMPLATE
argument_list|(
name|t2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|)
condition|)
name|val
operator|=
name|comp_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_TI_ARGS
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|look_hard
label|:
if|if
condition|(
operator|(
name|strict
operator|&
name|COMPARE_BASE
operator|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|strict
operator|&
name|COMPARE_RELAXED
operator|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
name|val
operator|=
operator|(
name|comptypes
argument_list|(
name|build_pointer_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This case is anti-symmetrical! 	 One can pass a base member (or member function) 	 to something expecting a derived member (or member function), 	 but not vice-versa!  */
name|val
operator|=
operator|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* first, check whether the referred types match with the          required level of strictness */
name|val
operator|=
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
goto|goto
name|look_hard
goto|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
operator|!
name|compexcepttypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
name|val
operator|=
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Target types must match incl. qualifiers.  We use ORIG_STRICT 	 here since this is the one place where 	 COMPARE_REDECLARATION should be used.  */
name|val
operator|=
name|comp_array_types
argument_list|(
name|comptypes
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|orig_strict
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
return|return
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t2
argument_list|)
operator|&&
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|TYPENAME_TYPE
case|:
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_IDENTIFIER
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|attrval
operator|==
literal|2
operator|&&
name|val
operator|==
literal|1
condition|?
literal|2
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of comp_target-types.  Make sure that the cv-quals change    only in the same direction as the target type.  */
end_comment

begin_function
specifier|static
name|int
name|comp_cv_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|nptrs
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|)
comment|/* The qualifications are incomparable.  */
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
condition|)
return|return
name|more_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
name|t
operator|=
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|==
literal|1
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
operator|)
operator|||
operator|(
name|t
operator|==
operator|-
literal|1
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 or -1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers, 0 if not. Return 1 means that TTR can be    converted to TTL. Return -1 means that TTL can be converted to TTR but    not vice versa.     NPTRS is the number of pointers we can strip off and keep cool.    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,    but to not permit B** to convert to A**.     This should go away.  Callers should use can_convert or something    similar instead.  (jason 17 Apr 1997)  */
end_comment

begin_function
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|nptrs
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
comment|/* If we get a pointer with nptrs == 0, we don't allow any tweaking 	 of the type pointed to.  This is necessary for reference init 	 semantics.  We won't get here from a previous call with nptrs == 1; 	 for multi-level pointers we end up in comp_ptr_ttypes.  */
operator|&&
name|nptrs
operator|>
literal|0
condition|)
block|{
name|int
name|is_ptr
init|=
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
decl_stmt|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptr
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|UNKNOWN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
operator|-
literal|1
argument_list|)
return|;
return|return
name|comp_cv_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
operator|-
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|comp_array_types
argument_list|(
name|comp_target_types
argument_list|,
name|ttl
argument_list|,
name|ttr
argument_list|,
name|COMPARE_STRICT
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|argsl
decl_stmt|,
name|argsr
decl_stmt|;
name|int
name|saw_contra
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
operator|-
literal|1
case|:
name|saw_contra
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|argsl
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|argsr
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
comment|/* Compare 'this' here, not in comp_target_parms.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|tl
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|ttl
argument_list|)
decl_stmt|;
name|tree
name|tr
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|ttr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_or_base_type_p
argument_list|(
name|tr
argument_list|,
name|tl
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|tl
argument_list|,
name|tr
argument_list|)
condition|)
name|saw_contra
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|argsl
operator|=
name|TREE_CHAIN
argument_list|(
name|argsl
argument_list|)
expr_stmt|;
name|argsr
operator|=
name|TREE_CHAIN
argument_list|(
name|argsr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|comp_target_parms
argument_list|(
name|argsl
argument_list|,
name|argsr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
operator|-
literal|1
case|:
name|saw_contra
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|saw_contra
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* for C++ */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|int
name|base
decl_stmt|;
comment|/* Contravariance: we can assign a pointer to base member to a pointer 	 to derived member.  Note difference from simple pointer case, where 	 we can pass a pointer to derived to a pointer to base.  */
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
condition|)
name|base
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|ttl
decl_stmt|;
name|ttl
operator|=
name|ttr
expr_stmt|;
name|ttr
operator|=
name|tmp
expr_stmt|;
name|base
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
return|return
name|base
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|comp_cv_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
operator|==
literal|1
condition|)
return|return
name|base
return|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
condition|)
block|{
if|if
condition|(
name|nptrs
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|build_pointer_type
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|build_pointer_type
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|ttl
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */
end_comment

begin_function
name|int
name|at_least_as_qualified_p
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
comment|/* All qualifiers for TYPE2 must also appear in TYPE1.  */
return|return
operator|(
operator|(
name|CP_TYPE_QUALS
argument_list|(
name|type1
argument_list|)
operator|&
name|CP_TYPE_QUALS
argument_list|(
name|type2
argument_list|)
operator|)
operator|==
name|CP_TYPE_QUALS
argument_list|(
name|type2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is more qualified than TYPE2.  */
end_comment

begin_function
name|int
name|more_qualified_p
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
return|return
operator|(
name|CP_TYPE_QUALS
argument_list|(
name|type1
argument_list|)
operator|!=
name|CP_TYPE_QUALS
argument_list|(
name|type2
argument_list|)
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is more cv-qualified than TYPE2, -1 if TYPE2 is    more cv-qualified that TYPE1, and 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_cv_qualification
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
if|if
condition|(
name|CP_TYPE_QUALS
argument_list|(
name|type1
argument_list|)
operator|==
name|CP_TYPE_QUALS
argument_list|(
name|type2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|at_least_as_qualified_p
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|at_least_as_qualified_p
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the cv-qualification signature of TYPE1 is a proper    subset of the cv-qualification signature of TYPE2, and the types    are similar.  Returns -1 if the other way 'round, and 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_cv_qual_signature
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
if|if
condition|(
name|comp_ptr_ttypes_real
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes_real
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If two types share a common base type, return that basetype.    If there is not a unique most-derived base type, this function    returns ERROR_MARK_NODE.  */
end_comment

begin_function
specifier|static
name|tree
name|common_base_type
parameter_list|(
name|tt1
parameter_list|,
name|tt2
parameter_list|)
name|tree
name|tt1
decl_stmt|,
name|tt2
decl_stmt|;
block|{
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If one is a baseclass of another, that's good enough.  */
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt1
argument_list|,
name|tt2
argument_list|)
condition|)
return|return
name|tt1
return|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt2
argument_list|,
name|tt1
argument_list|)
condition|)
return|return
name|tt2
return|;
comment|/* Otherwise, try to find a unique baseclass of TT1      that is shared by TT2, and follow that down.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|tt1
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|basetype
argument_list|,
name|tt2
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Same for TT2.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|tt1
argument_list|,
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two parameter type lists PARMS1 and PARMS2 are    equivalent in the sense that functions with those parameter types    can have equivalent types.  The two lists must be equivalent,    element by element.     C++: See comment above about TYPE1, TYPE2.  */
end_comment

begin_function
name|int
name|compparms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This really wants return whether or not parameter type lists    would make their owning functions assignment compatible or not.     The return value is like for comp_target_types.     This should go away, possibly with the exception of the empty parmlist    conversion; there are no conversions between function types in C++.    (jason 17 Apr 1997)  */
end_comment

begin_function
specifier|static
name|int
name|comp_target_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
name|int
name|warn_contravariance
init|=
literal|0
decl_stmt|;
comment|/* In C, an unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  This is not      true for C++, but let's do it anyway for unfixed headers.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|flag_strict_prototype
operator|&&
name|t2
operator|==
name|void_list_node
condition|)
comment|/* t1 might be the arglist of a function pointer in extern "C" 	   declared to take (), which we fudged to (...).  Don't make the 	   user pay for our mistake.  */
empty_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ prohibits conversion from `%#T' to `(...)'"
argument_list|,
name|parms2
argument_list|)
expr_stmt|;
return|return
name|self_promoting_args_p
argument_list|(
name|t2
argument_list|)
return|;
block|}
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|self_promoting_args_p
argument_list|(
name|t1
argument_list|)
return|;
for|for
control|(
init|;
name|t1
operator|||
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match, unless STRICT is<= 0.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strict
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|<
literal|0
condition|)
return|return
literal|1
operator|+
name|warn_contravariance
return|;
return|return
operator|(
operator|(
name|t1
operator|&&
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|)
operator|+
name|warn_contravariance
operator|)
return|;
block|}
name|p1
operator|=
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pedantic
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|strict
operator|<=
literal|0
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* The following is wrong for contravariance, 	     but many programs depend on it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Note backwards order due to contravariance.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strict
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
name|warn_contravariance
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.     C++: must make these work for type variants as well.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|intTI_type_node
condition|)
return|return
name|unsigned_intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|intDI_type_node
condition|)
return|return
name|unsigned_intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intSI_type_node
condition|)
return|return
name|unsigned_intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intHI_type_node
condition|)
return|return
name|unsigned_intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intQI_type_node
condition|)
return|return
name|unsigned_intQI_type_node
return|;
return|return
name|signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|unsigned_intTI_type_node
condition|)
return|return
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|unsigned_intDI_type_node
condition|)
return|return
name|intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intSI_type_node
condition|)
return|return
name|intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intHI_type_node
condition|)
return|return
name|intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intQI_type_node
condition|)
return|return
name|intQI_type_node
return|;
return|return
name|signed_or_unsigned_type
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|unsignedp
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Compute the value of the `sizeof' operator.  */
end_comment

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|SIZEOF_EXPR
argument_list|,
name|sizetype
argument_list|,
name|type
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a function type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a method type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a void type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
comment|/* ARM $5.3.2: ``When applied to a reference, the result is the size of the      referenced object.'' */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* We couldn't find anything in the ARM or the draft standard that says,      one way or the other, if doing sizeof on something that doesn't have      an object associated with it is correct or incorrect.  For example, if      you declare `struct S { char str[16]; };', and in your program do      a `sizeof (S::str)', should we flag that as an error or should we give      the size of it?  Since it seems like a reasonable thing to do, we'll go      with giving the value.  */
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* @@ This also produces an error for a signature ref.         In that case we should be able to do better.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`sizeof' applied to a signature type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"`sizeof' applied to incomplete type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* size_binop does not put the constant in range, so do it now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|expr_sizeof
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|SIZEOF_EXPR
argument_list|,
name|sizetype
argument_list|,
name|e
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"sizeof applied to a bit-field"
argument_list|)
expr_stmt|;
comment|/* ANSI says arrays and functions are converted inside comma.      But we can't really convert them in build_compound_expr      because that would break commas in lvalues.      So do the conversion here if operand was a comma.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
name|e
operator|=
name|default_conversion
argument_list|(
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids taking the sizeof a function type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|e
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
return|return
name|c_sizeof
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
comment|/* Convert in case a char is more than one unit.  */
name|t
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|ALIGNOF_EXPR
argument_list|,
name|sizetype
argument_list|,
name|type
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
condition|)
return|return
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
comment|/* C++: this is really correct!  */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* @@ This also produces an error for a signature ref.         In that case we should be able to do better.  */
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`__alignof' applied to a signature type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|t
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform the array-to-pointer and function-to-pointer conversions    for EXP.       In addition, references are converted to rvalues and manifest    constants are replaced by their values.  */
end_comment

begin_function
name|tree
name|decay_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|exp
operator|=
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|exp
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value.  We      don't do this for arrays, though; we want the address of the      first element of the array, not the address of the first element      of its initializing constant.  We *do* replace variables that the      user isn't really supposed to know about; this is a hack to deal      with __PRETTY_FUNCTION__ and the like.  */
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|code
operator|!=
name|ARRAY_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
condition|)
block|{
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|990506
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|is_overloaded_fn
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Stripping away the INDIRECT_REF is not the right 	     thing to do for references...  */
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|inner
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inner
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|decay_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_CONSTANT
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|exp
operator|=
name|decay_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|type
condition|)
return|return
name|cp_convert
argument_list|(
name|t
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Take the address of an inline function without setting TREE_ADDRESSABLE    or TREE_USED.  */
end_comment

begin_function
name|tree
name|inline_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff exp is a STRING_CST or the result of applying    decay_conversion to one.  */
end_comment

begin_function
name|int
name|string_conv_p
parameter_list|(
name|totype
parameter_list|,
name|exp
parameter_list|,
name|warn
parameter_list|)
name|tree
name|totype
decl_stmt|,
name|exp
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|flag_const_strings
operator|||
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|char_type_node
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|wchar_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Make sure that we don't try to convert between char and wchar_t.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Is this a string constant which has decayed to 'const char *'?  */
name|t
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|t
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
block|}
comment|/* This warning is not very useful, as it complains about printf.  */
if|if
condition|(
name|warn
operator|&&
name|warn_write_strings
condition|)
name|cp_warning
argument_list|(
literal|"deprecated conversion from string constant to `%T'"
argument_list|,
name|totype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|build_object_ref
parameter_list|(
name|datum
parameter_list|,
name|basetype
parameter_list|,
name|field
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|basetype
decl_stmt|,
name|field
decl_stmt|;
block|{
name|tree
name|dtype
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"request for member `%T::%D' in expression of non-aggregate type `%T'"
argument_list|,
name|basetype
argument_list|,
name|field
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"signature name in scope resolution ignored"
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|binfo_or_else
argument_list|(
name|basetype
argument_list|,
name|dtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
return|return
name|build_x_component_ref
argument_list|(
name|build_scoped_ref
argument_list|(
name|datum
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|field
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like `build_component_ref, but uses an already found field, and converts    from a reference.  Must compute access for current_class_ref.    Otherwise, ok.  */
end_comment

begin_function
name|tree
name|build_component_ref_1
parameter_list|(
name|datum
parameter_list|,
name|field
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|field
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
return|return
name|convert_from_reference
argument_list|(
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
name|protect
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a COND_EXPR, MIN_EXPR, or MAX_EXPR in T, return it in a form that we    can, for example, use as an lvalue.  This code used to be in    unary_complex_lvalue, but we needed it to deal with `a = (d == c) ? b : c'    expressions, where we're dealing with aggregates.  But now it's again only    called from unary_complex_lvalue.  The case (in particular) that led to    this was with CODE == ADDR_EXPR, since it's not an lvalue when we'd    get it there.  */
end_comment

begin_function
specifier|static
name|tree
name|rationalize_conditional_expr
parameter_list|(
name|code
parameter_list|,
name|t
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
comment|/* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that      the first operand is always the one to be used if both operands      are equal, so we know what conditional expression this used to be.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MAX_EXPR
condition|)
block|{
return|return
name|build_conditional_expr
argument_list|(
name|build_x_binary_op
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MIN_EXPR
condition|?
name|LE_EXPR
else|:
name|GE_EXPR
operator|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the TYPE of an anonymous union field inside T, return the    FIELD_DECL for the field.  If not found return NULL_TREE.  Because    anonymous unions can nest, we must also search all anonymous unions    that are directly reachable.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_anon_field
parameter_list|(
name|t
parameter_list|,
name|type
parameter_list|)
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* If we find it directly, return the field.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
name|field
return|;
block|}
comment|/* Otherwise, it could be nested, search harder.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|subfield
init|=
name|lookup_anon_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|subfield
condition|)
return|return
name|subfield
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build a COMPONENT_REF for a given DATUM, and it's member COMPONENT.    COMPONENT can be an IDENTIFIER_NODE that is the name of the member    that we are interested in, or it can be a FIELD_DECL.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
specifier|register
name|tree
name|basetype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
name|tree
name|field_type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* BASETYPE holds the type of the class containing the COMPONENT.  */
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference      inside it.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|2
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_DECL
case|:
name|cp_error
argument_list|(
literal|"invalid use of %D"
argument_list|,
name|datum
argument_list|)
expr_stmt|;
name|datum
operator|=
name|error_mark_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|datum
operator|=
name|resolve_offset_ref
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* First, see if there is a field or component with name COMPONENT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* I could not trigger this code. MvL */
name|my_friendly_abort
argument_list|(
literal|980326
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEAD
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CHAIN
argument_list|(
name|component
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|component
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|309
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|cp_error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|component
argument_list|,
name|datum
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|basetype
argument_list|,
name|datum
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"destructor specifier `%T::~%T' must have matching names"
argument_list|,
name|basetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%T' has no destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
if|if
condition|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|==
name|component
condition|)
comment|/* Special-case this because if we use normal lookups in an ambiguous        hierarchy, the compiler will abort (because vptr lookups are        not supposed to be ambiguous.  */
name|field
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|field
operator|=
name|component
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid use of type decl `%#D' as expression"
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|name
init|=
name|component
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
name|protect
operator|&&
operator|!
name|VFIELD_NAME_P
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Not found as a data field, look for it as a method.  If found, 	     then if this is the only possible one, return it, else 	     report ambiguity error.  */
name|tree
name|fndecls
init|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecls
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fndecls
condition|)
block|{
comment|/* If the function is unique and static, we can resolve it 		 now.  Otherwise, we have to wait and see what context it is 		 used in; a component_ref involving a non-static member 		 function can only be used in a call (expr.ref).  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecls
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
decl_stmt|;
name|enforce_access
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|fndecls
argument_list|)
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
else|else
block|{
comment|/* A unique non-static member function.  Other parts 			 of the compiler expect something with 			 unknown_type_node to be really overloaded, so 			 let's oblige.  */
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
operator|=
name|scratch_ovl_cons
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|datum
argument_list|,
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
name|cp_error
argument_list|(
literal|"`%#T' has no member named `%D'"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cp_pedwarn
argument_list|(
literal|"invalid use of type decl `%#D' as expression"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_RTL
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
name|mark_used
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
name|TREE_USED
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|field
return|;
block|}
block|}
comment|/* See if we have to do any conversions so that we pick up the field from the      right context.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|basetype
condition|)
block|{
name|tree
name|context
init|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|context
decl_stmt|;
while|while
condition|(
operator|!
name|same_type_p
argument_list|(
name|base
argument_list|,
name|basetype
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|base
argument_list|)
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|base
operator|=
name|TYPE_CONTEXT
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
comment|/* Handle base classes here...  */
if|if
condition|(
name|base
operator|!=
name|basetype
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|datum
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid reference to NULL ptr, use ptr-to-member instead"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
comment|/* It doesn't matter which vbase pointer we grab, just 		 find one of them.  */
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|base
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|addr
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|base
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|datum
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|datum
operator|!=
name|error_mark_node
argument_list|,
literal|311
argument_list|)
expr_stmt|;
block|}
name|basetype
operator|=
name|base
expr_stmt|;
comment|/* Handle things from anon unions here...  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|tree
name|subfield
init|=
name|lookup_anon_field
argument_list|(
name|basetype
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|tree
name|subdatum
init|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|subfield
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
return|return
name|build_component_ref
argument_list|(
name|subdatum
argument_list|,
name|field
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
return|;
block|}
block|}
comment|/* Compute the type of the field, as described in [expr.ref].  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* The standard says that the type of the result should be the        type referred to by the reference.  But for now, at least, we        do the conversion from reference type later.  */
empty_stmt|;
else|else
block|{
name|type_quals
operator|=
operator|(
name|CP_TYPE_QUALS
argument_list|(
name|field_type
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* A field is const (volatile) if the enclosing object, or the 	 field itself, is const (volatile).  But, a mutable field is 	 not const, even within a const object.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|field
argument_list|)
operator|&&
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SIGNATURE
argument_list|(
name|field_type
argument_list|)
condition|)
name|field_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|field_type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|ref
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|field_type
argument_list|,
name|break_out_cleanups
argument_list|(
name|datum
argument_list|)
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the expression const or volatile, as appropriate.  Even      though we've dealt with the type above, we still have to mark the      expression itself.  */
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Variant of build_component_ref for use in expressions, which should    never have REFERENCE_TYPE.  */
end_comment

begin_function
name|tree
name|build_x_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|t
init|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|t
operator|=
name|convert_from_reference
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.     This function may need to overload OPERATOR_FNNAME.    Must also handle REFERENCE_TYPEs for C++.  */
end_comment

begin_function
name|tree
name|build_x_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|ptr
argument_list|)
return|;
name|rval
operator|=
name|build_opfncall
argument_list|(
name|INDIRECT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ptr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build_indirect_ref
argument_list|(
name|ptr
argument_list|,
name|errorstring
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ptr
operator|==
name|current_class_ptr
condition|)
return|return
name|current_class_ref
return|;
name|pointer
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|ptr
else|:
name|default_conversion
argument_list|(
name|ptr
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [expr.unary.op] 	  	 If the type of the expression is "pointer to T," the type 	 of  the  result  is  "T."              We must use the canonical variant because certain parts of 	 the back end, like fold, do pointer comparisons between 	 types.  */
name|tree
name|t
init|=
name|canonical_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|flag_volatile
operator|&&
name|same_type_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* The POINTER was something like `&x'.  We simplify `*&x' to 	   `x'.  */
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|t
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	     so that we get the proper error message if the result is used 	     to assign to.  Also,&* is supposed to be a no-op.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
operator|||
name|flag_volatile
operator|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
comment|/* `pointer' won't be an error_mark_node if we were given a      pointer to member, so it's cool to check for this here.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of `%s' on pointer to member"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"cannot dereference signature pointer/reference"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pointer
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|errorstring
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid type argument"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).     If INDEX is of some user-defined type, it must be converted to    integer type.  Otherwise, to make a compatible PLUS_EXPR, it    will inherit the type of the array, which will be some pointer type.  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|tree
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* Subscripting with type char is likely to lose 	 on a machine where chars are signed. 	 So warn on any machine, but optionally. 	 Don't warn for unsigned char since that type is safe. 	 Don't warn for signed char because anyone who uses that 	 must have done so deliberately.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"array subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|idx
operator|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|idx
argument_list|,
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
comment|/* Note in C++ it is valid to subscript a `register' array, since 	 it is valid to take the address of something with that 	 storage specification.  */
if|if
condition|(
name|extra_warnings
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|warning
argument_list|(
literal|"subscripting array declared `register'"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are 	 or if the array is..  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
name|PLUS_EXPR
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.  The PARAMS do    not include any object pointer that may be required.  FUNCTION's    data type may be a function type or a pointer-to-function.     For C++: If FUNCTION's data type is a TREE_LIST, then the tree list    is the list of possible methods that FUNCTION could conceivably    be.  If the list of methods comes from a class, then it will be    a list of lists (where each element is associated with the class    that produced it), otherwise it will be a simple list (for    functions overloaded in global scope).     In the first case, TREE_VALUE (function) is the head of one of those    lists, and TREE_PURPOSE is the name of the function.     In the second case, TREE_PURPOSE (function) is the function's    name directly.     DECL is the class instance variable, usually CURRENT_CLASS_REF.     When calling a TEMPLATE_DECL, we don't require a complete return    type.  */
end_comment

begin_function
name|tree
name|build_x_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|decl
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|template_id
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_method
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* Save explicit template arguments if found */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|template_id
operator|=
name|function
expr_stmt|;
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|unknown_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Undo (Foo:bar)()...  */
name|type
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|function
operator|=
name|OVL_FUNCTION
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|function
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|DECL_RESULT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|build_member_call
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|template_id
condition|?
name|template_id
else|:
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|,
name|params
argument_list|)
return|;
name|is_method
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|function
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
comment|/* A friend template.  Make it look like a toplevel declaration.  */
if|if
condition|(
operator|!
name|is_method
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|function
operator|=
name|scratch_ovl_cons
argument_list|(
name|function
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Handle methods, friends, and overloaded functions, respectively.  */
if|if
condition|(
name|is_method
condition|)
block|{
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|function
operator|=
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|312
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Call via a pointer to member function.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* What other type of POINTER_TYPE could this be? */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
name|function
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|function
argument_list|)
expr_stmt|;
goto|goto
name|do_x_function
goto|;
block|}
comment|/* this is an abbreviated method call.          must go through here in case it is a virtual function. 	 @@ Perhaps this could be optimized.  */
if|if
condition|(
name|basetype
operator|&&
operator|(
operator|!
name|current_class_type
operator|||
operator|!
name|DERIVED_FROM_P
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|)
operator|)
condition|)
return|return
name|build_member_call
argument_list|(
name|basetype
argument_list|,
name|function
argument_list|,
name|params
argument_list|)
return|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"object missing in call to method `%D'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Yow: call from a static member function.  */
name|decl
operator|=
name|build_dummy_object
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
comment|/* Put back explicit template arguments, if any.  */
if|if
condition|(
name|template_id
condition|)
name|function
operator|=
name|template_id
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type
operator|==
name|unknown_type_node
condition|)
block|{
comment|/* Undo what we did in build_component_ref.  */
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_id
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
operator|=
name|function
expr_stmt|;
name|function
operator|=
name|template_id
expr_stmt|;
block|}
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|function
argument_list|)
condition|)
block|{
if|if
condition|(
name|OVL_FUNCTION
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* Put back explicit template arguments, if any.  */
if|if
condition|(
name|template_id
condition|)
name|function
operator|=
name|template_id
expr_stmt|;
return|return
name|build_new_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
block|}
else|else
comment|/* Remove a potential OVERLOAD around it */
name|function
operator|=
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|do_x_function
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
comment|/* If the component is a data element (or a virtual function), we play 	 games here to make things work.  */
name|tree
name|decl_addr
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|current_class_ref
expr_stmt|;
name|decl_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sigh.  OFFSET_REFs are being used for too many things. 	 They're being used both for -> and ->*, and we want to resolve 	 the -> cases here, but leave the ->*.  We could use 	 resolve_offset_ref for those, too, but it would call          get_member_function_from_ptrfunc and decl_addr wouldn't get          updated properly.  Nasty.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|function
operator|=
name|resolve_offset_ref
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function
operator|=
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|decl_addr
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|params
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl_addr
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|is_method
condition|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|ctypeptr
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Explicitly named method?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ctypeptr
operator|=
name|build_pointer_type
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expression with ptr-to-method type?  It could either be a plain 	 usage, or it might be a case where the ptr-to-method is being 	 passed in as an argument.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|tree
name|rec
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ctypeptr
operator|=
name|build_pointer_type
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
comment|/* Unexpected node type?  */
else|else
name|my_friendly_abort
argument_list|(
literal|116
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid call to member function needing `this' in static member function scope"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|decl
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctypeptr
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_c_cast
argument_list|(
name|ctypeptr
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|params
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resolve a pointer to member function.  INSTANCE is the object    instance to use, if the member points to a virtual member.  */
end_comment

begin_function
name|tree
name|get_member_function_from_ptrfunc
parameter_list|(
name|instance_ptrptr
parameter_list|,
name|function
parameter_list|)
name|tree
modifier|*
name|instance_ptrptr
decl_stmt|;
name|tree
name|function
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fntype
decl_stmt|,
name|idx
decl_stmt|,
name|e1
decl_stmt|,
name|delta
decl_stmt|,
name|delta2
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|,
name|aref
decl_stmt|,
name|vtbl
decl_stmt|;
name|tree
name|instance
decl_stmt|,
name|basetype
decl_stmt|;
name|tree
name|instance_ptr
init|=
operator|*
name|instance_ptrptr
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance_ptr
argument_list|)
condition|)
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|save_expr
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|function
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|e3
operator|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* If basetype doesn't have virtual functions, don't emit code to 	   handle that case.  */
name|e1
operator|=
name|e3
expr_stmt|;
else|else
block|{
comment|/* Promoting idx before saving it improves performance on RISC 	     targets.  Without promoting, the first compare used 	     load-with-sign-extend, while the second used normal load then 	     shift to sign-extend.  An optimizer flaw, perhaps, but it's 	     easier to make this change.  */
name|idx
operator|=
name|save_expr
argument_list|(
name|default_conversion
argument_list|(
name|build_component_ref
argument_list|(
name|function
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build_binary_op
argument_list|(
name|GE_EXPR
argument_list|,
name|idx
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
comment|/* Convert down to the right base, before using the instance.  */
name|instance
operator|=
name|convert_pointer_to_real
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|&&
name|instance_ptr
operator|!=
name|error_mark_node
condition|)
return|return
name|instance
return|;
name|vtbl
operator|=
name|convert_pointer_to
argument_list|(
name|ptr_type_node
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|delta2
operator|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta2
argument_list|)
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|vtbl
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|idx
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_vtable_thunks
condition|)
block|{
name|aref
operator|=
name|save_expr
argument_list|(
name|aref
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_vtable_thunks
condition|)
name|e2
operator|=
name|aref
expr_stmt|;
else|else
name|e2
operator|=
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e3
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
expr_stmt|;
comment|/* Make sure this doesn't get evaluated first inside one of the 	     branches of the COND_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|e1
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
operator|*
name|instance_ptrptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|e1
argument_list|)
operator|!=
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|cp_error
argument_list|(
literal|"object missing in `%E'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|function
operator|=
name|e1
expr_stmt|;
block|}
return|return
name|function
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call_real
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|require_complete
parameter_list|,
name|flags
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
name|int
name|require_complete
decl_stmt|,
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|,
name|fndecl
decl_stmt|;
specifier|register
name|tree
name|value_type
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|assembler_name
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_method
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|assembler_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|GNU_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
condition|?
name|name
else|:
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|function
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|pedantic
operator|&&
name|DECL_MAIN_P
argument_list|(
name|function
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids calling `main' from within program"
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|inline_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"must use .* or ->* to call pointer-to-member function in `%E (...)'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|is_method
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
name|is_method
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%E' cannot be used as a function"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|coerced_params
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
operator|&&
operator|(
name|name
operator|||
name|assembler_name
operator|)
condition|)
name|check_function_format
argument_list|(
name|name
argument_list|,
name|assembler_name
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
comment|/* C++ */
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
block|{
specifier|register
name|tree
name|result
init|=
name|build_call
argument_list|(
name|function
argument_list|,
name|value_type
argument_list|,
name|coerced_params
argument_list|)
decl_stmt|;
if|if
condition|(
name|require_complete
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|result
return|;
name|result
operator|=
name|require_complete_type
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|value_type
argument_list|)
condition|)
name|result
operator|=
name|build_cplus_new
argument_list|(
name|value_type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
return|return
name|build_function_call_real
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
literal|1
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the actual parameter expressions in the list VALUES    to the types in the list TYPELIST.    If parmdecls is exhausted, or when an element has NULL as its type,    perform the default conversions.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.        Return a list of expressions for the parameters as converted.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.     In C++, unspecified trailing parameters can be filled in with their    default arguments, if such were specified.  Do so here.  */
end_comment

begin_function
name|tree
name|convert_arguments
parameter_list|(
name|typelist
parameter_list|,
name|values
parameter_list|,
name|fndecl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|called_thing
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Argument passing is always copy-initialization.  */
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|called_thing
operator|=
literal|"constructor"
expr_stmt|;
else|else
name|called_thing
operator|=
literal|"member function"
expr_stmt|;
block|}
else|else
name|called_thing
operator|=
literal|"function"
expr_stmt|;
block|}
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"too many arguments to %s `%+#D'"
argument_list|,
name|called_thing
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
comment|/* In case anybody wants to know if this argument 	     list is valid.  */
if|if
condition|(
name|result
condition|)
name|TREE_TYPE
argument_list|(
name|tree_last
argument_list|(
name|result
argument_list|)
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|val
operator|=
name|resolve_offset_ref
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"parameter type of called function is incomplete"
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|,
literal|"argument passing"
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|parmval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|val
operator|=
name|convert_from_reference
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert_arg_to_ellipsis
argument_list|(
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|typetail
operator|!=
name|void_list_node
condition|)
block|{
comment|/* See if there are default arguments that can be used */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|typetail
operator|!=
name|void_list_node
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parmval
init|=
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
argument_list|,
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|parmval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|expr_tree_cons
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
comment|/* ends with `...'.  */
if|if
condition|(
name|typetail
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"too few arguments to %s `%+#D'"
argument_list|,
name|called_thing
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_list
return|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression, after performing default    conversions on the operands.  CODE is the kind of expression to build.  */
end_comment

begin_function
name|tree
name|build_x_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
return|return
name|build_binary_op_nodefault
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     ERROR_CODE is the code that determines what to say in error messages.    It is usually, but not always, the same as CODE.     Note that the operands will never have enumeral types    because either they have just had the default conversions performed    or they have both just been converted to some other type in which    the arithmetic is to be done.     C++: must do special pointer arithmetic when implementing    multiple inheritance, and deal with pointer to member functions.  */
end_comment

begin_function
name|tree
name|build_binary_op_nodefault
parameter_list|(
name|code
parameter_list|,
name|orig_op0
parameter_list|,
name|orig_op1
parameter_list|,
name|error_code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|orig_op0
decl_stmt|,
name|orig_op1
decl_stmt|;
name|enum
name|tree_code
name|error_code
decl_stmt|;
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means create the expression with this type, rather than      RESULT_TYPE.  */
name|tree
name|build_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      convert it to this type.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* Apply default conversions.  */
if|if
condition|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
name|op0
operator|=
name|decay_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|decay_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|default_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|default_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* DTRT if one side is an overloaded function, but complain about it.  */
if|if
condition|(
name|type_unknown_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"assuming cast to `%T' from overloaded function"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"assuming cast to `%T' from overloaded function"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|t
expr_stmt|;
block|}
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E / 0'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E / 0.'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* When dividing two signed integers, we have to promote to int. 	       unless we divide by a constant != -1.  Note that default 	       conversion will have been performed on the operands at this 	       point, so we have to dig out the original type to find out if 	       it was unsigned.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If one operand is a constant, and the other is a short type 	 that has been converted to an int, 	 really do the work in the short type and then convert the 	 result to int.  If we are lucky, the constant will be 0 or 1 	 in the short type, making the entire operation go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|code1
operator|==
name|INTEGER_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E %% 0'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"division by zero in `%E %% 0.'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
name|result_type
operator|=
name|boolean_type_node
expr_stmt|;
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s rotate count is negative"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"%s rotate count>= width of type"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|build_type
operator|=
name|boolean_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|tt0
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tt1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tt0
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type1
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conversion of a pointer to member to `void *'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt1
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type0
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_pedwarn
argument_list|(
literal|"comparison of distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|==
name|NULL_TREE
condition|)
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|error
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|error
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|integer_zero_node
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|op0
operator|=
name|build_component_ref
argument_list|(
name|op1
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|integer_zero_node
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
block|{
comment|/* The code we generate for the test is:  	  (op0.index == op1.index&& ((op1.index != -1&& op0.delta2 == op1.delta2) 	       || op0.pfn == op1.pfn)) */
name|tree
name|index0
init|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index1
init|=
name|save_expr
argument_list|(
name|build_component_ref
argument_list|(
name|op1
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pfn0
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|pfn1
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|tree
name|delta20
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|delta21
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|tree
name|integer_neg_one_node
init|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
name|e1
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|index0
argument_list|,
name|index1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|index1
argument_list|,
name|integer_neg_one_node
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e2
argument_list|,
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|delta20
argument_list|,
name|delta21
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't use build_binary_op for this cmp because it would get 	     confused by the ptr to method types and think we want pmfs.  */
name|e3
operator|=
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|pfn0
argument_list|,
name|pfn1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|e2
return|;
return|return
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|e2
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|type1
argument_list|)
condition|)
block|{
name|tree
name|index0
init|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|index1
decl_stmt|;
name|tree
name|pfn0
init|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|delta20
init|=
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|delta21
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|tree
name|integer_neg_one_node
init|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_one_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Map everything down one to make room for 		 the null pointer to member.  */
name|index1
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|op1
operator|=
name|integer_zero_node
expr_stmt|;
name|delta21
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delta21
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|delta21
argument_list|)
expr_stmt|;
name|delta21
operator|=
name|size_binop
argument_list|(
name|FLOOR_DIV_EXPR
argument_list|,
name|delta21
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|delta21
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|delta21
argument_list|)
expr_stmt|;
block|}
else|else
name|index1
operator|=
name|integer_neg_one_node
expr_stmt|;
block|{
name|tree
name|nop1
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nop1
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|nop1
expr_stmt|;
block|}
name|e1
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|index0
argument_list|,
name|index1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|index1
argument_list|,
name|integer_neg_one_node
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e2
argument_list|,
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|delta20
argument_list|,
name|delta21
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't use build_binary_op for this cmp because it would get 	     confused by the ptr to method types and think we want pmfs.  */
name|e3
operator|=
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|pfn0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|e2
return|;
return|return
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|e2
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|type0
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_pedwarn
argument_list|(
literal|"comparison of distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|build_type
operator|=
name|boolean_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_pedwarn
argument_list|(
literal|"comparison of distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|int
name|none_complex
init|=
operator|(
name|code0
operator|!=
name|COMPLEX_TYPE
operator|&&
name|code1
operator|!=
name|COMPLEX_TYPE
operator|)
decl_stmt|;
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
operator|&&
name|none_complex
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|arg0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|arg1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* We can shorten only if the shift count is less than the 		 number of bits in the smaller type size.  */
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|>
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
operator|(
operator|(
operator|(
name|unsigned
operator|)
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|val
argument_list|)
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
block|}
if|if
condition|(
name|short_compare
operator|&&
name|warn_sign_compare
condition|)
block|{
name|int
name|op0_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op1_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
comment|/* Check for comparison of different enum types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"comparison between `%#T' and `%#T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Give warnings for comparisons between signed and unsigned 	     quantities that may fail.  */
comment|/* Do the checking based on the original operand trees, so that 	     casts will be considered, but default promotions won't be.  */
comment|/* Do not warn if the comparison is being done in a signed type, 	     since the signed type will only be chosen if it can represent 	     all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if both operands are unsigned.  */
elseif|else
if|if
condition|(
name|op0_signed
operator|==
name|op1_signed
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the signed quantity is an unsuffixed 	     integer literal (or some static constant expression 	     involving such literals) and it is non-negative.  */
elseif|else
if|if
condition|(
operator|(
name|op0_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|orig_op0
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|orig_op1
argument_list|)
operator|>=
literal|0
operator|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the comparison is an equality operation, 	     the unsigned quantity is an integral constant and it does 	     not use the most significant bit of result_type.  */
elseif|else
if|if
condition|(
operator|(
name|resultcode
operator|==
name|EQ_EXPR
operator|||
name|resultcode
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|op0_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|orig_op1
argument_list|,
name|signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|orig_op0
argument_list|,
name|signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|"comparison between signed and unsigned"
argument_list|)
expr_stmt|;
comment|/* Warn if two unsigned values are being compared in a size 	     larger than their original size, and one (and only one) is the 	     result of a `~' operator.  This comparison will always fail.  	     Also warn if one operand is a constant, and the constant does not 	     have all bits set that are set in the ~ operand when it is 	     extended.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
operator|^
operator|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|HOST_WIDE_INT
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|primop1
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid operands `%T' and `%T' to binary `%O'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Issue warnings about peculiar, but legal, uses of NULL.  */
if|if
condition|(
comment|/* It's reasonable to use pointer values as operands of&& 	 and ||, so NULL is no exception.  */
operator|!
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|(
comment|/* If OP0 is NULL and OP1 is not a pointer, or vice versa.  */
operator|(
name|orig_op0
operator|==
name|null_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
comment|/* Or vice versa.  */
operator|||
operator|(
name|orig_op1
operator|==
name|null_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
comment|/* Or, both are NULL and the operation was not a comparison.  */
operator|||
operator|(
name|orig_op0
operator|==
name|null_node
operator|&&
name|orig_op1
operator|==
name|null_node
operator|&&
name|code
operator|!=
name|EQ_EXPR
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|)
operator|)
condition|)
comment|/* Some sort of arithmetic operation involving NULL was        performed.  Note that pointer-difference and pointer-addition        have already been handled above, and so we don't end up here in        that case.  */
name|cp_warning
argument_list|(
literal|"NULL used in arithmetic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|error_mark_node
operator|||
name|op1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|build_type
operator|==
name|NULL_TREE
condition|)
name|build_type
operator|=
name|result_type
expr_stmt|;
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|cp_convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|tree
name|folded
init|=
name|fold
argument_list|(
name|intop
argument_list|)
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
specifier|register
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|result_type
argument_list|,
name|ptrop
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer of type `void *' in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a function in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a method in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a member in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|size_in_bytes
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Needed to make OOPS V2R3 work.  */
name|intop
operator|=
name|folded
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|intop
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|intop
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ptrop
return|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|size_exp
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|intop
operator|=
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as sizetype      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|intop
operator|=
name|cp_convert
argument_list|(
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument with a suitable product by the object size.      Do this multiplication as signed, then convert to the appropriate      pointer type (actually unsigned integral).  */
name|intop
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|,
name|size_exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|ptrtype
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|tree
name|ptrtype
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrtype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|target_type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer of type `void *' in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a function in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a method in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids using pointer to a member in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is a pointer to an incomplete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
name|op1
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|?
name|integer_one_node
else|:
name|size_in_bytes
argument_list|(
name|target_type
argument_list|)
operator|)
expr_stmt|;
comment|/* Do the division.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case of taking the address of a COMPONENT_REF.    Called by `build_unary_op'.     ARG is the COMPONENT_REF whose address we want.    ARGTYPE is the pointer type that this address should have. */
end_comment

begin_function
specifier|static
name|tree
name|build_component_addr
parameter_list|(
name|arg
parameter_list|,
name|argtype
parameter_list|)
name|tree
name|arg
decl_stmt|,
name|argtype
decl_stmt|;
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|decl_type_context
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|981018
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"attempt to take address of bit-field structure member `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* Can't convert directly to ARGTYPE, since that 	 may have the same pointer type as one of our 	 baseclasses.  */
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|argtype
argument_list|,
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This conversion is harmless.  */
name|rval
operator|=
name|convert_force
argument_list|(
name|argtype
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|offset
init|=
name|size_binop
argument_list|(
name|EASY_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
decl_stmt|;
name|offset
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rval
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|rval
argument_list|,
name|cp_convert
argument_list|(
name|argtype
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  */
end_comment

begin_function
name|tree
name|build_x_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/*& rec, on incomplete RECORD_TYPEs is the simple opr&, not an      error message.  */
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|OFFSET_REF
operator|)
operator|)
condition|)
comment|/* don't look for a function */
empty_stmt|;
else|else
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_new_op
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|||
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|rval
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|warning
argument_list|(
literal|"taking address of temporary"
argument_list|)
expr_stmt|;
block|}
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Just like truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */
end_comment

begin_function
name|tree
name|condition_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|expr
return|;
name|t
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* C++: Must handle pointers to members.     Perhaps type instantiation should be extended to handle conversion    from aggregates to types we don't yet know we want?  (Or are those    cases typically errors which should be reported?)     NOCONVERT nonzero suppresses the default promotions    (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
operator||
name|WANT_POINTER
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary plus"
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary minus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|code
operator|=
name|CONJ_EXPR
expr_stmt|;
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
comment|/* Conjugating a real value is a no-op, but allow it anyway.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to conjugation"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
name|arg
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|error_mark_node
condition|)
return|return
name|val
return|;
name|errstring
operator|=
literal|"in argument to unary !"
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|arg
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Increment or decrement the real part of the value, 	 and don't change the imaginary part.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real
operator|=
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|real
argument_list|,
literal|1
argument_list|)
argument_list|,
name|imag
argument_list|)
return|;
block|}
comment|/* Report invalid types.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_POINTER
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no post-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-decrement operator for type"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"no post-decrement operator for type"
expr_stmt|;
break|break;
block|}
comment|/* Report something read-only.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_error
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* ARM $5.2.5 last annotation says this should be forbidden.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids %sing an enum"
argument_list|,
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|enum
name|tree_code
name|tmp
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|cp_error
argument_list|(
literal|"cannot %s a pointer to incomplete type `%T'"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|(
name|tmp
operator|==
name|FUNCTION_TYPE
operator|||
name|tmp
operator|==
name|METHOD_TYPE
operator|||
name|tmp
operator|==
name|VOID_TYPE
operator|||
name|tmp
operator|==
name|OFFSET_TYPE
operator|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"ANSI C++ forbids %sing a pointer of type `%T'"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|cp_convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|,
name|compound
decl_stmt|;
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
name|compound
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Eliminate warning about unused result of + or -.  */
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|compound
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|compound
return|;
block|}
default|default:
break|break;
block|}
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Forbid using -- on `bool'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|boolean_type_node
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid use of `--' on bool variable `%D'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|#
directive|if
literal|0
comment|/* This will only work if someone can convince Kenner to accept 	       my patch to expand_increment. (jason)  */
block|val = build (code, TREE_TYPE (arg), arg, inc);
else|#
directive|else
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|boolean_true_node
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|boolean_true_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
name|argtype
operator|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|DECL_MAIN_P
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* ARM $3.4 */
name|pedwarn
argument_list|(
literal|"taking address of function `main'"
argument_list|)
expr_stmt|;
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* We don't need to have `current_class_ptr' wrapped in a 	     NON_LVALUE_EXPR node.  */
if|if
condition|(
name|arg
operator|==
name|current_class_ref
condition|)
return|return
name|current_class_ptr
return|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* Don't let this be an lvalue.  */
return|return
name|non_lvalue
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|arg
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Uninstantiated types are all functions.  Taking the 	 address of a function is a no-op, so just return the 	 argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|my_friendly_abort
argument_list|(
literal|117
argument_list|)
expr_stmt|;
comment|/* We don't know the type yet, so just work around the problem. 	     We know that this will resolve to an lvalue.  */
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|OVL_NEXT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* They're trying to take the address of a unique non-static 	     member function.  This is ill-formed, but let's try to DTRT.  */
name|tree
name|base
decl_stmt|,
name|name
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_ref
condition|)
comment|/* An expression like&memfn.  */
name|pedwarn
argument_list|(
literal|"taking the address of a non-static member function"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"taking the address of a bound member function"
argument_list|)
expr_stmt|;
name|base
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp_pedwarn
argument_list|(
literal|"  to form a pointer to member function, say `&%T::%D'"
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build_offset_ref
argument_list|(
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"taking the address of a cast to non-reference type"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|argtype
operator|!=
name|error_mark_node
condition|)
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|addr
operator|=
name|build_component_addr
argument_list|(
name|arg
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   function counts as a constant */
if|if
condition|(
name|staticp
argument_list|(
name|arg
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|build_ptrmemfunc_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build_ptrmemfunc
argument_list|(
name|argtype
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_endif
unit|static tree convert_sequence (conversions, arg)      tree conversions;      tree arg; {   switch (TREE_CODE (conversions))     {     case NOP_EXPR:     case CONVERT_EXPR:     case FLOAT_EXPR:     case FIX_TRUNC_EXPR:     case FIX_FLOOR_EXPR:     case FIX_ROUND_EXPR:     case FIX_CEIL_EXPR:       return cp_convert (TREE_TYPE (conversions), 			 convert_sequence (TREE_OPERAND (conversions, 0), 					   arg));      default:       return arg;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MAX_EXPR
condition|)
return|return
name|rationalize_conditional_expr
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
return|return
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Handle (a = b) used as an "lvalue" for `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|arg
argument_list|,
name|real_result
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|arg
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The representation of something of type OFFSET_TYPE 	 is really the representation of a pointer to it. 	 Here give the representation its true type.  */
name|tree
name|t
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SCOPE_REF
argument_list|,
literal|313
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check all this code for right semantics.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"taking address of destructor"
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|is_dummy_object
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"taking address of bound pointer-to-member expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|build_offset_type
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_ptrmem_cst
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/* We permit compiler to make function calls returning      objects of aggregate type look like lvalues.  */
block|{
name|tree
name|targ
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|arg
expr_stmt|;
else|else
name|targ
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|targ
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Don't let anything else be handled specially.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is 1 if successful.     C++: we do not allow `current_class_ptr' to be addressable.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|x
operator|==
name|current_class_ptr
condition|)
block|{
if|if
condition|(
operator|!
name|flag_this_is_variable
condition|)
name|error
argument_list|(
literal|"address of `this' not available"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* so compiler doesn't die later */
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|DECL_IN_MEMORY_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We thought this would make a good constant variable, 	       but we were wrong.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_RTL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
operator|!
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Caller should not be trying to mark initialized 	   constant fields addressable.  */
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|314
argument_list|)
expr_stmt|;
case|case
name|CONST_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|extra_warnings
condition|)
name|cp_warning
argument_list|(
literal|"address requested for `%D', which is declared `register'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* We have to test both conditions here.  The first may be 	       non-zero in the case of processing a default function.  The 	       second may be non-zero in the case of a template function.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|x
argument_list|)
condition|)
name|mark_used
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TARGET_EXPR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_x_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|COND_EXPR
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
return|return
name|build_new_op
argument_list|(
name|COND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
specifier|register
name|tree
name|type1
decl_stmt|;
specifier|register
name|tree
name|type2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
specifier|register
name|tree
name|result_type
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If second operand is omitted, it is the same as the first one;      make sure it is calculated only once.  */
if|if
condition|(
name|op1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
name|ifexp
operator|=
name|op1
operator|=
name|save_expr
argument_list|(
name|ifexp
argument_list|)
expr_stmt|;
block|}
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|error_mark_node
operator|||
name|op2
operator|==
name|error_mark_node
operator|||
name|type1
operator|==
name|error_mark_node
operator|||
name|type2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|ifexp
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|ifexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* C++: REFERENCE_TYPES must be dereferenced.  */
if|if
condition|(
name|code1
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|op1
operator|=
name|convert_from_reference
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code2
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|op2
operator|=
name|convert_from_reference
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
block|}
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
operator|&&
name|code2
operator|!=
name|ARRAY_TYPE
operator|&&
name|code2
operator|!=
name|FUNCTION_TYPE
operator|&&
name|code2
operator|!=
name|METHOD_TYPE
condition|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|ifexp
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|)
return|return
operator|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
operator|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|op1
operator|=
name|DECL_INITIAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|decl_constant_value
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|op2
operator|=
name|DECL_INITIAL
argument_list|(
name|op2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|decl_constant_value
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
name|type1
operator|=
name|cp_build_qualified_type
argument_list|(
name|type1
argument_list|,
operator|(
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* ??? This is a kludge to deal with the fact that 	 we don't sort out integers and enums properly, yet.  */
name|result
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type1
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|!=
name|type1
condition|)
name|result
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type1
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* Expand both sides into the same slot, 	 hopefully the target of the ?: expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|tree
name|slot
init|=
name|build
argument_list|(
name|VAR_DECL
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|layout_decl
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|build
argument_list|(
name|TARGET_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|slot
argument_list|,
name|result
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* They don't match; promote them both and then try to reconcile them.      But don't permit mismatching enum types.  */
if|if
condition|(
name|code1
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|code2
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"enumeral mismatch in conditional expression: `%T' vs `%T'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code2
argument_list|)
operator|&&
name|type2
operator|!=
name|type_promotes_to
argument_list|(
name|type1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|code2
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code1
argument_list|)
operator|&&
name|type1
operator|!=
name|type_promotes_to
argument_list|(
name|type2
argument_list|)
condition|)
name|warning
argument_list|(
literal|"enumeral and non-enumeral type in conditional expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
name|VOID_TYPE
condition|)
block|{
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
condition|)
name|type1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code2
operator|!=
name|VOID_TYPE
condition|)
block|{
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type2
argument_list|)
condition|)
name|type2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|code2
operator|==
name|RECORD_TYPE
operator|&&
name|real_lvalue_p
argument_list|(
name|op1
argument_list|)
operator|&&
name|real_lvalue_p
argument_list|(
name|op2
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_RELAXED
argument_list|)
condition|)
block|{
name|type1
operator|=
name|build_reference_type
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|build_reference_type
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert_to_reference
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|op2
operator|=
name|convert_to_reference
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
else|else
name|result_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type1
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator||
name|CP_TYPE_QUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op2
argument_list|)
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|1
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
comment|/* C++ */
elseif|else
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
condition|)
name|result_type
operator|=
name|type2
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|&&
operator|(
name|result_type
operator|=
name|common_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|result_type
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"common base type of types `%T' and `%T' is ambiguous"
argument_list|,
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|&&
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"`%T' and `%T' converted to `%T *' in conditional expression"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|result_type
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
name|type2
operator|==
name|unknown_type_node
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|type1
operator|==
name|unknown_type_node
condition|)
name|result_type
operator|=
name|type2
expr_stmt|;
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
comment|/* The match does not look good.  If either is 	 an aggregate value, try converting to a scalar type.  */
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|code2
operator|==
name|RECORD_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"aggregate mismatch in conditional expression: `%T' vs `%T'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Warning: this code assumes that conversion between cv-variants of          a type is done using NOP_EXPRs.  */
if|if
condition|(
name|code1
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
block|{
comment|/* There are other types besides pointers and records.  */
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
condition|)
name|tmp
operator|=
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|,
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator||
name|TYPE_QUAL_RESTRICT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|type2
expr_stmt|;
name|tmp
operator|=
name|build_type_conversion
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"incompatible types `%T' and `%T' in `?:'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
else|else
name|STRIP_NOPS
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|common_type
argument_list|(
name|type2
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|tmp
operator|=
name|build_pointer_type
argument_list|(
name|cp_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator||
name|TYPE_QUAL_RESTRICT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|type1
expr_stmt|;
name|tmp
operator|=
name|build_type_conversion
argument_list|(
name|tmp
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"incompatible types `%T' and `%T' in `?:'"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
else|else
name|STRIP_NOPS
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|op2
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|result_type
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|result_type
argument_list|,
name|op1
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"converting"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|result_type
argument_list|,
name|op2
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"converting"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
return|;
return|return
name|convert_from_reference
argument_list|(
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle overloading of the ',' operator when needed.  Otherwise,    this function just builds an expression list.  */
end_comment

begin_function
name|tree
name|build_x_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|rest
init|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|list
argument_list|,
name|NULL_TREE
argument_list|)
return|;
if|if
condition|(
name|rest
operator|==
name|NULL_TREE
condition|)
return|return
name|build_compound_expr
argument_list|(
name|list
argument_list|)
return|;
name|result
operator|=
name|build_opfncall
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|build_x_compound_expr
argument_list|(
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|TREE_CHAIN
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
block|{
comment|/* the left-hand operand of a comma expression is like an expression          statement: we should warn if it doesn't have any side-effects,          unless it was explicitly cast to (void).  */
if|if
condition|(
operator|(
name|extra_warnings
operator|||
name|warn_unused
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"left-hand operand of comma expression has no effect"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* this requires a gcc backend patch to export warn_if_unused_value */
block|else if (warn_unused)     warn_if_unused_value (TREE_VALUE(list));
endif|#
directive|endif
return|return
name|build_compound_expr
argument_list|(
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_compound_expr
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
name|tree
name|first
decl_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|decl_constant_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since LIST is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Convert arrays to pointers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
else|else
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
name|first
operator|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|first
operator|=
name|require_complete_type_in_void
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rest
operator|=
name|build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* When pedantic, a compound expression cannot be a constant expression.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|first
argument_list|)
operator|&&
operator|!
name|pedantic
condition|)
return|return
name|rest
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|break_out_cleanups
argument_list|(
name|first
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_static_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|intype
decl_stmt|,
name|binfo
decl_stmt|;
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|STATIC_CAST_EXPR
argument_list|,
name|copy_to_permanent
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
operator|(
name|convert_from_reference
argument_list|(
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|CONV_STATIC
operator||
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_cplus_new
argument_list|(
name|type
argument_list|,
operator|(
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|ctor_identifier
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
operator|)
argument_list|)
return|;
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* FIXME handle casting to array type.  */
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|can_convert_arg
argument_list|(
name|type
argument_list|,
name|intype
argument_list|,
name|expr
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
operator|(
name|binfo
operator|=
name|get_binfo
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|binfo
operator|=
name|get_binfo
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|can_convert
argument_list|(
name|intype
argument_list|,
name|type
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|cp_error
argument_list|(
literal|"static_cast from `%T' to `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_reinterpret_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|intype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|REINTERPRET_CAST_EXPR
argument_list|,
name|copy_to_permanent
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"reinterpret_cast from `%T' rvalue to `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|build_reinterpret_cast
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PTR_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"reinterpret_cast from `%T' to `%T' loses precision"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRFN_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|comp_ptr_ttypes_reinterpret
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"reinterpret_cast from `%T' to `%T' casts away const (or volatile)"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|intype
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids casting between pointers to functions and objects"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"reinterpret_cast from `%T' to `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_const_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|intype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CONST_CAST_EXPR
argument_list|,
name|copy_to_permanent
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is not a pointer, reference, or pointer-to-data-member type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"as required by const_cast"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is a pointer or reference to a function type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"which is forbidden by const_cast"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"const_cast from `%T' rvalue to `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|comp_ptr_ttypes_const
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|intype
argument_list|)
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|comp_ptr_ttypes_const
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|cp_error
argument_list|(
literal|"const_cast from `%T' to `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.     ALLOW_NONCONVERTING is true if we should allow non-converting constructors    when doing the cast.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
name|tree
name|otype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|value
operator|=
name|resolve_offset_ref
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Allow casting from T1* to T2[] because Cfront allows it. 	 NIHCL uses it. It is not valid ANSI C however, and hence, not 	 valid ANSI C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids casting to an array type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ANSI C++ forbids casting to an array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"casting to function type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies signature type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CAST_EXPR
argument_list|,
name|type
argument_list|,
name|min_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
comment|/* Convert functions and arrays to pointers and      convert references to their expanded types,      but don't convert any other types.  If, however, we are      casting to a class type, there's no reason to do this: the      cast will only succeed if there is a converting constructor,      and the default conversions will be done at that point.  In      fact, doing the default conversion here is actually harmful      in cases like this:       typedef int A[2];      struct S { S(const A&); };       since we don't want the array-to-pointer conversion done.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
comment|/* Don't do the default conversion on a ->* expression.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|bound_pmf_p
argument_list|(
name|value
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* However, even for class types, we still need to strip away        the reference type, since the call to convert_force below        does not expect the input expression to be of reference        type.  */
name|value
operator|=
name|convert_from_reference
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"cast discards qualifiers from pointer target type"
argument_list|)
expr_stmt|;
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast increases required alignment of target type"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We should see about re-enabling these, they seem useful to      me.  */
block|if (TREE_CODE (type) == INTEGER_TYPE&& TREE_CODE (otype) == POINTER_TYPE&& TYPE_PRECISION (type) != TYPE_PRECISION (otype))     warning ("cast from pointer to integer of different size");    if (TREE_CODE (type) == POINTER_TYPE&& TREE_CODE (otype) == INTEGER_TYPE&& TYPE_PRECISION (type) != TYPE_PRECISION (otype)
comment|/* Don't warn about converting 0 to pointer, 	 provided the 0 was explicit--not cast or made by folding.  */
block|&& !(TREE_CODE (value) == INTEGER_CST&& integer_zerop (value)))     warning ("cast to pointer from integer of different size");
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|value
operator|=
name|require_complete_type_in_void
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|value
operator|=
operator|(
name|convert_from_reference
argument_list|(
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|CONV_C_CAST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|tree
name|ovalue
decl_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ovalue
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|convert_force
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|CONV_C_CAST
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Always produce some operator for an explicit cast,        so we can tell (for -pedantic) that the cast is no lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|value
operator|==
name|expr
operator|&&
name|real_lvalue_p
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.     C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
init|=
name|rhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
name|tree
name|olhs
init|=
name|lhs
decl_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
operator|||
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle assignment to signature pointers/refs.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|lhstype
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|lhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
block|{
return|return
name|build_signature_pointer_constructor
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle --foo = 5; as these are valid constructs in C++ */
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newrhs
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|==
name|error_mark_node
condition|)
return|return
name|cond
return|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* Case to void to suppress warning 			 from warn_if_unused_value.  */
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Static class member?  */
name|tree
name|member
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|lhs
operator|=
name|member
expr_stmt|;
else|else
block|{
name|compiler_error
argument_list|(
literal|"invalid static class member"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
name|lhs
operator|=
name|resolve_offset_ref
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
condition|)
return|return
name|lhs
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|modifycode
operator|!=
name|INIT_EXPR
condition|)
block|{
name|lhs
operator|=
name|convert_from_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
comment|/* Do the default thing */
empty_stmt|;
else|else
block|{
name|result
operator|=
name|build_method_call
argument_list|(
name|lhs
argument_list|,
name|ctor_identifier
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* `operator=' is not an inheritable operator.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
comment|/* Do the default thing */
empty_stmt|;
else|else
block|{
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
name|lhstype
operator|=
name|olhstype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|,
name|REFERENCE_TYPE
argument_list|)
condition|)
block|{
name|my_friendly_abort
argument_list|(
literal|978652
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"  in evaluation of `%Q(%#T, %#T)'"
argument_list|,
name|modifycode
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the cast type of the lhs,      and then true type of the lhs and store it there;      then convert result back to the cast type to be the value      of the assignment.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* WP 5.4.1:  The result is an lvalue if T is a reference type, 	   otherwise the result is an rvalue.   */
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|lhs
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
return|return
name|result
return|;
return|return
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|GNU_xref_assign
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Warn about storing in something that is `const'.  */
comment|/* For C++, don't warn if this is initialization.  */
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
comment|/* For assignment to `const' signature pointer/reference fields, 	 don't warn either, we already printed a better message before.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|lhstype
argument_list|)
comment|/* Functions are not modifiable, even though they are 	     lvalues.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower 	 than one, we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
block|}
comment|/* check to see if there is an assignment to `this' */
if|if
condition|(
name|lhs
operator|==
name|current_class_ptr
condition|)
block|{
if|if
condition|(
name|flag_this_is_variable
operator|>
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"assignment to `this' not in constructor or destructor"
argument_list|)
expr_stmt|;
name|current_function_just_assigned_this
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
condition|)
block|{
comment|/* Make modifycode now either a NOP_EXPR or an INIT_EXPR.  */
name|modifycode
operator|=
name|NOP_EXPR
expr_stmt|;
comment|/* Reference-bashing */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|lhstype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|lhs
operator|=
name|tmp
expr_stmt|;
name|olhstype
operator|=
name|lhstype
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|newrhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|newrhs
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|newrhs
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|newrhs
argument_list|)
condition|)
name|newrhs
operator|=
name|stabilize_reference
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
comment|/* Convert new value to destination type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|from_array
decl_stmt|;
if|if
condition|(
operator|!
name|same_or_base_type_p
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"incompatible types in assignment of `%T' to `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Allow array assignment in compiler-generated code.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids assignment of arrays"
argument_list|)
expr_stmt|;
comment|/* Have to wrap this in RTL_EXPR for two cases: 	 in base or member initialization and if we 	 are a branch of a ?: operator.  Since we 	 can't easily know the latter, just do it always.  */
name|result
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|from_array
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
literal|1
operator|+
operator|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|)
else|:
literal|0
expr_stmt|;
name|expand_vec_init
argument_list|(
name|lhs
argument_list|,
name|lhs
argument_list|,
name|array_type_nelts
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|newrhs
argument_list|,
name|from_array
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|result
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|result
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
name|newrhs
operator|=
name|convert_for_initialization
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|lhs
argument_list|)
condition|)
name|warning
argument_list|(
literal|"return value from function receives multiple initializations"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|lhs
argument_list|)
operator|=
name|newrhs
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Avoid warnings on enum bit fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|convert_force
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|lhstype
argument_list|)
condition|)
name|newrhs
operator|=
name|build_cplus_new
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
comment|/* Can't initialize directly from a TARGET_EXPR, since that would 	 cause the lhs to be constructed twice, and possibly result in 	 accidental self-initialization.  So we force the TARGET_EXPR to be 	 expanded without a target.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|newrhs
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|,
name|newrhs
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|lhs1
decl_stmt|;
name|tree
name|cond
init|=
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|cond
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lhs
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cannot have two identical lhs on this one tree (result) as preexpand 	 calls will rip them out and fill in RTL for them, but when the 	 rtl is generated, the calls will only be in the first side of the 	 condition, not on both, or before the conditional jump! (mrs) */
name|lhs1
operator|=
name|break_out_calls
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|lhs1
condition|)
comment|/* If there's no change, the COND_EXPR behaves like any other rhs.  */
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
decl_stmt|;
comment|/* We have to convert each arm to the proper type because the 	     types may have been munged by constant folding.  */
name|result
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|cond
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs1
argument_list|,
name|modifycode
argument_list|,
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
comment|/* Avoid warnings converting integral types back into enums      for enum bit fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|olhstype
argument_list|,
name|result
argument_list|,
name|olhs
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_x_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|MODOP_EXPR
argument_list|,
name|lhs
argument_list|,
name|build_min_nt
argument_list|(
name|modifycode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|modifycode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
return|return
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get difference in deltas for different pointer to member function    types.  Return integer_zero_node, if FROM cannot be converted to a    TO type.  If FORCE is true, then allow reverse conversions as well.     Note that the naming of FROM and TO is kind of backwards; the return    value is what we add to a TO in order to get a FROM.  They are named    this way because we call this function to find out how to convert from    a pointer to member of FROM to a pointer to member of TO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_delta_difference
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|force
parameter_list|)
name|tree
name|from
decl_stmt|,
name|to
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|tree
name|delta
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|to
operator|==
name|from
condition|)
return|return
name|delta
return|;
comment|/* Should get_base_distance here, so we can check if any thing along the      path is virtual, and we need to make sure we stay      inside the real binfos when going through virtual bases.      Maybe we should replace virtual bases with      binfo_member (...CLASSTYPE_VBASECLASSES...)...  (mrs) */
name|binfo
operator|=
name|get_binfo
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"   in pointer to member function conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|error_not_base_type
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"   in pointer to member conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
name|binfo
operator|=
name|get_binfo
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
literal|0
operator|||
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|delta
return|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"pointer to member cast to virtual base `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will only work if you are very careful"
argument_list|)
expr_stmt|;
block|}
name|delta
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
return|return
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|delta
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|cp_warning
argument_list|(
literal|"pointer to member cast from virtual base `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will only work if you are very careful"
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"pointer to member conversion from virtual base `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_ptrmemfunc1
parameter_list|(
name|type
parameter_list|,
name|delta
parameter_list|,
name|idx
parameter_list|,
name|pfn
parameter_list|,
name|delta2
parameter_list|)
name|tree
name|type
decl_stmt|,
name|delta
decl_stmt|,
name|idx
decl_stmt|,
name|pfn
decl_stmt|,
name|delta2
decl_stmt|;
block|{
name|tree
name|u
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This is the old way we did it.  We want to avoid calling      digest_init, so that it can give an error if we use { } when      initializing a pointer to member function.  */
block|if (pfn)     {       u = build_nt (CONSTRUCTOR, NULL_TREE, 		    expr_tree_cons (pfn_identifier, pfn, NULL_TREE));     }   else     {       u = build_nt (CONSTRUCTOR, NULL_TREE, 		    expr_tree_cons (delta2_identifier, delta2, NULL_TREE));     }    u = build_nt (CONSTRUCTOR, NULL_TREE, 		expr_tree_cons (NULL_TREE, delta, 			   expr_tree_cons (NULL_TREE, idx, 				      expr_tree_cons (NULL_TREE, u, NULL_TREE))));    return digest_init (type, u, (tree*)0);
else|#
directive|else
name|tree
name|delta_field
decl_stmt|,
name|idx_field
decl_stmt|,
name|pfn_or_delta2_field
decl_stmt|,
name|pfn_field
decl_stmt|,
name|delta2_field
decl_stmt|;
name|tree
name|subtype
decl_stmt|;
name|int
name|allconstant
decl_stmt|,
name|allsimple
decl_stmt|;
name|delta_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|idx_field
operator|=
name|TREE_CHAIN
argument_list|(
name|delta_field
argument_list|)
expr_stmt|;
name|pfn_or_delta2_field
operator|=
name|TREE_CHAIN
argument_list|(
name|idx_field
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|pfn_or_delta2_field
argument_list|)
expr_stmt|;
name|pfn_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|delta2_field
operator|=
name|TREE_CHAIN
argument_list|(
name|pfn_field
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
condition|)
block|{
name|allconstant
operator|=
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|allsimple
operator|=
operator|!
operator|!
name|initializer_constant_valid_p
argument_list|(
name|pfn
argument_list|,
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|expr_tree_cons
argument_list|(
name|pfn_field
argument_list|,
name|pfn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delta2
operator|=
name|convert_and_check
argument_list|(
name|delta_type_node
argument_list|,
name|delta2
argument_list|)
expr_stmt|;
name|allconstant
operator|=
name|TREE_CONSTANT
argument_list|(
name|delta2
argument_list|)
expr_stmt|;
name|allsimple
operator|=
operator|!
operator|!
name|initializer_constant_valid_p
argument_list|(
name|delta2
argument_list|,
name|TREE_TYPE
argument_list|(
name|delta2
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|expr_tree_cons
argument_list|(
name|delta2_field
argument_list|,
name|delta2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|delta
operator|=
name|convert_and_check
argument_list|(
name|delta_type_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|idx
operator|=
name|convert_and_check
argument_list|(
name|delta_type_node
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|allconstant
operator|=
name|allconstant
operator|&&
name|TREE_CONSTANT
argument_list|(
name|delta
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|allsimple
operator|=
name|allsimple
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|delta
argument_list|,
name|TREE_TYPE
argument_list|(
name|delta
argument_list|)
argument_list|)
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|idx
argument_list|,
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|subtype
argument_list|,
name|NULL_TREE
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|expr_tree_cons
argument_list|(
name|delta_field
argument_list|,
name|delta
argument_list|,
name|expr_tree_cons
argument_list|(
name|idx_field
argument_list|,
name|idx
argument_list|,
name|expr_tree_cons
argument_list|(
name|pfn_or_delta2_field
argument_list|,
name|u
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|u
argument_list|)
operator|=
name|allconstant
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|u
argument_list|)
operator|=
name|allconstant
operator|&&
name|allsimple
expr_stmt|;
return|return
name|u
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Build a constructor for a pointer to member function.  It can be    used to initialize global variables, local variable, or used    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we    want to be.     If FORCE is non-zero, then force this conversion, even if    we would rather not do it.  Usually set when using an explicit    cast.     Return error_mark_node, if something goes wrong.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc
parameter_list|(
name|type
parameter_list|,
name|pfn
parameter_list|,
name|force
parameter_list|)
name|tree
name|type
decl_stmt|,
name|pfn
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
comment|/* Handle multiple conversions of pointer to member functions.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|idx
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|delta
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|delta2
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|npfn
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ndelta
decl_stmt|,
name|ndelta2
decl_stmt|;
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|pfn_type
decl_stmt|;
comment|/* Is is already the right type? */
if|if
condition|(
name|type
operator|==
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
condition|)
return|return
name|pfn
return|;
name|pfn_type
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|pfn_type
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|cp_error
argument_list|(
literal|"conversion to `%T' from `%T'"
argument_list|,
name|type
argument_list|,
name|pfn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
comment|/* We could just build the resulting CONSTRUCTOR now, but we 	     don't, relying on the general machinery below, together 	     with constant-folding, to do the right thing.  We don't 	     want to return a PTRMEM_CST here, even though we could, 	     because a pointer-to-member constant ceases to be a 	     constant (from the point of view of the language) when it 	     is cast to another type.  */
name|expand_ptrmemfunc_cst
argument_list|(
name|pfn
argument_list|,
operator|&
name|ndelta
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|npfn
argument_list|,
operator|&
name|ndelta2
argument_list|)
expr_stmt|;
if|if
condition|(
name|npfn
condition|)
comment|/* This constant points to a non-virtual function. 	       NDELTA2 will be NULL, but it's value doesn't really 	       matter since we won't use it anyhow.  */
name|ndelta2
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
block|{
name|ndelta
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|pfn
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ndelta2
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|DELTA2_FROM_PTRMEMFUNC
argument_list|(
name|pfn
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|build_component_ref
argument_list|(
name|pfn
argument_list|,
name|index_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|get_delta_difference
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn_type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ndelta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|delta2
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ndelta2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e1
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|idx
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's a virtual function, this is what we want.  */
name|e2
operator|=
name|build_ptrmemfunc1
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|delta
argument_list|,
name|idx
argument_list|,
name|NULL_TREE
argument_list|,
name|delta2
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|npfn
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|npfn
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
comment|/* But if it's a non-virtual function, or NULL, we use this 	 instead.  */
name|e3
operator|=
name|build_ptrmemfunc1
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|delta
argument_list|,
name|idx
argument_list|,
name|npfn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
return|;
block|}
comment|/* Handle null pointer to member function conversions.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|pfn
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc1
argument_list|(
name|TYPE_GET_PTRMEMFUNC_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_zero_node
argument_list|,
name|pfn
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|pfn
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|pfn
argument_list|,
literal|1
argument_list|)
return|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|make_ptrmem_cst
argument_list|(
name|build_ptrmemfunc_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST    given by CST.  */
end_comment

begin_function
name|void
name|expand_ptrmemfunc_cst
parameter_list|(
name|cst
parameter_list|,
name|delta
parameter_list|,
name|idx
parameter_list|,
name|pfn
parameter_list|,
name|delta2
parameter_list|)
name|tree
name|cst
decl_stmt|;
name|tree
modifier|*
name|delta
decl_stmt|;
name|tree
modifier|*
name|idx
decl_stmt|;
name|tree
modifier|*
name|pfn
decl_stmt|;
name|tree
modifier|*
name|delta2
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|PTRMEM_CST_MEMBER
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|ptr_class
decl_stmt|,
name|fn_class
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The class that the function belongs to.  */
name|fn_class
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* The class that we're creating a pointer to member of.  */
name|ptr_class
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* First, calculate the adjustment to the function's class.  */
operator|*
name|delta
operator|=
name|get_delta_difference
argument_list|(
name|fn_class
argument_list|,
name|ptr_class
argument_list|,
comment|/*force=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
operator|*
name|idx
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|convert
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_addr_func
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|delta2
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* If we're dealing with a virtual function, we have to adjust 'this'          again, to point to the base which provides the vtable entry for          fn; the call will do the opposite adjustment.  */
name|tree
name|orig_class
init|=
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_or_else
argument_list|(
name|orig_class
argument_list|,
name|fn_class
argument_list|)
decl_stmt|;
operator|*
name|delta
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|delta
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Map everything down one to make room for the null PMF.  */
operator|*
name|idx
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Offset from an object of PTR_CLASS to the vptr for ORIG_CLASS.  */
operator|*
name|delta2
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
operator|*
name|delta
argument_list|,
name|get_vfield_offset
argument_list|(
name|TYPE_BINFO
argument_list|(
name|orig_class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an expression for DELTA2 from the pointer-to-member function    given by T.  */
end_comment

begin_function
name|tree
name|delta2_from_ptrmemfunc
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|idx
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|tree
name|delta2
decl_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|t
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|pfn
argument_list|,
operator|&
name|delta2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta2
condition|)
return|return
name|delta2
return|;
block|}
return|return
operator|(
name|build_component_ref
argument_list|(
name|build_component_ref
argument_list|(
name|t
argument_list|,
name|pfn_or_delta2_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|delta2_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return an expression for PFN from the pointer-to-member function    given by T.  */
end_comment

begin_function
name|tree
name|pfn_from_ptrmemfunc
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|idx
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|tree
name|delta2
decl_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|t
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|pfn
argument_list|,
operator|&
name|delta2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
condition|)
return|return
name|pfn
return|;
block|}
return|return
operator|(
name|build_component_ref
argument_list|(
name|build_component_ref
argument_list|(
name|t
argument_list|,
name|pfn_or_delta2_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.     C++: attempts to allow `convert' to find conversions involving    implicit type conversion between aggregate and scalar types    as per 8.5.6 of C++ manual.  Does not randomly dereference    pointers to aggregates!  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
if|if
condition|(
name|codel
operator|==
name|OFFSET_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|990505
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|is_overloaded_fn
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* If rhs is some sort of overloaded function, ocp_convert will either      do the right thing or complain; we don't need to check anything else.      So just hand off.  */
if|if
condition|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
comment|/* Issue warnings about peculiar, but legal, uses of NULL.  */
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|rhs
operator|==
name|null_node
condition|)
name|cp_warning
argument_list|(
literal|"converting NULL to non-pointer type"
argument_list|)
expr_stmt|;
comment|/* This should no longer change types on us.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|rhs
operator|=
name|DECL_INITIAL
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
condition|)
block|{
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Arithmetic types all interconvert.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|BOOLEAN_TYPE
operator|||
name|codel
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|BOOLEAN_TYPE
operator|||
name|coder
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
comment|/* But we should warn if assigning REAL_TYPE to INTEGER_TYPE.  */
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
operator|&&
name|codel
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_warning
argument_list|(
literal|"`%T' used for argument %P of `%D'"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_warning
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
comment|/* And we should warn if assigning a negative value to 	 an unsigned variable.  */
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|codel
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_NEGATED_INT
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_warning
argument_list|(
literal|"negative value `%E' passed as argument %P of `%D'"
argument_list|,
name|rhs
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_warning
argument_list|(
literal|"%s of negative value `%E' to `%T'"
argument_list|,
name|errtype
argument_list|,
name|rhs
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|overflow_warning
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|fold
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
return|return
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions involving enums.  */
elseif|else
if|if
condition|(
operator|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|coder
argument_list|)
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|)
operator|)
operator|||
operator|(
name|coder
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|INTEGRAL_CODE_P
argument_list|(
name|codel
argument_list|)
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|)
operator|)
condition|)
block|{
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|coder
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
decl_stmt|;
name|int
name|ctt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|coder
operator|==
name|RECORD_TYPE
condition|)
block|{
name|rhs
operator|=
name|build_optr_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
comment|/* If both pointers are of aggregate type, then we 	 can give better error messages, and save some work 	 as well.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|||
name|type
operator|==
name|class_star_type_node
operator|||
name|rhstype
operator|==
name|class_star_type_node
condition|)
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
else|else
name|binfo
operator|=
name|get_binfo
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
return|return
name|error_not_base_type
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
return|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards qualifiers"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards qualifiers"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
operator|(
name|ctt
operator|=
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* ARM $4.8, commentary on p39.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"no standard conversion from `%T' to `void *'"
argument_list|,
name|ttr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|ctt
operator|<
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
condition|)
name|cp_pedwarn
argument_list|(
literal|"converting `%T' to `%T' is a contravariance violation"
argument_list|,
name|rhstype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|&&
operator|!
name|null_ptr_cst_p
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|coder
operator|==
name|RECORD_TYPE
condition|)
name|cp_pedwarn
argument_list|(
literal|"implicit conversion of signature pointer to type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids implicit conversion from `void *' in %s"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
block|}
comment|/* Const and volatile mean something different for function types, 	     so the usual warnings are not appropriate.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|binfo_member
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s between pointer to members converting across virtual baseclasses"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|string_conv_p
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* converting from string constant to char *, OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards qualifiers"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards qualifiers"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' changes signedness"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' changes signedness"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|add_quals
init|=
literal|0
decl_stmt|;
name|int
name|drops_quals
init|=
literal|0
decl_stmt|;
name|int
name|left_const
init|=
literal|1
decl_stmt|;
name|int
name|unsigned_parity
decl_stmt|;
name|int
name|nptrs
init|=
literal|0
decl_stmt|;
comment|/* This code is basically a duplicate of comp_ptr_ttypes_real.  */
for|for
control|(
init|;
condition|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
operator|,
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
control|)
block|{
name|nptrs
operator|-=
literal|1
expr_stmt|;
name|drops_quals
operator||=
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|left_const
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|)
name|add_quals
operator|=
literal|1
expr_stmt|;
name|left_const
operator|&=
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
break|break;
block|}
name|unsigned_parity
operator|=
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|-
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsigned_parity
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
condition|)
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
else|else
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|add_quals
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' adds cv-quals without intervening `const'"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' adds cv-quals without intervening `const'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drops_quals
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' discards qualifiers"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' discards qualifiers"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_parity
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' changes signed to unsigned"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' changes signed to unsigned"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unsigned_parity
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' as argument %P of `%D' changes unsigned to signed"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' changes unsigned to signed"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
comment|/* C++ is not so friendly about converting function and 		 member function pointers as C.  Emit warnings here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
if|if
condition|(
operator|!
name|same_or_base_type_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"conflicting function types in %s:"
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
name|cp_warning
argument_list|(
literal|"\t`%T' != `%T'"
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_error
argument_list|(
literal|"passing `%T' as argument %P of `%D'"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
block|{
comment|/* An explicit constant 0 can convert to a pointer,          but not a 0 that results from casting or folding.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' to argument %P of `%D' lacks a cast"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' lacks a cast"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
block|}
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|coder
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|cp_pedwarn
argument_list|(
literal|"passing `%T' to argument %P of `%D' lacks a cast"
argument_list|,
name|rhstype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cp_pedwarn
argument_list|(
literal|"%s to `%T' from `%T' lacks a cast"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|BOOLEAN_TYPE
operator|&&
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|coder
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|rhstype
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_FLAG
argument_list|(
name|rhstype
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* C++ */
elseif|else
if|if
condition|(
operator|(
operator|(
name|coder
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|||
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|rhstype
argument_list|)
operator|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|ttl
init|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ttr
init|=
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|rhstype
argument_list|)
condition|?
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|rhstype
argument_list|)
else|:
name|rhstype
operator|)
decl_stmt|;
name|int
name|ctt
init|=
operator|(
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|INTEGER_TYPE
condition|?
literal|1
else|:
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|1
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|ctt
operator|<
literal|0
condition|)
name|cp_pedwarn
argument_list|(
literal|"converting `%T' to `%T' is a contravariance violation"
argument_list|,
name|ttr
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctt
operator|==
literal|0
condition|)
name|cp_error
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|ttl
argument_list|,
name|ttr
argument_list|)
expr_stmt|;
comment|/* compatible pointer to member functions.  */
return|return
name|build_ptrmemfunc
argument_list|(
name|ttl
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|ERROR_MARK
operator|||
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* This should no longer happen.  References are initialized via      `convert_for_initialization'.  They should otherwise be      bashed before coming here.  */
elseif|else
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|317
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|nrhs
init|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|)
decl_stmt|;
name|TREE_CONSTANT
argument_list|(
name|nrhs
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|nrhs
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* Handle anachronistic conversions from (::*)() to cv void* or (*)().  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
name|cp_error
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|rhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Convert RHS to be of type TYPE.    If EXP is non-zero, it is the target of the initialization.    ERRTYPE is a string to use in error messages.     Two major differences between the behavior of    `convert_for_assignment' and `convert_for_initialization'    are that references are bashed in the former, while    copied in the latter, and aggregates are assigned in    the former (operator=) while initialized in the    latter (X(X&)).     If using constructor make sure no conversion operator exists, if one does    exist, an ambiguity exists.     If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */
end_comment

begin_function
name|tree
name|convert_for_initialization
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|,
name|rhs
parameter_list|,
name|flags
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|codel
operator|!=
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* We accept references to incomplete types, so we can      return here before checking if RHS is of complete type.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* This should eventually happen in convert_arguments.  */
specifier|extern
name|int
name|warningcount
decl_stmt|,
name|errorcount
decl_stmt|;
name|int
name|savew
init|=
literal|0
decl_stmt|,
name|savee
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fndecl
condition|)
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|rhs
operator|=
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|flags
argument_list|,
name|exp
condition|?
name|exp
else|:
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|cp_warning_at
argument_list|(
literal|"in passing argument %P of `%+D'"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|cp_error_at
argument_list|(
literal|"in passing argument %P of `%+D'"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
name|exp
operator|=
name|require_complete_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|IS_SIGNATURE_POINTER
argument_list|(
name|type
argument_list|)
operator|||
name|IS_SIGNATURE_REFERENCE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|build_signature_pointer_constructor
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|flags
argument_list|)
return|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* Issue warnings about peculiar, but legal, uses of NULL.  We 	 do this *before* the call to decl_constant_value so as to 	 avoid duplicate warnings on code like `const int I = NULL; 	 f(I);'.  */
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|rhs
operator|==
name|null_node
condition|)
name|cp_warning
argument_list|(
literal|"converting NULL to non-pointer type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.     We don't do default conversions on all inputs, because it can screw    up operands that are expected to be in memory.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.     C++: upon seeing a `return', we must call destructors on all    variables in scope which had constructors called on them.    This means that if in a destructor, the base class destructors    must be called before returning.     The RETURN statement in C++ has initialization semantics.  */
end_comment

begin_function
name|void
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
specifier|extern
name|struct
name|nesting
modifier|*
name|cond_stack
decl_stmt|,
modifier|*
name|loop_stack
decl_stmt|,
modifier|*
name|case_stack
decl_stmt|;
specifier|extern
name|tree
name|dtor_label
decl_stmt|,
name|ctor_label
decl_stmt|;
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `noreturn' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|RETURN_STMT
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dtor_label
condition|)
block|{
if|if
condition|(
name|retval
condition|)
name|error
argument_list|(
literal|"returning a value from a destructor"
argument_list|)
expr_stmt|;
comment|/* Can't just return from a destructor.  */
name|expand_goto
argument_list|(
name|dtor_label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only operator new(...) throw(), can return NULL [expr.new/13].  */
if|if
condition|(
operator|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|||
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
operator|)
operator|&&
operator|!
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|retval
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"operator new should throw an exception, not return NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* A non-named return value does not count.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|retval
operator|=
name|current_class_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|retval
operator|=
name|result
expr_stmt|;
else|else
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|valtype
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
comment|/* Clear this, so finish_function won't say that we 		     reach the end of a non-void function (which we don't, 		     we gave a return!).  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_this_is_variable
condition|)
name|error
argument_list|(
literal|"return from a constructor: use `this = ...' instead"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"returning a value from a constructor"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|current_class_ptr
expr_stmt|;
block|}
comment|/* Effective C++ rule 15.  See also start_function.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|&&
name|retval
operator|!=
name|current_class_ref
condition|)
name|cp_warning
argument_list|(
literal|"`operator=' should return a reference to `*this'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|valtype
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now deal with possible C++ hair:      (1) Compute the return value.      (2) If there are aggregate values with destructors which      must be cleaned up, clean them (taking care      not to clobber the return value).      (3) If an X(X&) constructor is defined, the return      value must be returned via that.  */
if|if
condition|(
name|retval
operator|==
name|result
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* It's already done for us.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"return of void value in function returning non-void"
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
name|functype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* First convert the value to the function's return type, then 	 to the type of return value's location to handle the          case that functype is thiner than the valtype. */
name|retval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|functype
argument_list|,
name|retval
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|,
literal|"return"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|convert
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Avoid warning about control reaching end of function.  */
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* We can't initialize a register from a AGGR_INIT_EXPR.  */
elseif|else
if|if
condition|(
operator|!
name|current_function_returns_struct
operator|&&
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
name|retval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|,
name|retval
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add some useful error checking for C++.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|whats_returned
decl_stmt|;
comment|/* Sort through common things to see what it is 	     we are returning.  */
name|whats_returned
operator|=
name|retval
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|AGGR_INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
comment|/* Get the target.  */
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"returning reference to temporary"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEMP_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"reference to non-lvalue returned"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|whats_returned
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|whats_returned
argument_list|)
operator|)
condition|)
name|cp_warning_at
argument_list|(
literal|"reference to local variable `%D' returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|whats_returned
init|=
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|whats_returned
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|whats_returned
argument_list|)
operator|)
condition|)
name|cp_warning_at
argument_list|(
literal|"address of local variable `%D' returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|cond_stack
operator|==
literal|0
operator|&&
name|loop_stack
operator|==
literal|0
operator|&&
name|case_stack
operator|==
literal|0
condition|)
name|current_function_return_value
operator|=
name|retval
expr_stmt|;
if|if
condition|(
name|ctor_label
operator|&&
name|TREE_CODE
argument_list|(
name|ctor_label
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
comment|/* Here RETVAL is CURRENT_CLASS_PTR, so there's nothing to do.  */
name|expand_goto
argument_list|(
name|ctor_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|&&
name|retval
operator|!=
name|result
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|expand_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a C switch statement, testing expression EXP.    Return EXP if it is valid, an error node otherwise.  */
end_comment

begin_function
name|tree
name|c_expand_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|idx
decl_stmt|;
name|exp
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|get_unwidened
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned,      because if we did, int_fits_type_p would do the wrong thing      when checking case values for being in range,      and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|idx
expr_stmt|;
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|,
literal|"switch statement"
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the pointer-type FROM can be converted to the    pointer-type TO via a qualification conversion.  If CONSTP is -1,    then we return non-zero if the pointers are similar, and the    cv-qualification signature of FROM is a proper subset of that of TO.     If CONSTP is positive, then all outer pointers have been    const-qualified.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_real
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|constp
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|constp
decl_stmt|;
block|{
name|int
name|to_more_cv_qualified
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|same_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|constp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
operator|++
name|to_more_cv_qualified
expr_stmt|;
block|}
if|if
condition|(
name|constp
operator|>
literal|0
condition|)
name|constp
operator|&=
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
operator|(
name|constp
operator|>=
literal|0
operator|||
name|to_more_cv_qualified
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* When comparing, say, char ** to char const **, this function takes the    'char *' and 'char const *'.  Do not pass non-pointer types to this    function.  */
end_comment

begin_function
name|int
name|comp_ptr_ttypes
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
return|return
name|comp_ptr_ttypes_real
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if to and from are (possibly multi-level) pointers to the same    type or inheritance-related types, regardless of cv-quals.  */
end_comment

begin_function
name|int
name|ptr_reasonably_similar
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_RELAXED
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_RELAXED
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like comp_ptr_ttypes, for const_cast.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_const
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|same_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like comp_ptr_ttypes, for reinterpret_cast.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_reinterpret
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
name|int
name|constp
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|constp
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
literal|0
return|;
name|constp
operator|&=
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the type-qualifier set corresponding to TYPE.  */
end_comment

begin_function
name|int
name|cp_type_quals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the TYPE contains a mutable member */
end_comment

begin_function
name|int
name|cp_has_mutable_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_HAS_MUTABLE
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

end_unit

