begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C++ compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C++ front end.    It contains routines to build C++ expressions given their operands,    including computing the types of the result, C and C++ specific error    checks, and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_decl_stmt
specifier|static
name|tree
name|convert_for_assignment
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|cp_pointer_int_sum
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|rationalize_conditional_expr
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_target_parms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_ptr_ttypes_real
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_ptr_ttypes_const
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_ptr_ttypes_reinterpret
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_except_types
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_array_types
name|PARAMS
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|tree
argument_list|,
name|int
argument_list|)
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|common_base_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_anon_field
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|pointer_diff
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_component_addr
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|qualify_type_recursive
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_delta_difference
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_cv_target_types
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|casts_away_constness_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|casts_away_constness
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_warn_about_returning_address_of_local
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|strip_all_pointer_quals
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the target type of TYPE, which means return T for:    T*, T&, T[], T (...), and otherwise, just T.  */
end_comment

begin_function
name|tree
name|target_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)    Returns the error_mark_node if the VALUE does not have    complete type when this function returns.  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|processing_template_decl
operator|||
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|value
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|value
return|;
comment|/* If we see X::Y, we build an OFFSET_TYPE which has      not been laid out.  Try to avoid an error by interpreting      it as this->X::Y, if reasonable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|current_class_ref
operator|!=
literal|0
operator|&&
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_ref
condition|)
block|{
name|value
operator|=
name|resolve_offset_ref
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|value
argument_list|)
return|;
block|}
if|if
condition|(
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|value
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Try to complete TYPE, if it is incomplete.  For example, if TYPE is    a template instantiation, do the instantiation.  Returns TYPE,    whether or not it could be completed, unless something goes    horribly wrong, in which case the error_mark_node is returned.  */
end_comment

begin_function
name|tree
name|complete_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
comment|/* Rather than crash, we return something sure to cause an error        at some point.  */
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|processing_template_decl
condition|)
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
condition|)
name|instantiate_class_template
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Like complete_type, but issue an error if the TYPE cannot be    completed.  VALUE is used for informative diagnostics.    Returns NULL_TREE if the type cannot be made complete.  */
end_comment

begin_function
name|tree
name|complete_type_or_else
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|{
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
comment|/* We already issued an error.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether type of EXP is instantiated.  */
end_comment

begin_function
name|int
name|type_unknown_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
operator|||
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|unknown_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|unknown_type_node
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer or pointer to member type similar to T1, with a    cv-qualification signature that is the union of the cv-qualification    signatures of T1 and T2: [expr.rel], [expr.eq].  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type_recursive
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TYPE_PTR_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
block|{
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|tt2
init|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|b1
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|tree
name|tgt
decl_stmt|;
name|tree
name|attributes
init|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|b1
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|tt1
operator|=
name|TREE_TYPE
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|tt2
operator|=
name|TREE_TYPE
argument_list|(
name|tt2
argument_list|)
expr_stmt|;
block|}
else|else
name|b1
operator|=
name|NULL_TREE
expr_stmt|;
name|type_quals
operator|=
operator|(
name|cp_type_quals
argument_list|(
name|tt1
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|tt2
argument_list|)
operator|)
expr_stmt|;
name|tgt
operator|=
name|qualify_type_recursive
argument_list|(
name|tt1
argument_list|,
name|tt2
argument_list|)
expr_stmt|;
name|tgt
operator|=
name|cp_build_qualified_type
argument_list|(
name|tgt
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
condition|)
name|tgt
operator|=
name|build_offset_type
argument_list|(
name|b1
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
block|}
return|return
name|t1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two parameter lists.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     As an optimization, free the space we allocate if the parameter    lists are already common.  */
end_comment

begin_function
name|tree
name|commonparms
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|tree
name|oldargs
init|=
name|p1
decl_stmt|,
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|any_change
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|tree_last
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newargs
operator|==
name|void_list_node
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|any_change
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|!=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|any_change
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|merge_types
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any_change
condition|)
return|return
name|oldargs
return|;
return|return
name|newargs
return|;
block|}
end_function

begin_comment
comment|/* Given a type, perhaps copied for a typedef,    find the "original" version of it.  */
end_comment

begin_function
name|tree
name|original_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
while|while
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|x
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
break|break;
name|x
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
condition|)
break|break;
name|t
operator|=
name|x
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* T1 and T2 are arithmetic or enumeration types.  Return the type    that will result from the "usual arithmetic conversions" on T1 and    T2 as described in [expr].  */
end_comment

begin_function
name|tree
name|type_after_usual_arithmetic_conversions
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
block|{
name|enum
name|tree_code
name|code1
init|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* FIXME: Attributes.  */
name|my_friendly_assert
argument_list|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|,
literal|19990725
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|,
literal|19990725
argument_list|)
expr_stmt|;
comment|/* In what follows, we slightly generalize the rules given in [expr] so      as to deal with `long long' and `complex'.  First, merge the      attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* If one type is complex, form the common type of the non-complex      components, then make that complex.  Use T1 or T2 if it is the      required type.  */
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|subtype1
init|=
name|code1
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
decl_stmt|;
name|tree
name|subtype2
init|=
name|code2
operator|==
name|COMPLEX_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
else|:
name|t2
decl_stmt|;
name|tree
name|subtype
init|=
name|type_after_usual_arithmetic_conversions
argument_list|(
name|subtype1
argument_list|,
name|subtype2
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|==
name|subtype
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|build_complex_type
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Perform the integral promotions.  */
if|if
condition|(
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
name|t1
operator|=
name|type_promotes_to
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|type_promotes_to
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* The types are the same; no need to do anything fancy.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
comment|/* If one is a sizetype, use it so size_binop doesn't blow up.  */
if|if
condition|(
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* If one is unsigned long long, then convert the other to unsigned 	 long long.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* If one is a long long, and the other is an unsigned long, and 	 long long can represent all the values of an unsigned long, then 	 convert to a long long.  Otherwise, convert to an unsigned long 	 long.  Otherwise, if either operand is long long, convert the 	 other to long long. 	  	 Since we're here, we know the TYPE_PRECISION is the same; 	 therefore converting to long long cannot represent all the values 	 of an unsigned long, so we choose unsigned long long in that 	 case.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
operator|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
operator|)
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
decl_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Go through the same procedure, but for longs.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_unsigned_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
operator|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
operator|)
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
operator|)
decl_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|t
argument_list|,
name|attributes
argument_list|)
return|;
block|}
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
else|else
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|long_double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|double_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|double_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|double_type_node
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|float_type_node
argument_list|)
operator|||
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
argument_list|,
name|float_type_node
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|float_type_node
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Two floating-point types whose TYPE_MAIN_VARIANTs are none of          the standard C++ floating-point types.  Logic earlier in this          function has already eliminated the possibility that          TYPE_PRECISION (t2) != TYPE_PRECISION (t1), so there's no          compelling reason to choose one or the other.  */
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the composite pointer type (see [expr.rel]) for T1 and T2.    ARG1 and ARG2 are the values with those types.  The LOCATION is a    string describing the current location, in case an error occurs.  */
end_comment

begin_function
name|tree
name|composite_pointer_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|location
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|tree
name|arg1
decl_stmt|;
name|tree
name|arg2
decl_stmt|;
specifier|const
name|char
modifier|*
name|location
decl_stmt|;
block|{
name|tree
name|result_type
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* [expr.rel]       If one operand is a null pointer constant, the composite pointer      type is the type of the other operand.  */
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|arg2
argument_list|)
condition|)
return|return
name|t1
return|;
comment|/* Deal with pointer-to-member functions in the same way as we deal      with pointers to functions. */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* We have:         [expr.rel]         If one of the operands has type "pointer to cv1 void*", then        the other has type "pointer to cv2T", and the composite pointer        type is "pointer to cv12 void", where cv12 is the union of cv1        and cv2.      If either type is a pointer to void, make sure it is T1.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
name|t1
operator|=
name|t2
expr_stmt|;
name|t2
operator|=
name|t
expr_stmt|;
block|}
comment|/* Now, if T1 is a pointer to void, merge the qualifiers.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_PTRFN_P
argument_list|(
name|t2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function"
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
operator|(
name|cp_type_quals
argument_list|(
name|t1
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|t2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|full1
init|=
name|qualify_type_recursive
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
decl_stmt|;
name|tree
name|full2
init|=
name|qualify_type_recursive
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
decl_stmt|;
name|int
name|val
init|=
name|comp_target_types
argument_list|(
name|full1
argument_list|,
name|full2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|result_type
operator|=
name|full1
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|result_type
operator|=
name|full2
expr_stmt|;
else|else
block|{
name|pedwarn
argument_list|(
literal|"%s between distinct pointer types `%T' and `%T' lacks a cast"
argument_list|,
name|location
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|ptr_type_node
expr_stmt|;
block|}
block|}
return|return
name|build_type_attribute_variant
argument_list|(
name|result_type
argument_list|,
name|attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the merged type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This just combines attributes and default arguments; any other    differences would cause the two types to compare unalike.  */
end_comment

begin_function
name|tree
name|merge_types
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|original_type
argument_list|(
name|t1
argument_list|)
operator|==
name|original_type
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Merge the attributes.  */
name|attributes
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type.  */
block|{
name|tree
name|target
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|t1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_reference_type
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
name|t1
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|t1
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
block|{
name|tree
name|base
init|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|target
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|t1
operator|=
name|build_offset_type
argument_list|(
name|base
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
name|t1
operator|=
name|build_cplus_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|merge_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|raises
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|p2
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|p1
condition|)
return|return
name|build_type_attribute_variant
argument_list|(
name|t2
argument_list|,
name|attributes
argument_list|)
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|p1
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|rval
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|rval
argument_list|,
name|attributes
argument_list|)
return|;
block|}
name|rval
operator|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|commonparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_exception_variant
argument_list|(
name|rval
argument_list|,
name|raises
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|METHOD_TYPE
case|:
block|{
comment|/* Get this value the long way, since TYPE_METHOD_BASETYPE 	   is just the main variant of this.  */
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|t3
decl_stmt|;
comment|/* If this was a member function type, get back to the 	   original type of type member function (i.e., without 	   the class instance variable up front.  */
name|t1
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3
operator|=
name|merge_types
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|t3
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|t3
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t3
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build_exception_variant
argument_list|(
name|t3
argument_list|,
name|raises
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
empty_stmt|;
block|}
return|return
name|build_type_attribute_variant
argument_list|(
name|t1
argument_list|,
name|attributes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.     This is the type for the result of most arithmetic operations    if the operands have the given two types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
name|enum
name|tree_code
name|code1
decl_stmt|;
name|enum
name|tree_code
name|code2
decl_stmt|;
comment|/* If one type is nonsense, bail.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
operator|||
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t1
argument_list|)
operator|||
name|code1
operator|==
name|ENUMERAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|t2
argument_list|)
operator|||
name|code2
operator|==
name|ENUMERAL_TYPE
operator|||
name|code2
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
return|return
name|type_after_usual_arithmetic_conversions
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTR_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTR_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|t2
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
return|return
name|composite_pointer_type
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|error_mark_node
argument_list|,
name|error_mark_node
argument_list|,
literal|"conversion"
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two exception specifier types for exactness or subsetness, if    allowed. Returns 0 for mismatch, 1 for same, 2 if B is allowed by A.      [except.spec] "If a class X ... objects of class X or any class publicly    and unambigously derrived from X. Similarly, if a pointer type Y * ...    exceptions of type Y * or that are pointers to any type publicly and    unambigously derrived from Y. Otherwise a function only allows exceptions    that have the same type ..."    This does not mention cv qualifiers and is different to what throw    [except.throw] and catch [except.catch] will do. They will ignore the    top level cv qualifiers, and allow qualifiers in the pointer to class    example.        We implement the letter of the standard.  */
end_comment

begin_function
specifier|static
name|int
name|comp_except_types
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|exact
parameter_list|)
name|tree
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|exact
decl_stmt|;
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|cp_type_quals
argument_list|(
name|a
argument_list|)
operator|||
name|cp_type_quals
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|a
operator|=
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|TREE_TYPE
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_type_quals
argument_list|(
name|a
argument_list|)
operator|||
name|cp_type_quals
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ACCESSIBLY_UNIQUELY_DERIVED_P
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are equivalent exception specifiers.    If EXACT is 0, T2 can be a subset of T1 (according to 15.4/7),    otherwise it must be exact. Exception lists are unordered, but    we've already filtered out duplicates. Most lists will be in order,    we should try to make use of that.  */
end_comment

begin_function
name|int
name|comp_except_specs
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|exact
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|exact
decl_stmt|;
block|{
name|tree
name|probe
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
comment|/* T1 is ... */
return|return
name|t2
operator|==
name|NULL_TREE
operator|||
operator|!
name|exact
return|;
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
condition|)
comment|/* t1 is EMPTY */
return|return
name|t2
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
return|;
if|if
condition|(
name|t2
operator|==
name|NULL_TREE
condition|)
comment|/* T2 is ... */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
condition|)
comment|/* T2 is EMPTY, T1 is not */
return|return
operator|!
name|exact
return|;
comment|/* Neither set is ... or EMPTY, make sure each part of T2 is in T1.      Count how many we find, to determine exactness. For exact matching and      ordered T1, T2, this is an O(n) operation, otherwise its worst case is      O(nm).  */
for|for
control|(
name|base
operator|=
name|t1
init|;
name|t2
operator|!=
name|NULL_TREE
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
for|for
control|(
name|probe
operator|=
name|base
init|;
name|probe
operator|!=
name|NULL_TREE
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|TREE_VALUE
argument_list|(
name|probe
argument_list|)
decl_stmt|;
name|tree
name|b
init|=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp_except_types
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|exact
argument_list|)
condition|)
block|{
if|if
condition|(
name|probe
operator|==
name|base
operator|&&
name|exact
condition|)
name|base
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|probe
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|!
name|exact
operator|||
name|base
operator|==
name|NULL_TREE
operator|||
name|length
operator|==
name|list_length
argument_list|(
name|t1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the array types T1 and T2, using CMP as the type comparison    function for the element types.  STRICT is as for comptypes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|comp_array_types
argument_list|(
name|cmp
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
decl|register
name|int
argument_list|(
operator|*
name|cmp
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|d1
decl_stmt|;
name|tree
name|d2
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* The type of the array elements must be the same.  */
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
operator|&
operator|~
name|COMPARE_REDECLARATION
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|d1
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|==
name|d2
condition|)
return|return
literal|1
return|;
comment|/* If one of the arrays is dimensionless, and the other has a      dimension, they are of different types.  However, it is legal to      write:         extern int a[];        int a[3];       by [basic.link]:          declarations for an array object can specify        array types that differ by the presence or absence of a major        array bound (_dcl.array_).  */
if|if
condition|(
operator|!
name|d1
operator|||
operator|!
name|d2
condition|)
return|return
name|strict
operator|&
name|COMPARE_REDECLARATION
return|;
comment|/* Check that the dimensions are the same.  */
return|return
operator|(
name|cp_tree_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if T1 and T2 are compatible types for assignment or    various other operations.  STRICT is a bitwise-or of the COMPARE_*    flags.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|strict
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|int
name|attrval
decl_stmt|,
name|val
decl_stmt|;
name|int
name|orig_strict
init|=
name|strict
decl_stmt|;
comment|/* The special exemption for redeclaring array types without an      array bound only applies at the top level:         extern int (*i)[];        int (*i)[8];       is not legal, for example.  */
name|strict
operator|&=
operator|~
name|COMPARE_REDECLARATION
expr_stmt|;
comment|/* Suppress errors caused by previously reported errors */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* This should never happen.  */
name|my_friendly_assert
argument_list|(
name|t1
operator|!=
name|error_mark_node
argument_list|,
literal|307
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* If either type is the internal version of sizetype, return the      language version.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
operator|!=
literal|0
condition|)
name|t1
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
operator|!=
literal|0
condition|)
name|t2
operator|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict
operator|&
name|COMPARE_RELAXED
condition|)
block|{
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|cp_type_quals
argument_list|(
name|t1
argument_list|)
operator|!=
name|cp_type_quals
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strict
operator|==
name|COMPARE_STRICT
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_FOR_JAVA
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Allow for two different type nodes which have essentially the same      definition.  Note that we already checked for equality of the type      qualifiers (just above).  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strict
operator|&
name|COMPARE_NO_ATTRIBUTES
condition|)
name|attrval
operator|=
literal|1
expr_stmt|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|attrval
operator|=
call|(
modifier|*
name|targetm
operator|.
name|comp_type_attributes
call|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
if|if
condition|(
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t2
argument_list|)
operator|||
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t1
argument_list|)
operator|!=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
return|return
literal|1
return|;
comment|/* Don't check inheritance.  */
name|strict
operator|=
name|COMPARE_STRICT
expr_stmt|;
comment|/* fall through */
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t2
argument_list|)
operator|&&
operator|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_TI_TEMPLATE
argument_list|(
name|t2
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|)
condition|)
name|val
operator|=
name|comp_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_TI_ARGS
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|look_hard
label|:
if|if
condition|(
operator|(
name|strict
operator|&
name|COMPARE_BASE
operator|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
name|val
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strict
operator|&
name|COMPARE_RELAXED
operator|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|val
operator|=
operator|(
name|comptypes
argument_list|(
name|build_pointer_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
comment|/* first, check whether the referred types match with the          required level of strictness */
name|val
operator|=
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
name|strict
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
goto|goto
name|look_hard
goto|;
break|break;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|val
operator|=
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|||
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|strict
argument_list|)
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Target types must match incl. qualifiers.  We use ORIG_STRICT 	 here since this is the one place where 	 COMPARE_REDECLARATION should be used.  */
name|val
operator|=
name|comp_array_types
argument_list|(
name|comptypes
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|orig_strict
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
return|return
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t2
argument_list|)
operator|&&
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t1
argument_list|)
operator|==
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|TYPENAME_TYPE
case|:
if|if
condition|(
name|cp_tree_equal
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|<
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
if|if
condition|(
name|cp_tree_equal
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_IDENTIFIER
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|<
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|same_type_p
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|attrval
operator|==
literal|2
operator|&&
name|val
operator|==
literal|1
condition|?
literal|2
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of comp_target-types.  Make sure that the cv-quals change    only in the same direction as the target type.  */
end_comment

begin_function
specifier|static
name|int
name|comp_cv_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|nptrs
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|)
comment|/* The qualifications are incomparable.  */
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
condition|)
return|return
name|more_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
name|t
operator|=
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|==
literal|1
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
operator|)
operator|||
operator|(
name|t
operator|==
operator|-
literal|1
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 or -1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers, 0 if not. Return 1 means that TTR can be    converted to TTL. Return -1 means that TTL can be converted to TTR but    not vice versa.     NPTRS is the number of pointers we can strip off and keep cool.    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,    but to not permit B** to convert to A**.     This should go away.  Callers should use can_convert or something    similar instead.  (jason 17 Apr 1997)  */
end_comment

begin_function
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|,
name|nptrs
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
comment|/* If we get a pointer with nptrs == 0, we don't allow any tweaking 	 of the type pointed to.  This is necessary for reference init 	 semantics.  We won't get here from a previous call with nptrs == 1; 	 for multi-level pointers we end up in comp_ptr_ttypes.  */
operator|&&
name|nptrs
operator|>
literal|0
condition|)
block|{
name|int
name|is_ptr
init|=
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
decl_stmt|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptr
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|UNKNOWN_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|ttr
argument_list|,
name|ttl
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
operator|-
literal|1
argument_list|)
return|;
return|return
name|comp_cv_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
operator|-
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|comp_array_types
argument_list|(
name|comp_target_types
argument_list|,
name|ttl
argument_list|,
name|ttr
argument_list|,
name|COMPARE_STRICT
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|argsl
decl_stmt|,
name|argsr
decl_stmt|;
name|int
name|saw_contra
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
operator|-
literal|1
case|:
name|saw_contra
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|argsl
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|argsr
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
comment|/* Compare 'this' here, not in comp_target_parms.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|tl
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|ttl
argument_list|)
decl_stmt|;
name|tree
name|tr
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|ttr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|same_or_base_type_p
argument_list|(
name|tr
argument_list|,
name|tl
argument_list|)
condition|)
block|{
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|tl
argument_list|,
name|tr
argument_list|)
condition|)
name|saw_contra
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|argsl
operator|=
name|TREE_CHAIN
argument_list|(
name|argsl
argument_list|)
expr_stmt|;
name|argsr
operator|=
name|TREE_CHAIN
argument_list|(
name|argsr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|comp_target_parms
argument_list|(
name|argsl
argument_list|,
name|argsr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
operator|-
literal|1
case|:
name|saw_contra
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|saw_contra
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* for C++ */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|int
name|base
decl_stmt|;
comment|/* Contravariance: we can assign a pointer to base member to a pointer 	 to derived member.  Note difference from simple pointer case, where 	 we can pass a pointer to derived to a pointer to base.  */
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
condition|)
name|base
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|ttl
decl_stmt|;
name|ttl
operator|=
name|ttr
expr_stmt|;
name|ttr
operator|=
name|tmp
expr_stmt|;
name|base
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|ttl
operator|=
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|ttr
operator|=
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|comp_ptr_ttypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|)
condition|)
return|return
name|base
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|comp_cv_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
name|nptrs
argument_list|)
operator|==
literal|1
condition|)
return|return
name|base
return|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
condition|)
block|{
if|if
condition|(
name|nptrs
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|build_pointer_type
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|same_or_base_type_p
argument_list|(
name|build_pointer_type
argument_list|(
name|ttr
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|ttl
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */
end_comment

begin_function
name|int
name|at_least_as_qualified_p
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
comment|/* All qualifiers for TYPE2 must also appear in TYPE1.  */
return|return
operator|(
operator|(
name|cp_type_quals
argument_list|(
name|type1
argument_list|)
operator|&
name|cp_type_quals
argument_list|(
name|type2
argument_list|)
operator|)
operator|==
name|cp_type_quals
argument_list|(
name|type2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is more qualified than TYPE2.  */
end_comment

begin_function
name|int
name|more_qualified_p
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
return|return
operator|(
name|cp_type_quals
argument_list|(
name|type1
argument_list|)
operator|!=
name|cp_type_quals
argument_list|(
name|type2
argument_list|)
operator|&&
name|at_least_as_qualified_p
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if TYPE1 is more cv-qualified than TYPE2, -1 if TYPE2 is    more cv-qualified that TYPE1, and 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_cv_qualification
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type1
argument_list|)
operator|==
name|cp_type_quals
argument_list|(
name|type2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|at_least_as_qualified_p
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|at_least_as_qualified_p
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the cv-qualification signature of TYPE1 is a proper    subset of the cv-qualification signature of TYPE2, and the types    are similar.  Returns -1 if the other way 'round, and 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_cv_qual_signature
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
if|if
condition|(
name|comp_ptr_ttypes_real
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|comp_ptr_ttypes_real
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If two types share a common base type, return that basetype.    If there is not a unique most-derived base type, this function    returns ERROR_MARK_NODE.  */
end_comment

begin_function
specifier|static
name|tree
name|common_base_type
parameter_list|(
name|tt1
parameter_list|,
name|tt2
parameter_list|)
name|tree
name|tt1
decl_stmt|,
name|tt2
decl_stmt|;
block|{
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If one is a baseclass of another, that's good enough.  */
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt1
argument_list|,
name|tt2
argument_list|)
condition|)
return|return
name|tt1
return|;
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|tt2
argument_list|,
name|tt1
argument_list|)
condition|)
return|return
name|tt2
return|;
comment|/* Otherwise, try to find a unique baseclass of TT1      that is shared by TT2, and follow that down.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|tt1
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|basetype
argument_list|,
name|tt2
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Same for TT2.  */
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|tt2
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|tt2
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|trial
init|=
name|common_base_type
argument_list|(
name|tt1
argument_list|,
name|basetype
argument_list|)
decl_stmt|;
if|if
condition|(
name|trial
condition|)
block|{
if|if
condition|(
name|trial
operator|==
name|error_mark_node
condition|)
return|return
name|trial
return|;
if|if
condition|(
name|best
operator|==
name|NULL_TREE
condition|)
name|best
operator|=
name|trial
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|!=
name|trial
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two parameter type lists PARMS1 and PARMS2 are    equivalent in the sense that functions with those parameter types    can have equivalent types.  The two lists must be equivalent,    element by element.     C++: See comment above about TYPE1, TYPE2.  */
end_comment

begin_function
name|int
name|compparms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This really wants return whether or not parameter type lists    would make their owning functions assignment compatible or not.     The return value is like for comp_target_types.     This should go away, possibly with the exception of the empty parmlist    conversion; there are no conversions between function types in C++.    (jason 17 Apr 1997)  */
end_comment

begin_function
specifier|static
name|int
name|comp_target_parms
parameter_list|(
name|parms1
parameter_list|,
name|parms2
parameter_list|)
name|tree
name|parms1
decl_stmt|,
name|parms2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|parms1
decl_stmt|,
name|t2
init|=
name|parms2
decl_stmt|;
name|int
name|warn_contravariance
init|=
literal|0
decl_stmt|;
comment|/* In C, an unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  This is not      true for C++, but let's do it anyway for unfixed headers.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|!=
literal|0
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ prohibits conversion from `%#T' to `(...)'"
argument_list|,
name|parms2
argument_list|)
expr_stmt|;
return|return
name|self_promoting_args_p
argument_list|(
name|t2
argument_list|)
return|;
block|}
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
name|self_promoting_args_p
argument_list|(
name|t1
argument_list|)
return|;
for|for
control|(
init|;
name|t1
operator|||
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* If one parmlist is shorter than the other, 	 they fail to match, unless STRICT is<= 0.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pedantic
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
block|{
comment|/* The following is wrong for contravariance, 	     but many programs depend on it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
operator|==
name|void_type_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|&&
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Note backwards order due to contravariance.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warn_contravariance
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
return|return
literal|0
return|;
block|}
block|}
return|return
name|warn_contravariance
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the value of the `sizeof' operator.  */
end_comment

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|size
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|SIZEOF_EXPR
argument_list|,
name|type
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids applying `sizeof' to a function type"
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids applying `sizeof' to a member function"
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids applying `sizeof' to type `void' which is an incomplete type"
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
name|size
operator|=
name|size_one_node
expr_stmt|;
else|else
block|{
comment|/* ARM $5.3.2: ``When applied to a reference, the result is the 	 size of the referenced object.'' */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`sizeof' applied to non-static member"
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`sizeof' applied to incomplete type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_zero_node
expr_stmt|;
block|}
else|else
comment|/* Convert in case a char is more than one unit.  */
name|size
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* SIZE will have an integer type with TYPE_IS_SIZETYPE set.      TYPE_IS_SIZETYPE means that certain things (like overflow) will      never happen.  However, this node should really have type      `size_t', which is just a typedef for an ordinary integer type.  */
name|size
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|c_size_type_node
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|,
literal|20001021
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
name|tree
name|expr_sizeof
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|SIZEOF_EXPR
argument_list|,
name|e
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"sizeof applied to a bit-field"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids applying `sizeof' to an expression of function type"
argument_list|)
expr_stmt|;
return|return
name|c_sizeof
argument_list|(
name|char_type_node
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|e
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c_sizeof
argument_list|(
name|char_type_node
argument_list|)
return|;
block|}
comment|/* It's illegal to say `sizeof (X::i)' for `i' a non-static data      member unless you're in a non-static member of X.  So hand off to      resolve_offset_ref.  [expr.prim]  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|e
operator|=
name|resolve_offset_ref
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|e
return|;
return|return
name|c_sizeof
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|size
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
name|size
operator|=
name|size_one_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|size
operator|=
name|size_zero_node
expr_stmt|;
else|else
comment|/* Convert in case a char is more than one unit.  */
name|size
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* SIZE will have an integer type with TYPE_IS_SIZETYPE set.      TYPE_IS_SIZETYPE means that certain things (like overflow) will      never happen.  However, this node should really have type      `size_t', which is just a typedef for an ordinary integer type.  */
name|size
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|c_size_type_node
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|,
literal|20001021
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform the array-to-pointer and function-to-pointer conversions    for EXP.       In addition, references are converted to lvalues and manifest    constants are replaced by their values.  */
end_comment

begin_function
name|tree
name|decay_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|exp
operator|=
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|exp
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|exp
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value.  We      don't do this for arrays, though; we want the address of the      first element of the array, not the address of the first element      of its initializing constant.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|METHOD_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|is_overloaded_fn
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Stripping away the INDIRECT_REF is not the right 	     thing to do for references...  */
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|inner
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|inner
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|inner
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|decay_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_CONSTANT
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
comment|/* [basic.lval]: Class rvalues can have cv-qualified types; non-class      rvalues always have cv-unqualified types.  */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|exp
operator|=
name|cp_convert
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|exp
operator|=
name|decay_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_CODE_P
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|type_promotes_to
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|type
condition|)
return|return
name|cp_convert
argument_list|(
name|t
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Take the address of an inline function without setting TREE_ADDRESSABLE    or TREE_USED.  */
end_comment

begin_function
name|tree
name|inline_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|exp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff exp is a STRING_CST or the result of applying    decay_conversion to one.  */
end_comment

begin_function
name|int
name|string_conv_p
parameter_list|(
name|totype
parameter_list|,
name|exp
parameter_list|,
name|warn
parameter_list|)
name|tree
name|totype
decl_stmt|,
name|exp
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|flag_const_strings
operator|||
name|TREE_CODE
argument_list|(
name|totype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|totype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|char_type_node
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|t
argument_list|,
name|wchar_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* Make sure that we don't try to convert between char and wchar_t.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Is this a string constant which has decayed to 'const char *'?  */
name|t
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|t
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
block|}
comment|/* This warning is not very useful, as it complains about printf.  */
if|if
condition|(
name|warn
operator|&&
name|warn_write_strings
condition|)
name|warning
argument_list|(
literal|"deprecated conversion from string constant to `%T'"
argument_list|,
name|totype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|build_object_ref
parameter_list|(
name|datum
parameter_list|,
name|basetype
parameter_list|,
name|field
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|basetype
decl_stmt|,
name|field
decl_stmt|;
block|{
name|tree
name|dtype
decl_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%T::%D' in expression of non-aggregate type `%T'"
argument_list|,
name|basetype
argument_list|,
name|field
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|binfo_or_else
argument_list|(
name|basetype
argument_list|,
name|dtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
return|return
name|build_x_component_ref
argument_list|(
name|build_scoped_ref
argument_list|(
name|datum
argument_list|,
name|basetype
argument_list|)
argument_list|,
name|field
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like `build_component_ref, but uses an already found field, and converts    from a reference.  Must compute access for current_class_ref.    Otherwise, ok.  */
end_comment

begin_function
name|tree
name|build_component_ref_1
parameter_list|(
name|datum
parameter_list|,
name|field
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|field
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
return|return
name|convert_from_reference
argument_list|(
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
name|protect
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a COND_EXPR, MIN_EXPR, or MAX_EXPR in T, return it in a form that we    can, for example, use as an lvalue.  This code used to be in    unary_complex_lvalue, but we needed it to deal with `a = (d == c) ? b : c'    expressions, where we're dealing with aggregates.  But now it's again only    called from unary_complex_lvalue.  The case (in particular) that led to    this was with CODE == ADDR_EXPR, since it's not an lvalue when we'd    get it there.  */
end_comment

begin_function
specifier|static
name|tree
name|rationalize_conditional_expr
parameter_list|(
name|code
parameter_list|,
name|t
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
comment|/* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that      the first operand is always the one to be used if both operands      are equal, so we know what conditional expression this used to be.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MAX_EXPR
condition|)
block|{
return|return
name|build_conditional_expr
argument_list|(
name|build_x_binary_op
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MIN_EXPR
condition|?
name|LE_EXPR
else|:
name|GE_EXPR
operator|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the TYPE of an anonymous union field inside T, return the    FIELD_DECL for the field.  If not found return NULL_TREE.  Because    anonymous unions can nest, we must also search all anonymous unions    that are directly reachable.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_anon_field
parameter_list|(
name|t
parameter_list|,
name|type
parameter_list|)
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* If we find it directly, return the field.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|type
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|field
return|;
block|}
comment|/* Otherwise, it could be nested, search harder.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|subfield
init|=
name|lookup_anon_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|subfield
condition|)
return|return
name|subfield
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build a COMPONENT_REF for a given DATUM, and it's member COMPONENT.    COMPONENT can be an IDENTIFIER_NODE that is the name of the member    that we are interested in, or it can be a FIELD_DECL.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
specifier|register
name|tree
name|basetype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
name|tree
name|field_type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|tree
name|old_datum
decl_stmt|;
name|tree
name|old_basetype
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* BASETYPE holds the type of the class containing the COMPONENT.  */
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference      inside it.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|2
argument_list|)
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_DECL
case|:
name|error
argument_list|(
literal|"invalid use of `%D'"
argument_list|,
name|datum
argument_list|)
expr_stmt|;
name|datum
operator|=
name|error_mark_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|datum
operator|=
name|resolve_offset_ref
argument_list|(
name|datum
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
comment|/* First, see if there is a field or component with name COMPONENT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* I could not trigger this code. MvL */
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEAD
name|my_friendly_assert
argument_list|(
operator|!
operator|(
name|TREE_CHAIN
argument_list|(
name|component
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|component
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|309
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|datum
argument_list|,
name|component
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%D' in `%E', which is of non-aggregate type `%T'"
argument_list|,
name|component
argument_list|,
name|datum
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|basetype
argument_list|,
name|datum
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
operator|!=
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"destructor specifier `%T::~%T' must have matching names"
argument_list|,
name|basetype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type `%T' has no destructor"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Look up component name in the structure type definition.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|==
name|component
condition|)
comment|/* Special-case this because if we use normal lookups in an ambiguous        hierarchy, the compiler will abort (because vptr lookups are        not supposed to be ambiguous.  */
name|field
operator|=
name|TYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|field
operator|=
name|component
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of type decl `%#D' as expression"
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of template `%#D' as expression"
argument_list|,
name|component
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|name
init|=
name|component
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
comment|/* Source is in error, but produce a sensible diagnostic.  */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
name|protect
operator|&&
operator|!
name|VFIELD_NAME_P
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Not found as a data field, look for it as a method.  If found, 	     then if this is the only possible one, return it, else 	     report ambiguity error.  */
name|tree
name|fndecls
init|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fndecls
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fndecls
condition|)
block|{
comment|/* If the function is unique and static, we can resolve it 		 now.  Otherwise, we have to wait and see what context it is 		 used in; a component_ref involving a non-static member 		 function can only be used in a call (expr.ref).  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fndecls
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
decl_stmt|;
name|enforce_access
argument_list|(
name|basetype_path
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
else|else
block|{
comment|/* A unique non-static member function.  Other parts 			 of the compiler expect something with 			 unknown_type_node to be really overloaded, so 			 let's oblige.  */
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
operator|=
name|ovl_cons
argument_list|(
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
name|fndecls
operator|=
name|TREE_VALUE
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fndecls
operator|=
name|build_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|fndecls
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|datum
argument_list|,
name|fndecls
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
name|error
argument_list|(
literal|"`%#T' has no member named `%D'"
argument_list|,
name|basetype
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|pedwarn
argument_list|(
literal|"invalid use of type decl `%#D' as expression"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_RTL
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
name|mark_used
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
name|TREE_USED
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do evaluate the object when accessing a static member.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|datum
argument_list|)
condition|)
name|field
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|field
return|;
block|}
block|}
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|field
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|old_datum
operator|=
name|datum
expr_stmt|;
name|old_basetype
operator|=
name|basetype
expr_stmt|;
comment|/* See if we have to do any conversions so that we pick up the field from the      right context.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|basetype
condition|)
block|{
name|tree
name|context
init|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|context
decl_stmt|;
while|while
condition|(
operator|!
name|same_type_p
argument_list|(
name|base
argument_list|,
name|basetype
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|base
argument_list|)
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|TYPE_CONTEXT
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Handle base classes here...  */
if|if
condition|(
name|base
operator|!=
name|basetype
operator|&&
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|base_kind
name|kind
decl_stmt|;
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|,
name|base
argument_list|,
name|ba_check
argument_list|,
operator|&
name|kind
argument_list|)
decl_stmt|;
comment|/* Complain about use of offsetof which will break.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|kind
operator|==
name|bk_via_virtual
condition|)
block|{
name|error
argument_list|(
literal|"\ invalid offsetof from non-POD type `%#T'; use pointer to member instead"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|datum
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|datum
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|base
expr_stmt|;
comment|/* Handle things from anon unions here...  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|tree
name|subfield
init|=
name|lookup_anon_field
argument_list|(
name|basetype
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|tree
name|subdatum
init|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|subfield
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
return|return
name|build_component_ref
argument_list|(
name|subdatum
argument_list|,
name|field
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
return|;
block|}
block|}
comment|/* Complain about other invalid uses of offsetof, even though they will      give the right answer.  Note that we complain whether or not they      actually used the offsetof macro, since there's no way to know at this      point.  So we just give a warning, instead of a pedwarn.  */
if|if
condition|(
name|protect
operator|&&
name|CLASSTYPE_NON_POD_P
argument_list|(
name|old_basetype
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|old_datum
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|old_datum
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"\ invalid offsetof from non-POD type `%#T'; use pointer to member instead"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
comment|/* Compute the type of the field, as described in [expr.ref].  */
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* The standard says that the type of the result should be the        type referred to by the reference.  But for now, at least, we        do the conversion from reference type later.  */
empty_stmt|;
else|else
block|{
name|type_quals
operator|=
operator|(
name|cp_type_quals
argument_list|(
name|field_type
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* A field is const (volatile) if the enclosing object, or the 	 field itself, is const (volatile).  But, a mutable field is 	 not const, even within a const object.  */
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|field_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|field_type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|ref
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|field_type
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the expression const or volatile, as appropriate.  Even      though we've dealt with the type above, we still have to mark the      expression itself.  */
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Variant of build_component_ref for use in expressions, which should    never have REFERENCE_TYPE.  */
end_comment

begin_function
name|tree
name|build_x_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|t
init|=
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|component
argument_list|,
name|basetype_path
argument_list|,
name|protect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|t
operator|=
name|convert_from_reference
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.     This function may need to overload OPERATOR_FNNAME.    Must also handle REFERENCE_TYPEs for C++.  */
end_comment

begin_function
name|tree
name|build_x_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|ptr
argument_list|)
return|;
name|rval
operator|=
name|build_opfncall
argument_list|(
name|INDIRECT_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|ptr
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build_indirect_ref
argument_list|(
name|ptr
argument_list|,
name|errorstring
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ptr
operator|==
name|current_class_ptr
condition|)
return|return
name|current_class_ref
return|;
name|pointer
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|ptr
else|:
name|default_conversion
argument_list|(
name|ptr
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [expr.unary.op] 	  	 If the type of the expression is "pointer to T," the type 	 of  the  result  is  "T."              We must use the canonical variant because certain parts of 	 the back end, like fold, do pointer comparisons between 	 types.  */
name|tree
name|t
init|=
name|canonical_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* A pointer to incomplete type (other than cv void) can be              dereferenced [expr.unary.op]/1  */
name|error
argument_list|(
literal|"`%T' is not a pointer-to-object type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|flag_volatile
operator|&&
name|same_type_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* The POINTER was something like `&x'.  We simplify `*&x' to 	   `x'.  */
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|t
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	     so that we get the proper error message if the result is used 	     to assign to.  Also,&* is supposed to be a no-op.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_CONST_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|CP_TYPE_VOLATILE_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
operator|(
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
operator|||
name|flag_volatile
operator|)
expr_stmt|;
return|return
name|ref
return|;
block|}
block|}
comment|/* `pointer' won't be an error_mark_node if we were given a      pointer to member, so it's cool to check for this here.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of `%s' on pointer to member"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pointer
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|errorstring
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid type argument"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).     If INDEX is of some user-defined type, it must be converted to    integer type.  Otherwise, to make a compatible PLUS_EXPR, it    will inherit the type of the array, which will be some pointer type.  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|tree
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If ARRAY is a COMPOUND_EXPR or COND_EXPR, move our reference      inside it.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|array
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|1
argument_list|)
argument_list|,
name|idx
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|1
argument_list|)
argument_list|,
name|idx
argument_list|)
argument_list|,
name|build_array_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|array
argument_list|,
literal|2
argument_list|)
argument_list|,
name|idx
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* Subscripting with type char is likely to lose 	 on a machine where chars are signed. 	 So warn on any machine, but optionally. 	 Don't warn for unsigned char since that type is safe. 	 Don't warn for signed char because anyone who uses that 	 must have done so deliberately.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"array subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|idx
operator|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a constant value which is not within 	 the array bounds cannot be stored in a register either; because we 	 would get a crash in store_bit_field/extract_bit_field when trying 	 to access a non-existent part of the register.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|idx
argument_list|,
name|TYPE_VALUES
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
comment|/* Note in C++ it is valid to subscript a `register' array, since 	 it is valid to take the address of something with that 	 storage specification.  */
if|if
condition|(
name|extra_warnings
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|warning
argument_list|(
literal|"subscripting array declared `register'"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are 	 or if the array is..  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|CP_TYPE_VOLATILE_P
argument_list|(
name|type
argument_list|)
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|idx
argument_list|)
decl_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.  The PARAMS do    not include any object pointer that may be required.  FUNCTION's    data type may be a function type or a pointer-to-function.     For C++: If FUNCTION's data type is a TREE_LIST, then the tree list    is the list of possible methods that FUNCTION could conceivably    be.  If the list of methods comes from a class, then it will be    a list of lists (where each element is associated with the class    that produced it), otherwise it will be a simple list (for    functions overloaded in global scope).     In the first case, TREE_VALUE (function) is the head of one of those    lists, and TREE_PURPOSE is the name of the function.     In the second case, TREE_PURPOSE (function) is the function's    name directly.     DECL is the class instance variable, usually CURRENT_CLASS_REF.     When calling a TEMPLATE_DECL, we don't require a complete return    type.  */
end_comment

begin_function
name|tree
name|build_x_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|decl
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|template_id
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_method
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* Save explicit template arguments if found */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|template_id
operator|=
name|function
expr_stmt|;
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|unknown_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Undo (Foo:bar)()...  */
name|type
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|function
operator|=
name|OVL_FUNCTION
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|999
argument_list|)
expr_stmt|;
name|function
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|function
operator|=
name|resolve_offset_ref
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
operator|)
operator|||
operator|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|function
argument_list|)
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|build_member_call
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|template_id
condition|?
name|template_id
else|:
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|,
name|params
argument_list|)
return|;
name|is_method
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|function
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
comment|/* A friend template.  Make it look like a toplevel declaration.  */
if|if
condition|(
operator|!
name|is_method
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|function
operator|=
name|ovl_cons
argument_list|(
name|function
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Handle methods, friends, and overloaded functions, respectively.  */
if|if
condition|(
name|is_method
condition|)
block|{
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|function
operator|=
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|312
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Call via a pointer to member function.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* What other type of POINTER_TYPE could this be? */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
name|function
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|function
argument_list|)
expr_stmt|;
goto|goto
name|do_x_function
goto|;
block|}
comment|/* this is an abbreviated method call.          must go through here in case it is a virtual function. 	 @@ Perhaps this could be optimized.  */
if|if
condition|(
name|basetype
operator|&&
operator|(
operator|!
name|current_class_type
operator|||
operator|!
name|DERIVED_FROM_P
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|)
operator|)
condition|)
return|return
name|build_member_call
argument_list|(
name|basetype
argument_list|,
name|function
argument_list|,
name|params
argument_list|)
return|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object missing in call to method `%D'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Yow: call from a static member function.  */
name|decl
operator|=
name|build_dummy_object
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
block|}
comment|/* Put back explicit template arguments, if any.  */
if|if
condition|(
name|template_id
condition|)
name|function
operator|=
name|template_id
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type
operator|==
name|unknown_type_node
condition|)
block|{
comment|/* Undo what we did in build_component_ref.  */
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|template_id
argument_list|,
literal|20011228
argument_list|)
expr_stmt|;
name|template_id
operator|=
name|function
expr_stmt|;
block|}
else|else
block|{
name|function
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_id
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
operator|=
name|function
expr_stmt|;
name|function
operator|=
name|template_id
expr_stmt|;
block|}
block|}
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|function
argument_list|)
condition|)
block|{
if|if
condition|(
name|OVL_FUNCTION
argument_list|(
name|function
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* Put back explicit template arguments, if any.  */
if|if
condition|(
name|template_id
condition|)
name|function
operator|=
name|template_id
expr_stmt|;
return|return
name|build_new_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
block|}
else|else
comment|/* Remove a potential OVERLOAD around it */
name|function
operator|=
name|OVL_CURRENT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|do_x_function
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
comment|/* If the component is a data element (or a virtual function), we play 	 games here to make things work.  */
name|tree
name|decl_addr
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
condition|)
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|current_class_ref
expr_stmt|;
name|decl_addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sigh.  OFFSET_REFs are being used for too many things. 	 They're being used both for -> and ->*, and we want to resolve 	 the -> cases here, but leave the ->*.  We could use 	 resolve_offset_ref for those, too, but it would call          get_member_function_from_ptrfunc and decl_addr wouldn't get          updated properly.  Nasty.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|function
operator|=
name|resolve_offset_ref
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function
operator|=
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|decl_addr
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl_addr
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|function
argument_list|,
name|params
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|is_method
condition|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|ctypeptr
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Explicitly named method?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ctypeptr
operator|=
name|build_pointer_type
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expression with ptr-to-method type?  It could either be a plain 	 usage, or it might be a case where the ptr-to-method is being 	 passed in as an argument.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|tree
name|rec
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ctypeptr
operator|=
name|build_pointer_type
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
comment|/* Unexpected node type?  */
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid call to member function needing `this' in static member function scope"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"pointer to member function called, but not in class scope"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ctypeptr
argument_list|)
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|decl
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|decl
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|build_c_cast
argument_list|(
name|ctypeptr
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|params
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
return|return
name|build_function_call
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resolve a pointer to member function.  INSTANCE is the object    instance to use, if the member points to a virtual member.  */
end_comment

begin_function
name|tree
name|get_member_function_from_ptrfunc
parameter_list|(
name|instance_ptrptr
parameter_list|,
name|function
parameter_list|)
name|tree
modifier|*
name|instance_ptrptr
decl_stmt|;
name|tree
name|function
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fntype
decl_stmt|,
name|idx
decl_stmt|,
name|e1
decl_stmt|,
name|delta
decl_stmt|,
name|delta2
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|,
name|vtbl
decl_stmt|;
name|tree
name|instance
decl_stmt|,
name|basetype
decl_stmt|;
name|tree
name|instance_ptr
init|=
operator|*
name|instance_ptrptr
decl_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
comment|/* Extracting the function address from a pmf is only 	     allowed with -Wno-pmf-conversions. It only works for 	     pmf constants. */
name|e1
operator|=
name|build_addr_func
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|convert
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|e1
argument_list|)
expr_stmt|;
return|return
name|e1
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|instance_ptr
argument_list|)
condition|)
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|save_expr
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert down to the right base, before using the instance. */
name|instance
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|instance_ptr
argument_list|,
name|instance
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|&&
name|instance_ptr
operator|!=
name|error_mark_node
condition|)
return|return
name|instance
return|;
name|e3
operator|=
name|PFN_FROM_PTRMEMFUNC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtbl
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|function
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This used to avoid checking for virtual functions if basetype 	 has no virtual functions, according to an earlier ANSI draft. 	 With the final ISO C++ rules, such an optimization is 	 incorrect: A pointer to a derived member can be static_cast 	 to pointer-to-base-member, as long as the dynamic object 	 later has the right member. */
comment|/* Promoting idx before saving it improves performance on RISC 	 targets.  Without promoting, the first compare used 	 load-with-sign-extend, while the second used normal load then 	 shift to sign-extend.  An optimizer flaw, perhaps, but it's 	 easier to make this change.  */
name|idx
operator|=
name|cp_build_binary_op
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_index_type
argument_list|,
name|e3
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
condition|)
block|{
case|case
name|ptrmemfunc_vbit_in_pfn
case|:
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_index_type
argument_list|,
name|e3
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|ptrmemfunc_vbit_in_delta
case|:
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|delta
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_build_binary_op
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|vtable_index_type
argument_list|,
name|delta
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* DELTA2 is the amount by which to adjust the `this' pointer 	 to find the vtbl.  */
name|delta2
operator|=
name|delta
expr_stmt|;
name|vtbl
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta2
argument_list|)
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|vtbl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* When using function descriptors, the address of the 	 vtable entry is treated as a function pointer.  */
if|if
condition|(
name|TARGET_VTABLE_USES_DESCRIPTORS
condition|)
name|e2
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|e2
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e3
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
expr_stmt|;
comment|/* Make sure this doesn't get evaluated first inside one of the 	 branches of the COND_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|e1
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|e1
argument_list|)
expr_stmt|;
operator|*
name|instance_ptrptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|e1
argument_list|)
operator|!=
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|error
argument_list|(
literal|"object missing in `%E'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|function
operator|=
name|e1
expr_stmt|;
block|}
return|return
name|function
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call_real
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|require_complete
parameter_list|,
name|flags
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
name|int
name|require_complete
decl_stmt|,
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|,
name|fndecl
decl_stmt|;
specifier|register
name|tree
name|value_type
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|assembler_name
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|is_method
decl_stmt|;
name|tree
name|original
init|=
name|function
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|assembler_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|function
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|pedantic
operator|&&
name|DECL_MAIN_P
argument_list|(
name|function
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids calling `::main' from within program"
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|inline_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
name|function
operator|=
name|build_addr_func
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|fntype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"must use .* or ->* to call pointer-to-member function in `%E (...)'"
argument_list|,
name|original
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|is_method
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
name|is_method
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"`%E' cannot be used as a function"
argument_list|,
name|original
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|coerced_params
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
else|else
return|return
name|error_mark_node
return|;
block|}
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
condition|)
name|check_function_format
argument_list|(
name|NULL
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|expand_tree_builtin
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|,
name|params
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
comment|/* Some built-in function calls will be evaluated at      compile-time in fold ().  */
name|result
operator|=
name|fold
argument_list|(
name|build_call
argument_list|(
name|function
argument_list|,
name|coerced_params
argument_list|)
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_complete
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|result
return|;
name|result
operator|=
name|require_complete_type
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|value_type
argument_list|)
condition|)
name|result
operator|=
name|build_cplus_new
argument_list|(
name|value_type
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
return|return
name|build_function_call_real
argument_list|(
name|function
argument_list|,
name|params
argument_list|,
literal|1
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the actual parameter expressions in the list VALUES    to the types in the list TYPELIST.    If parmdecls is exhausted, or when an element has NULL as its type,    perform the default conversions.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.        Return a list of expressions for the parameters as converted.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.     In C++, unspecified trailing parameters can be filled in with their    default arguments, if such were specified.  Do so here.  */
end_comment

begin_function
name|tree
name|convert_arguments
parameter_list|(
name|typelist
parameter_list|,
name|values
parameter_list|,
name|fndecl
parameter_list|,
name|flags
parameter_list|)
name|tree
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
specifier|const
name|char
modifier|*
name|called_thing
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Argument passing is always copy-initialization.  */
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|called_thing
operator|=
literal|"constructor"
expr_stmt|;
else|else
name|called_thing
operator|=
literal|"member function"
expr_stmt|;
block|}
else|else
name|called_thing
operator|=
literal|"function"
expr_stmt|;
block|}
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"too many arguments to %s `%+#D'"
argument_list|,
name|called_thing
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
comment|/* In case anybody wants to know if this argument 	     list is valid.  */
if|if
condition|(
name|result
condition|)
name|TREE_TYPE
argument_list|(
name|tree_last
argument_list|(
name|result
argument_list|)
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|val
operator|=
name|resolve_offset_ref
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"parameter type of called function is incomplete"
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|parmval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|flags
argument_list|,
literal|"argument passing"
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parmval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|val
operator|=
name|convert_from_reference
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_CONSTANT_P
condition|)
comment|/* Don't do ellipsis conversion for __built_in_constant_p 	       as this will result in spurious warnings for non-POD 	       types.  */
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|convert_arg_to_ellipsis
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|typetail
operator|!=
name|void_list_node
condition|)
block|{
comment|/* See if there are default arguments that can be used */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|typetail
operator|!=
name|void_list_node
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parmval
init|=
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typetail
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|parmval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
comment|/* ends with `...'.  */
if|if
condition|(
name|typetail
operator|==
name|NULL_TREE
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fndecl
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"too few arguments to %s `%+#D'"
argument_list|,
name|called_thing
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_list
return|;
block|}
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a binary-operation expression, after performing default    conversions on the operands.  CODE is the kind of expression to build.  */
end_comment

begin_function
name|tree
name|build_x_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     Note that the operands will never have enumeral types    because either they have just had the default conversions performed    or they have both just been converted to some other type in which    the arithmetic is to be done.     C++: must do special pointer arithmetic when implementing    multiple inheritance, and deal with pointer to member functions.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|orig_op0
parameter_list|,
name|orig_op1
parameter_list|,
name|convert_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|orig_op0
decl_stmt|,
name|orig_op1
decl_stmt|;
name|int
name|convert_p
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means create the expression with this type, rather than      RESULT_TYPE.  */
name|tree
name|build_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      convert it to this type.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
comment|/* Apply default conversions.  */
name|op0
operator|=
name|orig_op0
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|decay_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|decay_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|default_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* DTRT if one side is an overloaded function, but complain about it.  */
if|if
condition|(
name|type_unknown_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|,
name|tf_none
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"assuming cast to type `%T' from overloaded function"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|instantiate_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|,
name|tf_none
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"assuming cast to type `%T' from overloaded function"
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|t
expr_stmt|;
block|}
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|cp_pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|cp_pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|cp_pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"division by zero in `%E / 0'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"division by zero in `%E / 0.'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* When dividing two signed integers, we have to promote to int. 	       unless we divide by a constant != -1.  Note that default 	       conversion will have been performed on the operands at this 	       point, so we have to dig out the original type to find out if 	       it was unsigned.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|code1
operator|==
name|INTEGER_TYPE
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"division by zero in `%E %% 0'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|real_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"division by zero in `%E %% 0.'"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Although it would be tempting to shorten always here, that loses 	     on some targets, since the modulo instruction is undefined if the 	     quotient can't be represented in the computation mode.  We shorten 	     only if unsigned or if dividing by something we know != -1.  */
name|shorten
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|op1
argument_list|)
operator|)
operator|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
name|result_type
operator|=
name|boolean_type_node
expr_stmt|;
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"right shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|"right shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"left shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|"left shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s rotate count is negative"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|warning
argument_list|(
literal|"%s rotate count>= width of type"
argument_list|,
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|)
condition|?
literal|"left"
else|:
literal|"right"
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the shift-count to an integer, regardless of 	     size of value being shifted.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
if|if
condition|(
name|warn_float_equal
operator|&&
operator|(
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|warning
argument_list|(
literal|"comparing floating point with == or != is unsafe"
argument_list|)
expr_stmt|;
name|build_type
operator|=
name|boolean_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|error
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|error
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|op0
operator|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|null_ptr_cst_p
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|cp_build_binary_op
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
block|{
comment|/* E will be the final comparison.  */
name|tree
name|e
decl_stmt|;
comment|/* E1 and E2 are for scratch.  */
name|tree
name|e1
decl_stmt|;
name|tree
name|e2
decl_stmt|;
name|tree
name|pfn0
decl_stmt|;
name|tree
name|pfn1
decl_stmt|;
name|tree
name|delta0
decl_stmt|;
name|tree
name|delta1
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|save_expr
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|save_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* We generate:  	     (op0.pfn == op1.pfn&& (!op0.pfn || op0.delta == op1.delta)) 	      	     The reason for the `!op0.pfn' bit is that a NULL 	     pointer-to-member is any member with a zero PFN; the 	     DELTA field is unspecified.  */
name|pfn0
operator|=
name|pfn_from_ptrmemfunc
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|pfn1
operator|=
name|pfn_from_ptrmemfunc
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|delta0
operator|=
name|build_component_ref
argument_list|(
name|op0
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta1
operator|=
name|build_component_ref
argument_list|(
name|op1
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|delta0
argument_list|,
name|delta1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|pfn0
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|cp_build_binary_op
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|e2
operator|=
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|pfn0
argument_list|,
name|pfn1
argument_list|)
expr_stmt|;
name|e
operator|=
name|cp_build_binary_op
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|e2
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
return|return
name|e
return|;
return|return
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|e
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type0
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|,
name|type1
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|,
name|type0
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|build_type
operator|=
name|boolean_type_node
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
name|result_type
operator|=
name|composite_pointer_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|result_type
operator|=
name|type0
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type0
expr_stmt|;
name|pedwarn
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|type1
expr_stmt|;
name|pedwarn
argument_list|(
literal|"ISO C++ forbids comparison between pointer and integer"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNORDERED_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
name|build_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|code0
operator|!=
name|REAL_TYPE
operator|||
name|code1
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"unordered comparison on non-floating point argument"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|common
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|||
name|code0
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|||
name|code1
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|int
name|none_complex
init|=
operator|(
name|code0
operator|!=
name|COMPLEX_TYPE
operator|&&
name|code1
operator|!=
name|COMPLEX_TYPE
operator|)
decl_stmt|;
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
operator|&&
name|none_complex
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|arg0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|arg1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* We can shorten only if the shift count is less than the 		 number of bits in the smaller type size.  */
operator|&&
name|compare_tree_int
argument_list|(
name|op1
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
operator|(
operator|(
operator|(
name|unsigned
operator|)
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|val
argument_list|)
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|short_compare
operator|||
name|code
operator|==
name|MIN_EXPR
operator|||
name|code
operator|==
name|MAX_EXPR
operator|)
operator|&&
name|warn_sign_compare
condition|)
block|{
name|int
name|op0_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|op1_signed
init|=
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|tree
name|primop0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
decl_stmt|;
name|tree
name|primop1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
decl_stmt|;
comment|/* Check for comparison of different enum types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison between types `%#T' and `%#T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Give warnings for comparisons between signed and unsigned 	     quantities that may fail.  */
comment|/* Do the checking based on the original operand trees, so that 	     casts will be considered, but default promotions won't be.  */
comment|/* Do not warn if the comparison is being done in a signed type, 	     since the signed type will only be chosen if it can represent 	     all the values of the unsigned type.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if both operands are unsigned.  */
elseif|else
if|if
condition|(
name|op0_signed
operator|==
name|op1_signed
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the signed quantity is an unsuffixed 	     integer literal (or some static constant expression 	     involving such literals or a conditional expression 	     involving such literals) and it is non-negative.  */
elseif|else
if|if
condition|(
operator|(
name|op0_signed
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|orig_op0
argument_list|)
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|tree_expr_nonnegative_p
argument_list|(
name|orig_op1
argument_list|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
comment|/* Do not warn if the comparison is an equality operation, 	     the unsigned quantity is an integral constant and it does 	     not use the most significant bit of result_type.  */
elseif|else
if|if
condition|(
operator|(
name|resultcode
operator|==
name|EQ_EXPR
operator|||
name|resultcode
operator|==
name|NE_EXPR
operator|)
operator|&&
operator|(
operator|(
name|op0_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|orig_op1
argument_list|,
name|signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|op1_signed
operator|&&
name|TREE_CODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|orig_op0
argument_list|,
name|signed_type
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|warning
argument_list|(
literal|"comparison between signed and unsigned integer expressions"
argument_list|)
expr_stmt|;
comment|/* Warn if two unsigned values are being compared in a size 	     larger than their original size, and one (and only one) is the 	     result of a `~' operator.  This comparison will always fail.  	     Also warn if one operand is a constant, and the constant does not 	     have all bits set that are set in the ~ operand when it is 	     extended.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
operator|^
operator|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop0
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|primop1
operator|=
name|get_narrower
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
operator|||
name|host_integerp
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|primop
decl_stmt|;
name|HOST_WIDE_INT
name|constant
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|unsigned
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|primop
operator|=
name|primop1
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp1
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|primop
operator|=
name|primop0
expr_stmt|;
name|unsignedp
operator|=
name|unsignedp0
expr_stmt|;
name|constant
operator|=
name|tree_low_cst
argument_list|(
name|primop1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
name|bits
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|unsignedp
condition|)
block|{
name|mask
operator|=
operator|(
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
name|bits
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|constant
operator|)
operator|!=
name|mask
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with constant"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsignedp0
operator|&&
name|unsignedp1
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of promoted ~unsigned with unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|error
argument_list|(
literal|"invalid operands of types `%T' and `%T' to binary `%O'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Issue warnings about peculiar, but legal, uses of NULL.  */
if|if
condition|(
comment|/* It's reasonable to use pointer values as operands of&& 	 and ||, so NULL is no exception.  */
operator|!
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
operator|&&
operator|(
comment|/* If OP0 is NULL and OP1 is not a pointer, or vice versa.  */
operator|(
name|orig_op0
operator|==
name|null_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
comment|/* Or vice versa.  */
operator|||
operator|(
name|orig_op1
operator|==
name|null_node
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
comment|/* Or, both are NULL and the operation was not a comparison.  */
operator|||
operator|(
name|orig_op0
operator|==
name|null_node
operator|&&
name|orig_op1
operator|==
name|null_node
operator|&&
name|code
operator|!=
name|EQ_EXPR
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|)
operator|)
condition|)
comment|/* Some sort of arithmetic operation involving NULL was        performed.  Note that pointer-difference and pointer-addition        have already been handled above, and so we don't end up here in        that case.  */
name|warning
argument_list|(
literal|"NULL used in arithmetic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|error_mark_node
operator|||
name|op1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|build_type
operator|==
name|NULL_TREE
condition|)
name|build_type
operator|=
name|result_type
expr_stmt|;
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|build_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|cp_convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|res_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
comment|/* pointer_int_sum() uses size_in_bytes() on the TREE_TYPE(res_type)      in certain circumstance (when it's valid to do so).  So we need      to make sure it's complete.  We don't need to check here, if we      can actually complete it at all, as those checks will be done in      pointer_int_sum() anyway.  */
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|res_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pointer_int_sum
argument_list|(
name|resultcode
argument_list|,
name|ptrop
argument_list|,
name|fold
argument_list|(
name|intop
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|ptrtype
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|register
name|tree
name|ptrtype
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrtype
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|target_type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer of type `void *' in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer to a function in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer to a method in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids using pointer to a member in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This generates an error if op1 is a pointer to an incomplete type.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of a pointer to an incomplete type in pointer arithmetic"
argument_list|)
expr_stmt|;
name|op1
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|)
condition|?
name|integer_one_node
else|:
name|size_in_bytes
argument_list|(
name|target_type
argument_list|)
operator|)
expr_stmt|;
comment|/* Do the division.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|cp_convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case of taking the address of a COMPONENT_REF.    Called by `build_unary_op'.     ARG is the COMPONENT_REF whose address we want.    ARGTYPE is the pointer type that this address should have. */
end_comment

begin_function
specifier|static
name|tree
name|build_component_addr
parameter_list|(
name|arg
parameter_list|,
name|argtype
parameter_list|)
name|tree
name|arg
decl_stmt|,
name|argtype
decl_stmt|;
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|basetype
init|=
name|decl_type_context
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|981018
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure member `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* Can't convert directly to ARGTYPE, since that 	 may have the same pointer type as one of our 	 baseclasses.  */
name|tree
name|binfo
init|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rval
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|argtype
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This conversion is harmless.  */
name|rval
operator|=
name|convert_force
argument_list|(
name|argtype
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|rval
argument_list|,
name|cp_convert
argument_list|(
name|argtype
argument_list|,
name|byte_position
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  */
end_comment

begin_function
name|tree
name|build_x_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
block|{
name|tree
name|exp
decl_stmt|;
name|int
name|ptrmem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/*& rec, on incomplete RECORD_TYPEs is the simple opr&, not an      error message.  */
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|OFFSET_REF
operator|)
operator|)
condition|)
comment|/* don't look for a function */
empty_stmt|;
else|else
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_new_op
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|xarg
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|||
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|rval
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|ptrmem
operator|=
name|PTRMEM_OK_P
argument_list|(
name|xarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrmem
operator|&&
operator|!
name|flag_ms_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* A single non-static member, make sure we don't allow a                  pointer-to-member.  */
name|xarg
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ovl_cons
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|xarg
argument_list|)
operator|=
name|ptrmem
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|warning
argument_list|(
literal|"taking address of temporary"
argument_list|)
expr_stmt|;
block|}
name|exp
operator|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|xarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|PTRMEM_OK_P
argument_list|(
name|exp
argument_list|)
operator|=
name|ptrmem
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Like truthvalue_conversion, but handle pointer-to-member constants, where    a null value is represented by an INTEGER_CST of -1.  */
end_comment

begin_function
name|tree
name|cp_truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|truthvalue_conversion
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */
end_comment

begin_function
name|tree
name|condition_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|perform_implicit_conversion
argument_list|(
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CLEANUP_POINT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* C++: Must handle pointers to members.     Perhaps type instantiation should be extended to handle conversion    from aggregates to types we don't yet know we want?  (Or are those    cases typically errors which should be reported?)     NOCONVERT nonzero suppresses the default promotions    (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
operator||
name|WANT_POINTER
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary plus"
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary minus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|code
operator|=
name|CONJ_EXPR
expr_stmt|;
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
comment|/* Conjugating a real value is a no-op, but allow it anyway.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_ENUM
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to conjugation"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
name|arg
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|error_mark_node
condition|)
return|return
name|val
return|;
name|errstring
operator|=
literal|"in argument to unary !"
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|REALPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_REALPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|arg
return|;
case|case
name|IMAGPART_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|TREE_IMAGPART
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
else|else
return|return
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Increment or decrement the real part of the value, 	 and don't change the imaginary part.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|real
operator|=
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imag
operator|=
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|real
argument_list|,
literal|1
argument_list|)
argument_list|,
name|imag
argument_list|)
return|;
block|}
comment|/* Report invalid types.  */
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_ARITH
operator||
name|WANT_POINTER
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no post-increment operator for type"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"no pre-decrement operator for type"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"no post-decrement operator for type"
expr_stmt|;
break|break;
block|}
comment|/* Report something read-only.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_error
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* ARM $5.2.5 last annotation says this should be forbidden.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids %sing an enum"
argument_list|,
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|enum
name|tree_code
name|tmp
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|complete_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot %s a pointer to incomplete type `%T'"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|(
name|tmp
operator|==
name|FUNCTION_TYPE
operator|||
name|tmp
operator|==
name|METHOD_TYPE
operator|||
name|tmp
operator|==
name|VOID_TYPE
operator|||
name|tmp
operator|==
name|OFFSET_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids %sing a pointer of type `%T'"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|cp_convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|,
name|compound
decl_stmt|;
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
name|compound
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Eliminate warning about unused result of + or -.  */
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|compound
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|compound
return|;
block|}
default|default:
break|break;
block|}
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Forbid using -- on `bool'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|boolean_type_node
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of `--' on bool variable `%D'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|#
directive|if
literal|0
comment|/* This will only work if someone can convince Kenner to accept 	       my patch to expand_increment. (jason)  */
block|val = build (code, TREE_TYPE (arg), arg, inc);
else|#
directive|else
name|val
operator|=
name|boolean_increment
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
name|argtype
operator|=
name|lvalue_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|DECL_MAIN_P
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* ARM $3.4 */
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking address of function `::main'"
argument_list|)
expr_stmt|;
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* We don't need to have `current_class_ptr' wrapped in a 	     NON_LVALUE_EXPR node.  */
if|if
condition|(
name|arg
operator|==
name|current_class_ref
condition|)
return|return
name|current_class_ptr
return|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvalue_p
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* Don't let this be an lvalue.  */
return|return
name|non_lvalue
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|arg
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Uninstantiated types are all functions.  Taking the 	 address of a function is a no-op, so just return the 	 argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_OPNAME_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
comment|/* We don't know the type yet, so just work around the problem. 	     We know that this will resolve to an lvalue.  */
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|OVL_NEXT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* They're trying to take the address of a unique non-static 	     member function.  This is ill-formed (except in MS-land), 	     but let's try to DTRT. 	     Note: We only handle unique functions here because we don't 	     want to complain if there's a static overload; non-unique 	     cases will be handled by instantiate_type.  But we need to 	     handle this case here to allow casts on the resulting PMF. 	     We could defer this in non-MS mode, but it's easier to give 	     a useful error here.  */
name|tree
name|base
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_ms_extensions
condition|)
block|{
if|if
condition|(
name|current_class_type
operator|&&
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_ref
condition|)
comment|/* An expression like&memfn.  */
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of an unqualified non-static member function to form a pointer to member function.  Say `&%T::%D'"
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of a bound member function to form a pointer to member function.  Say `&%T::%D'"
argument_list|,
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|build_offset_ref
argument_list|(
name|base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|arg
argument_list|)
return|;
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|arg
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of a cast to a non-lvalue expression"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|argtype
operator|!=
name|error_mark_node
condition|)
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|addr
operator|=
name|build_component_addr
argument_list|(
name|arg
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   function counts as a constant */
if|if
condition|(
name|staticp
argument_list|(
name|arg
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argtype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argtype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|build_ptrmemfunc_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build_ptrmemfunc
argument_list|(
name|argtype
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"%s"
argument_list|,
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MIN_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MAX_EXPR
condition|)
return|return
name|rationalize_conditional_expr
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
return|;
comment|/* Handle (a = b), (++a), and (--a) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREINCREMENT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PREDECREMENT_EXPR
condition|)
block|{
name|tree
name|lvalue
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lvalue
argument_list|)
condition|)
block|{
name|lvalue
operator|=
name|stabilize_reference
argument_list|(
name|lvalue
argument_list|)
expr_stmt|;
name|arg
operator|=
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|lvalue
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lvalue
argument_list|)
argument_list|,
name|arg
argument_list|,
name|lvalue
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|!=
name|ADDR_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Handle (a = b) used as an "lvalue" for `&'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|arg
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|arg
argument_list|,
name|real_result
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|arg
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* The representation of something of type OFFSET_TYPE 	 is really the representation of a pointer to it. 	 Here give the representation its true type.  */
name|tree
name|t
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SCOPE_REF
argument_list|,
literal|313
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
return|return
literal|0
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check all this code for right semantics.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"taking address of destructor"
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|is_dummy_object
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|error
argument_list|(
literal|"taking address of bound pointer-to-member expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|PTRMEM_OK_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* This cannot form a pointer to method, so we must 	         resolve the offset ref, and take the address of the 		 result.  For instance,&(C::m)	      */
name|arg
operator|=
name|resolve_offset_ref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot create pointer to reference member `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|build_offset_type
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_ptrmem_cst
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/* We permit compiler to make function calls returning      objects of aggregate type look like lvalues.  */
block|{
name|tree
name|targ
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|targ
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|arg
expr_stmt|;
else|else
name|targ
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|targ
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* Don't let anything else be handled specially.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is 1 if successful.     C++: we do not allow `current_class_ptr' to be addressable.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|x
operator|==
name|current_class_ptr
condition|)
block|{
name|error
argument_list|(
literal|"cannot take the address of `this', which is an rvalue expression"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* so compiler doesn't die later */
return|return
literal|1
return|;
block|}
case|case
name|VAR_DECL
case|:
comment|/* Caller should not be trying to mark initialized 	   constant fields addressable.  */
name|my_friendly_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|||
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|314
argument_list|)
expr_stmt|;
case|case
name|CONST_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"address requested for `%D', which is declared `register'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TARGET_EXPR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_x_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|COND_EXPR
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
return|return
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle overloading of the ',' operator when needed.  Otherwise,    this function just builds an expression list.  */
end_comment

begin_function
name|tree
name|build_x_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|rest
init|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|list
argument_list|,
name|NULL_TREE
argument_list|)
return|;
if|if
condition|(
name|rest
operator|==
name|NULL_TREE
condition|)
return|return
name|build_compound_expr
argument_list|(
name|list
argument_list|)
return|;
name|result
operator|=
name|build_opfncall
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|build_x_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|result
argument_list|,
name|TREE_CHAIN
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
block|{
comment|/* FIXME: This test should be in the implicit cast to void of the LHS. */
comment|/* the left-hand operand of a comma expression is like an expression          statement: we should warn if it doesn't have any side-effects,          unless it was explicitly cast to (void).  */
if|if
condition|(
operator|(
name|extra_warnings
operator|||
name|warn_unused_value
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"left-hand operand of comma expression has no effect"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* this requires a gcc backend patch to export warn_if_unused_value */
block|else if (warn_unused_value)     warn_if_unused_value (TREE_VALUE(list));
endif|#
directive|endif
return|return
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_compound_expr
argument_list|(
name|rest
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
name|tree
name|first
decl_stmt|;
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|decl_constant_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs, since LIST is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|list
operator|=
name|TREE_OPERAND
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
name|first
operator|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|first
operator|=
name|convert_to_void
argument_list|(
name|first
argument_list|,
literal|"left-hand operand of comma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rest
operator|=
name|build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* When pedantic, a compound expression cannot be a constant expression.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|first
argument_list|)
operator|&&
operator|!
name|pedantic
condition|)
return|return
name|rest
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|first
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_static_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|intype
decl_stmt|;
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|STATIC_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|expr
operator|=
name|convert_to_void
argument_list|(
name|expr
argument_list|,
comment|/*implicit=*/
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
operator|(
name|convert_from_reference
argument_list|(
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|CONV_STATIC
operator||
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_cplus_new
argument_list|(
name|type
argument_list|,
operator|(
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
operator|)
argument_list|)
return|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* FIXME handle casting to array type.  */
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
condition|?
name|can_convert_arg
argument_list|(
name|type
argument_list|,
name|intype
argument_list|,
name|expr
argument_list|)
else|:
name|can_convert_arg
argument_list|(
name|strip_all_pointer_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|strip_all_pointer_quals
argument_list|(
name|intype
argument_list|)
argument_list|,
name|expr
argument_list|)
condition|)
comment|/* This is a standard conversion. */
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PTROB_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROB_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
comment|/* They're pointers to objects. They must be aggregates that          are related non-virtually. */
name|base_kind
name|kind
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
operator|&
name|kind
argument_list|)
operator|&&
name|kind
operator|!=
name|bk_via_virtual
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
comment|/* They're pointers to members. The pointed to objects must be 	 the same (ignoring CV qualifiers), and the containing classes 	 must be related non-virtually. */
name|base_kind
name|kind
decl_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|strip_all_pointer_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|strip_all_pointer_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|lookup_base
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|ba_ignore
operator||
name|ba_quiet
argument_list|,
operator|&
name|kind
argument_list|)
operator|)
operator|&&
name|kind
operator|!=
name|bk_via_virtual
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|can_convert
argument_list|(
name|intype
argument_list|,
name|strip_all_pointer_quals
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* DR 128: "A value of integral _or enumeration_ type can be explicitly        converted to an enumeration type."        The integral to enumeration will be accepted by the previous clause.        We need to explicitly check for enumeration to enumeration.  */
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* [expr.static.cast]       The static_cast operator shall not be used to cast away      constness.  */
if|if
condition|(
name|ok
operator|&&
name|casts_away_constness
argument_list|(
name|intype
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"static_cast from type `%T' to type `%T' casts away constness"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|ok
condition|)
return|return
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|error
argument_list|(
literal|"invalid static_cast from type `%T' to type `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|tree
name|build_reinterpret_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|intype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|REINTERPRET_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid reinterpret_cast of an rvalue expression of type `%T' to type `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|build_reinterpret_cast
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
elseif|else
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|intype
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PTR_P
argument_list|(
name|intype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"reinterpret_cast from `%T' to `%T' loses precision"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRFN_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|comp_ptr_ttypes_reinterpret
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"reinterpret_cast from `%T' to `%T' casts away const (or volatile)"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|intype
argument_list|)
operator|)
operator|||
operator|(
name|TYPE_PTRFN_P
argument_list|(
name|intype
argument_list|)
operator|&&
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids casting between pointer-to-function and pointer-to-object"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"invalid reinterpret_cast from type `%T' to type `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_const_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|intype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|expr
operator|=
name|resolve_offset_ref
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CONST_CAST_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of const_cast with type `%T', which is not a pointer, reference, nor a pointer-to-data-member type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of const_cast with type `%T', which is a pointer or reference to a function type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue. 	 Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|intype
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid const_cast of an rvalue of type `%T' to type `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|comp_ptr_ttypes_const
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|intype
argument_list|)
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|comp_ptr_ttypes_const
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
condition|)
return|return
name|cp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|error
argument_list|(
literal|"invalid const_cast from type `%T' to type `%T'"
argument_list|,
name|intype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.     ALLOW_NONCONVERTING is true if we should allow non-converting constructors    when doing the cast.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
name|tree
name|otype
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|t
init|=
name|build_min
argument_list|(
name|CAST_EXPR
argument_list|,
name|type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|value
operator|=
name|resolve_offset_ref
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Allow casting from T1* to T2[] because Cfront allows it. 	 NIHCL uses it. It is not valid ISO C++ however.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids casting to an array type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ISO C++ forbids casting to an array type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid cast to function type `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
comment|/* Conversion to void does not cause any of the normal function to        * pointer, array to pointer and lvalue to rvalue decays.  */
name|value
operator|=
name|convert_to_void
argument_list|(
name|value
argument_list|,
comment|/*implicit=*/
name|NULL
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* Convert functions and arrays to pointers and      convert references to their expanded types,      but don't convert any other types.  If, however, we are      casting to a class type, there's no reason to do this: the      cast will only succeed if there is a converting constructor,      and the default conversions will be done at that point.  In      fact, doing the default conversion here is actually harmful      in cases like this:       typedef int A[2];      struct S { S(const A&); };       since we don't want the array-to-pointer conversion done.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
comment|/* Don't do the default conversion on a ->* expression.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|bound_pmf_p
argument_list|(
name|value
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/* However, even for class types, we still need to strip away        the reference type, since the call to convert_force below        does not expect the input expression to be of reference        type.  */
name|value
operator|=
name|convert_from_reference
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast from `%T' to `%T' discards qualifiers from pointer target type"
argument_list|,
name|otype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast from pointer to integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
comment|/* Don't warn about converting any constant.  */
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast to pointer from integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|value
operator|=
operator|(
name|convert_from_reference
argument_list|(
name|convert_to_reference
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|CONV_C_CAST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|tree
name|ovalue
decl_stmt|;
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ovalue
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|convert_force
argument_list|(
name|type
argument_list|,
name|value
argument_list|,
name|CONV_C_CAST
argument_list|)
expr_stmt|;
comment|/* Ignore any integer overflow caused by the cast.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|ovalue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Warn about possible alignment problems.  Do this here when we will have      instantiated any necessary template types.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast from `%T' to `%T' increases required alignment of target type"
argument_list|,
name|otype
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Always produce some operator for an explicit cast,        so we can tell (for -pedantic) that the cast is no lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|&&
name|value
operator|==
name|expr
operator|&&
name|real_lvalue_p
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|non_lvalue
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.     C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
init|=
name|rhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
name|tree
name|olhs
init|=
name|lhs
decl_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
operator|||
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle --foo = 5; as these are valid constructs in C++ */
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|lhs
operator|=
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newrhs
argument_list|)
return|;
case|case
name|MODIFY_EXPR
case|:
name|newrhs
operator|=
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
decl_stmt|;
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Check this here to avoid odd errors when trying to convert 	   a throw to the type of the COND_EXPR.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|cond
operator|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|error_mark_node
condition|)
return|return
name|cond
return|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* Cast to void to suppress warning 			 from warn_if_unused_value.  */
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
case|case
name|OFFSET_REF
case|:
name|lhs
operator|=
name|resolve_offset_ref
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
argument_list|,
literal|20011220
argument_list|)
expr_stmt|;
name|result
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
comment|/* Do the default thing */
empty_stmt|;
else|else
block|{
name|result
operator|=
name|build_method_call
argument_list|(
name|lhs
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|lhs
operator|=
name|convert_from_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|olhstype
operator|=
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
block|}
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|modifycode
operator|==
name|NOP_EXPR
condition|)
block|{
comment|/* `operator=' is not an inheritable operator.  */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|)
condition|)
comment|/* Do the default thing */
empty_stmt|;
else|else
block|{
name|result
operator|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
return|return
name|result
return|;
block|}
name|lhstype
operator|=
name|olhstype
expr_stmt|;
block|}
else|else
block|{
comment|/* A binary op has been requested.  Combine the old LHS      	     value with the RHS producing the value we should actually      	     store into the LHS.  */
name|my_friendly_assert
argument_list|(
operator|!
name|PROMOTES_TO_AGGR_TYPE
argument_list|(
name|lhstype
argument_list|,
name|REFERENCE_TYPE
argument_list|)
argument_list|,
literal|978652
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|cp_build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"  in evaluation of `%Q(%#T, %#T)'"
argument_list|,
name|modifycode
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Now it looks like a plain assignment.  */
name|modifycode
operator|=
name|NOP_EXPR
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|20011220
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
argument_list|,
literal|20011220
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the cast type of the lhs,      and then true type of the lhs and store it there;      then convert result back to the cast type to be the value      of the assignment.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
comment|/* ISO C++ 5.4/1: The result is an lvalue if T is a reference 	   type, otherwise the result is an rvalue.  */
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|lhs
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids cast to non-reference type used as lvalue"
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|cp_convert
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
return|return
name|result
return|;
return|return
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Warn about modifying something that is `const'.  Don't warn if      this is initialization.  */
if|if
condition|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|lhstype
argument_list|)
comment|/* Functions are not modifiable, even though they are 	     lvalues.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
comment|/* If it's an aggregate and any field is const, then it is 	     effectively const.  */
operator|||
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member, it has probably been      given type `int'.  Compute the type that would go with the actual      amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower 	 than one, we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|newrhs
argument_list|)
condition|)
name|newrhs
operator|=
name|stabilize_reference
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|from_array
decl_stmt|;
if|if
condition|(
operator|!
name|same_or_base_type_p
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|lhstype
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incompatible types in assignment of `%T' to `%T'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhstype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Allow array assignment in compiler-generated code.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids assignment of arrays"
argument_list|)
expr_stmt|;
name|from_array
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
literal|1
operator|+
operator|(
name|modifycode
operator|!=
name|INIT_EXPR
operator|)
else|:
literal|0
expr_stmt|;
return|return
name|build_vec_init
argument_list|(
name|lhs
argument_list|,
name|newrhs
argument_list|,
name|from_array
argument_list|)
return|;
block|}
if|if
condition|(
name|modifycode
operator|==
name|INIT_EXPR
condition|)
name|newrhs
operator|=
name|convert_for_initialization
argument_list|(
name|lhs
argument_list|,
name|lhstype
argument_list|,
name|newrhs
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"initialization"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Avoid warnings on enum bit fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|convert_force
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|lhstype
argument_list|)
condition|)
name|newrhs
operator|=
name|build_cplus_new
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
comment|/* Can't initialize directly from a TARGET_EXPR, since that would 	 cause the lhs to be constructed twice, and possibly result in 	 accidental self-initialization.  So we force the TARGET_EXPR to be 	 expanded without a target.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|newrhs
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|,
name|newrhs
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newrhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|tree
name|lhs1
decl_stmt|;
name|tree
name|cond
init|=
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|cond
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|lhs
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cannot have two identical lhs on this one tree (result) as preexpand 	 calls will rip them out and fill in RTL for them, but when the 	 rtl is generated, the calls will only be in the first side of the 	 condition, not on both, or before the conditional jump! (mrs) */
name|lhs1
operator|=
name|break_out_calls
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|lhs1
condition|)
comment|/* If there's no change, the COND_EXPR behaves like any other rhs.  */
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
decl_stmt|;
comment|/* We have to convert each arm to the proper type because the 	     types may have been munged by constant folding.  */
name|result
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|cond
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|lhs1
argument_list|,
name|modifycode
argument_list|,
name|cp_convert
argument_list|(
name|result_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|newrhs
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|result
operator|=
name|build
argument_list|(
name|modifycode
operator|==
name|NOP_EXPR
condition|?
name|MODIFY_EXPR
else|:
name|INIT_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
comment|/* Avoid warnings converting integral types back into enums      for enum bit fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|olhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|result
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|olhstype
argument_list|,
name|result
argument_list|,
name|olhs
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_x_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min_nt
argument_list|(
name|MODOP_EXPR
argument_list|,
name|lhs
argument_list|,
name|build_min_nt
argument_list|(
name|modifycode
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|tree
name|rval
init|=
name|build_opfncall
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|make_node
argument_list|(
name|modifycode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
return|return
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get difference in deltas for different pointer to member function    types.  Return integer_zero_node, if FROM cannot be converted to a    TO type.  If FORCE is true, then allow reverse conversions as well.     Note that the naming of FROM and TO is kind of backwards; the return    value is what we add to a TO in order to get a FROM.  They are named    this way because we call this function to find out how to convert from    a pointer to member of FROM to a pointer to member of TO.  */
end_comment

begin_function
specifier|static
name|tree
name|get_delta_difference
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|force
parameter_list|)
name|tree
name|from
decl_stmt|,
name|to
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|tree
name|delta
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|virt_binfo
decl_stmt|;
name|base_kind
name|kind
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|ba_check
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|bk_inaccessible
operator|||
name|kind
operator|==
name|bk_ambig
condition|)
block|{
name|error
argument_list|(
literal|"   in pointer to member function conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
if|if
condition|(
operator|!
name|binfo
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|error_not_base_type
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"   in pointer to member conversion"
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
name|binfo
operator|=
name|lookup_base
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|ba_check
argument_list|,
operator|&
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
return|return
name|delta
return|;
name|virt_binfo
operator|=
name|binfo_from_vbase
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|virt_binfo
condition|)
block|{
comment|/* This is a reinterpret cast, we choose to do nothing. */
name|warning
argument_list|(
literal|"pointer to member cast via virtual base `%T' of `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virt_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|virt_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
name|delta
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
name|virt_binfo
operator|=
name|binfo_from_vbase
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|virt_binfo
condition|)
block|{
comment|/* This is a reinterpret cast, we choose to do nothing. */
if|if
condition|(
name|force
condition|)
name|warning
argument_list|(
literal|"pointer to member cast via virtual base `%T' of `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virt_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|virt_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"pointer to member conversion via virtual base `%T' of `%T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|virt_binfo
argument_list|)
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|virt_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
name|delta
operator|=
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a constructor for the pointer-to-member-function TYPE using    the other components as specified.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc1
parameter_list|(
name|type
parameter_list|,
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|type
decl_stmt|,
name|delta
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|u
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|delta_field
decl_stmt|;
name|tree
name|pfn_field
decl_stmt|;
comment|/* Pull the FIELD_DECLs out of the type.  */
name|pfn_field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|delta_field
operator|=
name|TREE_CHAIN
argument_list|(
name|pfn_field
argument_list|)
expr_stmt|;
comment|/* Make sure DELTA has the type we want.  */
name|delta
operator|=
name|convert_and_check
argument_list|(
name|delta_type_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* Finish creating the initializer.  */
name|u
operator|=
name|tree_cons
argument_list|(
name|pfn_field
argument_list|,
name|pfn
argument_list|,
name|build_tree_list
argument_list|(
name|delta_field
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|u
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|pfn
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|u
argument_list|)
operator|=
operator|(
name|TREE_CONSTANT
argument_list|(
name|u
argument_list|)
operator|&&
operator|(
name|initializer_constant_valid_p
argument_list|(
name|pfn
argument_list|,
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|initializer_constant_valid_p
argument_list|(
name|delta
argument_list|,
name|TREE_TYPE
argument_list|(
name|delta
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
operator|)
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

begin_comment
comment|/* Build a constructor for a pointer to member function.  It can be    used to initialize global variables, local variable, or used    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we    want to be.     If FORCE is non-zero, then force this conversion, even if    we would rather not do it.  Usually set when using an explicit    cast.     Return error_mark_node, if something goes wrong.  */
end_comment

begin_function
name|tree
name|build_ptrmemfunc
parameter_list|(
name|type
parameter_list|,
name|pfn
parameter_list|,
name|force
parameter_list|)
name|tree
name|type
decl_stmt|,
name|pfn
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|pfn_type
init|=
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
decl_stmt|;
name|tree
name|to_type
init|=
name|build_ptrmemfunc_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Handle multiple conversions of pointer to member functions.  */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|delta
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|npfn
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|can_convert_arg
argument_list|(
name|to_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|pfn
argument_list|)
argument_list|,
name|pfn
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid conversion to type `%T' from type `%T'"
argument_list|,
name|to_type
argument_list|,
name|pfn_type
argument_list|)
expr_stmt|;
name|n
operator|=
name|get_delta_difference
argument_list|(
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|pfn_type
argument_list|)
argument_list|,
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|to_type
argument_list|)
argument_list|,
name|force
argument_list|)
expr_stmt|;
comment|/* We don't have to do any conversion to convert a 	 pointer-to-member to its own type.  But, we don't want to 	 just return a PTRMEM_CST if there's an explicit cast; that 	 cast should make the expression an invalid template argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|!=
name|PTRMEM_CST
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|to_type
argument_list|,
name|pfn_type
argument_list|)
condition|)
return|return
name|pfn
return|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|build_reinterpret_cast
argument_list|(
name|to_type
argument_list|,
name|pfn
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|pfn
argument_list|)
condition|)
name|pfn
operator|=
name|save_expr
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
comment|/* Obtain the function pointer and the current DELTA.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pfn
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
name|expand_ptrmemfunc_cst
argument_list|(
name|pfn
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|npfn
argument_list|)
expr_stmt|;
else|else
block|{
name|npfn
operator|=
name|build_component_ref
argument_list|(
name|pfn
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delta
operator|=
name|build_component_ref
argument_list|(
name|pfn
argument_list|,
name|delta_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Just adjust the DELTA field.  */
name|delta
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
operator|==
name|ptrmemfunc_vbit_in_delta
condition|)
name|n
operator|=
name|cp_build_binary_op
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|n
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|delta
operator|=
name|cp_build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|delta
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc1
argument_list|(
name|to_type
argument_list|,
name|delta
argument_list|,
name|npfn
argument_list|)
return|;
block|}
comment|/* Handle null pointer to member function conversions.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|pfn
argument_list|)
condition|)
block|{
name|pfn
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
return|return
name|build_ptrmemfunc1
argument_list|(
name|to_type
argument_list|,
name|integer_zero_node
argument_list|,
name|pfn
argument_list|)
return|;
block|}
if|if
condition|(
name|type_unknown_p
argument_list|(
name|pfn
argument_list|)
condition|)
return|return
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|pfn
argument_list|,
name|tf_error
operator||
name|tf_warning
argument_list|)
return|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|make_ptrmem_cst
argument_list|(
name|to_type
argument_list|,
name|fn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST    given by CST.     ??? There is no consistency as to the types returned for the above    values.  Some code acts as if its a sizetype and some as if its    integer_type_node.  */
end_comment

begin_function
name|void
name|expand_ptrmemfunc_cst
parameter_list|(
name|cst
parameter_list|,
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|cst
decl_stmt|;
name|tree
modifier|*
name|delta
decl_stmt|;
name|tree
modifier|*
name|pfn
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|PTRMEM_CST_MEMBER
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|tree
name|ptr_class
decl_stmt|,
name|fn_class
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The class that the function belongs to.  */
name|fn_class
operator|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* The class that we're creating a pointer to member of.  */
name|ptr_class
operator|=
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* First, calculate the adjustment to the function's class.  */
operator|*
name|delta
operator|=
name|get_delta_difference
argument_list|(
name|fn_class
argument_list|,
name|ptr_class
argument_list|,
comment|/*force=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
operator|*
name|pfn
operator|=
name|convert
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_addr_func
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we're dealing with a virtual function, we have to adjust 'this'          again, to point to the base which provides the vtable entry for          fn; the call will do the opposite adjustment.  */
name|tree
name|orig_class
init|=
name|DECL_VIRTUAL_CONTEXT
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|binfo_or_else
argument_list|(
name|orig_class
argument_list|,
name|fn_class
argument_list|)
decl_stmt|;
operator|*
name|delta
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|delta
argument_list|)
argument_list|,
operator|*
name|delta
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We set PFN to the vtable offset at which the function can be 	 found, plus one (unless ptrmemfunc_vbit_in_delta, in which 	 case delta is shifted left, and then incremented).  */
operator|*
name|pfn
operator|=
name|DECL_VINDEX
argument_list|(
name|fn
argument_list|)
expr_stmt|;
operator|*
name|pfn
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|pfn
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TARGET_PTRMEMFUNC_VBIT_LOCATION
condition|)
block|{
case|case
name|ptrmemfunc_vbit_in_pfn
case|:
operator|*
name|pfn
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|pfn
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ptrmemfunc_vbit_in_delta
case|:
operator|*
name|delta
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|delta
argument_list|)
argument_list|,
operator|*
name|delta
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|delta
argument_list|)
argument_list|,
operator|*
name|delta
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|pfn
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|*
name|pfn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an expression for PFN from the pointer-to-member function    given by T.  */
end_comment

begin_function
name|tree
name|pfn_from_ptrmemfunc
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PTRMEM_CST
condition|)
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|t
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|pfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
condition|)
return|return
name|pfn
return|;
block|}
return|return
name|build_component_ref
argument_list|(
name|t
argument_list|,
name|pfn_identifier
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expression EXPR is about to be implicitly converted to TYPE.  Warn    if this is a potentially dangerous thing to do.  Returns a possibly    marked EXPR.  */
end_comment

begin_function
name|tree
name|dubious_conversion_warnings
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Issue warnings about peculiar, but legal, uses of NULL.  */
if|if
condition|(
name|ARITHMETIC_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|expr
operator|==
name|null_node
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|warning
argument_list|(
literal|"passing NULL used for non-pointer %s %P of `%D'"
argument_list|,
name|errtype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%s to non-pointer type `%T' from NULL"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about assigning a floating-point type to an integer type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|warning
argument_list|(
literal|"passing `%T' for %s %P of `%D'"
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|errtype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%s to `%T' from `%T'"
argument_list|,
name|errtype
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And warn about assigning a negative value to an unsigned      variable.  */
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOOLEAN_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_NEGATED_INT
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|fndecl
condition|)
name|warning
argument_list|(
literal|"passing negative value `%E' for %s %P of `%D'"
argument_list|,
name|expr
argument_list|,
name|errtype
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%s of negative value `%E' to `%T'"
argument_list|,
name|errtype
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|overflow_warning
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|fold
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment to    an lvalue of type TYPE.  ERRTYPE is a string to use in error    messages: "assignment", "return", etc.  If FNDECL is non-NULL, we    are doing the conversion in order to pass the PARMNUMth argument of    FNDECL.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
if|if
condition|(
name|codel
operator|==
name|OFFSET_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
operator|||
name|rhstype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rhs
operator|=
name|dubious_conversion_warnings
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
comment|/* The RHS of an assignment cannot have void type.  */
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Simplify the RHS if possible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|rhs
operator|=
name|DECL_INITIAL
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|coder
operator|!=
name|ARRAY_TYPE
condition|)
name|rhs
operator|=
name|decl_constant_value
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* [expr.ass]       The expression is implicitly converted (clause _conv_) to the      cv-unqualified type of the left operand.       We allow bad conversions here because by the time we get to this point      we are committed to doing the conversion.  If we end up doing a bad      conversion, convert_like will complain.  */
if|if
condition|(
operator|!
name|can_convert_arg_bad
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
comment|/* When -Wno-pmf-conversions is use, we just silently allow 	 conversions from pointers-to-members to plain pointers.  If 	 the conversion doesn't work, cp_convert will complain.  */
if|if
condition|(
operator|!
name|warn_pmf2ptr
operator|&&
name|TYPE_PTR_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|rhstype
argument_list|)
condition|)
name|rhs
operator|=
name|cp_convert
argument_list|(
name|strip_top_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If the right-hand side has unknown type, then it is an 	     overloaded function.  Call instantiate_type to get error 	     messages.  */
if|if
condition|(
name|rhstype
operator|==
name|unknown_type_node
condition|)
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|tf_error
operator||
name|tf_warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fndecl
condition|)
name|error
argument_list|(
literal|"cannot convert `%T' to `%T' for argument `%P' to `%D'"
argument_list|,
name|rhstype
argument_list|,
name|type
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot convert `%T' to `%T' in %s"
argument_list|,
name|rhstype
argument_list|,
name|type
argument_list|,
name|errtype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|perform_implicit_conversion
argument_list|(
name|strip_top_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert RHS to be of type TYPE.    If EXP is non-zero, it is the target of the initialization.    ERRTYPE is a string to use in error messages.     Two major differences between the behavior of    `convert_for_assignment' and `convert_for_initialization'    are that references are bashed in the former, while    copied in the latter, and aggregates are assigned in    the former (operator=) while initialized in the    latter (X(X&)).     If using constructor make sure no conversion operator exists, if one does    exist, an ambiguity exists.     If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */
end_comment

begin_function
name|tree
name|convert_for_initialization
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|,
name|rhs
parameter_list|,
name|flags
parameter_list|,
name|errtype
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|codel
operator|!=
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|rhs
operator|=
name|resolve_offset_ref
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhs
operator|=
name|convert_from_reference
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* We accept references to incomplete types, so we can      return here before checking if RHS is of complete type.  */
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* This should eventually happen in convert_arguments.  */
name|int
name|savew
init|=
literal|0
decl_stmt|,
name|savee
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fndecl
condition|)
name|savew
operator|=
name|warningcount
operator|,
name|savee
operator|=
name|errorcount
expr_stmt|;
name|rhs
operator|=
name|initialize_reference
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|warningcount
operator|>
name|savew
condition|)
name|cp_warning_at
argument_list|(
literal|"in passing argument %P of `%+D'"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
name|savee
condition|)
name|cp_error_at
argument_list|(
literal|"in passing argument %P of `%+D'"
argument_list|,
name|parmnum
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|rhs
return|;
block|}
if|if
condition|(
name|exp
operator|!=
literal|0
condition|)
name|exp
operator|=
name|require_complete_type
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|flags
argument_list|)
return|;
return|return
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.     We don't do default conversions on all inputs, because it can screw    up operands that are expected to be in memory.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
comment|/* Restore the original value so that it's correct the next 	     time we expand this function.  */
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|o
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If RETVAL is the address of, or a reference to, a local variable or    temporary give an appropraite warning.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_warn_about_returning_address_of_local
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|whats_returned
init|=
name|retval
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return;
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|AGGR_INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
comment|/* Get the target.  */
name|whats_returned
operator|=
name|TREE_OPERAND
argument_list|(
name|whats_returned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"returning reference to temporary"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|TEMP_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"reference to non-lvalue returned"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|whats_returned
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|whats_returned
argument_list|)
operator|&&
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|whats_returned
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|whats_returned
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|whats_returned
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|cp_warning_at
argument_list|(
literal|"reference to local variable `%D' returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
else|else
name|cp_warning_at
argument_list|(
literal|"address of local variable `%D' returned"
argument_list|,
name|whats_returned
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Check that returning RETVAL from the current function is legal.    Return an expression explicitly showing all conversions required to    change RETVAL into the function return type, and to assign it to    the DECL_RESULT for the function.  */
end_comment

begin_function
name|tree
name|check_return_expr
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
comment|/* The type actually returned by the function, after any      promotions.  */
name|tree
name|valtype
decl_stmt|;
name|int
name|fn_returns_value_p
decl_stmt|;
comment|/* A `volatile' function is one that isn't supposed to return, ever.      (This is a G++ extension, used to get better code for functions      that call the `volatile' function.)  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `noreturn' has a `return' statement"
argument_list|)
expr_stmt|;
comment|/* Check for various simple errors.  */
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|retval
condition|)
name|error
argument_list|(
literal|"returning a value from a destructor"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|in_function_try_handler
condition|)
comment|/* If a return statement appears in a handler of the 	   function-try-block of a constructor, the program is ill-formed. */
name|error
argument_list|(
literal|"cannot return from a handler of a function-try-block of a constructor"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
condition|)
comment|/* You can't return a value from a constructor.  */
name|error
argument_list|(
literal|"returning a value from a constructor"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* When no explicit return-value is given in a function with a named      return value, the named return value is used.  */
name|result
operator|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|valtype
operator|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|valtype
operator|!=
name|NULL_TREE
argument_list|,
literal|19990924
argument_list|)
expr_stmt|;
name|fn_returns_value_p
operator|=
operator|!
name|VOID_TYPE_P
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
operator|&&
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|&&
name|fn_returns_value_p
condition|)
name|retval
operator|=
name|result
expr_stmt|;
comment|/* Check for a return statement with no return value in a function      that's supposed to return a value.  */
if|if
condition|(
operator|!
name|retval
operator|&&
name|fn_returns_value_p
condition|)
block|{
name|pedwarn
argument_list|(
literal|"return-statement with no value, in function declared with a non-void return type"
argument_list|)
expr_stmt|;
comment|/* Clear this, so finish_function won't say that we reach the 	 end of a non-void function (which we don't, we gave a 	 return!).  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check for a return statement with a value in a function that      isn't supposed to return a value.  */
elseif|else
if|if
condition|(
name|retval
operator|&&
operator|!
name|fn_returns_value_p
condition|)
block|{
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
condition|)
comment|/* You can return a `void' value from a function of `void' 	   type.  In that case, we have to evaluate the expression for 	   its side-effects.  */
name|finish_expr_stmt
argument_list|(
name|retval
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"return-statement with a value, in function declared with a void return type"
argument_list|)
expr_stmt|;
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
comment|/* There's really no value to return, after all.  */
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
comment|/* Remember that this function can sometimes return without a        value.  */
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Remember that this function did return a value.  */
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
comment|/* Only operator new(...) throw(), can return NULL [expr.new/13].  */
if|if
condition|(
operator|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NEW_EXPR
operator|||
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|VEC_NEW_EXPR
operator|)
operator|&&
operator|!
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_check_new
operator|&&
name|null_ptr_cst_p
argument_list|(
name|retval
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`operator new' must not return NULL unless it is declared `throw()' (or -fcheck-new is in effect)"
argument_list|)
expr_stmt|;
comment|/* Effective C++ rule 15.  See also start_function.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
operator|&&
name|retval
operator|!=
name|current_class_ref
condition|)
name|warning
argument_list|(
literal|"`operator=' should return a reference to `*this'"
argument_list|)
expr_stmt|;
comment|/* The fabled Named Return Value optimization, as per [class.copy]/15:       [...]      For  a function with a class return type, if the expression      in the return statement is the name of a local  object,  and  the  cv-      unqualified  type  of  the  local  object  is the same as the function      return type, an implementation is permitted to omit creating the  tem-      porary  object  to  hold  the function return value [...]       So, if this is a value-returning function that always returns the same      local variable, remember it.       It might be nice to be more flexible, and choose the first suitable      variable even if the function sometimes returns something else, but      then we run the risk of clobbering the variable we chose if the other      returned expression uses the chosen variable somehow.  And people expect      this restriction, anyway.  (jason 2000-11-19)       See finish_function, genrtl_start_function, and declare_return_variable      for other pieces of this optimization.  */
if|if
condition|(
name|fn_returns_value_p
operator|&&
name|flag_elide_constructors
condition|)
block|{
if|if
condition|(
name|retval
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|current_function_return_value
operator|==
name|NULL_TREE
operator|||
name|current_function_return_value
operator|==
name|retval
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|retval
argument_list|)
operator|==
name|current_function_decl
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|retval
argument_list|)
operator|&&
operator|(
name|DECL_ALIGN
argument_list|(
name|retval
argument_list|)
operator|>=
name|DECL_ALIGN
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
operator|&&
name|same_type_p
argument_list|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|)
argument_list|,
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|)
condition|)
name|current_function_return_value
operator|=
name|retval
expr_stmt|;
else|else
name|current_function_return_value
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* We don't need to do any conversions when there's nothing being      returned.  */
if|if
condition|(
operator|!
name|retval
operator|||
name|retval
operator|==
name|error_mark_node
condition|)
return|return
name|retval
return|;
comment|/* Do any required conversions.  */
if|if
condition|(
name|retval
operator|==
name|result
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* No conversions are required.  */
empty_stmt|;
else|else
block|{
comment|/* The type the function is declared to return.  */
name|tree
name|functype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* First convert the value to the function's return type, then 	 to the type of return value's location to handle the          case that functype is smaller than the valtype. */
name|retval
operator|=
name|convert_for_initialization
argument_list|(
name|NULL_TREE
argument_list|,
name|functype
argument_list|,
name|retval
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|,
literal|"return"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|convert
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* If the conversion failed, treat this just like `return;'.  */
if|if
condition|(
name|retval
operator|==
name|error_mark_node
condition|)
return|return
name|retval
return|;
comment|/* We can't initialize a register from a AGGR_INIT_EXPR.  */
elseif|else
if|if
condition|(
operator|!
name|current_function_returns_struct
operator|&&
name|TREE_CODE
argument_list|(
name|retval
argument_list|)
operator|==
name|TARGET_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
name|retval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|,
name|retval
argument_list|,
name|TREE_OPERAND
argument_list|(
name|retval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|maybe_warn_about_returning_address_of_local
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
comment|/* Actually copy the value returned into the appropriate location.  */
if|if
condition|(
name|retval
operator|&&
name|retval
operator|!=
name|result
condition|)
name|retval
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns non-zero if the pointer-type FROM can be converted to the    pointer-type TO via a qualification conversion.  If CONSTP is -1,    then we return non-zero if the pointers are similar, and the    cv-qualification signature of FROM is a proper subset of that of TO.     If CONSTP is positive, then all outer pointers have been    const-qualified.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_real
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|constp
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
name|int
name|constp
decl_stmt|;
block|{
name|int
name|to_more_cv_qualified
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|same_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|constp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
operator|++
name|to_more_cv_qualified
expr_stmt|;
block|}
if|if
condition|(
name|constp
operator|>
literal|0
condition|)
name|constp
operator|&=
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|&&
operator|(
name|constp
operator|>=
literal|0
operator|||
name|to_more_cv_qualified
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* When comparing, say, char ** to char const **, this function takes the    'char *' and 'char const *'.  Do not pass non-pointer types to this    function.  */
end_comment

begin_function
name|int
name|comp_ptr_ttypes
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
return|return
name|comp_ptr_ttypes_real
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if to and from are (possibly multi-level) pointers to the same    type or inheritance-related types, regardless of cv-quals.  */
end_comment

begin_function
name|int
name|ptr_reasonably_similar
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
comment|/* Any target type is similar enough to void.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|comptypes
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_RELAXED
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|to
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|to
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|from
argument_list|)
argument_list|,
name|COMPARE_BASE
operator||
name|COMPARE_RELAXED
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like comp_ptr_ttypes, for const_cast.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_const
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
operator|&&
name|same_type_p
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like comp_ptr_ttypes, for reinterpret_cast.  */
end_comment

begin_function
specifier|static
name|int
name|comp_ptr_ttypes_reinterpret
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|tree
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
name|int
name|constp
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
operator|,
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|from
operator|=
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|to
operator|=
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Const and volatile mean something different for function types, 	 so the usual checks are not appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|constp
operator|&&
operator|!
name|at_least_as_qualified_p
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
literal|0
return|;
name|constp
operator|&=
name|TYPE_READONLY
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|to
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the type qualifiers for this type, including the qualifiers on the    elements for an array type.  */
end_comment

begin_function
name|int
name|cp_type_quals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the TYPE contains a mutable member */
end_comment

begin_function
name|int
name|cp_has_mutable_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_HAS_MUTABLE
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of casts_away_constness.  Make T1 and T2 point at    exemplar types such that casting T1 to T2 is casting away castness    if and only if there is no implicit conversion from T1 to T2.  */
end_comment

begin_function
specifier|static
name|void
name|casts_away_constness_r
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
modifier|*
name|t1
decl_stmt|;
name|tree
modifier|*
name|t2
decl_stmt|;
block|{
name|int
name|quals1
decl_stmt|;
name|int
name|quals2
decl_stmt|;
comment|/* [expr.const.cast]       For multi-level pointer to members and multi-level mixed pointers      and pointers to members (conv.qual), the "member" aspect of a      pointer to member level is ignored when determining if a const      cv-qualifier has been cast away.  */
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
operator|*
name|t1
argument_list|)
condition|)
operator|*
name|t1
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
operator|*
name|t2
argument_list|)
condition|)
operator|*
name|t2
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|t2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* [expr.const.cast]       For  two  pointer types:              X1 is T1cv1,1 * ... cv1,N *   where T1 is not a pointer type             X2 is T2cv2,1 * ... cv2,M *   where T2 is not a pointer type             K is min(N,M)       casting from X1 to X2 casts away constness if, for a non-pointer      type T there does not exist an implicit conversion (clause      _conv_) from:              Tcv1,(N-K+1) * cv1,(N-K+2) * ... cv1,N *             to              Tcv2,(M-K+1) * cv2,(M-K+2) * ... cv2,M *.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|t1
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|t2
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
operator|*
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|cp_type_quals
argument_list|(
operator|*
name|t1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|cp_build_qualified_type
argument_list|(
name|void_type_node
argument_list|,
name|cp_type_quals
argument_list|(
operator|*
name|t2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|quals1
operator|=
name|cp_type_quals
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
name|quals2
operator|=
name|cp_type_quals
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
operator|*
name|t1
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
name|casts_away_constness_r
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
operator|*
name|t1
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|t1
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|t2
argument_list|)
expr_stmt|;
operator|*
name|t1
operator|=
name|cp_build_qualified_type
argument_list|(
operator|*
name|t1
argument_list|,
name|quals1
argument_list|)
expr_stmt|;
operator|*
name|t2
operator|=
name|cp_build_qualified_type
argument_list|(
operator|*
name|t2
argument_list|,
name|quals2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if casting from TYPE1 to TYPE2 casts away    constness.  */
end_comment

begin_function
specifier|static
name|int
name|casts_away_constness
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|;
name|tree
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [expr.const.cast] 	  	 Casting from an lvalue of type T1 to an lvalue of type T2 	 using a reference cast casts away constness if a cast from an 	 rvalue of type "pointer to T1" to the type "pointer to T2" 	 casts away constness.  */
name|t1
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
else|:
name|t1
operator|)
expr_stmt|;
return|return
name|casts_away_constness
argument_list|(
name|build_pointer_type
argument_list|(
name|t1
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_PTRMEM_P
argument_list|(
name|t2
argument_list|)
condition|)
comment|/* [expr.const.cast]                Casting from an rvalue of type "pointer to data member of X        of type T1" to the type "pointer to data member of Y of type        T2" casts away constness if a cast from an rvalue of type        "pointer to T1" to the type "pointer to T2" casts away        constness.  */
return|return
name|casts_away_constness
argument_list|(
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Casting away constness is only something that makes sense for      pointer or reference types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|0
return|;
comment|/* Top-level qualifiers don't matter.  */
name|t1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|casts_away_constness_r
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_convert
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns TYPE with its cv qualifiers removed    TYPE is T cv* .. *cv where T is not a pointer type,    returns T * .. *. (If T is an array type, then the cv qualifiers    above are those of the array members.)  */
end_comment

begin_function
specifier|static
name|tree
name|strip_all_pointer_quals
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|build_pointer_type
argument_list|(
name|strip_all_pointer_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
return|return
name|build_offset_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|strip_all_pointer_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

end_unit

