begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions for C++ name lookup routines.    Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"name-lookup.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_comment
comment|/* The bindings for a particular name in a particular scope.  */
end_comment

begin_struct
struct|struct
name|scope_binding
block|{
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EMPTY_SCOPE_BINDING
value|{ NULL_TREE, NULL_TREE }
end_define

begin_function_decl
specifier|static
name|cxx_scope
modifier|*
name|innermost_nonclass_level
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cxx_binding
modifier|*
name|binding_for_name
parameter_list|(
name|cxx_scope
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_name_innermost_nonclass_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|push_overloaded_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|lookup_using_namespace
parameter_list|(
name|tree
parameter_list|,
name|struct
name|scope_binding
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|qualified_lookup_using_namespace
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|struct
name|scope_binding
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_type_current_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|push_using_directive
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The :: namespace.  */
end_comment

begin_decl_stmt
name|tree
name|global_namespace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the anonymous namespace, throughout this translation    unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|anonymous_namespace_name
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Initialise anonymous_namespace_name if necessary, and return it.  */
end_comment

begin_function
specifier|static
name|tree
name|get_anonymous_namespace_name
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|anonymous_namespace_name
condition|)
block|{
comment|/* The anonymous namespace has to have a unique name 	 if typeinfo objects are being compared by name.  */
if|if
condition|(
operator|!
name|flag_weak
operator|||
operator|!
name|SUPPORTS_ONE_ONLY
condition|)
name|anonymous_namespace_name
operator|=
name|get_file_function_name
argument_list|(
literal|"N"
argument_list|)
expr_stmt|;
else|else
comment|/* The demangler expects anonymous namespaces to be called 	   something starting with '_GLOBAL__N_'.  */
name|anonymous_namespace_name
operator|=
name|get_identifier
argument_list|(
literal|"_GLOBAL__N_1"
argument_list|)
expr_stmt|;
block|}
return|return
name|anonymous_namespace_name
return|;
block|}
end_function

begin_comment
comment|/* Compute the chain index of a binding_entry given the HASH value of its    name and the total COUNT of chains.  COUNT is assumed to be a power    of 2.  */
end_comment

begin_define
define|#
directive|define
name|ENTRY_INDEX
parameter_list|(
name|HASH
parameter_list|,
name|COUNT
parameter_list|)
value|(((HASH)>> 3)& ((COUNT) - 1))
end_define

begin_comment
comment|/* A free list of "binding_entry"s awaiting for re-use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|binding_entry
name|free_binding_entry
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Create a binding_entry object for (NAME, TYPE).  */
end_comment

begin_function
specifier|static
specifier|inline
name|binding_entry
name|binding_entry_make
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|binding_entry
name|entry
decl_stmt|;
if|if
condition|(
name|free_binding_entry
condition|)
block|{
name|entry
operator|=
name|free_binding_entry
expr_stmt|;
name|free_binding_entry
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
block|}
else|else
name|entry
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|binding_entry_s
argument_list|)
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Put ENTRY back on the free list.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline void binding_entry_free (binding_entry entry) {   entry->name = NULL;   entry->type = NULL;   entry->chain = free_binding_entry;   free_binding_entry = entry; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* The datatype used to implement the mapping from names to types at    a given scope.  */
end_comment

begin_decl_stmt
name|struct
name|binding_table_s
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Array of chains of "binding_entry"s  */
name|binding_entry
modifier|*
name|GTY
argument_list|(
operator|(
name|length
argument_list|(
literal|"%h.chain_count"
argument_list|)
operator|)
argument_list|)
name|chain
decl_stmt|;
comment|/* The number of chains in this table.  This is the length of the      the member "chain" considered as an array.  */
name|size_t
name|chain_count
decl_stmt|;
comment|/* Number of "binding_entry"s in this table.  */
name|size_t
name|entry_count
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Construct TABLE with an initial CHAIN_COUNT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|binding_table_construct
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|size_t
name|chain_count
parameter_list|)
block|{
name|table
operator|->
name|chain_count
operator|=
name|chain_count
expr_stmt|;
name|table
operator|->
name|entry_count
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|chain
operator|=
name|GGC_CNEWVEC
argument_list|(
name|binding_entry
argument_list|,
name|table
operator|->
name|chain_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make TABLE's entries ready for reuse.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void binding_table_free (binding_table table) {   size_t i;   size_t count;    if (table == NULL)     return;    for (i = 0, count = table->chain_count; i< count; ++i)     {       binding_entry temp = table->chain[i];       while (temp != NULL) 	{ 	  binding_entry entry = temp; 	  temp = entry->chain; 	  binding_entry_free (entry); 	}       table->chain[i] = NULL;     }   table->entry_count = 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate a table with CHAIN_COUNT, assumed to be a power of two.  */
end_comment

begin_function
specifier|static
specifier|inline
name|binding_table
name|binding_table_new
parameter_list|(
name|size_t
name|chain_count
parameter_list|)
block|{
name|binding_table
name|table
init|=
name|GGC_NEW
argument_list|(
expr|struct
name|binding_table_s
argument_list|)
decl_stmt|;
name|table
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|binding_table_construct
argument_list|(
name|table
argument_list|,
name|chain_count
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* Expand TABLE to twice its current chain_count.  */
end_comment

begin_function
specifier|static
name|void
name|binding_table_expand
parameter_list|(
name|binding_table
name|table
parameter_list|)
block|{
specifier|const
name|size_t
name|old_chain_count
init|=
name|table
operator|->
name|chain_count
decl_stmt|;
specifier|const
name|size_t
name|old_entry_count
init|=
name|table
operator|->
name|entry_count
decl_stmt|;
specifier|const
name|size_t
name|new_chain_count
init|=
literal|2
operator|*
name|old_chain_count
decl_stmt|;
name|binding_entry
modifier|*
name|old_chains
init|=
name|table
operator|->
name|chain
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|binding_table_construct
argument_list|(
name|table
argument_list|,
name|new_chain_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_chain_count
condition|;
operator|++
name|i
control|)
block|{
name|binding_entry
name|entry
init|=
name|old_chains
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|old_chains
index|[
name|i
index|]
control|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|entry
operator|->
name|name
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|j
init|=
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|new_chain_count
argument_list|)
decl_stmt|;
name|old_chains
index|[
name|i
index|]
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
name|entry
operator|->
name|chain
operator|=
name|table
operator|->
name|chain
index|[
name|j
index|]
expr_stmt|;
name|table
operator|->
name|chain
index|[
name|j
index|]
operator|=
name|entry
expr_stmt|;
block|}
block|}
name|table
operator|->
name|entry_count
operator|=
name|old_entry_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a binding for NAME to TYPE into TABLE.  */
end_comment

begin_function
specifier|static
name|void
name|binding_table_insert
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|i
init|=
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|table
operator|->
name|chain_count
argument_list|)
decl_stmt|;
name|binding_entry
name|entry
init|=
name|binding_entry_make
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|entry
operator|->
name|chain
operator|=
name|table
operator|->
name|chain
index|[
name|i
index|]
expr_stmt|;
name|table
operator|->
name|chain
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
operator|++
name|table
operator|->
name|entry_count
expr_stmt|;
if|if
condition|(
literal|3
operator|*
name|table
operator|->
name|chain_count
operator|<
literal|5
operator|*
name|table
operator|->
name|entry_count
condition|)
name|binding_table_expand
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the binding_entry, if any, that maps NAME.  */
end_comment

begin_function
name|binding_entry
name|binding_table_find
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
name|hash
init|=
name|IDENTIFIER_HASH_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|binding_entry
name|entry
init|=
name|table
operator|->
name|chain
index|[
name|ENTRY_INDEX
argument_list|(
name|hash
argument_list|,
name|table
operator|->
name|chain_count
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|name
operator|!=
name|name
condition|)
name|entry
operator|=
name|entry
operator|->
name|chain
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Apply PROC -- with DATA -- to all entries in TABLE.  */
end_comment

begin_function
name|void
name|binding_table_foreach
parameter_list|(
name|binding_table
name|table
parameter_list|,
name|bt_foreach_proc
name|proc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|size_t
name|chain_count
init|=
name|table
operator|->
name|chain_count
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chain_count
condition|;
operator|++
name|i
control|)
block|{
name|binding_entry
name|entry
init|=
name|table
operator|->
name|chain
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|chain
control|)
name|proc
argument_list|(
name|entry
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|ENABLE_SCOPE_CHECKING
end_ifndef

begin_define
define|#
directive|define
name|ENABLE_SCOPE_CHECKING
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENABLE_SCOPE_CHECKING
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A free list of "cxx_binding"s, connected by their PREVIOUS.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
name|cxx_binding
operator|*
name|free_bindings
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Initialize VALUE and TYPE field for BINDING, and set the PREVIOUS    field to NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cxx_binding_init
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|binding
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|binding
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|binding
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* (GC)-allocate a binding object with VALUE and TYPE member initialized.  */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|cxx_binding_make
parameter_list|(
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|free_bindings
condition|)
block|{
name|binding
operator|=
name|free_bindings
expr_stmt|;
name|free_bindings
operator|=
name|binding
operator|->
name|previous
expr_stmt|;
block|}
else|else
name|binding
operator|=
name|GGC_NEW
argument_list|(
name|cxx_binding
argument_list|)
expr_stmt|;
name|cxx_binding_init
argument_list|(
name|binding
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|binding
return|;
block|}
end_function

begin_comment
comment|/* Put BINDING back on the free list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|cxx_binding_free
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|)
block|{
name|binding
operator|->
name|scope
operator|=
name|NULL
expr_stmt|;
name|binding
operator|->
name|previous
operator|=
name|free_bindings
expr_stmt|;
name|free_bindings
operator|=
name|binding
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new binding for NAME (with the indicated VALUE and TYPE    bindings) in the class scope indicated by SCOPE.  */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|new_class_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|type
parameter_list|,
name|cxx_scope
modifier|*
name|scope
parameter_list|)
block|{
name|cp_class_binding
modifier|*
name|cb
decl_stmt|;
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|cp_class_binding
argument_list|,
name|scope
operator|->
name|class_shadowed
argument_list|)
condition|)
block|{
name|cp_class_binding
modifier|*
name|old_base
decl_stmt|;
name|old_base
operator|=
name|VEC_index
argument_list|(
name|cp_class_binding
argument_list|,
name|scope
operator|->
name|class_shadowed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_reserve
argument_list|(
name|cp_class_binding
argument_list|,
name|gc
argument_list|,
name|scope
operator|->
name|class_shadowed
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Fixup the current bindings, as they might have moved.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cp_class_binding
argument_list|,
name|scope
operator|->
name|class_shadowed
argument_list|,
name|i
argument_list|,
name|cb
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cxx_binding
modifier|*
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|&
name|IDENTIFIER_BINDING
argument_list|(
name|cb
operator|->
name|identifier
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|b
operator|!=
operator|&
name|old_base
index|[
name|i
index|]
operator|.
name|base
condition|)
name|b
operator|=
operator|&
operator|(
operator|(
operator|*
name|b
operator|)
operator|->
name|previous
operator|)
expr_stmt|;
operator|*
name|b
operator|=
operator|&
name|cb
operator|->
name|base
expr_stmt|;
block|}
block|}
name|cb
operator|=
name|VEC_quick_push
argument_list|(
name|cp_class_binding
argument_list|,
name|scope
operator|->
name|class_shadowed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|cb
operator|=
name|VEC_safe_push
argument_list|(
name|cp_class_binding
argument_list|,
name|gc
argument_list|,
name|scope
operator|->
name|class_shadowed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|identifier
operator|=
name|name
expr_stmt|;
name|binding
operator|=
operator|&
name|cb
operator|->
name|base
expr_stmt|;
name|binding
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
name|cxx_binding_init
argument_list|(
name|binding
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|binding
return|;
block|}
end_function

begin_comment
comment|/* Make DECL the innermost binding for ID.  The LEVEL is the binding    level at which this declaration is being bound.  */
end_comment

begin_function
specifier|static
name|void
name|push_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|cxx_scope
modifier|*
name|level
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|level
operator|!=
name|class_binding_level
condition|)
block|{
name|binding
operator|=
name|cxx_binding_make
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|binding
operator|->
name|scope
operator|=
name|level
expr_stmt|;
block|}
else|else
name|binding
operator|=
name|new_class_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* Now, fill in the binding information.  */
name|binding
operator|->
name|previous
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOCAL_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
operator|(
name|level
operator|!=
name|class_binding_level
operator|)
expr_stmt|;
comment|/* And put it on the front of the list of bindings for ID.  */
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|binding
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the binding for DECL which should be the innermost binding    for ID.  */
end_comment

begin_function
name|void
name|pop_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL_TREE
condition|)
comment|/* It's easiest to write the loops that call this function without        checking whether or not the entities involved have names.  We        get here for such an entity.  */
return|return;
comment|/* Get the innermost binding for ID.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* The name should be bound.  */
name|gcc_assert
argument_list|(
name|binding
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* The DECL will be either the ordinary binding or the type      binding for this identifier.  Remove that binding.  */
if|if
condition|(
name|binding
operator|->
name|value
operator|==
name|decl
condition|)
name|binding
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|binding
operator|->
name|type
operator|==
name|decl
argument_list|)
expr_stmt|;
name|binding
operator|->
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|binding
operator|->
name|value
operator|&&
operator|!
name|binding
operator|->
name|type
condition|)
block|{
comment|/* We're completely done with the innermost binding for this 	 identifier.  Unhook it from the list of bindings.  */
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|binding
operator|->
name|previous
expr_stmt|;
comment|/* Add it to the free list.  */
name|cxx_binding_free
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BINDING records an existing declaration for a name in the current scope.    But, DECL is another declaration for that same identifier in the    same scope.  This is the `struct stat' hack whereby a non-typedef    class name or enum-name can be bound at the same level as some other    kind of entity.    3.3.7/1       A class name (9.1) or enumeration name (7.2) can be hidden by the      name of an object, function, or enumerator declared in the same scope.      If a class or enumeration name and an object, function, or enumerator      are declared in the same scope (in any order) with the same name, the      class or enumeration name is hidden wherever the object, function, or      enumerator name is visible.     It's the responsibility of the caller to check that    inserting this name is valid here.  Returns nonzero if the new binding    was successful.  */
end_comment

begin_function
specifier|static
name|bool
name|supplement_binding
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|bval
init|=
name|binding
operator|->
name|value
decl_stmt|;
name|bool
name|ok
init|=
name|true
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* The new name is the type name.  */
name|binding
operator|->
name|type
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
comment|/* BVAL is null when push_class_level_binding moves an 	      inherited type-binding out of the way to make room for a 	      new value binding.  */
operator|!
name|bval
comment|/* BVAL is error_mark_node when DECL's name has been used 	      in a non-class scope prior declaration.  In that case, 	      we should have already issued a diagnostic; for graceful 	      error recovery purpose, pretend this was the intended 	      declaration for that name.  */
operator|||
name|bval
operator|==
name|error_mark_node
comment|/* If BVAL is anticipated but has not yet been declared, 	      pretend it is not there at all.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|bval
argument_list|)
operator|&&
operator|!
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|bval
argument_list|)
operator|)
condition|)
name|binding
operator|->
name|value
operator|=
name|decl
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|bval
argument_list|)
condition|)
block|{
comment|/* The old binding was a type name.  It was placed in 	 VALUE field because it was thought, at the point it was 	 declared, to be the only entity with such a name.  Move the 	 type name into the type slot; it is now hidden by the new 	 binding.  */
name|binding
operator|->
name|type
operator|=
name|bval
expr_stmt|;
name|binding
operator|->
name|value
operator|=
name|decl
expr_stmt|;
name|binding
operator|->
name|value_is_inherited
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|bval
argument_list|)
operator|&&
name|binding
operator|->
name|scope
operator|->
name|kind
operator|!=
name|sk_class
operator|&&
operator|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|bval
argument_list|)
argument_list|)
comment|/* If either type involves template parameters, we must 		  wait until instantiation.  */
operator|||
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|bval
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* We have two typedef-names, both naming the same type to have        the same name.  In general, this is OK because of:  	 [dcl.typedef]  	 In a given scope, a typedef specifier can be used to redefine 	 the name of any type declared in that scope to refer to the 	 type to which it already refers.         However, in class scopes, this rule does not apply due to the        stricter language in [class.mem] prohibiting redeclarations of        members.  */
name|ok
operator|=
name|false
expr_stmt|;
comment|/* There can be two block-scope declarations of the same variable,      so long as they are `extern' declarations.  However, there cannot      be two declarations of the same static data member:         [class.mem]         A member shall not be declared twice in the        member-specification.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|bval
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|binding
operator|->
name|value
argument_list|,
comment|/*newdecl_is_friend=*/
name|false
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|bval
argument_list|)
operator|&&
name|ORIGINAL_NAMESPACE
argument_list|(
name|bval
argument_list|)
operator|==
name|ORIGINAL_NAMESPACE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* [namespace.alias]        In a declarative region, a namespace-alias-definition can be       used to redefine a namespace-alias declared in that declarative       region to refer only to the namespace to which it already       refers.  */
name|ok
operator|=
name|false
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"declaration of %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with previous declaration %q+#D"
argument_list|,
name|bval
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add DECL to the list of things declared in B.  */
end_comment

begin_function
specifier|static
name|void
name|add_decl_to_level
parameter_list|(
name|tree
name|decl
parameter_list|,
name|cxx_scope
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|&&
operator|!
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|namespaces
expr_stmt|;
name|b
operator|->
name|namespaces
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|vtables
expr_stmt|;
name|b
operator|->
name|vtables
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
comment|/* We build up the list in reverse order, and reverse it later if 	 necessary.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|decl
expr_stmt|;
name|b
operator|->
name|names_size
operator|++
expr_stmt|;
comment|/* If appropriate, add decl to separate list of statics.  We 	 include extern variables because they might turn out to be 	 static later.  It's OK for this list to contain a few false 	 positives.  */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_namespace
condition|)
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|b
operator|->
name|static_decls
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).  IS_FRIEND is true if X is    declared as a friend.     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl_maybe_friend
parameter_list|(
name|tree
name|x
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|need_new_binding
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|need_new_binding
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Template parameters have no context; they are not X::T even        when declared within a class or namespace.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
comment|/* A local declaration for a function doesn't constitute 	     nesting.  */
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
comment|/* A local declaration for an `extern' variable is in the 	     scope of the current namespace, not the current 	     function.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* If this is the declaration for a namespace-scope function, 	 but the declaration itself is in a local scope, mark the 	 declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
condition|)
name|DECL_LOCAL_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|different_binding_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In case this decl was explicitly namespace-qualified, look it 	 up in its namespace context.  */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|namespace_bindings_p
argument_list|()
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_name_innermost_nonclass_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* [basic.link] If there is a visible declaration of an entity 	 with linkage having the same name and type, ignoring entities 	 declared outside the innermost enclosing namespace scope, the 	 block scope declaration declares that same entity and 	 receives the linkage of the previous declaration.  */
if|if
condition|(
operator|!
name|t
operator|&&
name|current_function_decl
operator|&&
name|x
operator|!=
name|current_function_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Look in block scope.  */
name|t
operator|=
name|innermost_non_namespace_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Or in the innermost namespace.  */
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Does it have linkage?  Note that if this isn't a DECL, it's an 	     OVERLOAD, which is OK.  */
if|if
condition|(
name|t
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|t
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|different_binding_level
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are declaring a function, and the result of name-lookup 	 was an OVERLOAD, look for an overloaded instance that is 	 actually the same as the function we are declaring.  (If 	 there is one, we have to merge our declaration with the 	 previous declaration.)  */
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
name|tree
name|match
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
for|for
control|(
name|match
operator|=
name|t
init|;
name|match
condition|;
name|match
operator|=
name|OVL_NEXT
argument_list|(
name|match
argument_list|)
control|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|OVL_CURRENT
argument_list|(
name|match
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
break|break;
block|}
else|else
comment|/* Just choose one.  */
name|match
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|match
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|t
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|different_binding_level
condition|)
block|{
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
comment|/* The standard only says that the local extern 		   inherits linkage from the previous decl; in 		   particular, default args are not shared.  Add 		   the decl into a hash table to make sure only 		   the previous decl in this case is seen by the 		   middle end.  */
block|{
name|struct
name|cxx_int_tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_function_chain
operator|->
name|extern_decl_map
operator|==
name|NULL
condition|)
name|cp_function_chain
operator|->
name|extern_decl_map
operator|=
name|htab_create_ggc
argument_list|(
literal|20
argument_list|,
name|cxx_int_tree_map_hash
argument_list|,
name|cxx_int_tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|cxx_int_tree_map
argument_list|)
expr_stmt|;
name|h
operator|->
name|uid
operator|=
name|DECL_UID
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|t
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|cp_function_chain
operator|->
name|extern_decl_map
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|uid
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|cxx_int_tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|gcc_assert
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for duplicate params.  */
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|,
name|is_friend
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|DECL_EXTERN_C_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Don't do anything just yet.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|wchar_decl_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"redeclaration of %<wchar_t%> as %qT"
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Throw away the redeclaration.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|olddecl
init|=
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|,
name|is_friend
argument_list|)
decl_stmt|;
comment|/* If the redeclaration failed, we can stop at this 		 point.  */
if|if
condition|(
name|olddecl
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddecl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_MAIN_P
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* A redeclaration of main, but not a duplicate of the 		     previous one.  		     [basic.start.main]  		     This function shall not be overloaded.  */
name|error
argument_list|(
literal|"invalid redeclaration of %q+D"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"as %qD"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* We don't try to push this declaration since that 		     causes a crash.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
condition|)
name|check_default_args
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|check_template_shadow
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a function conjured up by the backend, massage it 	 so it looks friendly.  */
if|if
condition|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|retrofit_lang_decl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|SET_DECL_LANGUAGE
argument_list|(
name|x
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_LOCAL
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|x
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namespace_bindings_p
argument_list|()
condition|)
comment|/* We do not need to create a binding for this name; 	       push_overloaded_decl will have already done so if 	       necessary.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|push_overloaded_decl
argument_list|(
name|x
argument_list|,
name|PUSH_GLOBAL
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|x
condition|)
name|add_decl_to_level
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If declaring a type as a typedef, copy the type (unless we're 	 at line 0), and install this TYPE_DECL as the new type's typedef 	 name.  See the extensive comment in ../c-decl.c (pushdecl).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_IS_BUILTIN
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|x
comment|/* We don't want to copy the type when all we're 		      doing is making a TYPE_DECL for the purposes of 		      inlining.  */
operator|&&
operator|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|build_variant_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
condition|)
name|set_identifier_type_value
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Multiple external decls of the same identifier ought to match.  	 We get warnings about inline functions where they are defined. 	 We get warnings about other functions from push_overloaded_decl.  	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|decl
operator|=
name|OVL_FUNCTION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* If different sort of thing, we already gave an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"type mismatch with previous external decl of %q#D"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"previous external decl of %q+#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|is_friend
operator|&&
operator|!
name|flag_friend_injection
condition|)
block|{
comment|/* This is a new declaration of a friend function, so hide 	     it from ordinary function lookup.  */
name|DECL_ANTICIPATED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|namespace_bindings_p
argument_list|()
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Bind the name for the entity.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If new decl is `static' and an `extern' was seen previously, 	     warn about it.  */
if|if
condition|(
name|x
operator|!=
name|NULL_TREE
operator|&&
name|t
operator|!=
name|NULL_TREE
operator|&&
name|decls_match
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
name|warn_extern_redeclared_static
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|innermost_non_namespace_value
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_new_binding
condition|)
block|{
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Because push_local_binding will hook X on to the 		 current_binding_level's name list, we don't want to 		 do that again below.  */
name|need_new_binding
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a TYPE_DECL, push it into the type value slot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Clear out any TYPE_DECL shadowed by a namespace so that 	     we won't think this is a type.  The C struct hack doesn't 	     go through namespaces.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlocal
condition|)
block|{
name|tree
name|d
init|=
name|oldlocal
decl_stmt|;
while|while
condition|(
name|oldlocal
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|oldlocal
argument_list|)
condition|)
name|oldlocal
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|oldlocal
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
condition|)
name|oldlocal
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
name|decls_match
argument_list|(
name|x
argument_list|,
name|oldglobal
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"extern declaration of %q#D doesn't match"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"global declaration %q+#D"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
name|NULL_TREE
operator|&&
name|oldglobal
operator|==
name|NULL_TREE
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* Inline decls shadow nothing.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
comment|/* Don't check the `this' parameter.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|oldlocal
argument_list|)
condition|)
block|{
name|bool
name|err
init|=
name|false
decl_stmt|;
comment|/* Don't complain if it's from an enclosing function.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Go to where the parms should be and see if we find 		     them there.  */
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
operator|->
name|level_chain
decl_stmt|;
if|if
condition|(
name|FUNCTION_NEEDS_BODY_BLOCK
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* Skip the ctor/dtor cleanup level.  */
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
comment|/* ARM $8.3 */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_function_parms
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %q#D shadows a parameter"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|err
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q#D shadows a parameter"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"%Jshadowed declaration is here"
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|member
decl_stmt|;
if|if
condition|(
name|current_class_ptr
condition|)
name|member
operator|=
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
else|else
name|member
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|member
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|member
argument_list|)
condition|)
block|{
comment|/* Location of previous decl is not useful in this case.  */
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %qD shadows a member of 'this'"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %qD shadows a previous local"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"%Jshadowed declaration is here"
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldglobal
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|VAR_DECL
condition|)
comment|/* XXX shadow warnings in outer-more namespaces */
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %qD shadows a global declaration"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"%Jshadowed declaration is here"
argument_list|,
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|maybe_register_incomplete_var
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_new_binding
condition|)
name|add_decl_to_level
argument_list|(
name|x
argument_list|,
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|x
argument_list|)
condition|?
name|NAMESPACE_LEVEL
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|current_binding_level
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
return|return
name|pushdecl_maybe_friend
argument_list|(
name|x
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Enter DECL into the symbol table, if that's appropriate.  Returns    DECL, or a modified version thereof.  */
end_comment

begin_function
name|tree
name|maybe_push_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Add this decl to the current binding level, but not if it comes      from another scope, e.g. a static member variable.  TEM may equal      DECL or it may be a previous decl of the same name.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
comment|/* Definitions of namespace members outside their namespace are 	     possible.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|namespace_bindings_p
argument_list|()
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNKNOWN_TYPE
comment|/* The declaration of a template specialization does not affect 	 the functions available for overload resolution, so we do not 	 call pushdecl.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|decl
return|;
else|else
return|return
name|pushdecl
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Bind DECL to ID in the current_binding_level, assumed to be a local    binding level.  If PUSH_USING is set in FLAGS, we know that DECL    doesn't really belong to this binding level, that it got here    through a using-declaration.  */
end_comment

begin_function
name|void
name|push_local_binding
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Skip over any local classes.  This makes sense if we call      push_local_binding with a friend decl of a local class.  */
name|b
operator|=
name|innermost_nonclass_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookup_name_innermost_nonclass_level
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/* Supplement the existing binding.  */
if|if
condition|(
operator|!
name|supplement_binding
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
argument_list|,
name|decl
argument_list|)
condition|)
comment|/* It didn't work.  Something else must be bound at this 	   level.  Do not add DECL to the list of things to pop 	   later.  */
return|return;
block|}
else|else
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
condition|)
comment|/* We must put the OVERLOAD into a TREE_LIST since the        TREE_CHAIN of an OVERLOAD is already used.  Similarly for        decls that got here through a using-declaration.  */
name|decl
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* And put DECL on the list of things declared by the current      binding level.  */
name|add_decl_to_level
argument_list|(
name|decl
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see whether or not DECL is a variable that would have been    in scope under the ARM, but is not in scope under the ANSI/ISO    standard.  If so, issue an error message.  If name lookup would    work in both cases, but return a different result, this function    returns the result of ANSI/ISO lookup.  Otherwise, it returns    DECL.  */
end_comment

begin_function
name|tree
name|check_for_out_of_scope_variable
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|shadowed
decl_stmt|;
comment|/* We only care about out of scope variables.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|decl
return|;
name|shadowed
operator|=
name|DECL_HAS_SHADOWED_FOR_VAR_P
argument_list|(
name|decl
argument_list|)
condition|?
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|shadowed
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|shadowed
argument_list|)
condition|)
name|shadowed
operator|=
name|DECL_HAS_SHADOWED_FOR_VAR_P
argument_list|(
name|shadowed
argument_list|)
condition|?
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|shadowed
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|shadowed
condition|)
name|shadowed
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadowed
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"name lookup of %qD changed"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"  matches this %q+D under ISO standard rules"
argument_list|,
name|shadowed
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"  matches this %q+D under old rules"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|shadowed
return|;
block|}
comment|/* If we have already complained about this declaration, there's no      need to do it again.  */
if|if
condition|(
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|decl
return|;
name|DECL_ERROR_REPORTED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"name lookup of %qD changed for new ISO %<for%> scoping"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  cannot use obsolete binding at %q+D because "
literal|"it has a destructor"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"name lookup of %qD changed for new ISO %<for%> scoping"
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  using obsolete binding at %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* true means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|binding_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_class_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|indent
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string describing the kind of SCOPE we have.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cxx_scope_descriptor
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|)
block|{
comment|/* The order of this table must match the "scope_kind"      enumerators.  */
specifier|static
specifier|const
name|char
modifier|*
name|scope_kind_names
index|[]
init|=
block|{
literal|"block-scope"
block|,
literal|"cleanup-scope"
block|,
literal|"try-scope"
block|,
literal|"catch-scope"
block|,
literal|"for-scope"
block|,
literal|"function-parameter-scope"
block|,
literal|"class-scope"
block|,
literal|"namespace-scope"
block|,
literal|"template-parameter-scope"
block|,
literal|"template-explicit-spec-scope"
block|}
decl_stmt|;
specifier|const
name|scope_kind
name|kind
init|=
name|scope
operator|->
name|explicit_spec_p
condition|?
name|sk_template_spec
else|:
name|scope
operator|->
name|kind
decl_stmt|;
return|return
name|scope_kind_names
index|[
name|kind
index|]
return|;
block|}
end_function

begin_comment
comment|/* Output a debugging information about SCOPE when performing    ACTION at LINE.  */
end_comment

begin_function
specifier|static
name|void
name|cxx_scope_debug
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|action
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|desc
init|=
name|cxx_scope_descriptor
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|->
name|this_entity
condition|)
name|verbatim
argument_list|(
literal|"%s %s(%E) %p %d\n"
argument_list|,
name|action
argument_list|,
name|desc
argument_list|,
name|scope
operator|->
name|this_entity
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scope
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|verbatim
argument_list|(
literal|"%s %s %p %d\n"
argument_list|,
name|action
argument_list|,
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scope
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the estimated initial size of the hashtable of a NAMESPACE    scope.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|namespace_scope_ht_size
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|ns
argument_list|)
decl_stmt|;
return|return
name|name
operator|==
name|std_identifier
condition|?
name|NAMESPACE_STD_HT_SIZE
else|:
operator|(
name|name
operator|==
name|global_scope_name
condition|?
name|GLOBAL_SCOPE_HT_SIZE
else|:
name|NAMESPACE_ORDINARY_HT_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
expr|struct
name|cp_binding_level
operator|*
name|free_binding_level
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Insert SCOPE as the innermost binding level.  */
end_comment

begin_function
name|void
name|push_binding_level
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|scope
parameter_list|)
block|{
comment|/* Add it to the front of currently active scopes stack.  */
name|scope
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|scope
expr_stmt|;
name|keep_next_level_flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
block|{
name|scope
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|(
name|binding_depth
argument_list|)
expr_stmt|;
name|cxx_scope_debug
argument_list|(
name|scope
argument_list|,
name|input_line
argument_list|,
literal|"push"
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new KIND scope and make it the top of the active scopes stack.    ENTITY is the scope of the associated C++ entity (namespace, class,    function); it is NULL otherwise.  */
end_comment

begin_function
name|cxx_scope
modifier|*
name|begin_scope
parameter_list|(
name|scope_kind
name|kind
parameter_list|,
name|tree
name|entity
parameter_list|)
block|{
name|cxx_scope
modifier|*
name|scope
decl_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
operator|!
name|ENABLE_SCOPE_CHECKING
operator|&&
name|free_binding_level
condition|)
block|{
name|scope
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|scope
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|GGC_NEW
argument_list|(
name|cxx_scope
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|scope
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cxx_scope
argument_list|)
argument_list|)
expr_stmt|;
name|scope
operator|->
name|this_entity
operator|=
name|entity
expr_stmt|;
name|scope
operator|->
name|more_cleanups_ok
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|sk_cleanup
case|:
name|scope
operator|->
name|keep
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|sk_template_spec
case|:
name|scope
operator|->
name|explicit_spec_p
operator|=
name|true
expr_stmt|;
name|kind
operator|=
name|sk_template_parms
expr_stmt|;
comment|/* Fall through.  */
case|case
name|sk_template_parms
case|:
case|case
name|sk_block
case|:
case|case
name|sk_try
case|:
case|case
name|sk_catch
case|:
case|case
name|sk_for
case|:
case|case
name|sk_class
case|:
case|case
name|sk_function_parms
case|:
case|case
name|sk_omp
case|:
name|scope
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
break|break;
case|case
name|sk_namespace
case|:
name|NAMESPACE_LEVEL
argument_list|(
name|entity
argument_list|)
operator|=
name|scope
expr_stmt|;
name|scope
operator|->
name|static_decls
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|DECL_NAME
argument_list|(
name|entity
argument_list|)
operator|==
name|std_identifier
operator|||
name|DECL_NAME
argument_list|(
name|entity
argument_list|)
operator|==
name|global_scope_name
condition|?
literal|200
else|:
literal|10
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Should not happen.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
block|}
name|scope
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|push_binding_level
argument_list|(
name|scope
argument_list|)
expr_stmt|;
return|return
name|scope
return|;
block|}
end_function

begin_comment
comment|/* We're about to leave current scope.  Pop the top of the stack of    currently active scopes.  Return the enclosing scope, now active.  */
end_comment

begin_function
name|cxx_scope
modifier|*
name|leave_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|cxx_scope
modifier|*
name|scope
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_namespace
operator|&&
name|class_binding_level
condition|)
name|current_binding_level
operator|=
name|class_binding_level
expr_stmt|;
comment|/* We cannot leave a scope, if there are none left.  */
if|if
condition|(
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
condition|)
name|gcc_assert
argument_list|(
operator|!
name|global_scope_p
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
block|{
name|indent
argument_list|(
operator|--
name|binding_depth
argument_list|)
expr_stmt|;
name|cxx_scope_debug
argument_list|(
name|scope
argument_list|,
name|input_line
argument_list|,
literal|"leave"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_class_level
operator|!=
operator|(
name|scope
operator|==
name|class_binding_level
operator|)
condition|)
block|{
name|indent
argument_list|(
name|binding_depth
argument_list|)
expr_stmt|;
name|verbatim
argument_list|(
literal|"XXX is_class_level != (current_scope == class_scope)\n"
argument_list|)
expr_stmt|;
block|}
name|is_class_level
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_VISIBILITY
if|if
condition|(
name|scope
operator|->
name|has_visibility
condition|)
name|pop_visibility
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Move one nesting level up.  */
name|current_binding_level
operator|=
name|scope
operator|->
name|level_chain
expr_stmt|;
comment|/* Namespace-scopes are left most probably temporarily, not      completely; they can be reopened later, e.g. in namespace-extension      or any name binding activity that requires us to resume a      namespace.  For classes, we cache some binding levels.  For other      scopes, we just make the structure available for reuse.  */
if|if
condition|(
name|scope
operator|->
name|kind
operator|!=
name|sk_namespace
operator|&&
name|scope
operator|->
name|kind
operator|!=
name|sk_class
condition|)
block|{
name|scope
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ENABLE_SCOPE_CHECKING
operator|||
name|scope
operator|->
name|binding_depth
operator|==
name|binding_depth
argument_list|)
expr_stmt|;
name|free_binding_level
operator|=
name|scope
expr_stmt|;
block|}
comment|/* Find the innermost enclosing class scope, and reset      CLASS_BINDING_LEVEL appropriately.  */
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|class_binding_level
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|scope
operator|=
name|current_binding_level
init|;
name|scope
condition|;
name|scope
operator|=
name|scope
operator|->
name|level_chain
control|)
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|class_binding_level
operator|=
name|scope
expr_stmt|;
break|break;
block|}
block|}
return|return
name|current_binding_level
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resume_scope
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|b
parameter_list|)
block|{
comment|/* Resuming binding levels is meant only for namespaces,      and those cannot nest into classes.  */
name|gcc_assert
argument_list|(
operator|!
name|class_binding_level
argument_list|)
expr_stmt|;
comment|/* Also, resuming a non-directly nested namespace is a no-no.  */
name|gcc_assert
argument_list|(
name|b
operator|->
name|level_chain
operator|==
name|current_binding_level
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
block|{
name|b
operator|->
name|binding_depth
operator|=
name|binding_depth
expr_stmt|;
name|indent
argument_list|(
name|binding_depth
argument_list|)
expr_stmt|;
name|cxx_scope_debug
argument_list|(
name|b
argument_list|,
name|input_line
argument_list|,
literal|"resume"
argument_list|)
expr_stmt|;
name|is_class_level
operator|=
literal|0
expr_stmt|;
name|binding_depth
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the innermost binding level that is not for a class scope.  */
end_comment

begin_function
specifier|static
name|cxx_scope
modifier|*
name|innermost_nonclass_level
parameter_list|(
name|void
parameter_list|)
block|{
name|cxx_scope
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* We're defining an object of type TYPE.  If it needs a cleanup, but    we're not allowed to add any more objects with cleanups to the current    scope, create a new binding level.  */
end_comment

begin_function
name|void
name|maybe_push_cleanup_level
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|current_binding_level
operator|->
name|more_cleanups_ok
operator|==
literal|0
condition|)
block|{
name|begin_scope
argument_list|(
name|sk_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|statement_list
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|global_scope_p
argument_list|(
name|current_binding_level
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True if we are currently in a toplevel binding level.  This    means either the global binding level or a namespace in a toplevel    binding level.  Since there are no non-toplevel namespace levels,    this really means any namespace or template parameter level.  We    also include a class whose context is toplevel.  */
end_comment

begin_function
name|bool
name|toplevel_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|kind
operator|==
name|sk_namespace
operator|||
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
return|;
block|}
end_function

begin_comment
comment|/* True if this is a namespace scope, or if we are defining a class    which is itself at namespace scope, or whose enclosing class is    such a class, etc.  */
end_comment

begin_function
name|bool
name|namespace_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|innermost_nonclass_level
argument_list|()
decl_stmt|;
return|return
name|b
operator|->
name|kind
operator|==
name|sk_namespace
return|;
block|}
end_function

begin_comment
comment|/* True if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|bool
name|kept_level_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|current_binding_level
operator|->
name|blocks
operator|!=
name|NULL_TREE
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_cleanup
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
name|NULL_TREE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the kind of the innermost scope.  */
end_comment

begin_function
name|scope_kind
name|innermost_scope_kind
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_binding_level
operator|->
name|kind
return|;
block|}
end_function

begin_comment
comment|/* Returns true if this scope was created to store template parameters.  */
end_comment

begin_function
name|bool
name|template_parm_scope_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|innermost_scope_kind
argument_list|()
operator|==
name|sk_template_parms
return|;
block|}
end_function

begin_comment
comment|/* If KEEP is true, make a BLOCK node for the next binding level,    unconditionally.  Otherwise, use the normal logic to decide whether    or not to create a BLOCK.  */
end_comment

begin_function
name|void
name|keep_next_level
parameter_list|(
name|bool
name|keep
parameter_list|)
block|{
name|keep_next_level_flag
operator|=
name|keep
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* For debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_print_functions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_print_builtins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_binding_level
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|lvl
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" blocks=%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lvl
operator|->
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|more_cleanups_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" more-cleanups-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|have_cleanups
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" have-cleanups"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|->
name|names
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" names:\t"
argument_list|)
expr_stmt|;
comment|/* We can probably fit 3 names to a line?  */
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|no_print_functions
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|no_print_builtins
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
name|DECL_IS_BUILTIN
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
comment|/* Function decls tend to have longer names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|len
operator|=
literal|3
expr_stmt|;
else|else
name|len
operator|=
literal|2
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
name|print_node_brief
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VEC_length
argument_list|(
name|cp_class_binding
argument_list|,
name|lvl
operator|->
name|class_shadowed
argument_list|)
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|cp_class_binding
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" class-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cp_class_binding
argument_list|,
name|lvl
operator|->
name|class_shadowed
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|b
operator|->
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lvl
operator|->
name|type_shadowed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" type-shadowed:"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lvl
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_other_binding_stack
parameter_list|(
name|struct
name|cp_binding_level
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|stack
init|;
operator|!
name|global_scope_p
argument_list|(
name|level
argument_list|)
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"binding level %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|level
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_binding_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"current_binding_level=%p\n"
literal|"class_binding_level=%p\n"
literal|"NAMESPACE_LEVEL (global_namespace)=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|current_binding_level
argument_list|,
operator|(
name|void
operator|*
operator|)
name|class_binding_level
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding_level
condition|)
block|{
for|for
control|(
name|b
operator|=
name|class_binding_level
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
if|if
condition|(
name|b
operator|==
name|current_binding_level
condition|)
break|break;
if|if
condition|(
name|b
condition|)
name|b
operator|=
name|class_binding_level
expr_stmt|;
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
block|}
else|else
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|print_other_binding_stack
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"global:\n"
argument_list|)
expr_stmt|;
name|print_binding_level
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|global_namespace
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type associated with id.  */
end_comment

begin_function
name|tree
name|identifier_type_value
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* There is no type with that name, anywhere.  */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This is not the type marker, but the real thing.  */
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
operator|!=
name|global_type_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have to search for it. It must be on the global level, now.      Ask lookup_name not to return non-types.  */
name|id
operator|=
name|lookup_name_real
argument_list|(
name|id
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since    the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */
end_comment

begin_function
name|tree
name|identifier_global_value
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push a definition of struct, union or enum tag named ID.  into    binding_level B.  DECL is a TYPE_DECL for the type.  We assume that    the tag ID is not already defined.  */
end_comment

begin_function
specifier|static
name|void
name|set_identifier_type_value_with_scope
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|cxx_scope
modifier|*
name|b
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|!=
name|sk_namespace
condition|)
block|{
comment|/* Shadow the marker, not the real thing, so that the marker 	 gets restored later.  */
name|tree
name|old_type_value
init|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|b
operator|->
name|type_shadowed
operator|=
name|tree_cons
argument_list|(
name|id
argument_list|,
name|old_type_value
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
expr_stmt|;
name|type
operator|=
name|decl
condition|?
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|type_shadowed
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|cxx_binding
modifier|*
name|binding
init|=
name|binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|->
name|value
condition|)
name|supplement_binding
argument_list|(
name|binding
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|binding
operator|->
name|value
operator|=
name|decl
expr_stmt|;
comment|/* Store marker instead of real type.  */
name|type
operator|=
name|global_type_node
expr_stmt|;
block|}
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As set_identifier_type_value_with_scope, but using    current_binding_level.  */
end_comment

begin_function
name|void
name|set_identifier_type_value
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|set_identifier_type_value_with_scope
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|current_binding_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name for the constructor (or destructor) for the    specified class TYPE.  When given a template, this routine doesn't    lose the specialization.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|constructor_name_full
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name for the constructor (or destructor) for the    specified class.  When given a template, return the plain    unspecialized name.  */
end_comment

begin_function
name|tree
name|constructor_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|name
operator|=
name|constructor_name_full
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if NAME is the name for the constructor for TYPE.  */
end_comment

begin_function
name|bool
name|constructor_name_p
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|ctor_name
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
return|return
name|false
return|;
name|ctor_name
operator|=
name|constructor_name_full
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|ctor_name
condition|)
return|return
name|true
return|;
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|ctor_name
argument_list|)
operator|&&
name|name
operator|==
name|IDENTIFIER_TEMPLATE
argument_list|(
name|ctor_name
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Counter used to create anonymous type names.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|anon_cnt
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|anon_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return (from the stack of) the BINDING, if any, established at SCOPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cxx_binding
modifier|*
name|find_binding
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|cxx_binding
modifier|*
name|binding
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|binding
operator|!=
name|NULL
condition|;
name|binding
operator|=
name|binding
operator|->
name|previous
control|)
if|if
condition|(
name|binding
operator|->
name|scope
operator|==
name|scope
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|binding
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
operator|(
name|cxx_binding
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|cxx_binding
modifier|*
name|cxx_scope_find_binding_for_name
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|b
init|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
comment|/* Fold-in case where NAME is used only once.  */
if|if
condition|(
name|scope
operator|==
name|b
operator|->
name|scope
operator|&&
name|b
operator|->
name|previous
operator|==
name|NULL
condition|)
return|return
name|b
return|;
return|return
name|find_binding
argument_list|(
name|scope
argument_list|,
name|b
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Always returns a binding for name in scope.  If no binding is    found, make a new one.  */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|binding_for_name
parameter_list|(
name|cxx_scope
modifier|*
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* Not found, make a new one.  */
name|result
operator|=
name|cxx_binding_make
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|->
name|previous
operator|=
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|result
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
name|result
operator|->
name|is_local
operator|=
name|false
expr_stmt|;
name|result
operator|->
name|value_is_inherited
operator|=
name|false
expr_stmt|;
name|IDENTIFIER_NAMESPACE_BINDINGS
argument_list|(
name|name
argument_list|)
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Insert another USING_DECL into the current binding level, returning    this declaration. If this is a redeclaration, do nothing, and    return NULL_TREE if this not in namespace scope (in namespace    scope, a using decl might extend any previous bindings).  */
end_comment

begin_function
specifier|static
name|tree
name|push_using_decl
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|usings
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|USING_DECL_SCOPE
argument_list|(
name|decl
argument_list|)
operator|==
name|scope
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|decl
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|namespace_bindings_p
argument_list|()
condition|?
name|decl
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|USING_DECL_SCOPE
argument_list|(
name|decl
argument_list|)
operator|=
name|scope
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|current_binding_level
operator|->
name|usings
expr_stmt|;
name|current_binding_level
operator|->
name|usings
operator|=
name|decl
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the    caller to set DECL_CONTEXT properly.  */
end_comment

begin_function
name|tree
name|pushdecl_with_scope
parameter_list|(
name|tree
name|x
parameter_list|,
name|cxx_scope
modifier|*
name|level
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|function_decl
init|=
name|current_function_decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|level
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|b
operator|=
name|class_binding_level
expr_stmt|;
name|class_binding_level
operator|=
name|level
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class_binding_level
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|level
expr_stmt|;
name|x
operator|=
name|pushdecl_maybe_friend
argument_list|(
name|x
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|function_decl
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL for a non-member function, which may have    other definitions already in place.  We get around this by making    the value of the identifier point to a list of all the things that    want to be referenced by that name.  It is then up to the users of    that name to decide what to do with that list.     DECL may also be a TEMPLATE_DECL, with a FUNCTION_DECL in its    DECL_TEMPLATE_RESULT.  It is dealt with the same way.     FLAGS is a bitwise-or of the following values:      PUSH_LOCAL: Bind DECL in the current scope, rather than at 		 namespace scope.      PUSH_USING: DECL is being pushed as the result of a using 		 declaration.     IS_FRIEND is true if this is a friend declaration.     The value returned may be a previous declaration if we guessed wrong    about what language DECL should belong to (C or C++).  Otherwise,    it's always DECL (and never something that's not a _DECL).  */
end_comment

begin_function
specifier|static
name|tree
name|push_overloaded_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|old
decl_stmt|;
name|tree
name|new_binding
decl_stmt|;
name|int
name|doing_global
init|=
operator|(
name|namespace_bindings_p
argument_list|()
operator|||
operator|!
operator|(
name|flags
operator|&
name|PUSH_LOCAL
operator|)
operator|)
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|old
operator|=
name|namespace_binding
argument_list|(
name|name
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
name|lookup_name_innermost_nonclass_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|old
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|warn_shadow
operator|&&
operator|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|old
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q#D hides constructor for %q#T"
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|old
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|old
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|tree
name|dup
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|OVL_USED
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|decls_match
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%q#D conflicts with previous using declaration %q#D"
argument_list|,
name|decl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|dup
operator|=
name|duplicate_decls
argument_list|(
name|decl
argument_list|,
name|fn
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
comment|/* If DECL was a redeclaration of FN -- even an invalid 		 one -- pass that information along to our caller.  */
if|if
condition|(
name|dup
operator|==
name|fn
operator|||
name|dup
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|dup
argument_list|)
expr_stmt|;
block|}
comment|/* We don't overload implicit built-ins.  duplicate_decls() 	     may fail to merge the decls if the new decl is e.g. a 	     template function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|old
argument_list|)
operator|&&
operator|!
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|old
argument_list|)
condition|)
name|old
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old
operator|==
name|error_mark_node
condition|)
comment|/* Ignore the undefined symbol marker.  */
name|old
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"previous non-function declaration %q+#D"
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"conflicts with function declaration %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
comment|/* If it's a using declaration, we always need to build an OVERLOAD, 	 because it's the only way to remember that the declaration comes 	 from 'using', and have the lookup behave correctly.  */
operator|||
operator|(
name|flags
operator|&
name|PUSH_USING
operator|)
condition|)
block|{
if|if
condition|(
name|old
operator|&&
name|TREE_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|ovl_cons
argument_list|(
name|old
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_binding
operator|=
name|ovl_cons
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PUSH_USING
condition|)
name|OVL_USED
argument_list|(
name|new_binding
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* NAME is not ambiguous.  */
name|new_binding
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|doing_global
condition|)
name|set_namespace_binding
argument_list|(
name|name
argument_list|,
name|current_namespace
argument_list|,
name|new_binding
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We only create an OVERLOAD if there was a previous binding at 	 this level, or if decl is a template. In the former case, we 	 need to remove the old binding and replace it with the new 	 binding.  We must also run through the NAMES on the binding 	 level where the name was bound to update the chain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_binding
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|old
condition|)
block|{
name|tree
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|->
name|scope
operator|->
name|names
init|;
operator|*
name|d
condition|;
name|d
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
control|)
if|if
condition|(
operator|*
name|d
operator|==
name|old
operator|||
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|old
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|d
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* Just replace the old binding with the new.  */
name|TREE_VALUE
argument_list|(
operator|*
name|d
argument_list|)
operator|=
name|new_binding
expr_stmt|;
else|else
comment|/* Build a TREE_LIST to wrap the OVERLOAD.  */
operator|*
name|d
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|new_binding
argument_list|,
name|TREE_CHAIN
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And update the cxx_binding node.  */
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|->
name|value
operator|=
name|new_binding
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* We should always find a previous binding in this case.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Install the new binding.  */
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|new_binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a non-member using-declaration. Return the name and scope    being used, and the USING_DECL, or NULL_TREE on failure.  */
end_comment

begin_function
specifier|static
name|tree
name|validate_nonmember_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
comment|/* [namespace.udecl]        A using-declaration for a class member shall be a        member-declaration.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qT is not a namespace"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* 7.3.3/5 	   A using-declaration shall not name a template-id.  */
name|error
argument_list|(
literal|"a using-declaration cannot specify a template-id.  "
literal|"Try %<using %D%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"namespace %qD not allowed in using-declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
comment|/* It's a nested name with template parameter dependent scope. 	 This can only be using-declaration for class member.  */
name|error
argument_list|(
literal|"%qT is not a namespace"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|get_first_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a USING_DECL.  */
return|return
name|push_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process local and global using-declarations.  */
end_comment

begin_function
specifier|static
name|void
name|do_nonmember_using_decl
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|oldval
parameter_list|,
name|tree
name|oldtype
parameter_list|,
name|tree
modifier|*
name|newval
parameter_list|,
name|tree
modifier|*
name|newtype
parameter_list|)
block|{
name|struct
name|scope_binding
name|decls
init|=
name|EMPTY_SCOPE_BINDING
decl_stmt|;
operator|*
name|newval
operator|=
operator|*
name|newtype
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
operator|&
name|decls
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* Lookup error */
return|return;
if|if
condition|(
operator|!
name|decls
operator|.
name|value
operator|&&
operator|!
name|decls
operator|.
name|type
condition|)
block|{
name|error
argument_list|(
literal|"%qD not declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* LLVM LOCAL begin mainline */
comment|/* Shift the old and new bindings around so we're comparing class and      enumeration names to each other.  */
if|if
condition|(
name|oldval
operator|&&
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|oldval
argument_list|)
condition|)
block|{
name|oldtype
operator|=
name|oldval
expr_stmt|;
name|oldval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|decls
operator|.
name|value
operator|&&
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decls
operator|.
name|value
argument_list|)
condition|)
block|{
name|decls
operator|.
name|type
operator|=
name|decls
operator|.
name|value
expr_stmt|;
name|decls
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* LLVM LOCAL end mainline */
comment|/* It is impossible to overload a built-in function; any explicit      declaration eliminates the built-in declaration.  So, if OLDVAL      is a built-in, then we can just pretend it isn't there.  */
if|if
condition|(
name|oldval
operator|&&
name|TREE_CODE
argument_list|(
name|oldval
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|oldval
argument_list|)
operator|&&
operator|!
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|oldval
argument_list|)
condition|)
name|oldval
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* LLVM LOCAL begin mainline */
if|if
condition|(
name|decls
operator|.
name|value
condition|)
block|{
comment|/* Check for using functions.  */
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|decls
operator|.
name|value
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|;
if|if
condition|(
name|oldval
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|oldval
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|*
name|newval
operator|=
name|oldval
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|decls
operator|.
name|value
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|new_fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
comment|/* [namespace.udecl]  		 If a function declaration in namespace scope or block 		 scope has the same name and the same parameter types as a 		 function introduced by a using declaration the program is 		 ill-formed.  */
for|for
control|(
name|tmp1
operator|=
name|oldval
init|;
name|tmp1
condition|;
name|tmp1
operator|=
name|OVL_NEXT
argument_list|(
name|tmp1
argument_list|)
control|)
block|{
name|tree
name|old_fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_fn
operator|==
name|old_fn
condition|)
comment|/* The function already exists in the current namespace.  */
break|break;
elseif|else
if|if
condition|(
name|OVL_USED
argument_list|(
name|tmp1
argument_list|)
condition|)
continue|continue;
comment|/* this is a using decl */
elseif|else
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_fn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|DECL_ANTICIPATED
argument_list|(
name|old_fn
argument_list|)
operator|||
name|DECL_HIDDEN_FRIEND_P
argument_list|(
name|old_fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There was already a non-using declaration in 			 this scope with the same parameter types. If both 			 are the same extern "C" functions, that's ok.  */
if|if
condition|(
name|decls_match
argument_list|(
name|new_fn
argument_list|,
name|old_fn
argument_list|)
condition|)
break|break;
else|else
block|{
name|error
argument_list|(
literal|"%qD is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we broke out of the loop, there's no reason to add 		 this function to the using declarations for this 		 scope.  */
if|if
condition|(
name|tmp1
condition|)
continue|continue;
comment|/* If we are adding to an existing OVERLOAD, then we no 		 longer know the type of the set of functions.  */
if|if
condition|(
operator|*
name|newval
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|newval
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
comment|/* Add this new function to the set.  */
operator|*
name|newval
operator|=
name|build_overload
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|*
name|newval
argument_list|)
expr_stmt|;
comment|/* If there is only one function, then we use its type.  (A 		 using-declaration naming a single function can be used in 		 contexts where overload resolution cannot be 		 performed.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|newval
argument_list|)
operator|!=
name|OVERLOAD
condition|)
block|{
operator|*
name|newval
operator|=
name|ovl_cons
argument_list|(
operator|*
name|newval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OVL_USED
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|newval
operator|=
name|decls
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|oldval
operator|&&
operator|!
name|decls_match
argument_list|(
operator|*
name|newval
argument_list|,
name|oldval
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|newval
operator|=
name|oldval
expr_stmt|;
if|if
condition|(
name|decls
operator|.
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|decls
operator|.
name|type
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"reference to %qD is ambiguous"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|decls
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|newtype
operator|=
name|decls
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|oldtype
operator|&&
operator|*
name|newtype
operator|&&
operator|!
name|decls_match
argument_list|(
name|oldtype
argument_list|,
operator|*
name|newtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* If *newval is empty, shift any class or enumeration name down.  */
if|if
condition|(
operator|!
operator|*
name|newval
condition|)
block|{
operator|*
name|newval
operator|=
operator|*
name|newtype
expr_stmt|;
operator|*
name|newtype
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* LLVM LOCAL end mainline */
block|}
end_function

begin_comment
comment|/* Process a using-declaration at function scope.  */
end_comment

begin_function
name|void
name|do_local_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|,
name|newval
decl_stmt|,
name|newtype
decl_stmt|;
name|tree
name|orig_decl
init|=
name|decl
decl_stmt|;
name|decl
operator|=
name|validate_nonmember_using_decl
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|building_stmt_tree
argument_list|()
operator|&&
name|at_function_scope_p
argument_list|()
condition|)
name|add_decl_expr
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|lookup_name_innermost_nonclass_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|oldtype
operator|=
name|lookup_type_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|do_nonmember_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|oldval
argument_list|,
name|oldtype
argument_list|,
operator|&
name|newval
argument_list|,
operator|&
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|newval
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|term
decl_stmt|;
comment|/* We only need to push declarations for those functions 	     that were not already bound in the current level. 	     The old value might be NULL_TREE, it might be a single 	     function, or an OVERLOAD.  */
if|if
condition|(
name|oldval
operator|&&
name|TREE_CODE
argument_list|(
name|oldval
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|term
operator|=
name|OVL_FUNCTION
argument_list|(
name|oldval
argument_list|)
expr_stmt|;
else|else
name|term
operator|=
name|oldval
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|newval
init|;
name|fn
operator|&&
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
operator|!=
name|term
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
name|push_overloaded_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|PUSH_LOCAL
operator||
name|PUSH_USING
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|newval
argument_list|,
name|PUSH_USING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newtype
condition|)
block|{
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|newtype
argument_list|,
name|PUSH_USING
argument_list|)
expr_stmt|;
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|cp_emit_debug_info_for_using
argument_list|(
name|orig_decl
argument_list|,
name|current_scope
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if ROOT (a namespace, class, or function) encloses    CHILD.  CHILD may be either a class type or a namespace.  */
end_comment

begin_function
name|bool
name|is_ancestor
parameter_list|(
name|tree
name|root
parameter_list|,
name|tree
name|child
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|root
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|root
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|CLASS_TYPE_P
argument_list|(
name|root
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|child
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|CLASS_TYPE_P
argument_list|(
name|child
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* The global namespace encloses everything.  */
if|if
condition|(
name|root
operator|==
name|global_namespace
condition|)
return|return
name|true
return|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* If we've run out of scopes, stop.  */
if|if
condition|(
operator|!
name|child
condition|)
return|return
name|false
return|;
comment|/* If we've reached the ROOT, it encloses CHILD.  */
if|if
condition|(
name|root
operator|==
name|child
condition|)
return|return
name|true
return|;
comment|/* Go out one level.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|child
argument_list|)
condition|)
name|child
operator|=
name|TYPE_NAME
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
name|DECL_CONTEXT
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter the class or namespace scope indicated by T suitable for name    lookup.  T can be arbitrary scope, not necessary nested inside the    current scope.  Returns a non-null scope to pop iff pop_scope    should be called later to exit this scope.  */
end_comment

begin_function
name|tree
name|push_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|push_decl_namespace
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|at_class_scope_p
argument_list|()
operator|||
operator|!
name|same_type_p
argument_list|(
name|current_class_type
argument_list|,
name|t
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
comment|/* T is the same as the current scope.  There is therefore no 	   need to re-enter the scope.  Since we are not actually 	   pushing a new scope, our caller should not call 	   pop_scope.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Leave scope pushed by push_scope.  */
end_comment

begin_function
name|void
name|pop_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
elseif|else
if|if CLASS_TYPE_P
condition|(
name|t
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of push_inner_scope.  */
end_comment

begin_function
specifier|static
name|void
name|push_inner_scope_r
parameter_list|(
name|tree
name|outer
parameter_list|,
name|tree
name|inner
parameter_list|)
block|{
name|tree
name|prev
decl_stmt|;
if|if
condition|(
name|outer
operator|==
name|inner
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|inner
argument_list|)
operator|)
condition|)
return|return;
name|prev
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|?
name|inner
else|:
name|TYPE_NAME
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outer
operator|!=
name|prev
condition|)
name|push_inner_scope_r
argument_list|(
name|outer
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|save_template_parm
init|=
literal|0
decl_stmt|;
comment|/* Temporary take out template parameter scopes.  They are saved 	 in reversed order in save_template_parm.  */
while|while
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_template_parms
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|b
operator|->
name|level_chain
operator|=
name|save_template_parm
expr_stmt|;
name|save_template_parm
operator|=
name|b
expr_stmt|;
block|}
name|resume_scope
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|current_namespace
operator|=
name|inner
expr_stmt|;
comment|/* Restore template parameter scopes.  */
while|while
condition|(
name|save_template_parm
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|save_template_parm
decl_stmt|;
name|save_template_parm
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|b
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
block|}
else|else
name|pushclass
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter the scope INNER from current scope.  INNER must be a scope    nested inside current scope.  This works with both name lookup and    pushing name into scope.  In case a template parameter scope is present,    namespace is pushed under the template parameter scope according to    name lookup rule in 14.6.1/6.     Return the former current scope suitable for pop_inner_scope.  */
end_comment

begin_function
name|tree
name|push_inner_scope
parameter_list|(
name|tree
name|inner
parameter_list|)
block|{
name|tree
name|outer
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|outer
condition|)
name|outer
operator|=
name|current_namespace
expr_stmt|;
name|push_inner_scope_r
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|outer
return|;
block|}
end_function

begin_comment
comment|/* Exit the current scope INNER back to scope OUTER.  */
end_comment

begin_function
name|void
name|pop_inner_scope
parameter_list|(
name|tree
name|outer
parameter_list|,
name|tree
name|inner
parameter_list|)
block|{
if|if
condition|(
name|outer
operator|==
name|inner
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|NAMESPACE_DECL
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|inner
argument_list|)
operator|)
condition|)
return|return;
while|while
condition|(
name|outer
operator|!=
name|inner
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|save_template_parm
init|=
literal|0
decl_stmt|;
comment|/* Temporary take out template parameter scopes.  They are saved 	     in reversed order in save_template_parm.  */
while|while
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_template_parms
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|b
operator|->
name|level_chain
operator|=
name|save_template_parm
expr_stmt|;
name|save_template_parm
operator|=
name|b
expr_stmt|;
block|}
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Restore template parameter scopes.  */
while|while
condition|(
name|save_template_parm
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|save_template_parm
decl_stmt|;
name|save_template_parm
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|b
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
block|}
block|}
else|else
name|popclass
argument_list|()
expr_stmt|;
name|inner
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|?
name|inner
else|:
name|TYPE_NAME
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do a pushlevel for class declarations.  */
end_comment

begin_function
name|void
name|pushlevel_class
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
name|class_binding_level
operator|=
name|begin_scope
argument_list|(
name|sk_class
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ...and a poplevel for class declarations.  */
end_comment

begin_function
name|void
name|poplevel_class
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
init|=
name|class_binding_level
decl_stmt|;
name|cp_class_binding
modifier|*
name|cb
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|shadowed
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|level
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* If we're leaving a toplevel class, cache its binding level.  */
if|if
condition|(
name|current_class_depth
operator|==
literal|1
condition|)
name|previous_class_level
operator|=
name|level
expr_stmt|;
for|for
control|(
name|shadowed
operator|=
name|level
operator|->
name|type_shadowed
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the bindings for all of the class-level declarations.  */
if|if
condition|(
name|level
operator|->
name|class_shadowed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cp_class_binding
argument_list|,
name|level
operator|->
name|class_shadowed
argument_list|,
name|i
argument_list|,
name|cb
argument_list|)
condition|;
operator|++
name|i
control|)
name|IDENTIFIER_BINDING
argument_list|(
name|cb
operator|->
name|identifier
argument_list|)
operator|=
name|cb
operator|->
name|base
operator|.
name|previous
expr_stmt|;
name|ggc_free
argument_list|(
name|level
operator|->
name|class_shadowed
argument_list|)
expr_stmt|;
name|level
operator|->
name|class_shadowed
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now, pop out of the binding level which we created up in the      `pushlevel_class' routine.  */
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|is_class_level
operator|=
literal|1
expr_stmt|;
name|leave_scope
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set INHERITED_VALUE_BINDING_P on BINDING to true or false, as    appropriate.  DECL is the value to which a name has just been    bound.  CLASS_TYPE is the class in which the lookup occurred.  */
end_comment

begin_function
specifier|static
name|void
name|set_inherited_value_binding_p
parameter_list|(
name|cxx_binding
modifier|*
name|binding
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|class_type
parameter_list|)
block|{
if|if
condition|(
name|binding
operator|->
name|value
operator|==
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_properly_derived_from
argument_list|(
name|class_type
argument_list|,
name|context
argument_list|)
condition|)
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binding
operator|->
name|value
operator|==
name|decl
condition|)
comment|/* We only encounter a TREE_LIST when there is an ambiguity in the        base classes.  Such an ambiguity can be overridden by a        definition in this class.  */
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the declaration of X appear in CLASS scope.  */
end_comment

begin_function
name|bool
name|pushdecl_class_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|bool
name|is_valid
init|=
name|true
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Get the name of X.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|is_valid
operator|=
name|push_class_level_binding
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If X is an anonymous aggregate, all of its members are 	 treated as if they were members of the class containing the 	 aggregate, for naming purposes.  */
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
block|{
name|location_t
name|save_location
init|=
name|input_location
decl_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pushdecl_class_level
argument_list|(
name|f
argument_list|)
condition|)
name|is_valid
operator|=
name|false
expr_stmt|;
name|input_location
operator|=
name|save_location
expr_stmt|;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|is_valid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the BINDING (if any) for NAME in SCOPE, which is a class    scope.  If the value returned is non-NULL, and the PREVIOUS field    is not set, callers must set the PREVIOUS field explicitly.  */
end_comment

begin_function
specifier|static
name|cxx_binding
modifier|*
name|get_class_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|cxx_scope
modifier|*
name|scope
parameter_list|)
block|{
name|tree
name|class_type
decl_stmt|;
name|tree
name|type_binding
decl_stmt|;
name|tree
name|value_binding
decl_stmt|;
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|class_type
operator|=
name|scope
operator|->
name|this_entity
expr_stmt|;
comment|/* Get the type binding.  */
name|type_binding
operator|=
name|lookup_member
argument_list|(
name|class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Get the value binding.  */
name|value_binding
operator|=
name|lookup_member
argument_list|(
name|class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|,
comment|/*want_type=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_binding
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|value_binding
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|value_binding
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|)
operator|)
condition|)
comment|/* We found a type binding, even when looking for a non-type        binding.  This means that we already processed this binding        above.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|value_binding
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value_binding
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* NAME is ambiguous.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|value_binding
argument_list|)
condition|)
comment|/* NAME is some overloaded functions.  */
name|value_binding
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|value_binding
argument_list|)
expr_stmt|;
block|}
comment|/* If we found either a type binding or a value binding, create a      new binding object.  */
if|if
condition|(
name|type_binding
operator|||
name|value_binding
condition|)
block|{
name|binding
operator|=
name|new_class_binding
argument_list|(
name|name
argument_list|,
name|value_binding
argument_list|,
name|type_binding
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* This is a class-scope binding, not a block-scope binding.  */
name|LOCAL_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_inherited_value_binding_p
argument_list|(
name|binding
argument_list|,
name|value_binding
argument_list|,
name|class_type
argument_list|)
expr_stmt|;
block|}
else|else
name|binding
operator|=
name|NULL
expr_stmt|;
return|return
name|binding
return|;
block|}
end_function

begin_comment
comment|/* Make the declaration(s) of X appear in CLASS scope under the name    NAME.  Returns true if the binding is valid.  */
end_comment

begin_function
name|bool
name|push_class_level_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|x
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|tree
name|decl
init|=
name|x
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* The class_binding_level will be NULL if x is a template      parameter name in a member template.  */
if|if
condition|(
operator|!
name|class_binding_level
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Check for invalid member names.  */
name|gcc_assert
argument_list|(
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We could have been passed a tree list if this is an ambiguous      declaration. If so, pull the declaration out because      check_template_shadow will not handle a TREE_LIST.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|check_template_shadow
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* [class.mem]       If T is the name of a class, then each of the following shall      have a name different from T:       -- every static data member of class T;       -- every member of class T that is itself a type;       -- every enumerator of every member of class T that is an 	enumerated type;       -- every member of every anonymous union that is a member of 	class T.       (Non-static data members were also forbidden to have the same      name as T until TC1.)  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_SELF_REFERENCE_P
argument_list|(
name|x
argument_list|)
operator|)
comment|/* A data member of an anonymous union.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|!=
name|current_class_type
operator|)
operator|)
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|scope
init|=
name|context_for_name_lookup
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|scope
argument_list|,
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD has the same name as the class in which it is "
literal|"declared"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the current binding for NAME in this class, if any.  */
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binding
operator|||
name|binding
operator|->
name|scope
operator|!=
name|class_binding_level
condition|)
block|{
name|binding
operator|=
name|get_class_binding
argument_list|(
name|name
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
comment|/* If a new binding was created, put it at the front of the 	 IDENTIFIER_BINDING list.  */
if|if
condition|(
name|binding
condition|)
block|{
name|binding
operator|->
name|previous
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|=
name|binding
expr_stmt|;
block|}
block|}
comment|/* If there is already a binding, then we may need to update the      current value.  */
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|value
condition|)
block|{
name|tree
name|bval
init|=
name|binding
operator|->
name|value
decl_stmt|;
name|tree
name|old_decl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
condition|)
block|{
comment|/* If the old binding was from a base class, and was for a 	     tag name, slide it over to make room for the new binding. 	     The old binding is still visible if explicitly qualified 	     with a class-key.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|bval
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|old_decl
operator|=
name|binding
operator|->
name|type
expr_stmt|;
name|binding
operator|->
name|type
operator|=
name|bval
expr_stmt|;
name|binding
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|old_decl
operator|=
name|bval
expr_stmt|;
comment|/* Any inherited type declaration is hidden by the type 		 declaration in the derived class.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|x
argument_list|)
condition|)
name|binding
operator|->
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|is_overloaded_fn
argument_list|(
name|bval
argument_list|)
condition|)
name|old_decl
operator|=
name|bval
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|USING_DECL
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|is_overloaded_fn
argument_list|(
name|bval
argument_list|)
condition|)
name|old_decl
operator|=
name|bval
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bval
argument_list|)
operator|==
name|USING_DECL
operator|&&
name|is_overloaded_fn
argument_list|(
name|x
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|&&
name|binding
operator|->
name|scope
operator|==
name|class_binding_level
condition|)
block|{
name|binding
operator|->
name|value
operator|=
name|x
expr_stmt|;
comment|/* It is always safe to clear INHERITED_VALUE_BINDING_P 	     here.  This function is only used to register bindings 	     from with the class definition itself.  */
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|binding
argument_list|)
operator|=
literal|0
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note that we declared this value so that we can issue an error if      this is an invalid redeclaration of a name already used for some      other purpose.  */
name|note_name_declared_in_class
argument_list|(
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If we didn't replace an existing binding, put the binding on the      stack of bindings for the identifier, and update the shadowed      list.  */
if|if
condition|(
name|binding
operator|&&
name|binding
operator|->
name|scope
operator|==
name|class_binding_level
condition|)
comment|/* Supplement the existing binding.  */
name|ok
operator|=
name|supplement_binding
argument_list|(
name|binding
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Create a new binding.  */
name|push_binding
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
name|class_binding_level
argument_list|)
expr_stmt|;
name|ok
operator|=
name|true
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process "using SCOPE::NAME" in a class scope.  Return the    USING_DECL created.  */
end_comment

begin_function
name|tree
name|do_class_using_decl
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
comment|/* The USING_DECL returned by this function.  */
name|tree
name|value
decl_stmt|;
comment|/* The declaration (or declarations) name by this using      declaration.  NULL if we are in a template and cannot figure out      what has been named.  */
name|tree
name|decl
decl_stmt|;
comment|/* True if SCOPE is a dependent type.  */
name|bool
name|scope_dependent_p
decl_stmt|;
comment|/* True if SCOPE::NAME is dependent.  */
name|bool
name|name_dependent_p
decl_stmt|;
comment|/* True if any of the bases of CURRENT_CLASS_TYPE are dependent.  */
name|bool
name|bases_dependent_p
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|tree
name|base_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|scope
operator|||
operator|!
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"using-declaration for non-member at class scope"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Make sure the name is not invalid */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"%<%T::%D%> names destructor"
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|constructor_name_p
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<%T::%D%> names constructor"
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|constructor_name_p
argument_list|(
name|name
argument_list|,
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<%T::%D%> names constructor in %qT"
argument_list|,
name|scope
argument_list|,
name|name
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|scope_dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|name_dependent_p
operator|=
operator|(
name|scope_dependent_p
operator|||
operator|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
name|bases_dependent_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|bases_dependent_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* From [namespace.udecl]:         A using-declaration used as a member-declaration shall refer to a        member of a base class of the class being defined.       In general, we cannot check this constraint in a template because      we do not know the entire set of base classes of the current      class type.  However, if all of the base classes are      non-dependent, then we can avoid delaying the check until      instantiation.  */
if|if
condition|(
operator|!
name|scope_dependent_p
condition|)
block|{
name|base_kind
name|b_kind
decl_stmt|;
name|binfo
operator|=
name|lookup_base
argument_list|(
name|current_class_type
argument_list|,
name|scope
argument_list|,
name|ba_any
argument_list|,
operator|&
name|b_kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|b_kind
operator|<
name|bk_proper_base
condition|)
block|{
if|if
condition|(
operator|!
name|bases_dependent_p
condition|)
block|{
name|error_not_base_type
argument_list|(
name|scope
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|name_dependent_p
condition|)
block|{
name|decl
operator|=
name|lookup_member
argument_list|(
name|binfo
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
name|error
argument_list|(
literal|"no members matching %<%T::%D%> in %q#T"
argument_list|,
name|scope
argument_list|,
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* The binfo from which the functions came does not matter.  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|value
operator|=
name|build_lang_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|USING_DECL_DECLS
argument_list|(
name|value
argument_list|)
operator|=
name|decl
expr_stmt|;
name|USING_DECL_SCOPE
argument_list|(
name|value
argument_list|)
operator|=
name|scope
expr_stmt|;
name|DECL_DEPENDENT_P
argument_list|(
name|value
argument_list|)
operator|=
operator|!
name|decl
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the binding value for name in scope.  */
end_comment

begin_function
name|tree
name|namespace_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
else|else
comment|/* Unnecessary for the global namespace because it can't be an alias. */
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|binding
operator|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|binding
condition|?
name|binding
operator|->
name|value
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Set the binding value for name in scope.  */
end_comment

begin_function
name|void
name|set_namespace_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|b
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|NULL_TREE
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
name|b
operator|=
name|binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|value
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|val
operator|==
name|error_mark_node
condition|)
name|b
operator|->
name|value
operator|=
name|val
expr_stmt|;
else|else
name|supplement_binding
argument_list|(
name|b
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the context of a declaration to scope. Complain if we are not    outside scope.  */
end_comment

begin_function
name|void
name|set_decl_namespace
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|bool
name|friendp
parameter_list|)
block|{
name|tree
name|old
decl_stmt|,
name|fn
decl_stmt|;
comment|/* Get rid of namespace aliases.  */
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* It is ok for friends to be qualified in parallel space.  */
if|if
condition|(
operator|!
name|friendp
operator|&&
operator|!
name|is_ancestor
argument_list|(
name|current_namespace
argument_list|,
name|scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"declaration of %qD not in a namespace surrounding %qD"
argument_list|,
name|decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* Writing "int N::i" to declare a variable within "N" is invalid.  */
if|if
condition|(
name|scope
operator|==
name|current_namespace
condition|)
block|{
if|if
condition|(
name|at_namespace_scope_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"explicit qualification in declaration of %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See whether this has been declared in the namespace.  */
name|old
operator|=
name|lookup_qualified_name
argument_list|(
name|scope
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|error_mark_node
condition|)
comment|/* No old declaration at all.  */
goto|goto
name|complain
goto|;
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Don't compare non-function decls with decls_match here, since        it can't check for the correct constness at this        point. pushdecl will find those errors later.  */
return|return;
comment|/* Since decl is a function, old should contain a function decl.  */
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
goto|goto
name|complain
goto|;
name|fn
operator|=
name|OVL_CURRENT
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_associated_namespace
argument_list|(
name|scope
argument_list|,
name|CP_DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
goto|goto
name|complain
goto|;
comment|/* A template can be explicitly specialized in any namespace.  */
if|if
condition|(
name|processing_explicit_instantiation
condition|)
return|return;
if|if
condition|(
name|processing_template_decl
operator|||
name|processing_specialization
condition|)
comment|/* We have not yet called push_template_decl to turn a        FUNCTION_DECL into a TEMPLATE_DECL, so the declarations won't        match.  But, we'll check later, when we construct the        template.  */
return|return;
comment|/* Instantiations or specializations of templates may be declared as      friends in any namespace.  */
if|if
condition|(
name|friendp
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|old
condition|;
name|old
operator|=
name|OVL_NEXT
argument_list|(
name|old
argument_list|)
control|)
if|if
condition|(
name|decls_match
argument_list|(
name|decl
argument_list|,
name|OVL_CURRENT
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|decls_match
argument_list|(
name|decl
argument_list|,
name|old
argument_list|)
condition|)
return|return;
name|complain
label|:
name|error
argument_list|(
literal|"%qD should have been declared inside %qD"
argument_list|,
name|decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the namespace where the current declaration is declared.  */
end_comment

begin_function
specifier|static
name|tree
name|current_decl_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
comment|/* If we have been pushed into a different namespace, use it.  */
if|if
condition|(
name|decl_namespace_list
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|decl_namespace_list
argument_list|)
return|;
if|if
condition|(
name|current_class_type
condition|)
name|result
operator|=
name|decl_namespace_context
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
name|result
operator|=
name|decl_namespace_context
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|current_namespace
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we    select a name that is unique to this compilation unit.  */
end_comment

begin_function
name|void
name|push_namespace
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|push_namespace_with_attribs
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same, but specify attributes to apply to the namespace.  The attributes    only apply to the current namespace-body, not to any later extensions. */
end_comment

begin_function
name|void
name|push_namespace_with_attribs
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|d
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|need_new
init|=
literal|1
decl_stmt|;
name|int
name|implicit_use
init|=
literal|0
decl_stmt|;
name|bool
name|anon
init|=
operator|!
name|name
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* We should not get here if the global_namespace is not yet constructed      nor if NAME designates the global namespace:  The global scope is      constructed elsewhere.  */
name|gcc_assert
argument_list|(
name|global_namespace
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|global_scope_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|anon
condition|)
block|{
name|name
operator|=
name|get_anonymous_namespace_name
argument_list|()
expr_stmt|;
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
comment|/* Reopening anonymous namespace.  */
name|need_new
operator|=
literal|0
expr_stmt|;
name|implicit_use
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Check whether this is an extended namespace definition.  */
name|d
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|need_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"namespace alias %qD not allowed here, assuming %qD"
argument_list|,
name|d
argument_list|,
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need_new
condition|)
block|{
comment|/* Make a new namespace, binding the name to it.  */
name|d
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* The name of this namespace is not visible to other translation 	 units if it is an anonymous namespace or member thereof.  */
if|if
condition|(
name|anon
operator|||
name|decl_anon_ns_mem_p
argument_list|(
name|current_namespace
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|anon
condition|)
block|{
comment|/* Clear DECL_NAME for the benefit of debugging back ends.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|d
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|d
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|begin_scope
argument_list|(
name|sk_namespace
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|resume_scope
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit_use
condition|)
name|do_using_directive
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Enter the name space.  */
name|current_namespace
operator|=
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA_VISIBILITY
comment|/* Clear has_visibility in case a previous namespace-definition had a      visibility attribute and this one doesn't.  */
name|current_binding_level
operator|->
name|has_visibility
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|attributes
init|;
name|d
condition|;
name|d
operator|=
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|is_attribute_p
argument_list|(
literal|"visibility"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute directive ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|x
operator|=
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|STRING_CST
operator|||
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute requires a single NTBS argument"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|current_binding_level
operator|->
name|has_visibility
operator|=
literal|1
expr_stmt|;
name|push_visibility
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|found
label|:
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop from the scope of the current namespace.  */
end_comment

begin_function
name|void
name|pop_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|current_namespace
operator|!=
name|global_namespace
argument_list|)
expr_stmt|;
name|current_namespace
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* The binding level is not popped, as it might be re-opened later.  */
name|leave_scope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push into the scope of the namespace NS, even if it is deeply    nested within another namespace.  */
end_comment

begin_function
name|void
name|push_nested_namespace
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
if|if
condition|(
name|ns
operator|==
name|global_namespace
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
else|else
block|{
name|push_nested_namespace
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|push_namespace
argument_list|(
name|DECL_NAME
argument_list|(
name|ns
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pop back from the scope of the namespace NS, which was previously    entered with push_nested_namespace.  */
end_comment

begin_function
name|void
name|pop_nested_namespace
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
while|while
condition|(
name|ns
operator|!=
name|global_namespace
condition|)
block|{
name|pop_namespace
argument_list|()
expr_stmt|;
name|ns
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporarily set the namespace for the current declaration.  */
end_comment

begin_function
name|void
name|push_decl_namespace
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|decl
operator|=
name|decl_namespace_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl_namespace_list
operator|=
name|tree_cons
argument_list|(
name|ORIGINAL_NAMESPACE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|decl_namespace_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [namespace.memdef]/2 */
end_comment

begin_function
name|void
name|pop_decl_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|decl_namespace_list
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_namespace_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the namespace that is the common ancestor    of two given namespaces.  */
end_comment

begin_function
specifier|static
name|tree
name|namespace_ancestor
parameter_list|(
name|tree
name|ns1
parameter_list|,
name|tree
name|ns2
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ancestor
argument_list|(
name|ns1
argument_list|,
name|ns2
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ns1
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|namespace_ancestor
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|ns1
argument_list|)
argument_list|,
name|ns2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a namespace-alias declaration.  */
end_comment

begin_function
name|void
name|do_namespace_alias
parameter_list|(
name|tree
name|alias
parameter_list|,
name|tree
name|namespace
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
name|error_mark_node
condition|)
return|return;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|)
expr_stmt|;
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
comment|/* Build the alias.  */
name|alias
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|alias
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|alias
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|alias
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_scope
argument_list|()
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|alias
argument_list|)
expr_stmt|;
comment|/* Emit debug info for namespace alias.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|global_decl
call|)
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the current namespace,    if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_namespace_level
parameter_list|(
name|tree
name|x
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|t
operator|=
name|pushdecl_with_scope
argument_list|(
name|x
argument_list|,
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
comment|/* Now, the type_shadowed stack may screw us.  Munge it so it does      what we want.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|newval
decl_stmt|;
name|tree
modifier|*
name|ptr
init|=
operator|(
name|tree
operator|*
operator|)
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|!
name|global_scope_p
argument_list|(
name|b
argument_list|)
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|shadowed
init|=
name|b
operator|->
name|type_shadowed
decl_stmt|;
for|for
control|(
init|;
name|shadowed
condition|;
name|shadowed
operator|=
name|TREE_CHAIN
argument_list|(
name|shadowed
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|name
condition|)
block|{
name|ptr
operator|=
operator|&
name|TREE_VALUE
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
comment|/* Can't break out of the loop here because sometimes 		   a binding level will have duplicate bindings for 		   PT names.  It's gross, but I haven't time to fix it.  */
block|}
block|}
name|newval
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|tree
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* @@ This shouldn't be needed.  My test case "zstring.cc" trips 	     up here if this is changed to an assertion.  --KR  */
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|=
name|newval
expr_stmt|;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert USED into the using list of USER. Set INDIRECT_flag if this    directive is not directly from the source. Also find the common    ancestor and let our users know about the new namespace */
end_comment

begin_function
specifier|static
name|void
name|add_using_namespace
parameter_list|(
name|tree
name|user
parameter_list|,
name|tree
name|used
parameter_list|,
name|bool
name|indirect
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Using oneself is a no-op.  */
if|if
condition|(
name|user
operator|==
name|used
condition|)
block|{
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|user
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|used
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|)
expr_stmt|;
comment|/* Check if we already have this.  */
name|t
operator|=
name|purpose_member
argument_list|(
name|used
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|indirect
condition|)
comment|/* Promote to direct usage.  */
name|TREE_INDIRECT_USING
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add used to the user's using list.  */
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|used
argument_list|,
name|namespace_ancestor
argument_list|(
name|user
argument_list|,
name|used
argument_list|)
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INDIRECT_USING
argument_list|(
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
operator|=
name|indirect
expr_stmt|;
comment|/* Add user to the used's users list.  */
name|DECL_NAMESPACE_USERS
argument_list|(
name|used
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|user
argument_list|,
literal|0
argument_list|,
name|DECL_NAMESPACE_USERS
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursively add all namespaces used.  */
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
comment|/* indirect usage */
name|add_using_namespace
argument_list|(
name|user
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell everyone using us about the new used namespaces.  */
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_USERS
argument_list|(
name|user
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|add_using_namespace
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|used
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a using-declaration not appearing in class or local scope.  */
end_comment

begin_function
name|void
name|do_toplevel_using_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|,
name|newval
decl_stmt|,
name|newtype
decl_stmt|;
name|tree
name|orig_decl
init|=
name|decl
decl_stmt|;
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|decl
operator|=
name|validate_nonmember_using_decl
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
name|binding
operator|=
name|binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|current_namespace
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|binding
operator|->
name|value
expr_stmt|;
name|oldtype
operator|=
name|binding
operator|->
name|type
expr_stmt|;
name|do_nonmember_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|oldval
argument_list|,
name|oldtype
argument_list|,
operator|&
name|newval
argument_list|,
operator|&
name|newtype
argument_list|)
expr_stmt|;
comment|/* Emit debug info.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|cp_emit_debug_info_for_using
argument_list|(
name|orig_decl
argument_list|,
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* Copy declarations found.  */
if|if
condition|(
name|newval
condition|)
name|binding
operator|->
name|value
operator|=
name|newval
expr_stmt|;
if|if
condition|(
name|newtype
condition|)
name|binding
operator|->
name|type
operator|=
name|newtype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a using-directive.  */
end_comment

begin_function
name|void
name|do_using_directive
parameter_list|(
name|tree
name|namespace
parameter_list|)
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|namespace
operator|==
name|error_mark_node
condition|)
return|return;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|USING_STMT
argument_list|,
name|namespace
argument_list|)
argument_list|)
expr_stmt|;
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
name|push_using_directive
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|context
operator|=
name|current_scope
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* direct usage */
name|add_using_namespace
argument_list|(
name|current_namespace
argument_list|,
name|namespace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
block|}
comment|/* Emit debugging info.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|imported_module_or_decl
call|)
argument_list|(
name|namespace
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deal with a using-directive seen by the parser.  Currently we only    handle attributes here, since they cannot appear inside a template.  */
end_comment

begin_function
name|void
name|parse_using_directive
parameter_list|(
name|tree
name|namespace
parameter_list|,
name|tree
name|attribs
parameter_list|)
block|{
name|tree
name|a
decl_stmt|;
name|do_using_directive
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|attribs
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"strong"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"strong using only meaningful at namespace scope"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|namespace
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|is_ancestor
argument_list|(
name|current_namespace
argument_list|,
name|namespace
argument_list|)
condition|)
name|error
argument_list|(
literal|"current namespace %qD does not enclose strongly used namespace %qD"
argument_list|,
name|current_namespace
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|namespace
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|current_namespace
argument_list|,
literal|0
argument_list|,
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|namespace
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qD attribute directive ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the global scope if appropriate.    Calls cp_finish_decl to register the variable, initializing it with    *INIT, if INIT is non-NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|pushdecl_top_level_1
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
modifier|*
name|init
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|x
operator|=
name|pushdecl_namespace_level
argument_list|(
name|x
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|finish_decl
argument_list|(
name|x
argument_list|,
operator|*
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the global scope if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
return|return
name|pushdecl_top_level_1
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl_top_level, but adding the IS_FRIEND parameter.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level_maybe_friend
parameter_list|(
name|tree
name|x
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
return|return
name|pushdecl_top_level_1
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
name|is_friend
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in the global scope if    appropriate.  Calls cp_finish_decl to register the variable,    initializing it with INIT.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level_and_finish
parameter_list|(
name|tree
name|x
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
return|return
name|pushdecl_top_level_1
argument_list|(
name|x
argument_list|,
operator|&
name|init
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Combines two sets of overloaded functions into an OVERLOAD chain, removing    duplicates.  The first list becomes the tail of the result.     The algorithm is O(n^2).  We could get this down to O(n log n) by    doing a sort on the addresses of the functions, if that becomes    necessary.  */
end_comment

begin_function
specifier|static
name|tree
name|merge_functions
parameter_list|(
name|tree
name|s1
parameter_list|,
name|tree
name|s2
parameter_list|)
block|{
for|for
control|(
init|;
name|s2
condition|;
name|s2
operator|=
name|OVL_NEXT
argument_list|(
name|s2
argument_list|)
control|)
block|{
name|tree
name|fn2
init|=
name|OVL_CURRENT
argument_list|(
name|s2
argument_list|)
decl_stmt|;
name|tree
name|fns1
decl_stmt|;
for|for
control|(
name|fns1
operator|=
name|s1
init|;
name|fns1
condition|;
name|fns1
operator|=
name|OVL_NEXT
argument_list|(
name|fns1
argument_list|)
control|)
block|{
name|tree
name|fn1
init|=
name|OVL_CURRENT
argument_list|(
name|fns1
argument_list|)
decl_stmt|;
comment|/* If the function from S2 is already in S1, there is no 	     need to add it again.  For `extern "C"' functions, we 	     might have two FUNCTION_DECLs for the same function, in 	     different namespaces; again, we only need one of them.  */
if|if
condition|(
name|fn1
operator|==
name|fn2
operator|||
operator|(
name|DECL_EXTERN_C_P
argument_list|(
name|fn1
argument_list|)
operator|&&
name|DECL_EXTERN_C_P
argument_list|(
name|fn2
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|fn1
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|fn2
argument_list|)
operator|)
condition|)
break|break;
block|}
comment|/* If we exhausted all of the functions in S1, FN2 is new.  */
if|if
condition|(
operator|!
name|fns1
condition|)
name|s1
operator|=
name|build_overload
argument_list|(
name|fn2
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/* This should return an error not all definitions define functions.    It is not an error if we find two functions with exactly the    same signature, only if these are selected in overload resolution.    old is the current set of bindings, new the freshly-found binding.    XXX Do we want to give *all* candidates in case of ambiguity?    XXX In what way should I treat extern declarations?    XXX I don't want to repeat the entire duplicate_decls here */
end_comment

begin_comment
comment|/* LLVM LOCAL begin mainline */
end_comment

begin_function
specifier|static
name|void
name|ambiguous_decl
parameter_list|(
name|struct
name|scope_binding
modifier|*
name|old
parameter_list|,
name|cxx_binding
modifier|*
name|new
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|val
decl_stmt|,
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
name|old
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy the type.  */
name|type
operator|=
name|new
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
operator|||
operator|(
name|type
operator|&&
name|hidden_name_p
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HIDDEN
operator|)
operator|)
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Copy the value.  */
name|val
operator|=
name|new
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|hidden_name_p
argument_list|(
name|val
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HIDDEN
operator|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
else|else
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
comment|/* If we expect types or namespaces, and not templates, 	       or this is not a template class.  */
if|if
condition|(
operator|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
operator|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
operator|||
operator|(
name|type
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|LOOKUP_TYPES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Ignore built-in functions that are still anticipated.  */
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* If val is hidden, shift down any class or enumeration name.  */
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|val
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* LLVM LOCAL end mainline */
if|if
condition|(
operator|!
name|old
operator|->
name|value
condition|)
name|old
operator|->
name|value
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&&
name|val
operator|!=
name|old
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|old
operator|->
name|value
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|old
operator|->
name|value
operator|=
name|merge_functions
argument_list|(
name|old
operator|->
name|value
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|old
operator|->
name|value
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|old
operator|->
name|value
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|old
operator|->
name|value
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
comment|/* LLVM LOCAL begin mainline */
if|if
condition|(
operator|!
name|old
operator|->
name|type
condition|)
name|old
operator|->
name|type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&&
name|old
operator|->
name|type
operator|!=
name|type
condition|)
block|{
name|old
operator|->
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|old
operator|->
name|type
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|old
operator|->
name|type
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* LLVM LOCAL end mainline */
block|}
end_function

begin_comment
comment|/* Return the declarations that are members of the namespace NS.  */
end_comment

begin_function
name|tree
name|cp_namespace_decls
parameter_list|(
name|tree
name|ns
parameter_list|)
block|{
return|return
name|NAMESPACE_LEVEL
argument_list|(
name|ns
argument_list|)
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Combine prefer_type and namespaces_only into flags.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_flags
parameter_list|(
name|int
name|prefer_type
parameter_list|,
name|int
name|namespaces_only
parameter_list|)
block|{
if|if
condition|(
name|namespaces_only
condition|)
return|return
name|LOOKUP_PREFER_NAMESPACES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|1
condition|)
return|return
name|LOOKUP_PREFER_TYPES
return|;
if|if
condition|(
name|prefer_type
operator|>
literal|0
condition|)
return|return
name|LOOKUP_PREFER_BOTH
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a lookup that returned VAL, use FLAGS to decide if we want to    ignore it or not.  Subroutine of lookup_name_real and    lookup_type_scope.  */
end_comment

begin_function
specifier|static
name|bool
name|qualify_lookup
parameter_list|(
name|tree
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_NAMESPACES
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|flags
operator|&
operator|(
name|LOOKUP_PREFER_NAMESPACES
operator||
name|LOOKUP_PREFER_TYPES
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Given a lookup that returned VAL, decide if we want to ignore it or    not based on DECL_ANTICIPATED.  */
end_comment

begin_function
name|bool
name|hidden_name_p
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|val
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|val
argument_list|)
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Remove any hidden friend functions from a possibly overloaded set    of functions.  */
end_comment

begin_function
name|tree
name|remove_hidden_names
parameter_list|(
name|tree
name|fns
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fns
condition|)
return|return
name|fns
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|hidden_name_p
argument_list|(
name|fns
argument_list|)
condition|)
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
name|tree
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|fns
init|;
name|o
condition|;
name|o
operator|=
name|OVL_NEXT
argument_list|(
name|o
argument_list|)
control|)
if|if
condition|(
name|hidden_name_p
argument_list|(
name|OVL_CURRENT
argument_list|(
name|o
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|o
condition|)
block|{
name|tree
name|n
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|o
operator|=
name|fns
init|;
name|o
condition|;
name|o
operator|=
name|OVL_NEXT
argument_list|(
name|o
argument_list|)
control|)
if|if
condition|(
operator|!
name|hidden_name_p
argument_list|(
name|OVL_CURRENT
argument_list|(
name|o
argument_list|)
argument_list|)
condition|)
name|n
operator|=
name|build_overload
argument_list|(
name|OVL_CURRENT
argument_list|(
name|o
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fns
operator|=
name|n
expr_stmt|;
block|}
block|}
return|return
name|fns
return|;
block|}
end_function

begin_comment
comment|/* Unscoped lookup of a global: iterate over current namespaces,    considering using-directives.  */
end_comment

begin_function
specifier|static
name|tree
name|unqualified_namespace_lookup
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|initial
init|=
name|current_decl_namespace
argument_list|()
decl_stmt|;
name|tree
name|scope
init|=
name|initial
decl_stmt|;
name|tree
name|siter
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|val
condition|;
name|scope
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|scope
argument_list|)
control|)
block|{
name|struct
name|scope_binding
name|binding
init|=
name|EMPTY_SCOPE_BINDING
decl_stmt|;
name|cxx_binding
modifier|*
name|b
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
comment|/* LLVM LOCAL mainline */
name|ambiguous_decl
argument_list|(
operator|&
name|binding
argument_list|,
name|b
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Add all _DECLs seen through local using-directives.  */
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
operator|->
name|kind
operator|!=
name|sk_namespace
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
operator|&
name|binding
argument_list|,
name|level
operator|->
name|using_directives
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|)
condition|)
comment|/* Give up because of error.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* Add all _DECLs seen through global using-directives.  */
comment|/* XXX local and global using lists should work equally.  */
name|siter
operator|=
name|initial
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_using_namespace
argument_list|(
name|name
argument_list|,
operator|&
name|binding
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|siter
argument_list|)
argument_list|,
name|scope
argument_list|,
name|flags
argument_list|)
condition|)
comment|/* Give up because of error.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|siter
operator|==
name|scope
condition|)
break|break;
name|siter
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|siter
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|binding
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|global_namespace
condition|)
break|break;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL    or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type    bindings.     Returns a DECL (or OVERLOAD, or BASELINK) representing the    declaration found.  If no suitable declaration can be found,    ERROR_MARK_NODE is returned.  If COMPLAIN is true and SCOPE is    neither a class-type nor a namespace a diagnostic is issued.  */
end_comment

begin_function
name|tree
name|lookup_qualified_name
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|,
name|bool
name|is_type_p
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|struct
name|scope_binding
name|binding
init|=
name|EMPTY_SCOPE_BINDING
decl_stmt|;
name|flags
operator||=
name|LOOKUP_COMPLAIN
expr_stmt|;
if|if
condition|(
name|is_type_p
condition|)
name|flags
operator||=
name|LOOKUP_PREFER_TYPES
expr_stmt|;
if|if
condition|(
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
operator|&
name|binding
argument_list|,
name|flags
argument_list|)
condition|)
name|t
operator|=
name|binding
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_type
argument_list|(
name|scope
argument_list|,
name|complain
argument_list|)
condition|)
name|t
operator|=
name|lookup_member
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
literal|2
argument_list|,
name|is_type_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|error_mark_node
return|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of unqualified_namespace_lookup:    Add the bindings of NAME in used namespaces to VAL.    We are currently looking for names in namespace SCOPE, so we    look through USINGS for using-directives of namespaces    which have SCOPE as a common ancestor with the current scope.    Returns false on errors.  */
end_comment

begin_function
specifier|static
name|bool
name|lookup_using_namespace
parameter_list|(
name|tree
name|name
parameter_list|,
name|struct
name|scope_binding
modifier|*
name|val
parameter_list|,
name|tree
name|usings
parameter_list|,
name|tree
name|scope
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|iter
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Iterate over all used namespaces in current, searching for using      directives of scope.  */
for|for
control|(
name|iter
operator|=
name|usings
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|iter
argument_list|)
operator|==
name|scope
condition|)
block|{
name|tree
name|used
init|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
decl_stmt|;
name|cxx_binding
modifier|*
name|val1
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|used
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* Resolve ambiguities.  */
if|if
condition|(
name|val1
condition|)
comment|/* LLVM LOCAL mainline */
name|ambiguous_decl
argument_list|(
name|val
argument_list|,
name|val1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
operator|->
name|value
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [namespace.qual]    Accepts the NAME to lookup and its qualifying SCOPE.    Returns the name/type pair found into the cxx_binding *RESULT,    or false on error.  */
end_comment

begin_function
specifier|static
name|bool
name|qualified_lookup_using_namespace
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|scope
parameter_list|,
name|struct
name|scope_binding
modifier|*
name|result
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Maintain a list of namespaces visited...  */
name|tree
name|seen
init|=
name|NULL_TREE
decl_stmt|;
comment|/* ... and a list of namespace yet to see.  */
name|tree
name|todo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|todo_maybe
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|usings
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Look through namespace aliases.  */
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
while|while
condition|(
name|scope
operator|&&
name|result
operator|->
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|cxx_binding
modifier|*
name|binding
init|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|scope
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|seen
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
condition|)
comment|/* LLVM LOCAL mainline */
name|ambiguous_decl
argument_list|(
name|result
argument_list|,
name|binding
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Consider strong using directives always, and non-strong ones 	 if we haven't found a binding yet.  ??? Shouldn't we consider 	 non-strong ones if the initial RESULT is non-NULL, but the 	 binding in the given namespace is?  */
for|for
control|(
name|usings
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|scope
argument_list|)
init|;
name|usings
condition|;
name|usings
operator|=
name|TREE_CHAIN
argument_list|(
name|usings
argument_list|)
control|)
comment|/* If this was a real directive, and we have not seen it.  */
if|if
condition|(
operator|!
name|TREE_INDIRECT_USING
argument_list|(
name|usings
argument_list|)
condition|)
block|{
comment|/* Try to avoid queuing the same namespace more than once, 	       the exception being when a namespace was already 	       enqueued for todo_maybe and then a strong using is 	       found for it.  We could try to remove it from 	       todo_maybe, but it's probably not worth the effort.  */
if|if
condition|(
name|is_associated_namespace
argument_list|(
name|scope
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|seen
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|todo
argument_list|)
condition|)
name|todo
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|!
name|result
operator|->
name|value
operator|&&
operator|!
name|result
operator|->
name|type
operator|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|seen
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|todo
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|todo_maybe
argument_list|)
condition|)
name|todo_maybe
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo_maybe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|todo
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|todo_maybe
operator|&&
operator|(
operator|!
name|result
operator|->
name|value
operator|&&
operator|!
name|result
operator|->
name|type
operator|)
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo_maybe
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo_maybe
argument_list|)
expr_stmt|;
name|todo_maybe
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there never was a todo list.  */
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|result
operator|->
name|value
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the innermost non-namespace binding for NAME from a scope    containing BINDING, or, if BINDING is NULL, the current scope.  If    CLASS_P is false, then class bindings are ignored.  */
end_comment

begin_function
name|cxx_binding
modifier|*
name|outer_binding
parameter_list|(
name|tree
name|name
parameter_list|,
name|cxx_binding
modifier|*
name|binding
parameter_list|,
name|bool
name|class_p
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|outer
decl_stmt|;
name|cxx_scope
modifier|*
name|scope
decl_stmt|;
name|cxx_scope
modifier|*
name|outer_scope
decl_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
name|scope
operator|=
name|binding
operator|->
name|scope
operator|->
name|level_chain
expr_stmt|;
name|outer
operator|=
name|binding
operator|->
name|previous
expr_stmt|;
block|}
else|else
block|{
name|scope
operator|=
name|current_binding_level
expr_stmt|;
name|outer
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|outer_scope
operator|=
name|outer
condition|?
name|outer
operator|->
name|scope
else|:
name|NULL
expr_stmt|;
comment|/* Because we create class bindings lazily, we might be missing a      class binding for NAME.  If there are any class binding levels      between the LAST_BINDING_LEVEL and the scope in which OUTER was      declared, we must lookup NAME in those class scopes.  */
if|if
condition|(
name|class_p
condition|)
while|while
condition|(
name|scope
operator|&&
name|scope
operator|!=
name|outer_scope
operator|&&
name|scope
operator|->
name|kind
operator|!=
name|sk_namespace
condition|)
block|{
if|if
condition|(
name|scope
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|cxx_binding
modifier|*
name|class_binding
decl_stmt|;
name|class_binding
operator|=
name|get_class_binding
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_binding
condition|)
block|{
comment|/* Thread this new class-scope binding onto the 		   IDENTIFIER_BINDING list so that future lookups 		   find it quickly.  */
name|class_binding
operator|->
name|previous
operator|=
name|outer
expr_stmt|;
if|if
condition|(
name|binding
condition|)
name|binding
operator|->
name|previous
operator|=
name|class_binding
expr_stmt|;
else|else
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|=
name|class_binding
expr_stmt|;
return|return
name|class_binding
return|;
block|}
block|}
name|scope
operator|=
name|scope
operator|->
name|level_chain
expr_stmt|;
block|}
return|return
name|outer
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost block-scope or class-scope value binding for    NAME, or NULL_TREE if there is no such binding.  */
end_comment

begin_function
name|tree
name|innermost_non_namespace_value
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
name|outer_binding
argument_list|(
name|name
argument_list|,
comment|/*binding=*/
name|NULL
argument_list|,
comment|/*class_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|binding
condition|?
name|binding
operator|->
name|value
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the current binding level and its superiors in the    namespace of variables, functions and typedefs.  Return a ..._DECL    node of some kind representing its definition if there is only one    such declaration, or return a TREE_LIST with all the overloaded    definitions if there are many, or return 0 if it is undefined.    Hidden name, either friend declaration or built-in function, are    not ignored.     If PREFER_TYPE is> 0, we prefer TYPE_DECLs or namespaces.    If PREFER_TYPE is> 1, we reject non-type decls (e.g. namespaces).    Otherwise we prefer non-TYPE_DECLs.     If NONCLASS is nonzero, bindings in class scopes are ignored.  If    BLOCK_P is false, bindings in block scopes are ignored.  */
end_comment

begin_function
name|tree
name|lookup_name_real
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|prefer_type
parameter_list|,
name|int
name|nonclass
parameter_list|,
name|bool
name|block_p
parameter_list|,
name|int
name|namespaces_only
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|iter
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Conversion operators are handled specially because ordinary      unqualified name lookup will not find template conversion      operators.  */
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
operator|&&
name|level
operator|->
name|kind
operator|!=
name|sk_namespace
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|tree
name|class_type
decl_stmt|;
name|tree
name|operators
decl_stmt|;
comment|/* A conversion operator can only be declared in a class 	     scope.  */
if|if
condition|(
name|level
operator|->
name|kind
operator|!=
name|sk_class
condition|)
continue|continue;
comment|/* Lookup the conversion operator in the class.  */
name|class_type
operator|=
name|level
operator|->
name|this_entity
expr_stmt|;
name|operators
operator|=
name|lookup_fnfields
argument_list|(
name|class_type
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|operators
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|operators
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|flags
operator||=
name|lookup_flags
argument_list|(
name|prefer_type
argument_list|,
name|namespaces_only
argument_list|)
expr_stmt|;
comment|/* First, look in non-namespace scopes.  */
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
name|nonclass
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|block_p
operator|||
operator|!
name|nonclass
condition|)
for|for
control|(
name|iter
operator|=
name|outer_binding
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
operator|!
name|nonclass
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|outer_binding
argument_list|(
name|name
argument_list|,
name|iter
argument_list|,
operator|!
name|nonclass
argument_list|)
control|)
block|{
name|tree
name|binding
decl_stmt|;
comment|/* Skip entities we don't want.  */
if|if
condition|(
name|LOCAL_BINDING_P
argument_list|(
name|iter
argument_list|)
condition|?
operator|!
name|block_p
else|:
name|nonclass
condition|)
continue|continue;
comment|/* If this is the kind of thing we're looking for, we're done.  */
if|if
condition|(
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|value
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|iter
operator|->
name|value
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PREFER_TYPES
operator|)
operator|&&
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|type
argument_list|,
name|flags
argument_list|)
condition|)
name|binding
operator|=
name|iter
operator|->
name|type
expr_stmt|;
else|else
name|binding
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|binding
condition|)
block|{
if|if
condition|(
name|hidden_name_p
argument_list|(
name|binding
argument_list|)
condition|)
block|{
comment|/* A non namespace-scope binding can only be hidden if 		   we are in a local class, due to friend declarations. 		   In particular, consider:  		   void f() { 		     struct A { 		       friend struct B; 		       void g() { B* b; } // error: B is hidden 		     } 		     struct B {}; 		   }  		   The standard says that "B" is a local class in "f" 		   (but not nested within "A") -- but that name lookup 		   for "B" does not find this declaration until it is 		   declared directly with "f".  		   In particular:  		   [class.friend]  		   If a friend declaration appears in a local class and 		   the name specified is an unqualified name, a prior 		   declaration is looked up without considering scopes 		   that are outside the innermost enclosing non-class 		   scope. For a friend class declaration, if there is no 		   prior declaration, the class that is specified  		   belongs to the innermost enclosing non-class scope, 		   but if it is subsequently referenced, its name is not 		   found by name lookup until a matching declaration is 		   provided in the innermost enclosing nonclass scope. 		*/
name|gcc_assert
argument_list|(
name|current_class_type
operator|&&
name|LOCAL_CLASS_P
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This binding comes from a friend declaration in the local 		   class. The standard (11.4.8) states that the lookup can 		   only succeed if there is a non-hidden declaration in the 		   current scope, which is not the case here.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|binding
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now lookup in namespace scopes.  */
if|if
condition|(
operator|!
name|val
condition|)
name|val
operator|=
name|unqualified_namespace_lookup
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* If we have a single function from a using decl, pull it out.  */
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|OVERLOAD
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|OVL_FUNCTION
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|lookup_name_nonclass
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_function_nonclass
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|bool
name|block_p
parameter_list|)
block|{
return|return
name|lookup_arg_dependent
argument_list|(
name|name
argument_list|,
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|block_p
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_name_prefer_type
parameter_list|(
name|tree
name|name
parameter_list|,
name|int
name|prefer_type
parameter_list|)
block|{
return|return
name|lookup_name_real
argument_list|(
name|name
argument_list|,
name|prefer_type
argument_list|,
literal|0
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME for type used in elaborated name specifier in    the scopes given by SCOPE.  SCOPE can be either TS_CURRENT or    TS_WITHIN_ENCLOSING_NON_CLASS.  Although not implied by the    name, more scopes are checked if cleanup or template parameter    scope is encountered.     Unlike lookup_name_real, we make sure that NAME is actually    declared in the desired scope, not from inheritance, nor using    directive.  For using declaration, there is DR138 still waiting    to be resolved.  Hidden name coming from an earlier friend    declaration is also returned.     A TYPE_DECL best matching the NAME is returned.  Catching error    and issuing diagnostics are caller's responsibility.  */
end_comment

begin_function
name|tree
name|lookup_type_scope
parameter_list|(
name|tree
name|name
parameter_list|,
name|tag_scope
name|scope
parameter_list|)
block|{
name|cxx_binding
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Look in non-namespace scope first.  */
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_namespace
condition|)
name|iter
operator|=
name|outer_binding
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
comment|/*class_p=*/
name|true
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|iter
condition|;
name|iter
operator|=
name|outer_binding
argument_list|(
name|name
argument_list|,
name|iter
argument_list|,
comment|/*class_p=*/
name|true
argument_list|)
control|)
block|{
comment|/* Check if this is the kind of thing we're looking for. 	 If SCOPE is TS_CURRENT, also make sure it doesn't come from 	 base class.  For ITER->VALUE, we can simply use 	 INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to use 	 our own check.  	 We check ITER->TYPE before ITER->VALUE in order to handle 	   typedef struct C {} C; 	 correctly.  */
if|if
condition|(
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|type
argument_list|,
name|LOOKUP_PREFER_TYPES
argument_list|)
operator|&&
operator|(
name|scope
operator|!=
name|ts_current
operator|||
name|LOCAL_BINDING_P
argument_list|(
name|iter
argument_list|)
operator|||
name|DECL_CONTEXT
argument_list|(
name|iter
operator|->
name|type
argument_list|)
operator|==
name|iter
operator|->
name|scope
operator|->
name|this_entity
operator|)
condition|)
name|val
operator|=
name|iter
operator|->
name|type
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scope
operator|!=
name|ts_current
operator|||
operator|!
name|INHERITED_VALUE_BINDING_P
argument_list|(
name|iter
argument_list|)
operator|)
operator|&&
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|value
argument_list|,
name|LOOKUP_PREFER_TYPES
argument_list|)
condition|)
name|val
operator|=
name|iter
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|val
condition|)
break|break;
block|}
comment|/* Look in namespace scope.  */
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|iter
operator|=
name|cxx_scope_find_binding_for_name
argument_list|(
name|NAMESPACE_LEVEL
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
condition|)
block|{
comment|/* If this is the kind of thing we're looking for, we're done.  */
if|if
condition|(
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|type
argument_list|,
name|LOOKUP_PREFER_TYPES
argument_list|)
condition|)
name|val
operator|=
name|iter
operator|->
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|qualify_lookup
argument_list|(
name|iter
operator|->
name|value
argument_list|,
name|LOOKUP_PREFER_TYPES
argument_list|)
condition|)
name|val
operator|=
name|iter
operator|->
name|value
expr_stmt|;
block|}
block|}
comment|/* Type found, check if it is in the allowed scopes, ignoring cleanup      and template parameter scopes.  */
if|if
condition|(
name|val
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|b
condition|)
block|{
if|if
condition|(
name|iter
operator|->
name|scope
operator|==
name|b
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
operator|||
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|&&
name|scope
operator|==
name|ts_within_enclosing_non_class
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only in the innermost non-class    binding level.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_innermost_nonclass_level
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|b
operator|=
name|innermost_nonclass_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_namespace
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* extern "C" function() */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
operator|&&
name|LOCAL_BINDING_P
argument_list|(
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|cxx_binding
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|binding
operator|->
name|scope
operator|==
name|b
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|binding
operator|->
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|binding
operator|->
name|value
argument_list|)
operator|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|binding
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like lookup_name_innermost_nonclass_level, but for types.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_type_current_level
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|global_type_node
condition|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|type_shadowed
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
else|else
break|break;
block|}
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [basic.lookup.koenig] */
end_comment

begin_comment
comment|/* A nonzero return value in the functions below indicates an error.  */
end_comment

begin_struct
struct|struct
name|arg_lookup
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|namespaces
decl_stmt|;
name|tree
name|classes
decl_stmt|;
name|tree
name|functions
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bool
name|arg_assoc
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_args
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_type
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|add_function
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_namespace
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_class
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arg_assoc_template_arg
parameter_list|(
name|struct
name|arg_lookup
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add a function to the lookup structure.    Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|add_function
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
comment|/* We used to check here to see if the function was already in the list,      but that's O(n^2), which is just too expensive for function lookup.      Now we deal with the occasional duplicate in joust.  In doing this, we      assume that the number of duplicates will be small compared to the      total number of functions being compared, which should usually be the      case.  */
comment|/* We must find only functions, or exactly one non-function.  */
if|if
condition|(
operator|!
name|k
operator|->
name|functions
condition|)
name|k
operator|->
name|functions
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|==
name|k
operator|->
name|functions
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|k
operator|->
name|functions
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|k
operator|->
name|functions
operator|=
name|build_overload
argument_list|(
name|fn
argument_list|,
name|k
operator|->
name|functions
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|f1
init|=
name|OVL_CURRENT
argument_list|(
name|k
operator|->
name|functions
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|fn
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|f1
argument_list|)
condition|)
block|{
name|fn
operator|=
name|f1
expr_stmt|;
name|f1
operator|=
name|f2
expr_stmt|;
name|f2
operator|=
name|fn
expr_stmt|;
block|}
name|error
argument_list|(
literal|"%q+D is not a function,"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  conflict with %q+D"
argument_list|,
name|f2
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  in call to %qD"
argument_list|,
name|k
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff CURRENT has declared itself to be an associated    namespace of SCOPE via a strong using-directive (or transitive chain    thereof).  Both are namespaces.  */
end_comment

begin_function
name|bool
name|is_associated_namespace
parameter_list|(
name|tree
name|current
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|tree
name|seen
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|todo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|scope
operator|==
name|current
condition|)
return|return
name|true
return|;
name|seen
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|scope
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|seen
argument_list|)
condition|)
name|todo
operator|=
name|tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo
argument_list|)
expr_stmt|;
if|if
condition|(
name|todo
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether FN is a friend of an associated class of ARG.  */
end_comment

begin_function
specifier|static
name|bool
name|friend_of_associated_class_p
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
name|type
operator|=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|false
return|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If TYPE is a class, the class itself and all base classes are      associated classes.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_friend
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_friend
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
comment|/* If TYPE is a class member, the class of which it is a member is      an associated class.  */
if|if
condition|(
operator|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|is_friend
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add functions of a namespace to the lookup structure.    Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_namespace
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|scope
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|purpose_member
argument_list|(
name|scope
argument_list|,
name|k
operator|->
name|namespaces
argument_list|)
condition|)
return|return
literal|0
return|;
name|k
operator|->
name|namespaces
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|k
operator|->
name|namespaces
argument_list|)
expr_stmt|;
comment|/* Check out our super-users.  */
for|for
control|(
name|value
operator|=
name|DECL_NAMESPACE_ASSOCIATIONS
argument_list|(
name|scope
argument_list|)
init|;
name|value
condition|;
name|value
operator|=
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
control|)
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|value
operator|=
name|namespace_binding
argument_list|(
name|k
operator|->
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
name|value
condition|;
name|value
operator|=
name|OVL_NEXT
argument_list|(
name|value
argument_list|)
control|)
block|{
comment|/* We don't want to find arbitrary hidden functions via argument 	 dependent lookup.  We only want to find friends of associated 	 classes.  */
if|if
condition|(
name|hidden_name_p
argument_list|(
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|args
decl_stmt|;
for|for
control|(
name|args
operator|=
name|k
operator|->
name|args
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
if|if
condition|(
name|friend_of_associated_class_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|args
condition|)
continue|continue;
block|}
if|if
condition|(
name|add_function
argument_list|(
name|k
argument_list|,
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a template argument to the lookup    structure.  Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_template_arg
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
comment|/* [basic.lookup.koenig]       If T is a template-id, its associated namespaces and classes are      ... the namespaces and classes associated with the types of the      template arguments provided for template type parameters      (excluding template template parameters); the namespaces in which      any template template arguments are defined; and the classes in      which any member templates used as template template arguments      are defined.  [Note: non-type template arguments do not      contribute to the set of associated namespaces.  ]  */
comment|/* Consider first template template arguments.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|ctx
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* It's not a member template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
return|;
comment|/* Otherwise, it must be member template.  */
else|else
return|return
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
return|;
block|}
comment|/* It's not a template template argument, but it is a type template      argument.  */
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|arg
argument_list|)
return|;
comment|/* It's a non-type template argument.  */
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with class to the lookup structure.    Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_class
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|list
decl_stmt|,
name|friends
decl_stmt|,
name|context
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Backend build structures, such as __builtin_va_list, aren't      affected by all this.  */
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|purpose_member
argument_list|(
name|type
argument_list|,
name|k
operator|->
name|classes
argument_list|)
condition|)
return|return
name|false
return|;
name|k
operator|->
name|classes
operator|=
name|tree_cons
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|k
operator|->
name|classes
argument_list|)
expr_stmt|;
name|context
operator|=
name|decl_namespace_context
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|context
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Process baseclasses.  */
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* Process friends.  */
for|for
control|(
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
if|if
condition|(
name|k
operator|->
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
for|for
control|(
name|friends
operator|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
decl_stmt|;
comment|/* Only interested in global functions with potentially hidden 	     (i.e. unqualified) declarations.  */
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|!=
name|context
condition|)
continue|continue;
comment|/* Template specializations are never found by name lookup. 	     (Templates themselves can be found, but not template 	     specializations.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_USE_TEMPLATE
argument_list|(
name|fn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|add_function
argument_list|(
name|k
argument_list|,
name|fn
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* Process template arguments.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|list
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|list
argument_list|)
condition|;
operator|++
name|i
control|)
name|arg_assoc_template_arg
argument_list|(
name|k
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a given type.    Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_type
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* As we do not get the type of non-type dependent expressions      right, we can end up with such things without a type.  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Pointer to member: associate class type and value type.  */
if|if
condition|(
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|false
return|;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|false
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|type
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|decl_namespace_context
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
comment|/* The basetype is referenced in the first arg type, so just 	 fall through.  */
case|case
name|FUNCTION_TYPE
case|:
comment|/* Associate the parameter types.  */
if|if
condition|(
name|arg_assoc_args
argument_list|(
name|k
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Associate the return type.  */
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
return|return
name|false
return|;
case|case
name|TYPENAME_TYPE
case|:
return|return
name|false
return|;
case|case
name|LANG_TYPE
case|:
name|gcc_assert
argument_list|(
name|type
operator|==
name|unknown_type_node
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with arguments.  Returns true on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc_args
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
if|if
condition|(
name|arg_assoc
argument_list|(
name|k
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a given tree_node.  Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|bool
name|arg_assoc
parameter_list|(
name|struct
name|arg_lookup
modifier|*
name|k
parameter_list|,
name|tree
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
operator|!
name|type_unknown_p
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|n
operator|=
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|BASELINK
condition|)
name|n
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* [basic.lookup.koenig]  	 If T is a template-id, its associated namespaces and classes 	 are the namespace in which the template is defined; for 	 member templates, the member template's class...  */
name|tree
name|template
init|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|template
operator|=
name|TREE_OPERAND
argument_list|(
name|template
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* First, the template.  There may actually be more than one if 	 this is an overloaded function template.  But, in that case, 	 we only need the first; all the functions will be in the same 	 namespace.  */
name|template
operator|=
name|OVL_CURRENT
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
name|true
return|;
block|}
comment|/* It must be a member template.  */
elseif|else
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
name|true
return|;
comment|/* Now the arguments.  */
if|if
condition|(
name|args
condition|)
for|for
control|(
name|ix
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
init|;
name|ix
operator|--
condition|;
control|)
if|if
condition|(
name|arg_assoc_template_arg
argument_list|(
name|k
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|ix
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|OVL_CHAIN
argument_list|(
name|n
argument_list|)
control|)
if|if
condition|(
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Performs Koenig lookup depending on arguments, where fns    are the functions found in normal lookup.  */
end_comment

begin_function
name|tree
name|lookup_arg_dependent
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|fns
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|struct
name|arg_lookup
name|k
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Remove any hidden friend functions from the list of functions      found so far.  They will be added back by arg_assoc_class as      appropriate.  */
name|fns
operator|=
name|remove_hidden_names
argument_list|(
name|fns
argument_list|)
expr_stmt|;
name|k
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|k
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|k
operator|.
name|functions
operator|=
name|fns
expr_stmt|;
name|k
operator|.
name|classes
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We previously performed an optimization here by setting      NAMESPACES to the current namespace when it was safe. However, DR      164 says that namespaces that were already searched in the first      stage of template processing are searched again (potentially      picking up later definitions) in the second stage. */
name|k
operator|.
name|namespaces
operator|=
name|NULL_TREE
expr_stmt|;
name|arg_assoc_args
argument_list|(
operator|&
name|k
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fns
operator|=
name|k
operator|.
name|functions
expr_stmt|;
if|if
condition|(
name|fns
operator|&&
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"argument dependent lookup finds %q+D"
argument_list|,
name|fns
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  in call to %qD"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fns
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add namespace to using_directives. Return NULL_TREE if nothing was    changed (i.e. there was already a directive), or the fresh    TREE_LIST otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|push_using_directive
parameter_list|(
name|tree
name|used
parameter_list|)
block|{
name|tree
name|ud
init|=
name|current_binding_level
operator|->
name|using_directives
decl_stmt|;
name|tree
name|iter
decl_stmt|,
name|ancestor
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Check if we already have this.  */
if|if
condition|(
name|purpose_member
argument_list|(
name|used
argument_list|,
name|ud
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|namespace_ancestor
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ud
operator|=
name|current_binding_level
operator|->
name|using_directives
expr_stmt|;
name|ud
operator|=
name|tree_cons
argument_list|(
name|used
argument_list|,
name|ancestor
argument_list|,
name|ud
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|using_directives
operator|=
name|ud
expr_stmt|;
comment|/* Recursively add all namespaces used.  */
for|for
control|(
name|iter
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
name|push_using_directive
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The type TYPE is being declared.  If it is a class template, or a    specialization of a class template, do any processing required and    perform error-checking.  If IS_FRIEND is nonzero, this TYPE is    being declared a friend.  B is the binding level at which this TYPE    should be bound.     Returns the TYPE_DECL for TYPE, which may have been altered by this    processing.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_process_template_type_declaration
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|is_friend
parameter_list|,
name|cxx_scope
modifier|*
name|b
parameter_list|)
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_parmlist
condition|)
comment|/* You can't declare a new template type in a template parameter        list.  But, you can declare a non-template type:  	 template<class A*> struct S;         is a forward-declaration of `A'.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_namespace
operator|&&
name|current_binding_level
operator|->
name|kind
operator|!=
name|sk_namespace
condition|)
comment|/* If this new type is being injected into a containing scope,        then it's not a template type.  */
empty_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* This may change after the call to 	     push_template_decl_real, but we want the original value.  */
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
comment|/* If the current binding level is the binding level for the 	     template parameters (see the comment in 	     begin_template_parm_list) and the enclosing level is a class 	     scope, and we're not looking at a friend, push the 	     declaration of the member class into the class scope.  In the 	     friend case, push_template_decl will already have put the 	     friend into global scope, if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
name|is_friend
operator|&&
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
name|finish_member_declaration
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Put this UTD in the table of UTDs for the class.  */
if|if
condition|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL
condition|)
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|binding_table_new
argument_list|(
name|SCOPE_DEFAULT_HT_SIZE
argument_list|)
expr_stmt|;
name|binding_table_insert
argument_list|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Push a tag name NAME for struct/class/union/enum type TYPE.  In case    that the NAME is a class template, the tag is processed but not pushed.     The pushed scope depend on the SCOPE parameter:    - When SCOPE is TS_CURRENT, put it into the inner-most non-sk_cleanup      scope.    - When SCOPE is TS_GLOBAL, put it in the inner-most non-class and      non-template-parameter scope.  This case is needed for forward      declarations.    - When SCOPE is TS_WITHIN_ENCLOSING_NON_CLASS, this is similar to      TS_GLOBAL case except that names within template-parameter scopes      are not pushed at all.     Returns TYPE upon success and ERROR_MARK_NODE otherwise.  */
end_comment

begin_function
name|tree
name|pushtag
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|tag_scope
name|scope
parameter_list|)
block|{
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|b
operator|=
name|current_binding_level
expr_stmt|;
while|while
condition|(
comment|/* Cleanup scopes are not scopes from the point of view of 	    the language.  */
name|b
operator|->
name|kind
operator|==
name|sk_cleanup
comment|/* Neither are the scopes used to hold template parameters 	    for an explicit specialization.  For an ordinary template 	    declaration, these scopes are not scopes from the point of 	    view of the language.  */
operator|||
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
operator|(
name|b
operator|->
name|explicit_spec_p
operator|||
name|scope
operator|==
name|ts_global
operator|)
operator|)
operator|||
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|&&
operator|(
name|scope
operator|!=
name|ts_current
comment|/* We may be defining a new type in the initializer 		    of a static member variable. We allow this when 		    not pedantic, and it is particularly useful for 		    type punning via an anonymous union.  */
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|b
operator|->
name|this_entity
argument_list|)
operator|)
operator|)
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
comment|/* Do C++ gratuitous typedefing.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
condition|)
block|{
name|tree
name|tdef
decl_stmt|;
name|int
name|in_class
init|=
literal|0
decl_stmt|;
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|tree
name|cs
init|=
name|current_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|ts_current
condition|)
name|context
operator|=
name|cs
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_P
argument_list|(
name|cs
argument_list|)
condition|)
comment|/* When declaring a friend class of a local class, we want 	       to inject the newly named class into the scope 	       containing the local class, not the namespace 	       scope.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|get_type_decl
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|current_namespace
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|||
operator|(
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
name|b
operator|->
name|level_chain
operator|->
name|kind
operator|==
name|sk_class
operator|)
condition|)
name|in_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tdef
operator|=
name|create_implicit_typedef
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tdef
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
name|ts_within_enclosing_non_class
condition|)
block|{
comment|/* This is a friend.  Make this TYPE_DECL node hidden from 	     ordinary name lookup.  Its corresponding TEMPLATE_DECL 	     will be marked in push_template_decl_real.  */
name|retrofit_lang_decl
argument_list|(
name|tdef
argument_list|)
expr_stmt|;
name|DECL_ANTICIPATED
argument_list|(
name|tdef
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|tdef
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|decl
operator|=
name|maybe_process_template_type_declaration
argument_list|(
name|type
argument_list|,
name|scope
operator|==
name|ts_within_enclosing_non_class
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_class
condition|)
name|set_identifier_type_value_with_scope
argument_list|(
name|name
argument_list|,
name|tdef
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
condition|)
block|{
if|if
condition|(
operator|!
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
comment|/* Put this TYPE_DECL on the TYPE_FIELDS list for the 	       class.  But if it's a member template class, we want 	       the TEMPLATE_DECL, not the TYPE_DECL, so this is done 	       later.  */
name|finish_member_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|kind
operator|!=
name|sk_template_parms
condition|)
block|{
name|decl
operator|=
name|pushdecl_with_scope
argument_list|(
name|decl
argument_list|,
name|b
argument_list|,
comment|/*is_friend=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If this is a local class, keep track of it.  We need this 	 information for name-mangling, and so that it is possible to 	 find all function definitions in a translation unit in a 	 convenient way.  (It's otherwise tricky to find a member 	 function definition it's only pointed to from within a local 	 class.)  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|local_classes
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|type
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
operator|==
name|NULL
condition|)
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|binding_table_new
argument_list|(
name|SCOPE_DEFAULT_HT_SIZE
argument_list|)
expr_stmt|;
name|binding_table_insert
argument_list|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
comment|/* Set type visibility now if this is a forward declaration.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|determine_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines for reverting temporarily to top-level for instantiation    of templates and such.  We actually need to clear out the class- and    local-value slots of all identifiers, so that only the global values    are at all visible.  Simply setting current_binding_level to the global    scope isn't enough, because more binding levels may be pushed.  */
end_comment

begin_decl_stmt
name|struct
name|saved_scope
modifier|*
name|scope_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If ID has not already been marked, add an appropriate binding to    *OLD_BINDINGS.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|store_binding
argument_list|(
name|tree
name|id
argument_list|,
name|VEC
argument_list|(
name|cxx_saved_binding
argument_list|,
name|gc
argument_list|)
operator|*
operator|*
name|old_bindings
argument_list|)
block|{
name|cxx_saved_binding
modifier|*
name|saved
decl_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
operator|!
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
condition|)
return|return;
if|if
condition|(
name|IDENTIFIER_MARKED
argument_list|(
name|id
argument_list|)
condition|)
return|return;
name|IDENTIFIER_MARKED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved
operator|=
name|VEC_safe_push
argument_list|(
name|cxx_saved_binding
argument_list|,
name|gc
argument_list|,
operator|*
name|old_bindings
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|saved
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|saved
operator|->
name|binding
operator|=
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|saved
operator|->
name|real_type_value
operator|=
name|REAL_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_bindings
argument_list|(
name|tree
name|names
argument_list|,
name|VEC
argument_list|(
name|cxx_saved_binding
argument_list|,
name|gc
argument_list|)
operator|*
operator|*
name|old_bindings
argument_list|)
block|{
name|tree
name|t
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|id
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|store_binding
argument_list|(
name|id
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Like store_bindings, but NAMES is a vector of cp_class_binding    objects, rather than a TREE_LIST.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|store_class_bindings
argument_list|(
name|VEC
argument_list|(
name|cp_class_binding
argument_list|,
name|gc
argument_list|)
operator|*
name|names
argument_list|,
name|VEC
argument_list|(
name|cxx_saved_binding
argument_list|,
name|gc
argument_list|)
operator|*
operator|*
name|old_bindings
argument_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|cp_class_binding
modifier|*
name|cb
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cp_class_binding
argument_list|,
name|names
argument_list|,
name|i
argument_list|,
name|cb
argument_list|)
condition|;
operator|++
name|i
control|)
name|store_binding
argument_list|(
name|cb
operator|->
name|identifier
argument_list|,
name|old_bindings
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|push_to_top_level
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|saved_scope
modifier|*
name|s
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|sb
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
name|s
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|saved_scope
argument_list|)
expr_stmt|;
name|b
operator|=
name|scope_chain
condition|?
name|current_binding_level
else|:
literal|0
expr_stmt|;
comment|/* If we're in the middle of some function, save our state.  */
if|if
condition|(
name|cfun
condition|)
block|{
name|need_pop
operator|=
literal|1
expr_stmt|;
name|push_function_context_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|need_pop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scope_chain
operator|&&
name|previous_class_level
condition|)
name|store_class_bindings
argument_list|(
name|previous_class_level
operator|->
name|class_shadowed
argument_list|,
operator|&
name|s
operator|->
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Have to include the global scope, because class-scope decls      aren't listed anywhere useful.  */
for|for
control|(
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Template IDs are inserted into the global level. If they were 	 inserted into namespace level, finish_file wouldn't find them 	 when doing pending instantiations. Therefore, don't stop at 	 namespace level, but continue until :: .  */
if|if
condition|(
name|global_scope_p
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|store_bindings
argument_list|(
name|b
operator|->
name|names
argument_list|,
operator|&
name|s
operator|->
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* We also need to check class_shadowed to save class-level type 	 bindings, since pushclass doesn't fill in b->names.  */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|store_class_bindings
argument_list|(
name|b
operator|->
name|class_shadowed
argument_list|,
operator|&
name|s
operator|->
name|old_bindings
argument_list|)
expr_stmt|;
comment|/* Unwind type-value slots back to top level.  */
for|for
control|(
name|t
operator|=
name|b
operator|->
name|type_shadowed
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cxx_saved_binding
argument_list|,
name|s
operator|->
name|old_bindings
argument_list|,
name|i
argument_list|,
name|sb
argument_list|)
condition|;
operator|++
name|i
control|)
name|IDENTIFIER_MARKED
argument_list|(
name|sb
operator|->
name|identifier
argument_list|)
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|prev
operator|=
name|scope_chain
expr_stmt|;
name|s
operator|->
name|bindings
operator|=
name|b
expr_stmt|;
name|s
operator|->
name|need_pop_function_context
operator|=
name|need_pop
expr_stmt|;
name|s
operator|->
name|function_decl
operator|=
name|current_function_decl
expr_stmt|;
name|s
operator|->
name|skip_evaluation
operator|=
name|skip_evaluation
expr_stmt|;
name|scope_chain
operator|=
name|s
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_lang_base
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|current_lang_name
operator|=
name|lang_name_cplusplus
expr_stmt|;
name|current_namespace
operator|=
name|global_namespace
expr_stmt|;
name|push_class_stack
argument_list|()
expr_stmt|;
name|skip_evaluation
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_from_top_level
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|saved_scope
modifier|*
name|s
init|=
name|scope_chain
decl_stmt|;
name|cxx_saved_binding
modifier|*
name|saved
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
comment|/* Clear out class-level bindings cache.  */
if|if
condition|(
name|previous_class_level
condition|)
name|invalidate_class_lookup_cache
argument_list|()
expr_stmt|;
name|pop_class_stack
argument_list|()
expr_stmt|;
name|current_lang_base
operator|=
literal|0
expr_stmt|;
name|scope_chain
operator|=
name|s
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|cxx_saved_binding
argument_list|,
name|s
operator|->
name|old_bindings
argument_list|,
name|i
argument_list|,
name|saved
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|id
init|=
name|saved
operator|->
name|identifier
decl_stmt|;
name|IDENTIFIER_BINDING
argument_list|(
name|id
argument_list|)
operator|=
name|saved
operator|->
name|binding
expr_stmt|;
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|id
argument_list|,
name|saved
operator|->
name|real_type_value
argument_list|)
expr_stmt|;
block|}
comment|/* If we were in the middle of compiling a function, restore our      state.  */
if|if
condition|(
name|s
operator|->
name|need_pop_function_context
condition|)
name|pop_function_context_from
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|s
operator|->
name|function_decl
expr_stmt|;
name|skip_evaluation
operator|=
name|s
operator|->
name|skip_evaluation
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop off extraneous binding levels left over due to syntax errors.     We don't pop past namespaces, as they might be valid.  */
end_comment

begin_function
name|void
name|pop_everything
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|verbatim
argument_list|(
literal|"XXX entering pop_everything ()\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_class
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ENABLE_SCOPE_CHECKING
condition|)
name|verbatim
argument_list|(
literal|"XXX leaving pop_everything ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit debugging information for using declarations and directives.    If input tree is overloaded fn then emit debug info for all    candidates.  */
end_comment

begin_function
name|void
name|cp_emit_debug_info_for_using
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|context
parameter_list|)
block|{
comment|/* Don't try to emit any debug information if we have errors.  */
if|if
condition|(
name|sorrycount
operator|||
name|errorcount
condition|)
return|return;
comment|/* Ignore this FUNCTION_DECL if it refers to a builtin declaration      of a builtin function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|t
argument_list|)
condition|)
return|return;
comment|/* Do not supply context to imported_module_or_decl, if      it is a global namespace.  */
if|if
condition|(
name|context
operator|==
name|global_namespace
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* FIXME: Handle TEMPLATE_DECLs.  */
for|for
control|(
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|OVL_NEXT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|imported_module_or_decl
call|)
argument_list|(
name|t
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-name-lookup.h"
end_include

end_unit

