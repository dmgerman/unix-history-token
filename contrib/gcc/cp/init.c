begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle initialization things in C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|expand_aggr_vbase_init_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|construct_virtual_bases
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_aggr_init_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_default_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vec_delete_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|special_function_kind
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perform_member_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_base_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_builtin_delete_call
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|member_init_ok_or_else
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_virtual_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|sort_member_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|initializing_context
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_cleanup_for_base
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_temp_regvar
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|dfs_initialize_vtbl_ptrs
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_default_init
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_new_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_cookie_size
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_dtor_call
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|special_function_kind
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_field_list
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vtbl_address
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up local variable for this file.  MUST BE CALLED AFTER    INIT_DECL_PROCESSING.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BI_header_type
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_init_processing
parameter_list|()
block|{
name|tree
name|fields
index|[
literal|1
index|]
decl_stmt|;
comment|/* Define the structure that holds header information for      arrays allocated via operator new.  */
name|BI_header_type
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|nelts_identifier
argument_list|,
name|sizetype
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|BI_header_type
argument_list|,
literal|"__new_cookie"
argument_list|,
name|fields
argument_list|,
literal|0
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|ggc_add_tree_root
argument_list|(
operator|&
name|BI_header_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are about to generate some complex initialization code.    Conceptually, it is all a single expression.  However, we may want    to include conditionals, loops, and other such statement-level    constructs.  Therefore, we build the initialization code inside a    statement-expression.  This function starts such an expression.    STMT_EXPR_P and COMPOUND_STMT_P are filled in by this function;    pass them back to finish_init_stmts when the expression is    complete.  */
end_comment

begin_function
name|void
name|begin_init_stmts
parameter_list|(
name|stmt_expr_p
parameter_list|,
name|compound_stmt_p
parameter_list|)
name|tree
modifier|*
name|stmt_expr_p
decl_stmt|;
name|tree
modifier|*
name|compound_stmt_p
decl_stmt|;
block|{
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
operator|*
name|stmt_expr_p
operator|=
name|begin_stmt_expr
argument_list|()
expr_stmt|;
else|else
operator|*
name|stmt_expr_p
operator|=
name|begin_global_stmt_expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
operator|*
name|compound_stmt_p
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|)
expr_stmt|;
comment|/*   else      *compound_stmt_p = genrtl_begin_compound_stmt (has_no_scope=1);   */
block|}
end_function

begin_comment
comment|/* Finish out the statement-expression begun by the previous call to    begin_init_stmts.  Returns the statement-expression itself.  */
end_comment

begin_function
name|tree
name|finish_init_stmts
parameter_list|(
name|stmt_expr
parameter_list|,
name|compound_stmt
parameter_list|)
name|tree
name|stmt_expr
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
block|{
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|stmt_expr
operator|=
name|finish_stmt_expr
argument_list|(
name|stmt_expr
argument_list|)
expr_stmt|;
else|else
name|stmt_expr
operator|=
name|finish_global_stmt_expr
argument_list|(
name|stmt_expr
argument_list|)
expr_stmt|;
comment|/* To avoid spurious warnings about unused values, we set       TREE_USED.  */
if|if
condition|(
name|stmt_expr
condition|)
name|TREE_USED
argument_list|(
name|stmt_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_comment
comment|/* Constructors */
end_comment

begin_comment
comment|/* Called from initialize_vtbl_ptrs via dfs_walk.  BINFO is the base    which we want to initialize the vtable pointer for, DATA is    TREE_LIST whose TREE_VALUE is the this ptr expression.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_initialize_vtbl_ptrs
parameter_list|(
name|binfo
parameter_list|,
name|data
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|)
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base_ptr
init|=
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
decl_stmt|;
name|base_ptr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|base_ptr
argument_list|,
name|binfo
argument_list|,
comment|/*nonnull=*/
literal|1
argument_list|)
expr_stmt|;
name|expand_virtual_init
argument_list|(
name|binfo
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
block|}
name|SET_BINFO_MARKED
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Initialize all the vtable pointers in the object pointed to by    ADDR.  */
end_comment

begin_function
name|void
name|initialize_vtbl_ptrs
parameter_list|(
name|addr
parameter_list|)
name|tree
name|addr
decl_stmt|;
block|{
name|tree
name|list
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|build_tree_list
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Walk through the hierarchy, initializing the vptr in each base      class.  We do these in pre-order because can't find the virtual      bases for a class until we've initialized the vtbl for that      class.  */
name|dfs_walk_real
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_initialize_vtbl_ptrs
argument_list|,
name|NULL
argument_list|,
name|dfs_unmarked_real_bases_queue_p
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|dfs_walk
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_unmark
argument_list|,
name|dfs_marked_real_bases_queue_p
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [dcl.init]:    To default-initialize an object of type T means:    --if T is a non-POD class type (clause _class_), the default construc-     tor  for  T is called (and the initialization is ill-formed if T has     no accessible default constructor);    --if T is an array type, each element is default-initialized;    --otherwise, the storage for the object is zero-initialized.    A program that calls for default-initialization of an entity of refer-   ence type is ill-formed.  */
end_comment

begin_function
specifier|static
name|tree
name|build_default_init
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Other code will handle running the default constructor.  We can't do        anything with a CONSTRUCTOR for arrays here, as that would imply        copy-initialization.  */
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* This is a default initialization of an aggregate, but not one of 	 non-POD class type.  We cleverly notice that the initialization 	 rules in such a case are the same as for initialization with an 	 empty brace-initialization list.  */
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
comment|/*   --if T is a reference type, no initialization is performed.  */
return|return
name|NULL_TREE
return|;
else|else
block|{
name|init
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* We must make enumeral types the right type. */
name|init
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of emit_base_init.  */
end_comment

begin_function
specifier|static
name|void
name|perform_member_init
parameter_list|(
name|member
parameter_list|,
name|init
parameter_list|,
name|explicit
parameter_list|)
name|tree
name|member
decl_stmt|,
name|init
decl_stmt|;
name|int
name|explicit
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|decl
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|member
argument_list|,
name|NULL_TREE
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Deal with this here, as we will get confused if we try to call the      assignment op for an anonymous union.  This can happen in a      synthesized copy constructor.  */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|init
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|init
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
comment|/* Since `init' is already a TREE_LIST on the member_init_list, 	 only build it into one if we aren't already a list.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Initialization of one array from another.  */
name|finish_expr_stmt
argument_list|(
name|build_vec_init
argument_list|(
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_expr_stmt
argument_list|(
name|build_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|explicit
condition|)
block|{
name|init
operator|=
name|build_default_init
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|warning
argument_list|(
literal|"default-initialization of `%#D', which has reference type"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
comment|/* member traversal: note it leaves init NULL */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"uninitialized reference member `%D'"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* There was an explicit member initialization.  Do some 	     work in that case.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"initializer list treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|member
argument_list|,
name|NULL_TREE
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|finish_subobject
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a TREE_LIST containing (as the TREE_PURPOSE of each node) all    the FIELD_DECLs on the TYPE_FIELDS list for T, in reverse order.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_list
parameter_list|(
name|t
parameter_list|,
name|list
parameter_list|,
name|uses_unions_p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|int
modifier|*
name|uses_unions_p
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|;
comment|/* Note whether or not T is a union.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
operator|*
name|uses_unions_p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
comment|/* Skip CONST_DECLs for enumeration constants and so forth.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* Keep track of whether or not any fields are unions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
operator|*
name|uses_unions_p
operator|=
literal|1
expr_stmt|;
comment|/* For an anonymous struct or union, we must recursively 	 consider the fields of the anonymous type.  They can be 	 directly initialized from the constructor.  */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Add this field itself.  Synthesized copy constructors 	     initialize the entire aggregate.  */
name|list
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* And now add the fields in the anonymous aggregate.  */
name|list
operator|=
name|build_field_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|list
argument_list|,
name|uses_unions_p
argument_list|)
expr_stmt|;
block|}
comment|/* Add this field.  */
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
name|list
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* The MEMBER_INIT_LIST is a TREE_LIST.  The TREE_PURPOSE of each list    gives a FIELD_DECL in T that needs initialization.  The TREE_VALUE    gives the initializer, or list of initializer arguments.  Sort the    MEMBER_INIT_LIST, returning a version that contains the same    information but in the order that the fields should actually be    initialized.  Perform error-checking in the process.  */
end_comment

begin_function
specifier|static
name|tree
name|sort_member_init
parameter_list|(
name|t
parameter_list|,
name|member_init_list
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|member_init_list
decl_stmt|;
block|{
name|tree
name|init_list
decl_stmt|;
name|tree
name|last_field
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|uses_unions_p
decl_stmt|;
comment|/* Build up a list of the various fields, in sorted order.  */
name|init_list
operator|=
name|nreverse
argument_list|(
name|build_field_list
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|uses_unions_p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go through the explicit initializers, adding them to the      INIT_LIST.  */
name|last_field
operator|=
name|init_list
expr_stmt|;
for|for
control|(
name|init
operator|=
name|member_init_list
init|;
name|init
condition|;
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
control|)
block|{
name|tree
name|f
decl_stmt|;
name|tree
name|initialized_field
decl_stmt|;
name|initialized_field
operator|=
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|initialized_field
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|20000516
argument_list|)
expr_stmt|;
comment|/* If the explicit initializers are in sorted order, then the 	 INITIALIZED_FIELD will be for a field following the 	 LAST_FIELD.  */
for|for
control|(
name|f
operator|=
name|last_field
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|f
argument_list|)
operator|==
name|initialized_field
condition|)
break|break;
comment|/* Give a warning, if appropriate.  */
if|if
condition|(
name|warn_reorder
operator|&&
operator|!
name|f
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"member initializers for `%#D'"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|last_field
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  and `%#D'"
argument_list|,
name|initialized_field
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will be re-ordered to match declaration order"
argument_list|)
expr_stmt|;
block|}
comment|/* Look again, from the beginning of the list.  We must find the 	 field on this loop.  */
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|f
operator|=
name|init_list
expr_stmt|;
while|while
condition|(
name|TREE_PURPOSE
argument_list|(
name|f
argument_list|)
operator|!=
name|initialized_field
condition|)
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* If there was already an explicit initializer for this field, 	 issue an error.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
condition|)
name|error
argument_list|(
literal|"multiple initializations given for member `%D'"
argument_list|,
name|initialized_field
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Mark the field as explicitly initialized.  */
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* And insert the initializer.  */
name|TREE_VALUE
argument_list|(
name|f
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the location of the last explicitly initialized 	 field.  */
name|last_field
operator|=
name|f
expr_stmt|;
block|}
comment|/* [class.base.init]       If a ctor-initializer specifies more than one mem-initializer for      multiple members of the same union (including members of      anonymous unions), the ctor-initializer is ill-formed.  */
if|if
condition|(
name|uses_unions_p
condition|)
block|{
name|last_field
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|init
operator|=
name|init_list
init|;
name|init
condition|;
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
control|)
block|{
name|tree
name|field
decl_stmt|;
name|tree
name|field_type
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* Skip uninitialized members.  */
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
condition|)
continue|continue;
comment|/* See if this field is a member of a union, or a member of a 	     structure contained in a union, etc.  */
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
expr_stmt|;
for|for
control|(
name|field_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
init|;
operator|!
name|same_type_p
argument_list|(
name|field_type
argument_list|,
name|t
argument_list|)
condition|;
name|field_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|field_type
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
break|break;
comment|/* If this field is not a member of a union, skip it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
comment|/* It's only an error if we have two initializers for the same 	     union type.  */
if|if
condition|(
operator|!
name|last_field
condition|)
block|{
name|last_field
operator|=
name|field
expr_stmt|;
continue|continue;
block|}
comment|/* See if LAST_FIELD and the field initialized by INIT are 	     members of the same union.  If so, there's a problem, 	     unless they're actually members of the same structure 	     which is itself a member of a union.  For example, given:  	       union { struct { int i; int j; }; };  	     initializing both `i' and `j' makes sense.  */
name|field_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|tree
name|last_field_type
decl_stmt|;
name|last_field_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|last_field
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|last_field_type
argument_list|,
name|field_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"initializations for multiple members of `%T'"
argument_list|,
name|last_field_type
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|last_field_type
argument_list|,
name|t
argument_list|)
condition|)
break|break;
name|last_field_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|last_field_type
argument_list|)
expr_stmt|;
block|}
comment|/* If we've reached the outermost class, then we're 		 done.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|field_type
argument_list|,
name|t
argument_list|)
condition|)
break|break;
name|field_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|last_field
operator|=
name|field
expr_stmt|;
block|}
block|}
return|return
name|init_list
return|;
block|}
end_function

begin_comment
comment|/* Like sort_member_init, but used for initializers of base classes.    *RBASE_PTR is filled in with the initializers for non-virtual bases;    vbase_ptr gets the virtual bases.  */
end_comment

begin_function
specifier|static
name|void
name|sort_base_init
parameter_list|(
name|t
parameter_list|,
name|base_init_list
parameter_list|,
name|rbase_ptr
parameter_list|,
name|vbase_ptr
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|base_init_list
decl_stmt|;
name|tree
modifier|*
name|rbase_ptr
decl_stmt|,
decl|*
name|vbase_ptr
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|x
decl_stmt|;
name|tree
name|last
decl_stmt|;
comment|/* For warn_reorder.  */
name|int
name|last_pos
init|=
literal|0
decl_stmt|;
name|tree
name|last_base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rbases
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vbases
init|=
name|NULL_TREE
decl_stmt|;
comment|/* First walk through and splice out vbase and invalid initializers.      Also replace types with binfos.  */
name|last
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
operator|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|TREE_VEC
condition|?
name|basetype
else|:
name|binfo_or_else
argument_list|(
name|basetype
argument_list|,
name|t
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
comment|/* BASETYPE might be an inaccessible direct base (because it 	   is also an indirect base).  */
continue|continue;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* Virtual base classes are special cases.  Their 	     initializers are recorded with this constructor, and they 	     are used when this constructor is the top-level 	     constructor called.  */
name|tree
name|v
init|=
name|binfo_for_vbase
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|vbases
operator|=
name|tree_cons
argument_list|(
name|v
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
name|vbases
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, it must be an immediate base class.  */
name|my_friendly_assert
argument_list|(
name|same_type_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|,
literal|20011113
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|x
expr_stmt|;
name|last
operator|=
name|x
expr_stmt|;
block|}
block|}
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now walk through our regular bases and make sure they're initialized.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
comment|/* The base for which we're currently initializing.  */
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* The initializer for BASE_BINFO.  */
name|tree
name|init
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
comment|/* We haven't found the BASE_BINFO yet.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Loop through all the explicitly initialized bases, looking 	 for an appropriate initializer.  */
for|for
control|(
name|x
operator|=
name|base_init_list
operator|,
name|pos
operator|=
literal|0
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|,
operator|++
name|pos
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|base_binfo
operator|&&
operator|!
name|init
condition|)
block|{
if|if
condition|(
name|warn_reorder
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|last_pos
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"base initializers for `%#T'"
argument_list|,
name|last_base
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  and `%#T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will be re-ordered to match inheritance order"
argument_list|)
expr_stmt|;
block|}
name|last_pos
operator|=
name|pos
expr_stmt|;
name|last_base
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we won't try to work on this init again.  */
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binfo
operator|==
name|base_binfo
condition|)
block|{
name|error
argument_list|(
literal|"base class `%T' already initialized"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we didn't find BASE_BINFO in the list, create a dummy entry 	 so the two lists (RBASES and the list of bases) will be 	 symmetrical.  */
if|if
condition|(
operator|!
name|init
condition|)
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|rbases
operator|=
name|chainon
argument_list|(
name|rbases
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
operator|*
name|rbase_ptr
operator|=
name|rbases
expr_stmt|;
operator|*
name|vbase_ptr
operator|=
name|vbases
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Perform whatever initializations have yet to be done on the base    class, and non-static data members, of the CURRENT_CLASS_TYPE.    These actions are given by the BASE_INIT_LIST and MEM_INIT_LIST,    respectively.     If there is a need for a call to a constructor, we must surround    that call with a pushlevel/poplevel pair, since we are technically    at the PARM level of scope.  */
end_comment

begin_function
name|void
name|emit_base_init
parameter_list|(
name|mem_init_list
parameter_list|,
name|base_init_list
parameter_list|)
name|tree
name|mem_init_list
decl_stmt|;
name|tree
name|base_init_list
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|rbase_init_list
decl_stmt|,
name|vbase_init_list
decl_stmt|;
name|tree
name|t
init|=
name|current_class_type
decl_stmt|;
name|tree
name|t_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|BINFO_N_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
name|mem_init_list
operator|=
name|sort_member_init
argument_list|(
name|t
argument_list|,
name|mem_init_list
argument_list|)
expr_stmt|;
name|sort_base_init
argument_list|(
name|t
argument_list|,
name|base_init_list
argument_list|,
operator|&
name|rbase_init_list
argument_list|,
operator|&
name|vbase_init_list
argument_list|)
expr_stmt|;
comment|/* First, initialize the virtual base classes, if we are      constructing the most-derived object.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|first_arg
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|construct_virtual_bases
argument_list|(
name|t
argument_list|,
name|current_class_ref
argument_list|,
name|current_class_ptr
argument_list|,
name|vbase_init_list
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
block|}
comment|/* Now, perform initialization of non-virtual base classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|void_list_node
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|==
name|t_binfo
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|rbase_init_list
argument_list|)
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|rbase_init_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|extra_warnings
operator|&&
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"base class `%#T' should be explicitly initialized in the copy constructor"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|!=
name|void_list_node
condition|)
block|{
name|member
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|base_binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|base_binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|build_indirect_ref
argument_list|(
name|member
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
block|}
name|expand_cleanup_for_base
argument_list|(
name|base_binfo
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|rbase_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|rbase_init_list
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the vtable pointers for the class.  */
name|initialize_vtbl_ptrs
argument_list|(
name|current_class_ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|mem_init_list
condition|)
block|{
name|tree
name|init
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|int
name|from_init_list
decl_stmt|;
name|member
operator|=
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
comment|/* See if we had a user-specified member initialization.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|mem_init_list
argument_list|)
condition|)
block|{
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|from_init_list
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|from_init_list
operator|=
literal|0
expr_stmt|;
comment|/* Effective C++ rule 12.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|init
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|member
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|warning
argument_list|(
literal|"`%D' should be initialized in the member initialization list"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|perform_member_init
argument_list|(
name|member
argument_list|,
name|init
argument_list|,
name|from_init_list
argument_list|)
expr_stmt|;
name|mem_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the address of the vtable (i.e., the value that should be    assigned to the vptr) for BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtbl_address
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|binfo_for
init|=
name|binfo
decl_stmt|;
name|tree
name|vtbl
decl_stmt|;
if|if
condition|(
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
operator|&&
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* If this is a virtual primary base, then the vtable we want to store        is that for the base this is being used as the primary base of.  We        can't simply skip the initialization, because we may be expanding the        inits of a subobject constructor where the virtual base layout        can be different.  */
while|while
condition|(
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo_for
argument_list|)
condition|)
name|binfo_for
operator|=
name|BINFO_PRIMARY_BASE_OF
argument_list|(
name|binfo_for
argument_list|)
expr_stmt|;
comment|/* Figure out what vtable BINFO's vtable is based on, and mark it as      used.  */
name|vtbl
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo_for
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now compute the address to use when initializing the vptr.  */
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo_for
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vtbl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|vtbl
return|;
block|}
end_function

begin_comment
comment|/* This code sets up the virtual function tables appropriate for    the pointer DECL.  It is a one-ply initialization.     BINFO is the exact type that DECL is supposed to be.  In    multiple inheritance, this might mean "C's A" if C : A, B.  */
end_comment

begin_function
specifier|static
name|void
name|expand_virtual_init
parameter_list|(
name|binfo
parameter_list|,
name|decl
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|vtbl
decl_stmt|,
name|vtbl_ptr
decl_stmt|;
name|tree
name|vtt_index
decl_stmt|;
comment|/* Compute the initializer for vptr.  */
name|vtbl
operator|=
name|build_vtbl_address
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* We may get this vptr from a VTT, if this is a subobject      constructor or subobject destructor.  */
name|vtt_index
operator|=
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtt_index
condition|)
block|{
name|tree
name|vtbl2
decl_stmt|;
name|tree
name|vtt_parm
decl_stmt|;
comment|/* Compute the value to use, when there's a VTT.  */
name|vtt_parm
operator|=
name|current_vtt_parm
expr_stmt|;
name|vtbl2
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtt_parm
argument_list|)
argument_list|,
name|vtt_parm
argument_list|,
name|vtt_index
argument_list|)
expr_stmt|;
name|vtbl2
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|vtbl2
argument_list|)
expr_stmt|;
comment|/* The actual initializer is the VTT value only in the subobject 	 constructor.  In maybe_clone_body we'll substitute NULL for 	 the vtt_parm in the case of the non-subobject constructor.  */
name|vtbl
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|vtbl2
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the location of the vtpr.  */
name|vtbl_ptr
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|vtbl_ptr
operator|!=
name|error_mark_node
argument_list|,
literal|20010730
argument_list|)
expr_stmt|;
comment|/* Assign the vtable to the vptr.  */
name|vtbl
operator|=
name|convert_force
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl_ptr
argument_list|)
argument_list|,
name|vtbl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|vtbl_ptr
argument_list|,
name|NOP_EXPR
argument_list|,
name|vtbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If an exception is thrown in a constructor, those base classes already    constructed must be destroyed.  This function creates the cleanup    for BINFO, which has just been constructed.  If FLAG is non-NULL,    it is a DECL which is non-zero when this base needs to be    destroyed.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanup_for_base
parameter_list|(
name|binfo
parameter_list|,
name|flag
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|flag
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Call the destructor.  */
name|expr
operator|=
operator|(
name|build_scoped_method_call
argument_list|(
name|current_class_ref
argument_list|,
name|binfo
argument_list|,
name|base_dtor_identifier
argument_list|,
name|NULL_TREE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|flag
argument_list|)
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|finish_subobject
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of `expand_aggr_vbase_init'.    BINFO is the binfo of the type that is being initialized.    INIT_LIST is the list of initializers for the virtual baseclass.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_vbase_init_1
parameter_list|(
name|binfo
parameter_list|,
name|exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|exp
decl_stmt|,
name|addr
decl_stmt|,
name|init_list
decl_stmt|;
block|{
name|tree
name|init
init|=
name|purpose_member
argument_list|(
name|binfo
argument_list|,
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Call constructors, but don't set up vtables.  */
name|expand_aggr_init_1
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|ref
argument_list|,
name|init
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the virtual base-classes of THIS_REF (whose address is    THIS_PTR).  The object has the indicated TYPE.  The construction    actually takes place only if FLAG is non-zero.  INIT_LIST is list    of initializations for constructors to perform.  */
end_comment

begin_function
specifier|static
name|void
name|construct_virtual_bases
parameter_list|(
name|type
parameter_list|,
name|this_ref
parameter_list|,
name|this_ptr
parameter_list|,
name|init_list
parameter_list|,
name|flag
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|this_ref
decl_stmt|;
name|tree
name|this_ptr
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|tree
name|flag
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
comment|/* If there are no virtual baseclasses, we shouldn't even be here.  */
name|my_friendly_assert
argument_list|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|19990621
argument_list|)
expr_stmt|;
comment|/* Now, run through the baseclasses, initializing each.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|inner_if_stmt
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|tree
name|vbase
decl_stmt|;
comment|/* If there are virtual base classes with destructors, we need to 	 emit cleanups to destroy them if an exception is thrown during 	 the construction process.  These exception regions (i.e., the 	 period during which the cleanups must occur) begin from the time 	 the construction is complete to the end of the function.  If we 	 create a conditional block in which to initialize the 	 base-classes, then the cleanup region for the virtual base begins 	 inside a block, and ends outside of that block.  This situation 	 confuses the sjlj exception-handling code.  Therefore, we do not 	 create a single conditional block, but one for each 	 initialization.  (That way the cleanup regions always begin 	 in the outer block.)  We trust the back-end to figure out 	 that the FLAG will not change across initializations, and 	 avoid doing multiple tests.  */
name|inner_if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|flag
argument_list|,
name|inner_if_stmt
argument_list|)
expr_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the location of the virtual base.  If we're 	 constructing virtual bases, then we must be the most derived 	 class.  Therefore, we don't have to look up the virtual base; 	 we already know where it is.  */
name|vbase
operator|=
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|this_ptr
argument_list|)
argument_list|,
name|this_ptr
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|this_ptr
argument_list|)
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vbase
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|expand_aggr_vbase_init_1
argument_list|(
name|vbase
argument_list|,
name|this_ref
argument_list|,
name|exp
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|inner_if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
name|expand_cleanup_for_base
argument_list|(
name|vbase
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the context in which this FIELD can be initialized.  */
end_comment

begin_function
specifier|static
name|tree
name|initializing_context
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
name|tree
name|t
init|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* Anonymous union members can be initialized in the first enclosing      non-anonymous union context.  */
while|while
condition|(
name|t
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Function to give error message if member initialization specification    is erroneous.  FIELD is the member we decided to initialize.    TYPE is the type for which the initialization is being performed.    FIELD must be a member of TYPE.        MEMBER_NAME is the name of the member.  */
end_comment

begin_function
specifier|static
name|int
name|member_init_ok_or_else
parameter_list|(
name|field
parameter_list|,
name|type
parameter_list|,
name|member_name
parameter_list|)
name|tree
name|field
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|member_name
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|initializing_context
argument_list|(
name|field
argument_list|)
operator|!=
name|type
condition|)
block|{
name|error
argument_list|(
literal|"class `%T' does not have any field named `%D'"
argument_list|,
name|type
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field `%#D' is static; the only point of initialization is its definition"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* EXP is an expression of aggregate type. NAME is an IDENTIFIER_NODE    which names a field, or it is a _TYPE node or TYPE_DECL which names    a base for that type.  INIT is a parameter list for that field's or    base's constructor.  Check the validity of NAME, and return a    TREE_LIST of the base _TYPE or FIELD_DECL and the INIT. EXP is used    only to get its type.  If NAME is invalid, return NULL_TREE and    issue a diagnostic.     An old style unnamed direct single base construction is permitted,    where NAME is NULL.  */
end_comment

begin_function
name|tree
name|expand_member_init
parameter_list|(
name|exp
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|,
name|field
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|20011113
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
comment|/* This is an obsolete unnamed base class initializer.  The 	 parser will already have warned about its use.  */
switch|switch
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"unnamed initializer for `%T', which has no base classes"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
case|case
literal|1
case|:
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unnamed initializer for `%T', which uses multiple inheritance"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
block|{
if|if
condition|(
name|current_template_parms
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|vec_binfo_member
argument_list|(
name|basetype
argument_list|,
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* A direct base.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|binfo_for_vbase
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
condition|)
comment|/* A virtual base.  */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"type `%D' is not a direct or virtual base of `%T'"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type `%D' is not a direct base of `%T'"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|init
operator|=
name|build_tree_list
argument_list|(
name|basetype
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|field
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* This is like `expand_member_init', only it stores one aggregate    value into another.     INIT comes in two flavors: it is either a value which    is to be stored in EXP, or it is a parameter list    to go to a constructor, which will operate on EXP.    If INIT is not a parameter list for a constructor, then set    LOOKUP_ONLYCONVERTING.    If FLAGS is LOOKUP_ONLYCONVERTING then it is the = init form of    the initializer, if FLAGS is 0, then it is the (init) form.    If `init' is a CONSTRUCTOR, then we emit a warning message,    explaining that such initializations are invalid.     If INIT resolves to a CALL_EXPR which happens to return    something of the type we are looking for, then we know    that we can safely use that call to perform the    initialization.     The virtual function table pointer cannot be set up here, because    we do not really know its type.     Virtual baseclass pointers are also set up here.     This never calls operator=().     When initializing, nothing is CONST.     A default copy constructor may have to be used to perform the    initialization.     A constructor or a conversion operator may have to be used to    perform the initialization, but not both, as it would be ambiguous.  */
end_comment

begin_function
name|tree
name|build_aggr_init
parameter_list|(
name|exp
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|stmt_expr
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|int
name|destroy_temps
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_const
init|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_volatile
init|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Must arrange to initialize each element of EXP 	 from elements of INIT.  */
name|tree
name|itype
init|=
name|init
condition|?
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|init
operator|&&
operator|!
name|itype
condition|)
block|{
comment|/* Handle bad initializers like: 	     class COMPLEX { 	     public: 	       double re, im; 	       COMPLEX(double r = 0.0, double i = 0.0) {re = r; im = i;}; 	       ~COMPLEX() {}; 	     };  	     int main(int argc, char **argv) { 	       COMPLEX zees(1.0, 0.0)[10]; 	     } 	  */
name|error
argument_list|(
literal|"bad array initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
name|stmt_expr
operator|=
name|build_vec_init
argument_list|(
name|exp
argument_list|,
name|init
argument_list|,
name|init
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|itype
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
comment|/* just know that we've seen something for this node */
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|begin_init_stmts
argument_list|(
operator|&
name|stmt_expr
argument_list|,
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
name|destroy_temps
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
operator||
name|flags
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|finish_init_stmts
argument_list|(
name|stmt_expr
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|destroy_temps
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_default_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|ctor_name
decl_stmt|;
comment|/* It fails because there may not be a constructor which takes      its own type as the first (or only parameter), but which does      take other types via a conversion.  So, if the thing initializing      the expression is a unit element of type X, first try X(X&),      followed by initialization by X.  If neither of these work      out, then look hard.  */
name|tree
name|rval
decl_stmt|;
name|tree
name|parms
decl_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
condition|)
block|{
comment|/* Base subobjects should only get direct-initialization.  */
if|if
condition|(
name|true_exp
operator|!=
name|exp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DIRECT_BIND
condition|)
comment|/* Do nothing.  We hit this in two cases:  Reference initialization, 	   where we aren't initializing a real variable, so we don't want 	   to run a new constructor; and catching an exception, where we 	   have already built up the constructor call so we could wrap it 	   in an exception region.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
comment|/* A brace-enclosed initializer has whatever type is 	   required.  There's no need to convert it.  */
empty_stmt|;
else|else
name|init
operator|=
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TRY_CATCH_EXPR
condition|)
comment|/* We need to protect the initialization of a catch parm 	   with a call to terminate(), which shows up as a TRY_CATCH_EXPR 	   around the TARGET_EXPR for the copy constructor.  See 	   expand_start_catch_block.  */
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|)
condition|)
block|{
name|parms
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|parms
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_exp
operator|==
name|exp
condition|)
name|ctor_name
operator|=
name|complete_ctor_identifier
expr_stmt|;
else|else
name|ctor_name
operator|=
name|base_ctor_identifier
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|ctor_name
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|finish_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
else|else
name|genrtl_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is responsible for initializing EXP with INIT    (if any).     BINFO is the binfo of the type for who we are performing the    initialization.  For example, if W is a virtual base class of A and B,    and C : A, B.    If we are initializing B, then W must contain B's W vtable, whereas    were we initializing C, W must contain C's W vtable.     TRUE_EXP is nonzero if it is the true expression being initialized.    In this case, it may be EXP, or may just contain EXP.  The reason we    need this is because if EXP is a base element of TRUE_EXP, we    don't necessarily know by looking at EXP where its virtual    baseclass fields should really be pointing.  But we do know    from TRUE_EXP.  In constructors, we don't know anything about    the value being initialized.     FLAGS is just passes to `build_method_call'.  See that function for    its description.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|error_mark_node
operator|&&
name|type
operator|!=
name|error_mark_node
argument_list|,
literal|211
argument_list|)
expr_stmt|;
comment|/* Use a function returning the desired type to initialize EXP for us.      If the function is a constructor, and its first argument is      NULL_TREE, know that it was meant for us--just slide exp on      in and expand the constructor.  Constructors now come      as TARGET_EXPRs.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* If store_init_value returns NULL_TREE, the INIT has been 	 record in the DECL_INITIAL for EXP.  That means there's 	 nothing more we have to do.  */
if|if
condition|(
operator|!
name|store_init_value
argument_list|(
name|exp
argument_list|,
name|init
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|building_stmt_tree
argument_list|()
condition|)
name|expand_decl_init
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_expr_stmt
argument_list|(
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We know that expand_default_init can handle everything we want      at this point.  */
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error if TYPE is not a user-defined, aggregate type.  If    OR_ELSE is nonzero, give an error message.  */
end_comment

begin_function
name|int
name|is_aggr_type
parameter_list|(
name|type
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|error
argument_list|(
literal|"`%T' is not an aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like is_aggr_typedef, but returns typedef if successful.  */
end_comment

begin_function
name|tree
name|get_aggr_from_typedef
parameter_list|(
name|name
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|or_else
condition|)
name|error
argument_list|(
literal|"`%T' fails to be an aggregate typedef"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|error
argument_list|(
literal|"type `%T' is of non-aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|get_type_value
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This code could just as well go in `class.c', but is placed here for    modularity.  */
end_comment

begin_comment
comment|/* For an expression of the form TYPE :: NAME (PARMLIST), build    the appropriate function call.  */
end_comment

begin_function
name|tree
name|build_member_call
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|,
name|parmlist
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|method_name
decl_stmt|;
name|int
name|dtor
init|=
literal|0
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
comment|/* 'name' already refers to the decls from the namespace, since we 	 hit do_identifier for template_ids.  */
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: Since we don't do independent names right yet, the 	 name might also be a LOOKUP_EXPR. Once we resolve this to a 	 real decl earlier, this can go. This may happen during 	 tsubst'ing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
block|{
name|method_name
operator|=
name|lookup_namespace_name
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|=
name|method_name
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|method_name
argument_list|)
argument_list|,
literal|980519
argument_list|)
expr_stmt|;
return|return
name|build_x_function_call
argument_list|(
name|name
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|build_x_function_call
argument_list|(
name|lookup_namespace_name
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|method_name
argument_list|)
condition|)
name|method_name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|method_name
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|=
name|method_name
expr_stmt|;
block|}
else|else
name|method_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtor
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This shouldn't be here, and build_member_call shouldn't appear in      parse.y!  (mrs)  */
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|get_aggr_from_typedef
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|ns
init|=
name|lookup_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|&&
name|TREE_CODE
argument_list|(
name|ns
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
return|return
name|build_x_function_call
argument_list|(
name|build_offset_ref
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* An operator we did not like.  */
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|dtor
condition|)
block|{
name|error
argument_list|(
literal|"cannot call destructor `%T::~%T' without object"
argument_list|,
name|type
argument_list|,
name|method_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|type
argument_list|,
operator|&
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* Convert 'this' to the specified type to disambiguate conversion      to the function's context.  Apparently Standard C++ says that we      shouldn't do this.  */
if|if
condition|(
name|decl
operator|==
name|current_class_ref
operator|&&
operator|!
name|pedantic
operator|&&
name|ACCESSIBLY_UNIQUELY_DERIVED_P
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|olddecl
init|=
name|current_class_ptr
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldtype
operator|!=
name|type
condition|)
block|{
name|tree
name|newtype
init|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
decl_stmt|;
name|decl
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|olddecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|method_name
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|||
name|method_name
operator|==
name|constructor_name_full
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|parmlist
argument_list|)
return|;
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|method_name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|?
name|name
else|:
name|method_name
argument_list|,
name|parmlist
argument_list|,
name|basetype_path
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
operator|(
name|t
operator|=
name|lookup_field
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|is_dummy_object
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-static field `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|decl
operator|=
name|t
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid use of member `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|decl
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|build_function_call
argument_list|(
name|decl
argument_list|,
name|parmlist
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no method `%T::%D'"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build a reference to a member of an aggregate.  This is not a    C++ `&', but really something which can have its address taken,    and then act as a pointer to member, for example TYPE :: FIELD    can have its address taken by saying& TYPE :: FIELD.     @@ Prints out lousy diagnostics for operator<typename>    @@ fields.     @@ This function should be rewritten and placed in search.c.  */
end_comment

begin_function
name|tree
name|build_offset_ref
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|t
init|=
name|error_mark_node
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|basebinfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|orig_name
init|=
name|name
decl_stmt|;
comment|/* class templates can come in as TEMPLATE_DECLs here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|name
return|;
if|if
condition|(
name|processing_template_decl
operator|||
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* If the NAME is a TEMPLATE_ID_EXPR, we are looking at 	 something like `a.template f<int>' or the like.  For the most 	 part, we treat this just like a.f.  We do remember, however, 	 the template-id that was used.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|orig_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
comment|/* This can happen during tsubst'ing.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
comment|/* Handle namespace names fully here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|t
operator|=
name|lookup_namespace_name
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
comment|/* Reconstruct the TEMPLATE_ID_EXPR.  */
name|t
operator|=
name|build
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|TREE_OPERAND
argument_list|(
name|orig_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_unknown_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert_from_reference
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|check_dtor_name
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"qualified type `%T' does not match destructor name `~%T'"
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|dtor_identifier
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incomplete type `%T' does not have member `%D'"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|type
argument_list|,
operator|&
name|basebinfo
argument_list|)
expr_stmt|;
name|member
operator|=
name|lookup_member
argument_list|(
name|basebinfo
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* A lot of this logic is now handled in lookup_member.  */
if|if
condition|(
name|member
operator|&&
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
comment|/* Go from the TREE_BASELINK to the member function info.  */
name|tree
name|fnfields
init|=
name|member
decl_stmt|;
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* The FNFIELDS are going to contain functions that aren't 	     necessarily templates, and templates that don't 	     necessarily match the explicit template parameters.  We 	     save all the functions, and the explicit parameters, and 	     then figure out exactly what to instantiate with what 	     arguments in instantiate_type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|OVERLOAD
condition|)
comment|/* The code in instantiate_type which will process this 	       expects to encounter OVERLOADs, not raw functions.  */
name|t
operator|=
name|ovl_cons
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|TREE_OPERAND
argument_list|(
name|orig_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Get rid of a potential OVERLOAD around it */
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* unique functions are handled easily.  */
if|if
condition|(
operator|!
name|enforce_access
argument_list|(
name|basebinfo
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|t
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
name|TREE_TYPE
argument_list|(
name|fnfields
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|decl
argument_list|,
name|fnfields
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
name|t
operator|=
name|member
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"`%D' is not a member of type `%T'"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* static class members and class-specific enum      values can be returned without further ado.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"illegal pointer to bit-field `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* static class functions too.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* In member functions, the form `type::name' is no longer      equivalent to `this->type::name', at least not until      resolve_offset_ref.  */
name|t
operator|=
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|build_offset_type
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* If a OFFSET_REF made it through to here, then it did    not have its address taken.  */
end_comment

begin_function
name|tree
name|resolve_offset_ref
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
argument_list|,
literal|214
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"object missing in use of pointer-to-member construct"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|member
operator|=
name|exp
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|current_class_ref
expr_stmt|;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_ms_extensions
condition|)
comment|/* A single non-static member, make sure we don't allow a            pointer-to-member.  */
name|exp
operator|=
name|ovl_cons
argument_list|(
name|member
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* These were static members.  */
if|if
condition|(
name|mark_addressable
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|member
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|member
return|;
comment|/* Syntax error can cause a member which should      have been seen as static to be grok'd as non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|current_class_ref
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member `%D' is non-static but referenced as a static member"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* The first case is really just a reference to a member of `this'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|base
operator|==
name|current_class_ref
operator|||
name|is_dummy_object
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|tree
name|expr
decl_stmt|;
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
comment|/* Try to get to basetype from 'this'; if that doesn't work,          nothing will.  */
name|base
operator|=
name|current_class_ref
expr_stmt|;
comment|/* First convert to the intermediate base specified, if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|base
operator|=
name|build_scoped_ref
argument_list|(
name|base
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't check access on the conversion; we might be after a member 	 promoted by an access- or using-declaration, and we have already 	 checked access for the member itself.  */
name|basetype
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_ignore
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|base
argument_list|,
name|basetype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|member
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
comment|/* Ensure that we have an object.  */
if|if
condition|(
name|is_dummy_object
argument_list|(
name|base
argument_list|)
condition|)
name|addr
operator|=
name|error_mark_node
expr_stmt|;
else|else
comment|/* If this is a reference to a member function, then return the        address of the member function (which may involve going        through the object's vtable), otherwise, return an expression        for the dereferenced pointer-to-member construct.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"object missing in `%E'"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|lookup_base
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|,
name|ba_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|addr
argument_list|,
name|basetype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|member
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|addr
argument_list|,
name|member
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a `const' declaration, and its value is a known    constant, then return that value.  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common subroutines of build_new and build_vec_delete.  */
end_comment

begin_comment
comment|/* Call the global __builtin_delete to delete ADDR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_builtin_delete_call
parameter_list|(
name|addr
parameter_list|)
name|tree
name|addr
decl_stmt|;
block|{
name|mark_used
argument_list|(
name|global_delete_fndecl
argument_list|)
expr_stmt|;
return|return
name|build_call
argument_list|(
name|global_delete_fndecl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a C++ "new" expression. DECL is either a TREE_LIST    (which needs to go through some sort of groktypename) or it    is the name of the class we are newing. INIT is an initialization value.    It is either an EXPRLIST, an EXPR_NO_COMMAS, or something in braces.    If INIT is void_type_node, it means do *not* call a constructor    for this instance.     For types with constructors, the data returned is initialized    by the appropriate constructor.     Whether the type has a constructor or not, if it has a pointer    to a virtual function table, then that pointer is set up    here.     Unless I am mistaken, a call to new () will return initialized    data regardless of whether the constructor itself is private or    not.  NOPE; new fails if the constructor is private (jcm).     Note that build_new does nothing to assure that any special    alignment requirements of the type are met.  Rather, it leaves    it up to malloc to do the right thing.  Otherwise, folding to    the right alignment cal cause problems if the user tries to later    free the memory returned by `new'.     PLACEMENT is the `placement' list for user-defined operator new ().  */
end_comment

begin_function
name|tree
name|build_new
parameter_list|(
name|placement
parameter_list|,
name|decl
parameter_list|,
name|init
parameter_list|,
name|use_global_new
parameter_list|)
name|tree
name|placement
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|int
name|use_global_new
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|;
name|tree
name|nelts
init|=
name|NULL_TREE
decl_stmt|,
name|t
decl_stmt|;
name|int
name|has_array
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|absdcl
init|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|last_absdcl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|my_friendly_assert
argument_list|(
name|immediate_size_expand
operator|==
literal|0
argument_list|,
literal|19990926
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
comment|/* probably meant to be a vec new */
name|tree
name|this_nelts
decl_stmt|;
while|while
condition|(
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|has_array
operator|=
literal|1
expr_stmt|;
name|this_nelts
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|this_nelts
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"new of array type fails to specify size"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|nelts
operator|=
name|this_nelts
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|this_nelts
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"size in array new must have integral type"
argument_list|)
expr_stmt|;
name|this_nelts
operator|=
name|save_expr
argument_list|(
name|cp_convert
argument_list|(
name|sizetype
argument_list|,
name|this_nelts
argument_list|)
argument_list|)
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|==
name|integer_zero_node
condition|)
block|{
name|warning
argument_list|(
literal|"zero size array reserves no space"
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
name|nelts
operator|=
name|cp_build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|last_absdcl
condition|)
name|TREE_OPERAND
argument_list|(
name|last_absdcl
argument_list|,
literal|0
argument_list|)
operator|=
name|absdcl
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|absdcl
expr_stmt|;
name|type
operator|=
name|groktypename
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* An aggregate type.  */
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A builtin type.  */
name|decl
operator|=
name|lookup_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|215
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|has_array
condition|)
name|t
operator|=
name|tree_cons
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|build_min_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|nelts
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|type
expr_stmt|;
name|rval
operator|=
name|build_min_nt
argument_list|(
name|NEW_EXPR
argument_list|,
name|placement
argument_list|,
name|t
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|rval
argument_list|)
operator|=
name|use_global_new
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* ``A reference cannot be created by the new operator.  A reference      is not an object (8.2.2, 8.4.3), so a pointer to it could not be      returned by new.'' ARM 5.3.3 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a reference type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* When the object being created is an array, the new-expression yields a      pointer to the initial element (if any) of the array.  For example,      both new int and new int[10] return an int*.  5.3.4.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|has_array
operator|==
literal|0
condition|)
block|{
name|nelts
operator|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|has_array
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_array
condition|)
name|t
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|type
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|NEW_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|placement
argument_list|,
name|t
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|rval
argument_list|)
operator|=
name|use_global_new
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build_new_1
argument_list|(
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Given a Java class, return a decl for the corresponding java.lang.Class. */
end_comment

begin_function
name|tree
name|build_java_class_ref
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|class_decl
decl_stmt|;
specifier|static
name|tree
name|CL_suffix
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|CL_suffix
operator|==
name|NULL_TREE
condition|)
name|CL_suffix
operator|=
name|get_identifier
argument_list|(
literal|"class$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jclass_node
operator|==
name|NULL_TREE
condition|)
block|{
name|jclass_node
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
literal|"jclass"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jclass_node
operator|==
name|NULL_TREE
condition|)
name|fatal_error
argument_list|(
literal|"call to Java constructor, while `jclass' undefined"
argument_list|)
expr_stmt|;
name|jclass_node
operator|=
name|TREE_TYPE
argument_list|(
name|jclass_node
argument_list|)
expr_stmt|;
block|}
comment|/* Mangle the class$ field */
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|CL_suffix
condition|)
block|{
name|mangle_decl
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|field
condition|)
name|internal_error
argument_list|(
literal|"can't find class$"
argument_list|)
expr_stmt|;
block|}
name|class_decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|class_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|jclass_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|class_decl
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|class_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|class_decl
return|;
block|}
end_function

begin_comment
comment|/* Returns the size of the cookie to use when allocating an array    whose elements have the indicated TYPE.  Assumes that it is already    known that a cookie is needed.  */
end_comment

begin_function
specifier|static
name|tree
name|get_cookie_size
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|cookie_size
decl_stmt|;
comment|/* We need to allocate an additional max (sizeof (size_t), alignof      (true_type)) bytes.  */
name|tree
name|sizetype_size
decl_stmt|;
name|tree
name|type_align
decl_stmt|;
name|sizetype_size
operator|=
name|size_in_bytes
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|type_align
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_CST_LT_UNSIGNED
argument_list|(
name|type_align
argument_list|,
name|sizetype_size
argument_list|)
condition|)
name|cookie_size
operator|=
name|sizetype_size
expr_stmt|;
else|else
name|cookie_size
operator|=
name|type_align
expr_stmt|;
return|return
name|cookie_size
return|;
block|}
end_function

begin_comment
comment|/* Called from cplus_expand_expr when expanding a NEW_EXPR.  The return    value is immediately handed to expand_expr.  */
end_comment

begin_function
specifier|static
name|tree
name|build_new_1
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|placement
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|true_type
decl_stmt|,
name|size
decl_stmt|,
name|rval
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|full_type
decl_stmt|;
name|tree
name|nelts
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|alloc_call
decl_stmt|,
name|alloc_expr
decl_stmt|,
name|alloc_node
decl_stmt|;
name|tree
name|cookie_expr
decl_stmt|,
name|init_expr
decl_stmt|;
name|int
name|has_array
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|use_cookie
decl_stmt|,
name|nothrow
decl_stmt|,
name|check_new
decl_stmt|;
comment|/* Nonzero if the user wrote `::new' rather than just `new'.  */
name|int
name|globally_qualified_p
decl_stmt|;
comment|/* Nonzero if we're going to call a global operator new, rather than      a class-specific version.  */
name|int
name|use_global_new
decl_stmt|;
name|int
name|use_java_new
init|=
literal|0
decl_stmt|;
comment|/* If non-NULL, the number of extra bytes to allocate at the      beginning of the storage allocated for an array-new expression in      order to store the number of elements.  */
name|tree
name|cookie_size
init|=
name|NULL_TREE
decl_stmt|;
comment|/* True if the function we are calling is a placement allocation      function.  */
name|bool
name|placement_allocation_fn_p
decl_stmt|;
name|placement
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|globally_qualified_p
operator|=
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|has_array
operator|=
literal|1
expr_stmt|;
name|nelts
operator|=
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|full_type
operator|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|nelts
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|full_type
operator|=
name|build_index_type
argument_list|(
name|full_type
argument_list|)
expr_stmt|;
name|full_type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|full_type
argument_list|)
expr_stmt|;
block|}
else|else
name|full_type
operator|=
name|type
expr_stmt|;
name|true_type
operator|=
name|type
expr_stmt|;
name|code
operator|=
name|has_array
condition|?
name|VEC_NEW_EXPR
else|:
name|NEW_EXPR
expr_stmt|;
comment|/* If our base type is an array, then make sure we know how many elements      it has.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|true_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|this_nelts
init|=
name|array_type_nelts_top
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
name|nelts
operator|=
name|cp_build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|)
expr_stmt|;
name|true_type
operator|=
name|TREE_TYPE
argument_list|(
name|true_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|true_type
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|size
operator|=
name|size_in_bytes
argument_list|(
name|true_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_array
condition|)
name|size
operator|=
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|size
argument_list|,
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|true_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid type `void' for new"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|true_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Figure out whether or not we're going to use the global operator      new.  */
if|if
condition|(
operator|!
name|globally_qualified_p
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|true_type
argument_list|)
operator|&&
operator|(
name|has_array
condition|?
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|true_type
argument_list|)
else|:
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|true_type
argument_list|)
operator|)
condition|)
name|use_global_new
operator|=
literal|0
expr_stmt|;
else|else
name|use_global_new
operator|=
literal|1
expr_stmt|;
comment|/* We only need cookies for arrays containing types for which we      need cookies.  */
if|if
condition|(
operator|!
name|has_array
operator|||
operator|!
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|true_type
argument_list|)
condition|)
name|use_cookie
operator|=
literal|0
expr_stmt|;
comment|/* When using placement new, users may not realize that they need      the extra storage.  We require that the operator called be      the global placement operator delete[].  */
elseif|else
if|if
condition|(
name|placement
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|placement
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|placement
argument_list|)
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
name|use_cookie
operator|=
operator|!
name|use_global_new
expr_stmt|;
comment|/* Otherwise, we need the cookie.  */
else|else
name|use_cookie
operator|=
literal|1
expr_stmt|;
comment|/* Compute the number of extra bytes to allocate, now that we know      whether or not we need the cookie.  */
if|if
condition|(
name|use_cookie
condition|)
block|{
name|cookie_size
operator|=
name|get_cookie_size
argument_list|(
name|true_type
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|cookie_size
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the object.  */
if|if
condition|(
operator|!
name|placement
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|tree
name|class_addr
decl_stmt|,
name|alloc_decl
decl_stmt|;
name|tree
name|class_decl
init|=
name|build_java_class_ref
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
name|tree
name|class_size
init|=
name|size_in_bytes
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|alloc_name
index|[]
init|=
literal|"_Jv_AllocObject"
decl_stmt|;
name|use_java_new
operator|=
literal|1
expr_stmt|;
name|alloc_decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|alloc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_decl
operator|==
name|NULL_TREE
condition|)
name|fatal_error
argument_list|(
literal|"call to Java constructor with `%s' undefined"
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
name|class_addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|jclass_node
argument_list|,
name|class_decl
argument_list|)
expr_stmt|;
name|alloc_call
operator|=
operator|(
name|build_function_call
argument_list|(
name|alloc_decl
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|class_size
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fnname
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|ansi_opname
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_global_new
condition|)
name|alloc_call
operator|=
operator|(
name|build_new_function_call
argument_list|(
name|lookup_function_nonclass
argument_list|(
name|fnname
argument_list|,
name|args
argument_list|)
argument_list|,
name|args
argument_list|)
operator|)
expr_stmt|;
else|else
name|alloc_call
operator|=
name|build_method_call
argument_list|(
name|build_dummy_object
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloc_call
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The ALLOC_CALL should be a CALL_EXPR, and the first operand      should be the address of a known FUNCTION_DECL.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|alloc_call
argument_list|)
operator|==
name|CALL_EXPR
argument_list|,
literal|20000521
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|,
literal|20000521
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|20000521
argument_list|)
expr_stmt|;
comment|/* Now, check to see if this function is actually a placement      allocation function.  This can happen even when PLACEMENT is NULL      because we might have something like:         struct S { void* operator new (size_t, int i = 0); };       A call to `new S' will get this allocation function, even though      there is no explicit placement argument.  If there is more than      one argument, or there are variable arguments, then this is a      placement allocation function.  */
name|placement_allocation_fn_p
operator|=
operator|(
name|type_num_arguments
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|>
literal|1
operator|||
name|varargs_function_p
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
comment|/*        unless an allocation function is declared with an empty  excep-      tion-specification  (_except.spec_),  throw(), it indicates failure to      allocate storage by throwing a bad_alloc exception  (clause  _except_,      _lib.bad.alloc_); it returns a non-null pointer otherwise If the allo-      cation function is declared  with  an  empty  exception-specification,      throw(), it returns null to indicate failure to allocate storage and a      non-null pointer otherwise.       So check for a null exception spec on the op new we just called.  */
comment|/* The ADDR_EXPR.  */
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The function.  */
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nothrow
operator|=
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|check_new
operator|=
operator|(
name|flag_check_new
operator|||
name|nothrow
operator|)
operator|&&
operator|!
name|use_java_new
expr_stmt|;
name|alloc_expr
operator|=
name|alloc_call
expr_stmt|;
if|if
condition|(
name|use_cookie
condition|)
comment|/* Adjust so we're pointing to the start of the object.  */
name|alloc_expr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|alloc_expr
argument_list|)
argument_list|,
name|alloc_expr
argument_list|,
name|cookie_size
argument_list|)
expr_stmt|;
comment|/* While we're working, use a pointer to the type we've actually      allocated.  */
name|alloc_expr
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|full_type
argument_list|)
argument_list|,
name|alloc_expr
argument_list|)
expr_stmt|;
comment|/* Now save the allocation expression so we only evaluate it once.  */
name|alloc_expr
operator|=
name|get_target_expr
argument_list|(
name|alloc_expr
argument_list|)
expr_stmt|;
name|alloc_node
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now initialize the cookie.  */
if|if
condition|(
name|use_cookie
condition|)
block|{
name|tree
name|cookie
decl_stmt|;
comment|/* Store the number of bytes allocated so that we can know how 	 many elements to destroy later.  We use the last sizeof 	 (size_t) bytes to store the number of elements.  */
name|cookie
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|alloc_node
argument_list|,
name|size_in_bytes
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|cookie
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cookie_expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cookie
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|cookie_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cookie_expr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now initialize the allocated object.  */
name|init_expr
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
condition|)
block|{
name|init_expr
operator|=
name|build_indirect_ref
argument_list|(
name|alloc_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|void_zero_node
condition|)
name|init
operator|=
name|build_default_init
argument_list|(
name|full_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|init
operator|&&
name|pedantic
operator|&&
name|has_array
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids initialization in array new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_array
condition|)
name|init_expr
operator|=
name|build_vec_init
argument_list|(
name|init_expr
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|init_expr
operator|=
name|build_method_call
argument_list|(
name|init_expr
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|init
argument_list|,
name|TYPE_BINFO
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We are processing something like `new int (10)', which 	     means allocate an int, and initialize it with 10.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C++ forbids aggregate initializer to new"
argument_list|)
expr_stmt|;
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|init_expr
operator|=
name|build_modify_expr
argument_list|(
name|init_expr
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If any part of the object initialization terminates by throwing an 	 exception and a suitable deallocation function can be found, the 	 deallocation function is called to free the memory in which the 	 object was being constructed, after which the exception continues 	 to propagate in the context of the new-expression. If no 	 unambiguous matching deallocation function can be found, 	 propagating the exception does not cause the object's memory to be 	 freed.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|use_java_new
condition|)
block|{
name|enum
name|tree_code
name|dcode
init|=
name|has_array
condition|?
name|VEC_DELETE_EXPR
else|:
name|DELETE_EXPR
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|LOOKUP_NORMAL
operator||
operator|(
name|globally_qualified_p
operator|*
name|LOOKUP_GLOBAL
operator|)
operator|)
decl_stmt|;
comment|/* The Standard is unclear here, but the right thing to do              is to use the same method for finding deallocation              functions that we use for finding allocation functions.  */
name|flags
operator||=
name|LOOKUP_SPECULATIVELY
expr_stmt|;
name|cleanup
operator|=
name|build_op_delete_call
argument_list|(
name|dcode
argument_list|,
name|alloc_node
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
operator|(
name|placement_allocation_fn_p
condition|?
name|alloc_call
else|:
name|NULL_TREE
operator|)
argument_list|)
expr_stmt|;
comment|/* Ack!  First we allocate the memory.  Then we set our sentry 	     variable to true, and expand a cleanup that deletes the memory 	     if sentry is true.  Then we run the constructor, and finally 	     clear the sentry.  	     It would be nice to be able to handle this without the sentry 	     variable, perhaps with a TRY_CATCH_EXPR, but this doesn't 	     work.  We allocate the space first, so if there are any 	     temporaries with cleanups in the constructor args we need this 	     EH region to extend until end of full-expression to preserve 	     nesting.  	     If the backend had some mechanism so that we could force the 	     allocation to be expanded after all the other args to the 	     constructor, that would fix the nesting problem and we could 	     do away with this complexity.  But that would complicate other 	     things; in particular, it would make it difficult to bail out 	     if the allocation function returns null.  */
if|if
condition|(
name|cleanup
condition|)
block|{
name|tree
name|end
decl_stmt|,
name|sentry
decl_stmt|,
name|begin
decl_stmt|;
name|begin
operator|=
name|get_target_expr
argument_list|(
name|boolean_true_node
argument_list|)
expr_stmt|;
name|sentry
operator|=
name|TREE_OPERAND
argument_list|(
name|begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|begin
argument_list|,
literal|2
argument_list|)
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|sentry
argument_list|,
name|cleanup
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|end
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sentry
argument_list|)
argument_list|,
name|sentry
argument_list|,
name|boolean_false_node
argument_list|)
expr_stmt|;
name|init_expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|begin
argument_list|,
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|init_expr
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|true_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"uninitialized const in `new' of `%#T'"
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
comment|/* Now build up the return value in reverse order.  */
name|rval
operator|=
name|alloc_node
expr_stmt|;
if|if
condition|(
name|init_expr
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|init_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie_expr
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|cookie_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|alloc_node
condition|)
comment|/* If we didn't modify anything, strip the TARGET_EXPR and return the        (adjusted) call.  */
name|rval
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|check_new
condition|)
block|{
name|tree
name|ifexp
init|=
name|cp_build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|alloc_node
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|rval
argument_list|,
name|alloc_node
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|alloc_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
comment|/* Now strip the outer ARRAY_TYPE, so we return a pointer to the first      element.  */
name|rval
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|build_vec_delete_1
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|type
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|type
decl_stmt|;
name|special_function_kind
name|auto_delete_vec
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|virtual_size
decl_stmt|;
name|tree
name|ptype
init|=
name|build_pointer_type
argument_list|(
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|size_exp
init|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Temporary variables used by the loop.  */
name|tree
name|tbase
decl_stmt|,
name|tbase_init
decl_stmt|;
comment|/* This is the body of the loop that implements the deletion of a      single element, and moves temp variables to next elements.  */
name|tree
name|body
decl_stmt|;
comment|/* This is the LOOP_EXPR that governs the deletion of the elements.  */
name|tree
name|loop
decl_stmt|;
comment|/* This is the thing that governs what to do after the loop has run.  */
name|tree
name|deallocate_expr
init|=
literal|0
decl_stmt|;
comment|/* This is the BIND_EXPR which holds the outermost iterator of the      loop.  It is convenient to set this variable up and test it before      executing any other code in the loop.      This is also the containing expression returned by this function.  */
name|tree
name|controller
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|loop
operator|=
name|integer_zero_node
expr_stmt|;
goto|goto
name|no_destructor
goto|;
block|}
comment|/* The below is short by the cookie size.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
name|tbase
operator|=
name|create_temporary_var
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
name|tbase_init
operator|=
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|base
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|tbase
argument_list|)
operator|=
literal|1
expr_stmt|;
name|controller
operator|=
name|build
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tbase
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|controller
argument_list|)
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|ptype
argument_list|,
name|tbase
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|1
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|tbase
argument_list|,
name|size_exp
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build
argument_list|(
name|EXIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|tbase
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build
argument_list|(
name|LOOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_compound_expr
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tbase_init
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build_compound_expr
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|no_destructor
label|:
comment|/* If the delete flag is one, or anything else with the low bit set,      delete the storage.  */
name|deallocate_expr
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|auto_delete_vec
operator|!=
name|sfk_base_destructor
condition|)
block|{
name|tree
name|base_tbd
decl_stmt|;
comment|/* The below is short by the cookie size.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* no header */
name|base_tbd
operator|=
name|base
expr_stmt|;
else|else
block|{
name|tree
name|cookie_size
decl_stmt|;
name|cookie_size
operator|=
name|get_cookie_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base_tbd
operator|=
name|cp_convert
argument_list|(
name|ptype
argument_list|,
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|string_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|cookie_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* True size with header.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|cookie_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auto_delete_vec
operator|==
name|sfk_deleting_destructor
condition|)
name|deallocate_expr
operator|=
name|build_x_delete
argument_list|(
name|base_tbd
argument_list|,
literal|2
operator||
name|use_global_delete
argument_list|,
name|virtual_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|&&
name|deallocate_expr
operator|!=
name|integer_zero_node
condition|)
block|{
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|deallocate_expr
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|loop
expr_stmt|;
comment|/* Outermost wrapper: If pointer is null, punt.  */
name|body
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|controller
argument_list|,
literal|1
argument_list|)
operator|=
name|body
expr_stmt|;
return|return
name|controller
return|;
block|}
else|else
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|body
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an unnamed variable of the indicated TYPE.  */
end_comment

begin_function
name|tree
name|create_temporary_var
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a new temporary variable of the indicated TYPE, initialized    to INIT.     It is not entered into current_binding_level, because that breaks    things when it comes time to do final cleanups (which take place    "outside" the binding contour of the function).  */
end_comment

begin_function
specifier|static
name|tree
name|get_temp_regvar
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|create_temporary_var
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
condition|)
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|building_stmt_tree
argument_list|()
condition|)
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* `build_vec_init' returns tree structure that performs    initialization of a vector of aggregate types.     BASE is a reference to the vector, of ARRAY_TYPE.    INIT is the (possibly NULL) initializer.     FROM_ARRAY is 0 if we should init everything with INIT    (i.e., every element initialized from INIT).    FROM_ARRAY is 1 if we should index into INIT in parallel    with initialization of DECL.    FROM_ARRAY is 2 if we should index into INIT in parallel,    but use assignment instead of initialization.  */
end_comment

begin_function
name|tree
name|build_vec_init
parameter_list|(
name|base
parameter_list|,
name|init
parameter_list|,
name|from_array
parameter_list|)
name|tree
name|base
decl_stmt|,
name|init
decl_stmt|;
name|int
name|from_array
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|base2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|iterator
decl_stmt|;
comment|/* The type of the array.  */
name|tree
name|atype
init|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
decl_stmt|;
comment|/* The type of an element in the array.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|atype
argument_list|)
decl_stmt|;
comment|/* The type of a pointer to an element in the array.  */
name|tree
name|ptype
decl_stmt|;
name|tree
name|stmt_expr
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|int
name|destroy_temps
decl_stmt|;
name|tree
name|try_block
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|try_body
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|num_initialized_elts
init|=
literal|0
decl_stmt|;
name|tree
name|maxindex
init|=
name|array_type_nelts
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxindex
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* For g++.ext/arrnew.C.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|atype
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
comment|/* Don't do this if the CONSTRUCTOR might contain something 	      that might throw and require us to clean up.  */
operator|&&
operator|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|target_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|from_array
operator|)
condition|)
block|{
comment|/* Do non-default initialization of POD arrays resulting from 	 brace-enclosed initializers.  In this case, digest_init and 	 store_constructor will handle the semantics for us.  */
name|stmt_expr
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|atype
argument_list|,
name|base
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
name|maxindex
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|base
operator|=
name|cp_convert
argument_list|(
name|ptype
argument_list|,
name|default_conversion
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The code we are generating looks like:         T* t1 = (T*) base;        T* rval = t1;        ptrdiff_t iterator = maxindex;        try { 	 do { 	   ... initialize *t1 ... 	   ++t1; 	 } while (--iterator != -1);        } catch (...) {          ... destroy elements that were constructed ...        }        return rval;              We can omit the try and catch blocks if we know that the      initialization will never throw an exception, or if the array      elements do not have destructors.  We can omit the loop completely if      the elements of the array do not have constructors.         We actually wrap the entire body of the above in a STMT_EXPR, for      tidiness.         When copying from array to another, when the array elements have      only trivial copy constructors, we should use __builtin_memcpy      rather than generating a loop.  That way, we could take advantage      of whatever cleverness the back-end has for dealing with copies      of blocks of memory.  */
name|begin_init_stmts
argument_list|(
operator|&
name|stmt_expr
argument_list|,
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
name|destroy_temps
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|get_temp_regvar
argument_list|(
name|ptype
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_temp_regvar
argument_list|(
name|ptype
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
comment|/* Protect the entire array initialization so that we can destroy      the partially constructed array if an exception is thrown.      But don't do this if we're assigning.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|from_array
operator|!=
literal|2
condition|)
block|{
name|try_block
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|try_body
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* Do non-default initialization of non-POD arrays resulting from 	 brace-enclosed initializers.  */
name|tree
name|elts
decl_stmt|;
name|from_array
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|elts
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
decl_stmt|;
name|tree
name|baseref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|num_initialized_elts
operator|++
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|finish_expr_stmt
argument_list|(
name|build_aggr_init
argument_list|(
name|baseref
argument_list|,
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|baseref
argument_list|,
name|NOP_EXPR
argument_list|,
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|iterator
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out INIT so that we don't get confused below.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_array
condition|)
block|{
comment|/* If initializing one array from another, initialize element by 	 element.  We rely upon the below calls the do argument 	 checking.  */
if|if
condition|(
name|init
condition|)
block|{
name|base2
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|base2
argument_list|)
expr_stmt|;
name|base2
operator|=
name|get_temp_regvar
argument_list|(
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer ends prematurely"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Now, default-initialize any remaining elements.  We don't need to      do that if a) the type does not need constructing, or b) we've      already initialized all the elements.       We do need to keep going if we're copying an array.  */
if|if
condition|(
name|from_array
operator|||
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|host_integerp
argument_list|(
name|maxindex
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|num_initialized_elts
operator|==
name|tree_low_cst
argument_list|(
name|maxindex
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* If the ITERATOR is equal to -1, then we don't have to loop; 	 we've already initialized all the elements.  */
name|tree
name|if_stmt
decl_stmt|;
name|tree
name|do_stmt
decl_stmt|;
name|tree
name|do_body
decl_stmt|;
name|tree
name|elt_init
decl_stmt|;
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_minus_one_node
argument_list|)
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
comment|/* Otherwise, loop through the elements.  */
name|do_stmt
operator|=
name|begin_do_stmt
argument_list|()
expr_stmt|;
name|do_body
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* When we're not building a statement-tree, things are a little 	 complicated.  If, when we recursively call build_aggr_init, 	 an expression containing a TARGET_EXPR is expanded, then it 	 may get a cleanup.  Then, the result of that expression is 	 passed to finish_expr_stmt, which will call 	 expand_start_target_temps/expand_end_target_temps.  However, 	 the latter call will not cause the cleanup to run because 	 that block will still be on the block stack.  So, we call 	 expand_start_target_temps here manually; the corresponding 	 call to expand_end_target_temps below will cause the cleanup 	 to be performed.  */
if|if
condition|(
operator|!
name|building_stmt_tree
argument_list|()
condition|)
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_array
condition|)
block|{
name|tree
name|to
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|from
decl_stmt|;
if|if
condition|(
name|base2
condition|)
name|from
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
else|else
name|from
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|from_array
operator|==
literal|2
condition|)
name|elt_init
operator|=
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|elt_init
operator|=
name|build_aggr_init
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from
condition|)
name|elt_init
operator|=
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|init
operator|!=
literal|0
condition|)
name|sorry
argument_list|(
literal|"cannot initialize multi-dimensional array with initializer"
argument_list|)
expr_stmt|;
name|elt_init
operator|=
name|build_vec_init
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|elt_init
operator|=
name|build_aggr_init
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The initialization of each array element is a 	 full-expression, as per core issue 124.  */
if|if
condition|(
operator|!
name|building_stmt_tree
argument_list|()
condition|)
block|{
name|genrtl_expr_stmt
argument_list|(
name|elt_init
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|elt_init
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
block|}
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|base2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|,
name|do_body
argument_list|)
expr_stmt|;
name|finish_do_body
argument_list|(
name|do_stmt
argument_list|)
expr_stmt|;
name|finish_do_stmt
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|iterator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_minus_one_node
argument_list|)
argument_list|,
name|do_stmt
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|()
expr_stmt|;
block|}
comment|/* Make sure to cleanup any partially constructed elements.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|from_array
operator|!=
literal|2
condition|)
block|{
name|tree
name|e
decl_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|1
argument_list|,
name|try_body
argument_list|)
expr_stmt|;
name|finish_cleanup_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_vec_delete_1
argument_list|(
name|rval
argument_list|,
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|iterator
argument_list|)
argument_list|,
name|type
argument_list|,
name|sfk_base_destructor
argument_list|,
comment|/*use_global_delete=*/
literal|0
argument_list|)
expr_stmt|;
name|finish_cleanup
argument_list|(
name|e
argument_list|,
name|try_block
argument_list|)
expr_stmt|;
block|}
comment|/* The value of the array initialization is the address of the      first element in the array.  */
name|finish_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|finish_init_stmts
argument_list|(
name|stmt_expr
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|destroy_temps
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_comment
comment|/* Free up storage of type TYPE, at address ADDR.     TYPE is a POINTER_TYPE and can be ptr_type_node for no special type    of pointer.     VIRTUAL_SIZE is the amount of storage that was allocated, and is    used as the second argument to operator delete.  It can include    things like padding and magic size cookies.  It has virtual in it,    because if you have a base pointer and you delete through a virtual    destructor, it should be the size of the dynamic object, not the    static object, see Free Store 12.5 ISO C++.     This does not call any destructors.  */
end_comment

begin_function
name|tree
name|build_x_delete
parameter_list|(
name|addr
parameter_list|,
name|which_delete
parameter_list|,
name|virtual_size
parameter_list|)
name|tree
name|addr
decl_stmt|;
name|int
name|which_delete
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
block|{
name|int
name|use_global_delete
init|=
name|which_delete
operator|&
literal|1
decl_stmt|;
name|int
name|use_vec_delete
init|=
operator|!
operator|!
operator|(
name|which_delete
operator|&
literal|2
operator|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|use_vec_delete
condition|?
name|VEC_DELETE_EXPR
else|:
name|DELETE_EXPR
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
operator|(
name|use_global_delete
operator|*
name|LOOKUP_GLOBAL
operator|)
decl_stmt|;
return|return
name|build_op_delete_call
argument_list|(
name|code
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call the DTOR_KIND destructor for EXP.  FLAGS are as for    build_delete.  */
end_comment

begin_function
specifier|static
name|tree
name|build_dtor_call
parameter_list|(
name|exp
parameter_list|,
name|dtor_kind
parameter_list|,
name|flags
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|special_function_kind
name|dtor_kind
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
switch|switch
condition|(
name|dtor_kind
condition|)
block|{
case|case
name|sfk_complete_destructor
case|:
name|name
operator|=
name|complete_dtor_identifier
expr_stmt|;
break|break;
case|case
name|sfk_base_destructor
case|:
name|name
operator|=
name|base_dtor_identifier
expr_stmt|;
break|break;
case|case
name|sfk_deleting_destructor
case|:
name|name
operator|=
name|deleting_dtor_identifier
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a call to a destructor. TYPE is the type to cast ADDR to.    ADDR is an expression which yields the store to be destroyed.    AUTO_DELETE is the name of the destructor to call, i.e., either    sfk_complete_destructor, sfk_base_destructor, or    sfk_deleting_destructor.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.  */
end_comment

begin_function
name|tree
name|build_delete
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|,
name|auto_delete
parameter_list|,
name|flags
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|type
decl_stmt|,
name|addr
decl_stmt|;
name|special_function_kind
name|auto_delete
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Can happen when CURRENT_EXCEPTION_OBJECT gets its type      set to `error_mark_node' before it gets properly cleaned up.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
goto|goto
name|handle_array
goto|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Call the builtin operator delete.  */
return|return
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* throw away const and volatile on target type of addr */
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|handle_array
label|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"unknown array size in delete"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete
argument_list|(
name|addr
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|auto_delete
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Don't check PROTECT here; leave that decision to the 	 destructor.  If the destructor is accessible, call it, 	 else report error.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|220
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|auto_delete
operator|!=
name|sfk_deleting_destructor
condition|)
return|return
name|void_zero_node
return|;
return|return
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|addr
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
operator||
operator|(
name|use_global_delete
operator|*
name|LOOKUP_GLOBAL
operator|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|do_delete
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ifexp
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
argument_list|,
literal|20011213
argument_list|)
expr_stmt|;
comment|/* For `::delete x', we must not use the deleting destructor 	 since then we would not be sure to get the global `operator 	 delete'.  */
if|if
condition|(
name|use_global_delete
operator|&&
name|auto_delete
operator|==
name|sfk_deleting_destructor
condition|)
block|{
comment|/* We will use ADDR multiple times so we must save it.  */
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Delete the object. */
name|do_delete
operator|=
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Otherwise, treat this like a complete object destructor 	     call.  */
name|auto_delete
operator|=
name|sfk_complete_destructor
expr_stmt|;
block|}
comment|/* If the destructor is non-virtual, there is no deleting 	 variant.  Instead, we must explicitly call the appropriate 	 `operator delete' here.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|auto_delete
operator|==
name|sfk_deleting_destructor
condition|)
block|{
comment|/* We will use ADDR multiple times so we must save it.  */
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Build the call.  */
name|do_delete
operator|=
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|addr
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Call the complete object destructor.  */
name|auto_delete
operator|=
name|sfk_complete_destructor
expr_stmt|;
block|}
name|expr
operator|=
name|build_dtor_call
argument_list|(
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|auto_delete
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_delete
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|,
name|do_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
condition|)
comment|/* Explicit destructor call; don't check for null pointer.  */
name|ifexp
operator|=
name|integer_one_node
expr_stmt|;
else|else
comment|/* Handle deleting a null pointer.  */
name|ifexp
operator|=
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifexp
operator|!=
name|integer_one_node
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
end_function

begin_comment
comment|/* At the beginning of a destructor, push cleanups that will call the    destructors for our base classes and members.     Called from setup_vtbl_ptr.  */
end_comment

begin_function
name|void
name|push_base_cleanups
parameter_list|()
block|{
name|tree
name|binfos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|expr
decl_stmt|;
comment|/* Run destructors for all virtual baseclasses.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|cond
init|=
operator|(
name|condition_conversion
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_two_node
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* The CLASSTYPE_VBASECLASSES list is in initialization 	 order, which is also the right order for pushing cleanups.  */
for|for
control|(
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|vbase
init|=
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
name|tree
name|base_type
init|=
name|BINFO_TYPE
argument_list|(
name|vbase
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|base_type
argument_list|)
condition|)
block|{
name|tree
name|base_ptr_type
init|=
name|build_pointer_type
argument_list|(
name|base_type
argument_list|)
decl_stmt|;
name|expr
operator|=
name|current_class_ptr
expr_stmt|;
comment|/* Convert to the basetype here, as we know the layout is 		 fixed. What is more, if we let build_method_call do it, 		 it will use the vtable, which may have been clobbered 		 by the deletion of our primary base.  */
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|base_ptr_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|base_ptr_type
argument_list|,
name|expr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|vbase
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_method_call
argument_list|(
name|expr
argument_list|,
name|base_dtor_identifier
argument_list|,
name|NULL_TREE
argument_list|,
name|vbase
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|binfos
operator|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* Take care of the remaining baseclasses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|expr
operator|=
name|build_scoped_method_call
argument_list|(
name|current_class_ref
argument_list|,
name|base_binfo
argument_list|,
name|base_dtor_identifier
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_member
init|=
operator|(
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
name|tree
name|this_type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|this_type
argument_list|,
name|this_member
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For type TYPE, delete the virtual baseclass objects of DECL.  */
end_comment

begin_function
name|tree
name|build_vbase_delete
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|addr
operator|!=
name|error_mark_node
argument_list|,
literal|222
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|this_addr
init|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_addr
argument_list|)
argument_list|,
name|this_addr
argument_list|,
name|sfk_base_destructor
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
return|return
name|build_compound_expr
argument_list|(
name|nreverse
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a C++ vector delete expression.    MAXINDEX is the number of elements to be deleted.    ELT_SIZE is the nominal size of each element in the vector.    BASE is the expression that should yield the store to be deleted.    This function expands (or synthesizes) these calls itself.    AUTO_DELETE_VEC says whether the container (vector) should be deallocated.     This also calls delete for virtual baseclasses of elements of the vector.     Update: MAXINDEX is no longer needed.  The size can be extracted from the    start of the vector for pointers, and from the type for arrays.  We still    use MAXINDEX for arrays because it happens to already have one of the    values we'd have to extract.  (We could use MAXINDEX with pointers to    confirm the size, and trap if the numbers differ; not clear that it'd    be worth bothering.)  */
end_comment

begin_function
name|tree
name|build_vec_delete
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|;
name|special_function_kind
name|auto_delete_vec
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|base
operator|=
name|resolve_offset_ref
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|stabilize_reference
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Since we can use base many times, save_expr it.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|save_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Step back one from start of vector, and read dimension.  */
name|tree
name|cookie_addr
decl_stmt|;
name|type
operator|=
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cookie_addr
operator|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|base
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|maxindex
operator|=
name|build_indirect_ref
argument_list|(
name|cookie_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* get the total number of things in the array, maxindex is a bad name */
name|maxindex
operator|=
name|array_type_nelts_total
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"type to vector delete is neither pointer or array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete_1
argument_list|(
name|base
argument_list|,
name|maxindex
argument_list|,
name|type
argument_list|,
name|auto_delete_vec
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
end_function

end_unit

