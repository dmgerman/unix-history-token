begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle initialization things in C++.    Copyright (C) 1987, 89, 92-98, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* In C++, structures with well-defined constructors are initialized by    those constructors, unasked.  CURRENT_BASE_INIT_LIST    holds a list of stmts for a BASE_INIT term in the grammar.    This list has one element for each base class which must be    initialized.  The list elements are [basename, init], with    type basetype.  This allows the possibly anachronistic form    (assuming d : a, b, c) "d (int a) : c(a+5), b (a-4), a (a+3)"    where each successive term can be handed down the constructor    line.  Perhaps this was not intended.  */
end_comment

begin_decl_stmt
name|tree
name|current_base_init_list
decl_stmt|,
name|current_member_init_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_aggr_vbase_init_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|construct_virtual_bases
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_aggr_init_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_default_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_vec_delete_1
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|perform_member_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_base_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_builtin_delete_call
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|member_init_ok_or_else
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_virtual_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|sort_member_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|initializing_context
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_vec_init_try_block
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_vec_init_catch_clause
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_java_class_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_cleanup_for_base
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache the identifier nodes for the magic field of a new cookie.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|nc_nelts_field_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|minus_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up local variable for this file.  MUST BE CALLED AFTER    INIT_DECL_PROCESSING.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BI_header_type
decl_stmt|,
name|BI_header_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_init_processing
parameter_list|()
block|{
name|tree
name|fields
index|[
literal|1
index|]
decl_stmt|;
name|minus_one
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Define the structure that holds header information for      arrays allocated via operator new.  */
name|BI_header_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|nc_nelts_field_id
operator|=
name|get_identifier
argument_list|(
literal|"nelts"
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|nc_nelts_field_id
argument_list|,
name|sizetype
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|BI_header_type
argument_list|,
literal|"__new_cookie"
argument_list|,
name|fields
argument_list|,
literal|0
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|BI_header_size
operator|=
name|size_in_bytes
argument_list|(
name|BI_header_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of emit_base_init.  For BINFO, initialize all the    virtual function table pointers, except those that come from    virtual base classes.  Initialize binfo's vtable pointer, if    INIT_SELF is true.  CAN_ELIDE is true when we know that all virtual    function table pointers in all bases have been initialized already,    probably because their constructors have just be run.  ADDR is the    pointer to the object whos vtables we are going to initialize.     REAL_BINFO is usually the same as BINFO, except when addr is not of    pointer to the type of the real derived type that we want to    initialize for.  This is the case when addr is a pointer to a sub    object of a complete object, and we only want to do part of the    complete object's initialization of vtable pointers.  This is done    for all virtual table pointers in virtual base classes.  REAL_BINFO    is used to find the BINFO_VTABLE that we initialize with.  BINFO is    used for conversions of addr to subobjects.     BINFO_TYPE (real_binfo) must be BINFO_TYPE (binfo).     Relies upon binfo being inside TYPE_BINFO (TREE_TYPE (TREE_TYPE    (addr))).  */
end_comment

begin_function
name|void
name|expand_direct_vtbls_init
parameter_list|(
name|real_binfo
parameter_list|,
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|can_elide
parameter_list|,
name|addr
parameter_list|)
name|tree
name|real_binfo
decl_stmt|,
name|binfo
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|init_self
decl_stmt|,
name|can_elide
decl_stmt|;
block|{
name|tree
name|real_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|real_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|real_binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|real_binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|real_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|real_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|real_base_binfo
argument_list|)
condition|)
name|expand_direct_vtbls_init
argument_list|(
name|real_base_binfo
argument_list|,
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|can_elide
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Before turning this on, make sure it is correct.  */
block|if (can_elide&& ! BINFO_MODIFIED (binfo))     return;
endif|#
directive|endif
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base_ptr
init|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|expand_virtual_init
argument_list|(
name|real_binfo
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 348 - 351 */
end_comment

begin_comment
comment|/* Subroutine of emit_base_init.  */
end_comment

begin_function
specifier|static
name|void
name|perform_member_init
parameter_list|(
name|member
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|,
name|explicit
parameter_list|)
name|tree
name|member
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
name|int
name|explicit
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|init
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
comment|/* Since `init' is already a TREE_LIST on the current_member_init_list, 	 only build it into one if we aren't already a list.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|init
operator|=
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Initialization of one array from another.  */
name|expand_vec_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decl
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|explicit
condition|)
block|{
comment|/* default-initialization.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|cp_error
argument_list|(
literal|"default-initialization of `%#D', which has reference type"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|init
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* member traversal: note it leaves init NULL */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|cp_pedwarn
argument_list|(
literal|"uninitialized reference member `%D'"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* There was an explicit member initialization.  Do some 	     work in that case.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"initializer list treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* We only build this with a null init if we got it from the 	 current_member_init_list.  */
if|if
condition|(
name|init
operator|||
name|explicit
condition|)
block|{
name|decl
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|expr
decl_stmt|;
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|expr
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|add_partial_entry
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|warn_reorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine of emit_member_init.  */
end_comment

begin_function
specifier|static
name|tree
name|sort_member_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|,
name|member
decl_stmt|,
name|name
decl_stmt|,
name|field
decl_stmt|;
name|tree
name|init_list
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|last_pos
init|=
literal|0
decl_stmt|;
name|tree
name|last_field
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
name|int
name|pos
decl_stmt|;
comment|/* member could be, for example, a CONST_DECL for an enumerated 	 tag; we don't want to try to initialize that, since it already 	 has a value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_NAME
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|current_member_init_list
operator|,
name|pos
operator|=
literal|0
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|,
operator|++
name|pos
control|)
block|{
comment|/* If we cleared this out, then pay no attention to it.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This happens in templates, since the IDENTIFIER is replaced              with the COMPONENT_REF in tsubst_expr.  */
block|field = (TREE_CODE (name) == COMPONENT_REF 		   ? TREE_OPERAND (name, 1) : IDENTIFIER_CLASS_VALUE (name));
else|#
directive|else
comment|/* Let's find out when this happens.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|COMPONENT_REF
argument_list|,
literal|348
argument_list|)
expr_stmt|;
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If one member shadows another, get the outermost one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|member
condition|)
block|{
if|if
condition|(
name|warn_reorder
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|last_pos
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"member initializers for `%#D'"
argument_list|,
name|last_field
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  and `%#D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will be re-ordered to match declaration order"
argument_list|)
expr_stmt|;
block|}
name|last_pos
operator|=
name|pos
expr_stmt|;
name|last_field
operator|=
name|field
expr_stmt|;
block|}
comment|/* Make sure we won't try to work on this init again.  */
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|x
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
comment|/* If we didn't find MEMBER in the list, create a dummy entry 	 so the two lists (INIT_LIST and the list of members) will be 	 symmetrical.  */
name|x
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|got_it
label|:
name|init_list
operator|=
name|chainon
argument_list|(
name|init_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Initializers for base members go at the end.  */
for|for
control|(
name|x
operator|=
name|current_member_init_list
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|init_list
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"multiple initializations given for member `%D'"
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|init_list
operator|=
name|chainon
argument_list|(
name|init_list
argument_list|,
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
return|return
name|init_list
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_base_init
parameter_list|(
name|t
parameter_list|,
name|rbase_ptr
parameter_list|,
name|vbase_ptr
parameter_list|)
name|tree
name|t
decl_stmt|,
decl|*
name|rbase_ptr
decl_stmt|,
modifier|*
name|vbase_ptr
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|x
decl_stmt|;
name|tree
name|last
decl_stmt|;
comment|/* For warn_reorder.  */
name|int
name|last_pos
init|=
literal|0
decl_stmt|;
name|tree
name|last_base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rbases
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vbases
init|=
name|NULL_TREE
decl_stmt|;
comment|/* First walk through and splice out vbase and invalid initializers.      Also replace names with binfos.  */
name|last
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|basetype
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Initializer for single base class.  Must not 	     use multiple inheritance or this is ambiguous.  */
switch|switch
condition|(
name|n_baseclasses
condition|)
block|{
case|case
literal|0
case|:
name|cp_error
argument_list|(
literal|"`%T' does not have a base class to initialize"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
break|break;
default|default:
name|cp_error
argument_list|(
literal|"unnamed initializer ambiguous for `%T' which uses multiple inheritance"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|basetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* Virtual base classes are special cases.  Their initializers 	     are recorded with this constructor, and they are used when 	     this constructor is the top-level constructor called.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|v
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|BINFO_TYPE
argument_list|(
name|v
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
condition|)
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|tree_cons
argument_list|(
name|v
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
name|vbases
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Otherwise, if it is not an immediate base class, complain.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is not an immediate base class of `%T'"
argument_list|,
name|basetype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|365
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|x
expr_stmt|;
name|last
operator|=
name|x
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now walk through our regular bases and make sure they're initialized.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|current_base_init_list
operator|,
name|pos
operator|=
literal|0
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|,
operator|++
name|pos
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|binfo
operator|==
name|base_binfo
condition|)
block|{
if|if
condition|(
name|warn_reorder
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|last_pos
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"base initializers for `%#T'"
argument_list|,
name|last_base
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  and `%#T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will be re-ordered to match inheritance order"
argument_list|)
expr_stmt|;
block|}
name|last_pos
operator|=
name|pos
expr_stmt|;
name|last_base
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we won't try to work on this init again.  */
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|x
operator|=
name|build_tree_list
argument_list|(
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
comment|/* If we didn't find BASE_BINFO in the list, create a dummy entry 	 so the two lists (RBASES and the list of bases) will be 	 symmetrical.  */
name|x
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|got_it
label|:
name|rbases
operator|=
name|chainon
argument_list|(
name|rbases
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
operator|*
name|rbase_ptr
operator|=
name|rbases
expr_stmt|;
operator|*
name|vbase_ptr
operator|=
name|vbases
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Perform whatever initializations have yet to be done on the base    class of the class variable.  These actions are in the global    variable CURRENT_BASE_INIT_LIST.  Such an action could be    NULL_TREE, meaning that the user has explicitly called the base    class constructor with no arguments.     If there is a need for a call to a constructor, we must surround    that call with a pushlevel/poplevel pair, since we are technically    at the PARM level of scope.     Argument IMMEDIATELY, if zero, forces a new sequence to be    generated to contain these new insns, so it can be emitted later.    This sequence is saved in the global variable BASE_INIT_EXPR.    Otherwise, the insns are emitted into the current sequence.     Note that emit_base_init does *not* initialize virtual base    classes.  That is done specially, elsewhere.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|base_init_expr
decl_stmt|,
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|emit_base_init
parameter_list|(
name|t
parameter_list|,
name|immediately
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|immediately
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|mem_init_list
decl_stmt|;
name|tree
name|rbase_init_list
decl_stmt|,
name|vbase_init_list
decl_stmt|;
name|tree
name|t_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|immediately
condition|)
block|{
name|int
name|momentary
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Make the RTL_EXPR node temporary, not momentary, 	 so that rtl_expr_chain doesn't become garbage.  */
name|momentary
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|expr
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Always emit a line number note so we can step into constructors.  */
name|emit_line_note_force
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|mem_init_list
operator|=
name|sort_member_init
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|sort_base_init
argument_list|(
name|t
argument_list|,
operator|&
name|rbase_init_list
argument_list|,
operator|&
name|vbase_init_list
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* First, initialize the virtual base classes, if we are      constructing the most-derived object.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|first_arg
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|construct_virtual_bases
argument_list|(
name|t
argument_list|,
name|current_class_ref
argument_list|,
name|current_class_ptr
argument_list|,
name|vbase_init_list
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
block|}
comment|/* Now, perform initialization of non-virtual base classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|void_list_node
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|my_friendly_assert
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|==
name|t_binfo
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|rbase_init_list
argument_list|)
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|rbase_init_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|extra_warnings
operator|&&
name|copy_args_p
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|cp_warning
argument_list|(
literal|"base class `%#T' should be explicitly initialized in the copy constructor"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|!=
name|void_list_node
condition|)
block|{
name|expand_start_target_temps
argument_list|()
expr_stmt|;
name|member
operator|=
name|convert_pointer_to_real
argument_list|(
name|base_binfo
argument_list|,
name|current_class_ptr
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|base_binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|build_indirect_ref
argument_list|(
name|member
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
name|expand_cleanup_for_base
argument_list|(
name|base_binfo
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|rbase_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|rbase_init_list
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize all the virtual function table fields that      do come from virtual base classes.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|expand_indirect_vtbls_init
argument_list|(
name|t_binfo
argument_list|,
name|current_class_ref
argument_list|,
name|current_class_ptr
argument_list|)
expr_stmt|;
comment|/* Initialize all the virtual function table fields that      do not come from virtual base classes.  */
name|expand_direct_vtbls_init
argument_list|(
name|t_binfo
argument_list|,
name|t_binfo
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|current_class_ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
name|tree
name|init
decl_stmt|,
name|name
decl_stmt|;
name|int
name|from_init_list
decl_stmt|;
comment|/* member could be, for example, a CONST_DECL for an enumerated 	 tag; we don't want to try to initialize that, since it already 	 has a value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_NAME
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
comment|/* See if we had a user-specified member initialization.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
condition|)
block|{
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|from_init_list
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (name) == COMPONENT_REF) 	    name = DECL_NAME (TREE_OPERAND (name, 1));
else|#
directive|else
comment|/* Also see if it's ever a COMPONENT_REF here.  If it is, we 	     need to do `expand_assignment (name, init, 0, 0);' and 	     a continue.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|COMPONENT_REF
argument_list|,
literal|349
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|from_init_list
operator|=
literal|0
expr_stmt|;
comment|/* Effective C++ rule 12.  */
if|if
condition|(
name|warn_ecpp
operator|&&
name|init
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|member
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|cp_warning
argument_list|(
literal|"`%D' should be initialized in the member initialization list"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|perform_member_init
argument_list|(
name|member
argument_list|,
name|name
argument_list|,
name|init
argument_list|,
name|from_init_list
argument_list|)
expr_stmt|;
name|mem_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
block|}
comment|/* Now initialize any members from our bases.  */
while|while
condition|(
name|mem_init_list
condition|)
block|{
name|tree
name|name
decl_stmt|,
name|init
decl_stmt|,
name|field
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
condition|)
block|{
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
comment|/* XXX: this may need the COMPONENT_REF operand 0 check if 	     it turns out we actually get them.  */
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* If one member shadows another, get the outermost one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_type_context
argument_list|(
name|field
argument_list|)
operator|!=
name|current_class_type
condition|)
name|cp_error
argument_list|(
literal|"field `%D' not in immediate context"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* It turns out if you have an anonymous union in the 	     class, a member from it can end up not being on the 	     list of fields (rather, the type is), and therefore 	     won't be seen by the for loop above.  */
comment|/* The code in this for loop is derived from a general loop 	     which had this check in it.  Theoretically, we've hit 	     every initialization for the list of members in T, so 	     we shouldn't have anything but these left in this list.  */
block|my_friendly_assert (DECL_FIELD_CONTEXT (field) != t, 351);
endif|#
directive|endif
name|perform_member_init
argument_list|(
name|field
argument_list|,
name|name
argument_list|,
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mem_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|immediately
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|base_init_expr
operator|==
literal|0
argument_list|,
literal|207
argument_list|)
expr_stmt|;
name|base_init_expr
operator|=
name|expr
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rtl_expr_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|rtl_expr_chain
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* All the implicit try blocks we built up will be zapped      when we come to a real binding contour boundary.  */
block|}
end_function

begin_comment
comment|/* Check that all fields are properly initialized after    an assignment to `this'.  */
end_comment

begin_function
name|void
name|check_base_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|member
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|member
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"field `%D' used before initialized (after assignment to `this')"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This code sets up the virtual function tables appropriate for    the pointer DECL.  It is a one-ply initialization.     BINFO is the exact type that DECL is supposed to be.  In    multiple inheritance, this might mean "C's A" if C : A, B.  */
end_comment

begin_function
specifier|static
name|void
name|expand_virtual_init
parameter_list|(
name|binfo
parameter_list|,
name|decl
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|vtbl
decl_stmt|,
name|vtbl_ptr
decl_stmt|;
name|tree
name|vtype
decl_stmt|,
name|vtype_binfo
decl_stmt|;
comment|/* This code is crusty.  Should be simple, like:      vtbl = BINFO_VTABLE (binfo);      */
name|vtype
operator|=
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|vtype_binfo
operator|=
name|get_binfo
argument_list|(
name|vtype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo_value
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|convert_pointer_to_real
argument_list|(
name|vtype_binfo
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|vtbl_ptr
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtbl_ptr
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Have to convert VTBL since array sizes may be different.  */
name|vtbl
operator|=
name|convert_force
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl_ptr
argument_list|)
argument_list|,
name|vtbl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|vtbl_ptr
argument_list|,
name|NOP_EXPR
argument_list|,
name|vtbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If an exception is thrown in a constructor, those base classes already    constructed must be destroyed.  This function creates the cleanup    for BINFO, which has just been constructed.  If FLAG is non-NULL,    it is a DECL which is non-zero when this base needs to be    destroyed.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanup_for_base
parameter_list|(
name|binfo
parameter_list|,
name|flag
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|flag
decl_stmt|;
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* All cleanups must be on the function_obstack.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Call the destructor.  */
name|expr
operator|=
operator|(
name|build_scoped_method_call
argument_list|(
name|current_class_ref
argument_list|,
name|binfo
argument_list|,
name|dtor_identifier
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|truthvalue_conversion
argument_list|(
name|flag
argument_list|)
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|add_partial_entry
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of `expand_aggr_vbase_init'.    BINFO is the binfo of the type that is being initialized.    INIT_LIST is the list of initializers for the virtual baseclass.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_vbase_init_1
parameter_list|(
name|binfo
parameter_list|,
name|exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|exp
decl_stmt|,
name|addr
decl_stmt|,
name|init_list
decl_stmt|;
block|{
name|tree
name|init
init|=
name|purpose_member
argument_list|(
name|binfo
argument_list|,
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Call constructors, but don't set up vtables.  */
name|expand_aggr_init_1
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|ref
argument_list|,
name|init
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the virtual base-classes of THIS_REF (whose address is    THIS_PTR).  The object has the indicated TYPE.  The construction    actually takes place only if FLAG is non-zero.  INIT_LIST is list    of initialization for constructor to perform.  */
end_comment

begin_function
specifier|static
name|void
name|construct_virtual_bases
parameter_list|(
name|type
parameter_list|,
name|this_ref
parameter_list|,
name|this_ptr
parameter_list|,
name|init_list
parameter_list|,
name|flag
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|this_ref
decl_stmt|;
name|tree
name|this_ptr
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|tree
name|flag
decl_stmt|;
block|{
name|tree
name|vbases
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* If there are no virtual baseclasses, we shouldn't even be here.  */
name|my_friendly_assert
argument_list|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|,
literal|19990621
argument_list|)
expr_stmt|;
comment|/* First set the pointers in our object that tell us where to find      our virtual baseclasses.  */
name|expand_start_cond
argument_list|(
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|init_vbase_pointers
argument_list|(
name|type
argument_list|,
name|this_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|expand_expr_stmt
argument_list|(
name|build_compound_expr
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
comment|/* Now, run through the baseclasses, initializing each.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|tmp
init|=
name|purpose_member
argument_list|(
name|vbases
argument_list|,
name|result
argument_list|)
decl_stmt|;
comment|/* If there are virtual base classes with destructors, we need to 	 emit cleanups to destroy them if an exception is thrown during 	 the construction process.  These exception regions (i.e., the 	 period during which the cleanups must occur) begin from the time 	 the construction is complete to the end of the function.  If we 	 create a conditional block in which to initialize the 	 base-classes, then the cleanup region for the virtual base begins 	 inside a block, and ends outside of that block.  This situation 	 confuses the sjlj exception-handling code.  Therefore, we do not 	 create a single conditional block, but one for each 	 initialization.  (That way the cleanup regions always begin 	 in the outer block.)  We trust the back-end to figure out 	 that the FLAG will not change across initializations, and 	 avoid doing multiple tests.  */
name|expand_start_cond
argument_list|(
name|flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_vbase_init_1
argument_list|(
name|vbases
argument_list|,
name|this_ref
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_cleanup_for_base
argument_list|(
name|vbases
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the context in which this FIELD can be initialized.  */
end_comment

begin_function
specifier|static
name|tree
name|initializing_context
parameter_list|(
name|field
parameter_list|)
name|tree
name|field
decl_stmt|;
block|{
name|tree
name|t
init|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* Anonymous union members can be initialized in the first enclosing      non-anonymous union context.  */
while|while
condition|(
name|t
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Function to give error message if member initialization specification    is erroneous.  FIELD is the member we decided to initialize.    TYPE is the type for which the initialization is being performed.    FIELD must be a member of TYPE.        MEMBER_NAME is the name of the member.  */
end_comment

begin_function
specifier|static
name|int
name|member_init_ok_or_else
parameter_list|(
name|field
parameter_list|,
name|type
parameter_list|,
name|member_name
parameter_list|)
name|tree
name|field
decl_stmt|;
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|member_name
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
operator|||
name|initializing_context
argument_list|(
name|field
argument_list|)
operator|!=
name|type
condition|)
block|{
name|cp_error
argument_list|(
literal|"class `%T' does not have any field named `%s'"
argument_list|,
name|type
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"field `%#D' is static; only point of initialization is its declaration"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If NAME is a viable field name for the aggregate DECL,    and PARMS is a viable parameter list, then expand an _EXPR    which describes this initialization.     Note that we do not need to chase through the class's base classes    to look for NAME, because if it's in that list, it will be handled    by the constructor for that base class.     We do not yet have a fixed-point finder to instantiate types    being fed to overloaded constructors.  If there is a unique    constructor, then argument types can be got from that one.     If INIT is non-NULL, then it the initialization should    be placed in `current_base_init_list', where it will be processed    by `emit_base_init'.  */
end_comment

begin_function
name|void
name|expand_member_init
parameter_list|(
name|exp
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|,
name|field
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* complain about this later */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
switch|switch
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"base class initializer specified, but no base class to initialize"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"initializer for unnamed base class ambiguous"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"(type `%T' uses multiple inheritance)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The grammar should not allow fields which have names that are      TYPENAMEs.  Therefore, if the field has a non-NULL TREE_TYPE, we      may assume that this is an attempt to initialize a base class      member of the current type.  Otherwise, it is an attempt to      initialize a member field.  */
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|||
name|basetype
condition|)
block|{
name|tree
name|base_init
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
block|{
if|#
directive|if
literal|0
block|if (basetype) 	    name = TYPE_IDENTIFIER (basetype); 	  else 	    { 	      error ("no base class to initialize"); 	      return; 	    }
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|basetype
operator|!=
name|type
operator|&&
operator|!
name|current_template_parms
operator|&&
operator|!
name|vec_binfo_member
argument_list|(
name|basetype
argument_list|,
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
goto|goto
name|try_member
goto|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"type `%T' is not an immediate or virtual basetype for `%T'"
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"type `%T' is not an immediate basetype for `%T'"
argument_list|,
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|purpose_member
argument_list|(
name|basetype
argument_list|,
name|current_base_init_list
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"base class `%T' already initialized"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|warn_reorder
operator|&&
name|current_member_init_list
condition|)
block|{
name|cp_warning
argument_list|(
literal|"base initializer for `%T'"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"   will be re-ordered to precede member initializations"
argument_list|)
expr_stmt|;
block|}
name|base_init
operator|=
name|build_tree_list
argument_list|(
name|basetype
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|chainon
argument_list|(
name|current_base_init_list
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|member_init
decl_stmt|;
name|try_member
label|:
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|current_member_init_list
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"field `%D' already initialized"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return;
block|}
name|member_init
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|chainon
argument_list|(
name|current_member_init_list
argument_list|,
name|member_init
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is like `expand_member_init', only it stores one aggregate    value into another.     INIT comes in two flavors: it is either a value which    is to be stored in EXP, or it is a parameter list    to go to a constructor, which will operate on EXP.    If INIT is not a parameter list for a constructor, then set    LOOKUP_ONLYCONVERTING.    If FLAGS is LOOKUP_ONLYCONVERTING then it is the = init form of    the initializer, if FLAGS is 0, then it is the (init) form.    If `init' is a CONSTRUCTOR, then we emit a warning message,    explaining that such initializations are invalid.     ALIAS_THIS is nonzero iff we are initializing something which is    essentially an alias for current_class_ref.  In this case, the base    constructor may move it on us, and we must keep track of such    deviations.     If INIT resolves to a CALL_EXPR which happens to return    something of the type we are looking for, then we know    that we can safely use that call to perform the    initialization.     The virtual function table pointer cannot be set up here, because    we do not really know its type.     Virtual baseclass pointers are also set up here.     This never calls operator=().     When initializing, nothing is CONST.     A default copy constructor may have to be used to perform the    initialization.     A constructor or a conversion operator may have to be used to    perform the initialization, but not both, as it would be ambiguous.  */
end_comment

begin_function
name|void
name|expand_aggr_init
parameter_list|(
name|exp
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_const
init|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_volatile
init|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Must arrange to initialize each element of EXP 	 from elements of INIT.  */
name|tree
name|itype
init|=
name|init
condition|?
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Handle bad initializers like: 	     class COMPLEX { 	     public: 	       double re, im; 	       COMPLEX(double r = 0.0, double i = 0.0) {re = r; im = i;}; 	       ~COMPLEX() {}; 	     };  	     int main(int argc, char **argv) { 	       COMPLEX zees(1.0, 0.0)[10]; 	     } 	  */
name|error
argument_list|(
literal|"bad array initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|expand_vec_init
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
name|init
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|itype
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
comment|/* just know that we've seen something for this node */
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If initializing from a GNU C CONSTRUCTOR, consider the elts in the      constructor as parameters to an implicit GNU C++ constructor.  */
block|if (init&& TREE_CODE (init) == CONSTRUCTOR&& TYPE_HAS_CONSTRUCTOR (type)&& TREE_TYPE (init) == type)     init = CONSTRUCTOR_ELTS (init);
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
operator||
name|flags
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_default_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|/* It fails because there may not be a constructor which takes      its own type as the first (or only parameter), but which does      take other types via a conversion.  So, if the thing initializing      the expression is a unit element of type X, first try X(X&),      followed by initialization by X.  If neither of these work      out, then look hard.  */
name|tree
name|rval
decl_stmt|;
name|tree
name|parms
decl_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
condition|)
block|{
comment|/* Base subobjects should only get direct-initialization.  */
if|if
condition|(
name|true_exp
operator|!=
name|exp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DIRECT_BIND
condition|)
comment|/* Do nothing.  We hit this in two cases:  Reference initialization, 	   where we aren't initializing a real variable, so we don't want 	   to run a new constructor; and catching an exception, where we 	   have already built up the constructor call so we could wrap it 	   in an exception region.  */
empty_stmt|;
else|else
name|init
operator|=
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TRY_CATCH_EXPR
condition|)
comment|/* We need to protect the initialization of a catch parm 	   with a call to terminate(), which shows up as a TRY_CATCH_EXPR 	   around the TARGET_EXPR for the copy constructor.  See 	   expand_start_catch_block.  */
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|)
condition|)
block|{
name|parms
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|parms
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
name|parms
operator|=
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|true_exp
operator|==
name|exp
condition|)
name|parms
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
else|else
name|parms
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
block|}
name|rval
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|ctor_identifier
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
condition|)
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is responsible for initializing EXP with INIT    (if any).     BINFO is the binfo of the type for who we are performing the    initialization.  For example, if W is a virtual base class of A and B,    and C : A, B.    If we are initializing B, then W must contain B's W vtable, whereas    were we initializing C, W must contain C's W vtable.     TRUE_EXP is nonzero if it is the true expression being initialized.    In this case, it may be EXP, or may just contain EXP.  The reason we    need this is because if EXP is a base element of TRUE_EXP, we    don't necessarily know by looking at EXP where its virtual    baseclass fields should really be pointing.  But we do know    from TRUE_EXP.  In constructors, we don't know anything about    the value being initialized.     ALIAS_THIS serves the same purpose it serves for expand_aggr_init.     FLAGS is just passes to `build_method_call'.  See that function for    its description.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|error_mark_node
operator|&&
name|type
operator|!=
name|error_mark_node
argument_list|,
literal|211
argument_list|)
expr_stmt|;
comment|/* Use a function returning the desired type to initialize EXP for us.      If the function is a constructor, and its first argument is      NULL_TREE, know that it was meant for us--just slide exp on      in and expand the constructor.  Constructors now come      as TARGET_EXPRs.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|store_init_value
argument_list|(
name|exp
argument_list|,
name|init
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|expand_decl_init
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We know that expand_default_init can handle everything we want      at this point.  */
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error if NAME is not the name of a user-defined,    aggregate type.  If OR_ELSE is nonzero, give an error message.  */
end_comment

begin_function
name|int
name|is_aggr_typedef
parameter_list|(
name|name
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not an aggregate typedef"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not an aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Report an error if TYPE is not a user-defined, aggregate type.  If    OR_ELSE is nonzero, give an error message.  */
end_comment

begin_function
name|int
name|is_aggr_type
parameter_list|(
name|type
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not an aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like is_aggr_typedef, but returns typedef if successful.  */
end_comment

begin_function
name|tree
name|get_aggr_from_typedef
parameter_list|(
name|name
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' fails to be an aggregate typedef"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"type `%T' is of non-aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|get_type_value
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This code could just as well go in `class.c', but is placed here for    modularity.  */
end_comment

begin_comment
comment|/* For an expression of the form TYPE :: NAME (PARMLIST), build    the appropriate function call.  */
end_comment

begin_function
name|tree
name|build_member_call
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|,
name|parmlist
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|method_name
decl_stmt|;
name|int
name|dtor
init|=
literal|0
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
comment|/* 'name' already refers to the decls from the namespace, since we 	 hit do_identifier for template_ids.  */
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: Since we don't do independent names right yet, the 	 name might also be a LOOKUP_EXPR. Once we resolve this to a 	 real decl earlier, this can go. This may happen during 	 tsubst'ing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
block|{
name|method_name
operator|=
name|lookup_namespace_name
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|=
name|method_name
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|is_overloaded_fn
argument_list|(
name|method_name
argument_list|)
argument_list|,
literal|980519
argument_list|)
expr_stmt|;
return|return
name|build_x_function_call
argument_list|(
name|name
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|std_node
condition|)
return|return
name|build_x_function_call
argument_list|(
name|do_scoped_id
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|build_x_function_call
argument_list|(
name|lookup_namespace_name
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|method_name
argument_list|)
condition|)
name|method_name
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|method_name
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|=
name|method_name
expr_stmt|;
block|}
else|else
name|method_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtor
operator|=
literal|1
expr_stmt|;
block|}
comment|/* This shouldn't be here, and build_member_call shouldn't appear in      parse.y!  (mrs)  */
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|get_aggr_from_typedef
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|ns
init|=
name|lookup_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|&&
name|TREE_CODE
argument_list|(
name|ns
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
return|return
name|build_x_function_call
argument_list|(
name|build_offset_ref
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|current_class_ref
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* An operator we did not like.  */
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|dtor
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot call destructor `%T::~%T' without object"
argument_list|,
name|type
argument_list|,
name|method_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|type
argument_list|,
operator|&
name|basetype_path
argument_list|)
expr_stmt|;
comment|/* Convert 'this' to the specified type to disambiguate conversion      to the function's context.  Apparently Standard C++ says that we      shouldn't do this.  */
if|if
condition|(
name|decl
operator|==
name|current_class_ref
operator|&&
operator|!
name|pedantic
operator|&&
name|ACCESSIBLY_UNIQUELY_DERIVED_P
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|olddecl
init|=
name|current_class_ptr
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldtype
operator|!=
name|type
condition|)
block|{
name|tree
name|newtype
init|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUALS
argument_list|(
name|oldtype
argument_list|)
argument_list|)
decl_stmt|;
name|decl
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|olddecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|method_name
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|||
name|method_name
operator|==
name|constructor_name_full
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|parmlist
argument_list|)
return|;
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|method_name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|?
name|name
else|:
name|method_name
argument_list|,
name|parmlist
argument_list|,
name|basetype_path
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
operator|(
name|t
operator|=
name|lookup_field
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|is_dummy_object
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid use of non-static field `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|decl
operator|=
name|t
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"invalid use of member `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|decl
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|build_function_call
argument_list|(
name|decl
argument_list|,
name|parmlist
argument_list|)
return|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"no method `%T::%D'"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build a reference to a member of an aggregate.  This is not a    C++ `&', but really something which can have its address taken,    and then act as a pointer to member, for example TYPE :: FIELD    can have its address taken by saying& TYPE :: FIELD.     @@ Prints out lousy diagnostics for operator<typename>    @@ fields.     @@ This function should be rewritten and placed in search.c.  */
end_comment

begin_function
name|tree
name|build_offset_ref
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|t
init|=
name|error_mark_node
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|basebinfo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|orig_name
init|=
name|name
decl_stmt|;
comment|/* class templates can come in as TEMPLATE_DECLs here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|name
return|;
if|if
condition|(
name|type
operator|==
name|std_node
condition|)
return|return
name|do_scoped_id
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|processing_template_decl
operator|||
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|SCOPE_REF
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
comment|/* Handle namespace names fully here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|t
operator|=
name|lookup_namespace_name
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
operator|&&
operator|!
name|type_unknown_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|convert_from_reference
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* If the NAME is a TEMPLATE_ID_EXPR, we are looking at 	 something like `a.template f<int>' or the like.  For the most 	 part, we treat this just like a.f.  We do remember, however, 	 the template-id that was used.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|orig_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
comment|/* This can happen during tsubst'ing.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|check_dtor_name
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"qualified type `%T' does not match destructor name `~%T'"
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|dtor_identifier
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* I think this is wrong, but the draft is unclear.  --jason 6/15/98 */
block|else if (name == constructor_name_full (type) 	   || name == constructor_name (type))     name = ctor_identifier;
endif|#
directive|endif
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"incomplete type `%T' does not have member `%D'"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|type
argument_list|,
operator|&
name|basebinfo
argument_list|)
expr_stmt|;
name|member
operator|=
name|lookup_member
argument_list|(
name|basebinfo
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* A lot of this logic is now handled in lookup_field and      lookup_fnfield.  */
if|if
condition|(
name|member
operator|&&
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
comment|/* Go from the TREE_BASELINK to the member function info.  */
name|tree
name|fnfields
init|=
name|member
decl_stmt|;
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* The FNFIELDS are going to contain functions that aren't 	     necessarily templates, and templates that don't 	     necessarily match the explicit template parameters.  We 	     save all the functions, and the explicit parameters, and 	     then figure out exactly what to instantiate with what 	     arguments in instantiate_type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|OVERLOAD
condition|)
comment|/* The code in instantiate_type which will process this 	       expects to encounter OVERLOADs, not raw functions.  */
name|t
operator|=
name|ovl_cons
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|decl
argument_list|,
name|build
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|TREE_OPERAND
argument_list|(
name|orig_name
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Get rid of a potential OVERLOAD around it */
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* unique functions are handled easily.  */
name|basebinfo
operator|=
name|TREE_PURPOSE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enforce_access
argument_list|(
name|basebinfo
argument_list|,
name|t
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
return|;
block|}
comment|/* FNFIELDS is most likely allocated on the search_obstack, 	 which will go away after this class scope.  If we need 	 to save this value for later (i.e. for use as an initializer 	 for a static variable), then do so here.  	 ??? The smart thing to do for the case of saving initializers 	 is to resolve them before we're done with this scope.  */
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|fnfields
argument_list|)
operator|&&
operator|!
name|allocation_temporary_p
argument_list|()
condition|)
name|fnfields
operator|=
name|copy_list
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fnfields
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|unknown_type_node
argument_list|,
name|decl
argument_list|,
name|fnfields
argument_list|)
return|;
block|}
name|t
operator|=
name|member
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' is not a member of type `%T'"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* static class members and class-specific enum      values can be returned without further ado.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"illegal pointer to bit field `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* static class functions too.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|53
argument_list|)
expr_stmt|;
comment|/* In member functions, the form `type::name' is no longer      equivalent to `this->type::name', at least not until      resolve_offset_ref.  */
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|build_offset_type
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If a OFFSET_REF made it through to here, then it did    not have its address taken.  */
end_comment

begin_function
name|tree
name|resolve_offset_ref
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
argument_list|,
literal|214
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"object missing in use of pointer-to-member construct"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|member
operator|=
name|exp
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|current_class_ref
expr_stmt|;
block|}
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"assuming& on overloaded member function"
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|cp_pedwarn
argument_list|(
literal|"assuming& on `%E'"
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_PTRMEM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* These were static members.  */
if|if
condition|(
name|mark_addressable
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|member
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|member
return|;
comment|/* Syntax error can cause a member which should      have been seen as static to be grok'd as non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|current_class_ref
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member `%D' is non-static but referenced as a static member"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|member
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* The first case is really just a reference to a member of `this'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|base
operator|==
name|current_class_ref
operator|||
name|is_dummy_object
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|base
operator|=
name|current_class_ptr
expr_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|basetype_path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Kludge: we need to use basetype_path now, because 	 convert_pointer_to will bash it.  */
name|enforce_access
argument_list|(
name|basetype_path
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* Even in the case of illegal access, we form the 	 COMPONENT_REF; that will allow better error recovery than 	 just feeding back error_mark_node.  */
name|expr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
return|;
block|}
comment|/* Ensure that we have an object.  */
if|if
condition|(
name|is_dummy_object
argument_list|(
name|base
argument_list|)
condition|)
name|addr
operator|=
name|error_mark_node
expr_stmt|;
else|else
comment|/* If this is a reference to a member function, then return the        address of the member function (which may involve going        through the object's vtable), otherwise, return an expression        for the dereferenced pointer-to-member construct.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"object missing in `%E'"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|member
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|member
argument_list|)
expr_stmt|;
comment|/* Pointer to data members are offset by one, so that a null 	 pointer with a real value of 0 is distinguishable from an 	 offset of the first member of a structure.  */
name|member
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|member
argument_list|,
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
name|member
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|addr
argument_list|,
name|member
argument_list|)
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|56
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common subroutines of build_new and build_vec_delete.  */
end_comment

begin_comment
comment|/* Call the global __builtin_delete to delete ADDR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_builtin_delete_call
parameter_list|(
name|addr
parameter_list|)
name|tree
name|addr
decl_stmt|;
block|{
name|mark_used
argument_list|(
name|global_delete_fndecl
argument_list|)
expr_stmt|;
return|return
name|build_call
argument_list|(
name|global_delete_fndecl
argument_list|,
name|void_type_node
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a C++ "new" expression. DECL is either a TREE_LIST    (which needs to go through some sort of groktypename) or it    is the name of the class we are newing. INIT is an initialization value.    It is either an EXPRLIST, an EXPR_NO_COMMAS, or something in braces.    If INIT is void_type_node, it means do *not* call a constructor    for this instance.     For types with constructors, the data returned is initialized    by the appropriate constructor.     Whether the type has a constructor or not, if it has a pointer    to a virtual function table, then that pointer is set up    here.     Unless I am mistaken, a call to new () will return initialized    data regardless of whether the constructor itself is private or    not.  NOPE; new fails if the constructor is private (jcm).     Note that build_new does nothing to assure that any special    alignment requirements of the type are met.  Rather, it leaves    it up to malloc to do the right thing.  Otherwise, folding to    the right alignment cal cause problems if the user tries to later    free the memory returned by `new'.     PLACEMENT is the `placement' list for user-defined operator new ().  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_check_new
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_new
parameter_list|(
name|placement
parameter_list|,
name|decl
parameter_list|,
name|init
parameter_list|,
name|use_global_new
parameter_list|)
name|tree
name|placement
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|int
name|use_global_new
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|;
name|tree
name|nelts
init|=
name|NULL_TREE
decl_stmt|,
name|t
decl_stmt|;
name|int
name|has_array
init|=
literal|0
decl_stmt|;
name|tree
name|pending_sizes
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|absdcl
init|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|last_absdcl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|old_immediate_size_expand
operator|=
name|immediate_size_expand
expr_stmt|;
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
block|}
name|nelts
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|my_friendly_abort
argument_list|(
literal|215
argument_list|)
expr_stmt|;
while|while
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
comment|/* probably meant to be a vec new */
name|tree
name|this_nelts
decl_stmt|;
while|while
condition|(
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|has_array
operator|=
literal|1
expr_stmt|;
name|this_nelts
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|this_nelts
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"new of array type fails to specify size"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|nelts
operator|=
name|this_nelts
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|flags
init|=
name|pedantic
condition|?
name|WANT_INT
else|:
operator|(
name|WANT_INT
operator||
name|WANT_ENUM
operator|)
decl_stmt|;
if|if
condition|(
name|build_expr_type_conversion
argument_list|(
name|flags
argument_list|,
name|this_nelts
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"size in array new must have integral type"
argument_list|)
expr_stmt|;
name|this_nelts
operator|=
name|save_expr
argument_list|(
name|cp_convert
argument_list|(
name|sizetype
argument_list|,
name|this_nelts
argument_list|)
argument_list|)
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|==
name|integer_zero_node
condition|)
block|{
name|warning
argument_list|(
literal|"zero size array reserves no space"
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
name|nelts
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|last_absdcl
condition|)
name|TREE_OPERAND
argument_list|(
name|last_absdcl
argument_list|,
literal|0
argument_list|)
operator|=
name|absdcl
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|absdcl
expr_stmt|;
name|type
operator|=
name|groktypename
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|pending_sizes
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* An aggregate type.  */
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A builtin type.  */
name|decl
operator|=
name|lookup_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|215
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|decl
expr_stmt|;
name|decl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|has_array
condition|)
name|t
operator|=
name|min_tree_cons
argument_list|(
name|min_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|build_min_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|nelts
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|type
expr_stmt|;
name|rval
operator|=
name|build_min_nt
argument_list|(
name|NEW_EXPR
argument_list|,
name|placement
argument_list|,
name|t
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|rval
argument_list|)
operator|=
name|use_global_new
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* ``A reference cannot be created by the new operator.  A reference      is not an object (8.2.2, 8.4.3), so a pointer to it could not be      returned by new.'' ARM 5.3.3 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a reference type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* When the object being created is an array, the new-expression yields a      pointer to the initial element (if any) of the array.  For example,      both new int and new int[10] return an int*.  5.3.4.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|has_array
operator|==
literal|0
condition|)
block|{
name|nelts
operator|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|has_array
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_array
condition|)
name|t
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|type
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|NEW_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|placement
argument_list|,
name|t
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|rval
argument_list|)
operator|=
name|use_global_new
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pending_sizes
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|chainon
argument_list|(
name|pending_sizes
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*). */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|jclass_node
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a Java class, return a decl for the corresponding java.lang.Class. */
end_comment

begin_function
specifier|static
name|tree
name|build_java_class_ref
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|,
name|class_decl
decl_stmt|;
specifier|static
name|tree
name|CL_prefix
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|CL_prefix
operator|==
name|NULL_TREE
condition|)
name|CL_prefix
operator|=
name|get_identifier
argument_list|(
literal|"_CL_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jclass_node
operator|==
name|NULL_TREE
condition|)
block|{
name|jclass_node
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
literal|"jclass"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jclass_node
operator|==
name|NULL_TREE
condition|)
name|fatal
argument_list|(
literal|"call to Java constructor, while `jclass' undefined"
argument_list|)
expr_stmt|;
name|jclass_node
operator|=
name|TREE_TYPE
argument_list|(
name|jclass_node
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|build_overload_with_type
argument_list|(
name|CL_prefix
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|class_decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|class_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|jclass_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|class_decl
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|class_decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|class_decl
return|;
block|}
end_function

begin_comment
comment|/* Called from cplus_expand_expr when expanding a NEW_EXPR.  The return    value is immediately handed to expand_expr.  */
end_comment

begin_function
name|tree
name|build_new_1
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|placement
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|true_type
decl_stmt|,
name|size
decl_stmt|,
name|rval
decl_stmt|;
name|tree
name|nelts
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|alloc_expr
decl_stmt|,
name|alloc_node
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|has_array
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|NEW_EXPR
decl_stmt|;
name|int
name|use_cookie
decl_stmt|,
name|nothrow
decl_stmt|,
name|check_new
decl_stmt|;
name|int
name|use_global_new
decl_stmt|;
name|int
name|use_java_new
init|=
literal|0
decl_stmt|;
name|placement
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|use_global_new
operator|=
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|has_array
operator|=
literal|1
expr_stmt|;
name|nelts
operator|=
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|true_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|CP_TYPE_QUALS
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If our base type is an array, then make sure we know how many elements      it has.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|true_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|this_nelts
init|=
name|array_type_nelts_top
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
name|nelts
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|)
expr_stmt|;
name|true_type
operator|=
name|TREE_TYPE
argument_list|(
name|true_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|true_type
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|has_array
condition|)
name|size
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_in_bytes
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|true_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid type `void' for new"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|true_type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|true_type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|signature_error
argument_list|(
name|NULL_TREE
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* When we allocate an array, and the corresponding deallocation      function takes a second argument of type size_t, and that's the      "usual deallocation function", we allocate some extra space at      the beginning of the array to store the size of the array.       Well, that's what we should do.  For backwards compatibility, we      have to do this whenever there's a two-argument array-delete      operator.        FIXME: For -fnew-abi, we don't have to maintain backwards      compatibility and we should fix this.  */
name|use_cookie
operator|=
operator|(
name|has_array
operator|&&
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|true_type
argument_list|)
operator|&&
operator|!
operator|(
name|placement
operator|&&
operator|!
name|TREE_CHAIN
argument_list|(
name|placement
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|placement
argument_list|)
argument_list|)
operator|==
name|ptr_type_node
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|use_cookie
condition|)
block|{
name|tree
name|extra
init|=
name|BI_header_size
decl_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_array
condition|)
block|{
name|code
operator|=
name|VEC_NEW_EXPR
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|pedantic
condition|)
name|cp_pedwarn
argument_list|(
literal|"initialization in array new"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the object.  */
if|if
condition|(
operator|!
name|has_array
operator|&&
operator|!
name|placement
operator|&&
name|flag_this_is_variable
operator|>
literal|0
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|true_type
argument_list|)
operator|&&
name|init
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"constructors take parameter lists"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|placement
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|tree
name|class_addr
decl_stmt|,
name|alloc_decl
decl_stmt|;
name|tree
name|class_decl
init|=
name|build_java_class_ref
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
name|tree
name|class_size
init|=
name|size_in_bytes
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
specifier|static
name|char
name|alloc_name
index|[]
init|=
literal|"_Jv_AllocObject"
decl_stmt|;
name|use_java_new
operator|=
literal|1
expr_stmt|;
name|alloc_decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|alloc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_decl
operator|==
name|NULL_TREE
condition|)
name|fatal
argument_list|(
literal|"call to Java constructor, while `%s' undefined"
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
name|class_addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|jclass_node
argument_list|,
name|class_decl
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_function_call
argument_list|(
name|alloc_decl
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|class_addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|class_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|susp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
comment|/* We will use RVAL when generating an exception handler for 	   this new-expression, so we must save it.  */
name|susp
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|rval
operator|=
name|build_op_new_call
argument_list|(
name|code
argument_list|,
name|true_type
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
operator||
operator|(
name|use_global_new
operator|*
name|LOOKUP_GLOBAL
operator|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_exceptions
condition|)
name|resume_momentary
argument_list|(
name|susp
argument_list|)
expr_stmt|;
block|}
comment|/*        unless an allocation function is declared with an empty  excep-      tion-specification  (_except.spec_),  throw(), it indicates failure to      allocate storage by throwing a bad_alloc exception  (clause  _except_,      _lib.bad.alloc_); it returns a non-null pointer otherwise If the allo-      cation function is declared  with  an  empty  exception-specification,      throw(), it returns null to indicate failure to allocate storage and a      non-null pointer otherwise.       So check for a null exception spec on the op new we just called.  */
name|nothrow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
comment|/* The CALL_EXPR.  */
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* The function.  */
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nothrow
operator|=
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|check_new
operator|=
operator|(
name|flag_check_new
operator|||
name|nothrow
operator|)
operator|&&
operator|!
name|use_java_new
expr_stmt|;
if|if
condition|(
operator|(
name|check_new
operator|||
name|flag_exceptions
operator|)
operator|&&
name|rval
condition|)
block|{
name|alloc_expr
operator|=
name|get_target_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|alloc_node
operator|=
name|rval
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|alloc_expr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* if rval is NULL_TREE I don't have to allocate it, but are we totally      sure we have some extra bytes in that case for the BI_header_size      cookies? And how does that interact with the code below? (mrs) */
comment|/* Finish up some magic for new'ed arrays */
if|if
condition|(
name|use_cookie
operator|&&
name|rval
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|extra
init|=
name|BI_header_size
decl_stmt|;
name|tree
name|cookie
decl_stmt|,
name|exp1
decl_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* for ptr arithmetic */
name|rval
operator|=
name|save_expr
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rval
argument_list|,
name|extra
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store header info.  */
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|rval
argument_list|,
name|extra
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|exp1
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|nc_nelts_field_id
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp1
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Don't call any constructors or do any initialization.  */
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|has_array
condition|)
block|{
comment|/* We are processing something like `new int (10)', which 	     means allocate an int, and initialize it with 10.  */
name|tree
name|deref
decl_stmt|;
name|tree
name|deref_type
decl_stmt|;
comment|/* At present RVAL is a temporary variable, created to hold 	     the value from the call to `operator new'.  We transform 	     it to (*RVAL = INIT, RVAL).  */
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|deref
operator|=
name|build_indirect_ref
argument_list|(
name|rval
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Even for something like `new const int (10)' we must 	     allow the expression to be non-const while we do the 	     initialization.  */
name|deref_type
operator|=
name|TREE_TYPE
argument_list|(
name|deref
argument_list|)
expr_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|deref_type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|deref
argument_list|)
operator|=
name|cp_build_qualified_type
argument_list|(
name|deref_type
argument_list|,
name|CP_TYPE_QUALS
argument_list|(
name|deref_type
argument_list|)
operator|&
operator|~
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|deref
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|pedwarn
argument_list|(
literal|"initializer list appears where operand should be used"
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_for_initialization
argument_list|(
name|deref
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"new"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|deref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|has_array
condition|)
block|{
name|tree
name|newrval
decl_stmt|;
comment|/* Constructors are never virtual. If it has an initialization, we 	     need to complain if we aren't allowed to use the ctor that took 	     that argument.  */
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_COMPLAIN
decl_stmt|;
if|if
condition|(
name|rval
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|init
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
block|}
if|if
condition|(
name|use_java_new
condition|)
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|newrval
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|newrval
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrval
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|newrval
operator|=
name|build_indirect_ref
argument_list|(
name|newrval
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|newrval
operator|=
name|build_method_call
argument_list|(
name|newrval
argument_list|,
name|ctor_identifier
argument_list|,
name|init
argument_list|,
name|TYPE_BINFO
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrval
operator|==
name|NULL_TREE
operator|||
name|newrval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Java constructors compiled by jc1 do not return this. */
if|if
condition|(
name|use_java_new
condition|)
name|newrval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|newrval
argument_list|)
argument_list|,
name|newrval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|newrval
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|build
argument_list|(
name|VEC_INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|save_expr
argument_list|(
name|rval
argument_list|)
argument_list|,
name|init
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
comment|/* If any part of the object initialization terminates by throwing an 	 exception and a suitable deallocation function can be found, the 	 deallocation function is called to free the memory in which the 	 object was being constructed, after which the exception continues 	 to propagate in the context of the new-expression. If no 	 unambiguous matching deallocation function can be found, 	 propagating the exception does not cause the object's memory to be 	 freed.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|alloc_expr
operator|&&
operator|!
name|use_java_new
condition|)
block|{
name|enum
name|tree_code
name|dcode
init|=
name|has_array
condition|?
name|VEC_DELETE_EXPR
else|:
name|DELETE_EXPR
decl_stmt|;
name|tree
name|cleanup
decl_stmt|,
name|fn
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
operator|(
name|use_global_new
operator|*
name|LOOKUP_GLOBAL
operator|)
decl_stmt|;
comment|/* All cleanups must last longer than normal.  */
name|int
name|yes
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
if|if
condition|(
name|placement
condition|)
block|{
name|flags
operator||=
name|LOOKUP_SPECULATIVELY
expr_stmt|;
comment|/* We expect alloc_expr to look like a TARGET_EXPR around 		 a NOP_EXPR around the CALL_EXPR we want.  */
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy size to the saveable obstack.  */
name|size
operator|=
name|mapcar
argument_list|(
name|size
argument_list|,
name|permanent_p
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_op_delete_call
argument_list|(
name|dcode
argument_list|,
name|alloc_node
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Ack!  First we allocate the memory.  Then we set our sentry 	     variable to true, and expand a cleanup that deletes the memory 	     if sentry is true.  Then we run the constructor and store the 	     returned pointer in buf.  Then we clear sentry and return buf.  */
if|if
condition|(
name|cleanup
condition|)
block|{
name|tree
name|end
decl_stmt|,
name|sentry
decl_stmt|,
name|begin
decl_stmt|,
name|buf
decl_stmt|,
name|t
init|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
decl_stmt|;
name|begin
operator|=
name|get_target_expr
argument_list|(
name|boolean_true_node
argument_list|)
expr_stmt|;
name|sentry
operator|=
name|TREE_OPERAND
argument_list|(
name|begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|begin
argument_list|,
literal|2
argument_list|)
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|sentry
argument_list|,
name|cleanup
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_target_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|end
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sentry
argument_list|)
argument_list|,
name|sentry
argument_list|,
name|boolean_false_node
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|end
argument_list|)
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|t
argument_list|,
name|begin
argument_list|,
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|t
argument_list|,
name|rval
argument_list|,
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|t
argument_list|,
name|end
argument_list|,
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|true_type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"uninitialized const in `new' of `%#T'"
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|alloc_expr
operator|&&
name|rval
operator|==
name|alloc_node
condition|)
block|{
name|rval
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|alloc_expr
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|check_new
operator|&&
name|alloc_expr
condition|)
block|{
comment|/* Did we modify the storage?  */
name|tree
name|ifexp
init|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|alloc_node
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|rval
argument_list|,
name|alloc_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloc_expr
condition|)
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|alloc_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|!=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The type of new int [3][3] is not int *, but int [3] * */
name|rval
operator|=
name|build_c_cast
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|build_vec_delete_1
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|type
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|auto_delete
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|auto_delete_vec
decl_stmt|,
name|auto_delete
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|virtual_size
decl_stmt|;
name|tree
name|ptype
init|=
name|build_pointer_type
argument_list|(
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|size_exp
init|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Temporary variables used by the loop.  */
name|tree
name|tbase
decl_stmt|,
name|tbase_init
decl_stmt|;
comment|/* This is the body of the loop that implements the deletion of a      single element, and moves temp variables to next elements.  */
name|tree
name|body
decl_stmt|;
comment|/* This is the LOOP_EXPR that governs the deletion of the elements.  */
name|tree
name|loop
decl_stmt|;
comment|/* This is the thing that governs what to do after the loop has run.  */
name|tree
name|deallocate_expr
init|=
literal|0
decl_stmt|;
comment|/* This is the BIND_EXPR which holds the outermost iterator of the      loop.  It is convenient to set this variable up and test it before      executing any other code in the loop.      This is also the containing expression returned by this function.  */
name|tree
name|controller
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|loop
operator|=
name|integer_zero_node
expr_stmt|;
goto|goto
name|no_destructor
goto|;
block|}
comment|/* The below is short by BI_header_size */
name|virtual_size
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
name|tbase
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|tbase_init
operator|=
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|base
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|tbase
argument_list|)
operator|=
literal|1
expr_stmt|;
name|controller
operator|=
name|build
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tbase
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|controller
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|auto_delete
operator|!=
name|integer_zero_node
operator|&&
name|auto_delete
operator|!=
name|integer_two_node
condition|)
block|{
name|tree
name|base_tbd
init|=
name|cp_convert
argument_list|(
name|ptype
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|BI_header_size
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This is the real size */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_delete
argument_list|(
name|base_tbd
argument_list|,
literal|2
operator||
name|use_global_delete
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|ptype
argument_list|,
name|tbase
argument_list|,
name|auto_delete
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|1
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|tbase
argument_list|,
name|size_exp
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build
argument_list|(
name|EXIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|tbase
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build
argument_list|(
name|LOOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_compound_expr
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tbase_init
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build_compound_expr
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|no_destructor
label|:
comment|/* If the delete flag is one, or anything else with the low bit set,      delete the storage.  */
if|if
condition|(
name|auto_delete_vec
operator|==
name|integer_zero_node
condition|)
name|deallocate_expr
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|tree
name|base_tbd
decl_stmt|;
comment|/* The below is short by BI_header_size */
name|virtual_size
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* no header */
name|base_tbd
operator|=
name|base
expr_stmt|;
else|else
block|{
name|base_tbd
operator|=
name|cp_convert
argument_list|(
name|ptype
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|string_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|BI_header_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* True size with header.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
block|}
name|deallocate_expr
operator|=
name|build_x_delete
argument_list|(
name|base_tbd
argument_list|,
literal|2
operator||
name|use_global_delete
argument_list|,
name|virtual_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_delete_vec
operator|!=
name|integer_one_node
condition|)
name|deallocate_expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete_vec
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|deallocate_expr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|&&
name|deallocate_expr
operator|!=
name|integer_zero_node
condition|)
block|{
name|body
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|deallocate_expr
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|loop
expr_stmt|;
comment|/* Outermost wrapper: If pointer is null, punt.  */
name|body
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|body
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|controller
argument_list|,
literal|1
argument_list|)
operator|=
name|body
expr_stmt|;
return|return
name|controller
return|;
block|}
else|else
return|return
name|cp_convert
argument_list|(
name|void_type_node
argument_list|,
name|body
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Protect the vector initialization with a try-block so that we can    destroy the first few elements if constructing a later element    causes an exception to be thrown.  TYPE is the type of the array    elements.  */
end_comment

begin_function
specifier|static
name|void
name|expand_vec_init_try_block
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|flag_exceptions
condition|)
return|return;
comment|/* The code we generate looks like:         try {          // Initialize the vector.        } catch (...) {          // Destory the elements that need destroying. 	 throw;        }        Here we're just beginning the `try'.  */
name|expand_eh_region_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add code to destroy the array elements constructed so far if the    construction of some element in the array causes an exception to be    thrown.  RVAL is the address of the last element in the array.    TYPE is the type of the array elements.  MAXINDEX is the maximum    allowable index into the array.  ITERATOR is an integer variable    indicating how many elements remain to be constructed.  */
end_comment

begin_function
specifier|static
name|void
name|expand_vec_init_catch_clause
parameter_list|(
name|rval
parameter_list|,
name|type
parameter_list|,
name|maxindex
parameter_list|,
name|iterator
parameter_list|)
name|tree
name|rval
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|maxindex
decl_stmt|;
name|tree
name|iterator
decl_stmt|;
block|{
name|tree
name|e
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|flag_exceptions
condition|)
return|return;
comment|/* We have to ensure that this can live to the cleanup expansion      time, since we know it is only ever needed once, generate code      now.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cleanup
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|cleanup
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|cleanup
argument_list|)
operator|=
literal|1
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_vec_delete_1
argument_list|(
name|rval
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|iterator
argument_list|)
argument_list|,
name|type
argument_list|,
comment|/*auto_delete_vec=*/
name|integer_zero_node
argument_list|,
comment|/*auto_delete=*/
name|integer_zero_node
argument_list|,
comment|/*use_global_delete=*/
literal|0
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|e
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|cleanup
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|cleanup
operator|=
name|protect_with_terminate
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|expand_eh_region_end
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* `expand_vec_init' performs initialization of a vector of aggregate    types.     DECL is passed only for error reporting, and provides line number    and source file name information.    BASE is the space where the vector will be.    MAXINDEX is the maximum index of the array (one less than the 	    number of elements).    INIT is the (possibly NULL) initializer.     FROM_ARRAY is 0 if we should init everything with INIT    (i.e., every element initialized from INIT).    FROM_ARRAY is 1 if we should index into INIT in parallel    with initialization of DECL.    FROM_ARRAY is 2 if we should index into INIT in parallel,    but use assignment instead of initialization.  */
end_comment

begin_function
name|tree
name|expand_vec_init
parameter_list|(
name|decl
parameter_list|,
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|init
parameter_list|,
name|from_array
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|init
decl_stmt|;
name|int
name|from_array
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|base2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|iterator
decl_stmt|;
name|int
name|num_initialized_elts
init|=
literal|0
decl_stmt|;
name|maxindex
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxindex
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|rval
operator|=
name|make_tree_vec
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
operator|=
name|base
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
operator|=
name|maxindex
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|2
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|rval
return|;
block|}
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|default_conversion
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|cp_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|rval
operator|=
name|get_temp_regvar
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_temp_regvar
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
comment|/* Protect the entire array initialization so that we can destroy      the partially constructed array if an exception is thrown.  */
name|expand_vec_init_try_block
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
operator|(
operator|!
name|decl
operator|||
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Do non-default initialization resulting from brace-enclosed 	 initializers.  */
name|tree
name|elts
decl_stmt|;
name|tree
name|baseref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|from_array
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|elts
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
decl_stmt|;
name|num_initialized_elts
operator|++
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|expand_aggr_init
argument_list|(
name|baseref
argument_list|,
name|elt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expand_assignment
argument_list|(
name|baseref
argument_list|,
name|elt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|iterator
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out INIT so that we don't get confused below.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_array
condition|)
block|{
comment|/* If initializing one array from another, initialize element by 	 element.  We rely upon the below calls the do argument 	 checking.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|sorry
argument_list|(
literal|"initialization of array from dissimilar array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|init
condition|)
block|{
name|base2
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|base2
argument_list|)
expr_stmt|;
name|base2
operator|=
name|get_temp_regvar
argument_list|(
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer ends prematurely"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Now, default-initialize any remaining elements.  We don't need to      do that if a) the type does not need constructing, or b) we've      already initialized all the elements.       We do need to keep going if we're copying an array.  */
if|if
condition|(
name|from_array
operator|||
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|maxindex
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|num_initialized_elts
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|maxindex
argument_list|)
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* If the ITERATOR is equal to -1, then we don't have to loop; 	 we've already initialized all the elements.  */
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iterator
argument_list|,
name|minus_one
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Otherwise, loop through the elements.  */
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The initialization of each array element is a full-expression.  */
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_array
condition|)
block|{
name|tree
name|to
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|from
decl_stmt|;
if|if
condition|(
name|base2
condition|)
name|from
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
else|else
name|from
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|from_array
operator|==
literal|2
condition|)
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from
condition|)
name|expand_assignment
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|57
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|init
operator|!=
literal|0
condition|)
name|sorry
argument_list|(
literal|"cannot initialize multi-dimensional array with initializer"
argument_list|)
expr_stmt|;
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|base
argument_list|)
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_aggr_init
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|expand_assignment
argument_list|(
name|base2
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base2
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Cleanup any temporaries needed for the initial value.  */
name|expand_end_target_temps
argument_list|()
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|build
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|ptrdiff_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|minus_one
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_end_loop
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* Make sure to cleanup any partially constructed elements.  */
name|expand_vec_init_catch_clause
argument_list|(
name|rval
argument_list|,
name|type
argument_list|,
name|maxindex
argument_list|,
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Free up storage of type TYPE, at address ADDR.     TYPE is a POINTER_TYPE and can be ptr_type_node for no special type    of pointer.     VIRTUAL_SIZE is the amount of storage that was allocated, and is    used as the second argument to operator delete.  It can include    things like padding and magic size cookies.  It has virtual in it,    because if you have a base pointer and you delete through a virtual    destructor, it should be the size of the dynamic object, not the    static object, see Free Store 12.5 ANSI C++ WP.     This does not call any destructors.  */
end_comment

begin_function
name|tree
name|build_x_delete
parameter_list|(
name|addr
parameter_list|,
name|which_delete
parameter_list|,
name|virtual_size
parameter_list|)
name|tree
name|addr
decl_stmt|;
name|int
name|which_delete
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
block|{
name|int
name|use_global_delete
init|=
name|which_delete
operator|&
literal|1
decl_stmt|;
name|int
name|use_vec_delete
init|=
operator|!
operator|!
operator|(
name|which_delete
operator|&
literal|2
operator|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|use_vec_delete
condition|?
name|VEC_DELETE_EXPR
else|:
name|DELETE_EXPR
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
operator|(
name|use_global_delete
operator|*
name|LOOKUP_GLOBAL
operator|)
decl_stmt|;
return|return
name|build_op_delete_call
argument_list|(
name|code
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|flags
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a call to a destructor. TYPE is the type to cast ADDR to.    ADDR is an expression which yields the store to be destroyed.    AUTO_DELETE is nonzero if a call to DELETE should be made or not.    If in the program, (AUTO_DELETE& 2) is non-zero, we tear down the    virtual baseclasses.    If in the program, (AUTO_DELETE& 1) is non-zero, then we deallocate.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     This function does not delete an object's virtual base classes.  */
end_comment

begin_function
name|tree
name|build_delete
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|,
name|auto_delete
parameter_list|,
name|flags
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|type
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|auto_delete
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Can happen when CURRENT_EXCEPTION_OBJECT gets its type      set to `error_mark_node' before it gets properly cleaned up.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|void_type_node
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
goto|goto
name|handle_array
goto|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Call the builtin operator delete.  */
return|return
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* throw away const and volatile on target type of addr */
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|handle_array
label|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"unknown array size in delete"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete
argument_list|(
name|addr
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|auto_delete
argument_list|,
name|integer_zero_node
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Don't check PROTECT here; leave that decision to the 	 destructor.  If the destructor is accessible, call it, 	 else report error.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|220
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|auto_delete
operator|==
name|integer_zero_node
condition|)
return|return
name|void_zero_node
return|;
return|return
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|addr
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
operator||
operator|(
name|use_global_delete
operator|*
name|LOOKUP_GLOBAL
operator|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
comment|/* Below, we will reverse the order in which these calls are made.      If we have a destructor, then that destructor will take care      of the base classes; otherwise, we must do that here.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|passed_auto_delete
decl_stmt|;
name|tree
name|do_delete
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ifexp
decl_stmt|;
if|if
condition|(
name|use_global_delete
condition|)
block|{
name|tree
name|cond
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|call
init|=
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|call
argument_list|,
name|void_zero_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|void_zero_node
condition|)
name|do_delete
operator|=
name|cond
expr_stmt|;
name|passed_auto_delete
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_two_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|passed_auto_delete
operator|=
name|auto_delete
expr_stmt|;
name|expr
operator|=
name|build_method_call
argument_list|(
name|ref
argument_list|,
name|dtor_identifier
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|passed_auto_delete
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_delete
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|,
name|do_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
condition|)
comment|/* Explicit destructor call; don't check for null pointer.  */
name|ifexp
operator|=
name|integer_one_node
expr_stmt|;
else|else
comment|/* Handle deleting a null pointer.  */
name|ifexp
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifexp
operator|!=
name|integer_one_node
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
block|{
comment|/* We only get here from finish_function for a destructor.  */
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|base_binfo
init|=
name|n_baseclasses
operator|>
literal|0
condition|?
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|tree
name|exprstmt
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parent_auto_delete
init|=
name|auto_delete
decl_stmt|;
name|tree
name|cond
decl_stmt|;
comment|/* Set this again before we call anything, as we might get called 	 recursively.  */
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we have member delete or vbases, we call delete in 	 finish_function.  */
if|if
condition|(
name|auto_delete
operator|==
name|integer_zero_node
condition|)
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|base_binfo
operator|==
name|NULL_TREE
operator|||
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|cond
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|exprstmt
operator|=
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_auto_delete
decl_stmt|;
if|if
condition|(
name|BINFO_OFFSET_ZEROP
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|this_auto_delete
operator|=
name|parent_auto_delete
expr_stmt|;
else|else
name|this_auto_delete
operator|=
name|integer_zero_node
expr_stmt|;
name|expr
operator|=
name|build_scoped_method_call
argument_list|(
name|ref
argument_list|,
name|base_binfo
argument_list|,
name|dtor_identifier
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|this_auto_delete
argument_list|)
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of the remaining baseclasses.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|base_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|expr
operator|=
name|build_scoped_method_call
argument_list|(
name|ref
argument_list|,
name|base_binfo
argument_list|,
name|dtor_identifier
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_member
init|=
name|build_component_ref
argument_list|(
name|ref
argument_list|,
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|this_type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|this_type
argument_list|,
name|this_member
argument_list|,
name|integer_two_node
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exprstmt
condition|)
return|return
name|build_compound_expr
argument_list|(
name|exprstmt
argument_list|)
return|;
comment|/* Virtual base classes make this function do nothing.  */
return|return
name|void_zero_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* For type TYPE, delete the virtual baseclass objects of DECL.  */
end_comment

begin_function
name|tree
name|build_vbase_delete
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|addr
operator|!=
name|error_mark_node
argument_list|,
literal|222
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|this_addr
init|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|result
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_addr
argument_list|)
argument_list|,
name|this_addr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
return|return
name|build_compound_expr
argument_list|(
name|nreverse
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a C++ vector delete expression.    MAXINDEX is the number of elements to be deleted.    ELT_SIZE is the nominal size of each element in the vector.    BASE is the expression that should yield the store to be deleted.    This function expands (or synthesizes) these calls itself.    AUTO_DELETE_VEC says whether the container (vector) should be deallocated.    AUTO_DELETE say whether each item in the container should be deallocated.     This also calls delete for virtual baseclasses of elements of the vector.     Update: MAXINDEX is no longer needed.  The size can be extracted from the    start of the vector for pointers, and from the type for arrays.  We still    use MAXINDEX for arrays because it happens to already have one of the    values we'd have to extract.  (We could use MAXINDEX with pointers to    confirm the size, and trap if the numbers differ; not clear that it'd    be worth bothering.)  */
end_comment

begin_function
name|tree
name|build_vec_delete
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|auto_delete
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|;
name|tree
name|auto_delete_vec
decl_stmt|,
name|auto_delete
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|base
operator|=
name|resolve_offset_ref
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|stabilize_reference
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Since we can use base many times, save_expr it.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|save_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Step back one from start of vector, and read dimension.  */
name|tree
name|cookie_addr
init|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|base
argument_list|,
name|BI_header_size
argument_list|)
decl_stmt|;
name|tree
name|cookie
init|=
name|build_indirect_ref
argument_list|(
name|cookie_addr
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|nc_nelts_field_id
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
do|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* get the total number of things in the array, maxindex is a bad name */
name|maxindex
operator|=
name|array_type_nelts_total
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"type to vector delete is neither pointer or array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete_1
argument_list|(
name|base
argument_list|,
name|maxindex
argument_list|,
name|type
argument_list|,
name|auto_delete_vec
argument_list|,
name|auto_delete
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
end_function

end_unit

