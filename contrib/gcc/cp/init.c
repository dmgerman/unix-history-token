begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle initialization things in C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* High-level class interface.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_function_decl
specifier|static
name|bool
name|begin_init_stmts
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|finish_init_stmts
parameter_list|(
name|bool
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|construct_virtual_base
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_default_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_vec_delete_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|special_function_kind
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|perform_member_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_builtin_delete_call
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|member_init_ok_or_else
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_virtual_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|sort_mem_initializers
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|initializing_context
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_cleanup_for_base
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_temp_regvar
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|dfs_initialize_vtbl_ptrs
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_default_init
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_dtor_call
parameter_list|(
name|tree
parameter_list|,
name|special_function_kind
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_field_list
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_vtbl_address
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We are about to generate some complex initialization code.    Conceptually, it is all a single expression.  However, we may want    to include conditionals, loops, and other such statement-level    constructs.  Therefore, we build the initialization code inside a    statement-expression.  This function starts such an expression.    STMT_EXPR_P and COMPOUND_STMT_P are filled in by this function;    pass them back to finish_init_stmts when the expression is    complete.  */
end_comment

begin_function
specifier|static
name|bool
name|begin_init_stmts
parameter_list|(
name|tree
modifier|*
name|stmt_expr_p
parameter_list|,
name|tree
modifier|*
name|compound_stmt_p
parameter_list|)
block|{
name|bool
name|is_global
init|=
operator|!
name|building_stmt_tree
argument_list|()
decl_stmt|;
operator|*
name|stmt_expr_p
operator|=
name|begin_stmt_expr
argument_list|()
expr_stmt|;
operator|*
name|compound_stmt_p
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_NO_SCOPE
argument_list|)
expr_stmt|;
return|return
name|is_global
return|;
block|}
end_function

begin_comment
comment|/* Finish out the statement-expression begun by the previous call to    begin_init_stmts.  Returns the statement-expression itself.  */
end_comment

begin_function
specifier|static
name|tree
name|finish_init_stmts
parameter_list|(
name|bool
name|is_global
parameter_list|,
name|tree
name|stmt_expr
parameter_list|,
name|tree
name|compound_stmt
parameter_list|)
block|{
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|finish_stmt_expr
argument_list|(
name|stmt_expr
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|building_stmt_tree
argument_list|()
operator|==
name|is_global
argument_list|)
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_comment
comment|/* Constructors */
end_comment

begin_comment
comment|/* Called from initialize_vtbl_ptrs via dfs_walk.  BINFO is the base    which we want to initialize the vtable pointer for, DATA is    TREE_LIST whose TREE_VALUE is the this ptr expression.  */
end_comment

begin_function
specifier|static
name|tree
name|dfs_initialize_vtbl_ptrs
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return
name|dfs_skip_bases
return|;
if|if
condition|(
operator|!
name|BINFO_PRIMARY_P
argument_list|(
name|binfo
argument_list|)
operator|||
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|base_ptr
init|=
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|data
argument_list|)
decl_stmt|;
name|base_ptr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|base_ptr
argument_list|,
name|binfo
argument_list|,
comment|/*nonnull=*/
literal|1
argument_list|)
expr_stmt|;
name|expand_virtual_init
argument_list|(
name|binfo
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Initialize all the vtable pointers in the object pointed to by    ADDR.  */
end_comment

begin_function
name|void
name|initialize_vtbl_ptrs
parameter_list|(
name|tree
name|addr
parameter_list|)
block|{
name|tree
name|list
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|build_tree_list
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Walk through the hierarchy, initializing the vptr in each base      class.  We do these in pre-order because we can't find the virtual      bases for a class until we've initialized the vtbl for that      class.  */
name|dfs_walk_once
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|dfs_initialize_vtbl_ptrs
argument_list|,
name|NULL
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an expression for the zero-initialization of an object with    type T.  This expression will either be a constant (in the case    that T is a scalar), or a CONSTRUCTOR (in the case that T is an    aggregate).  In either case, the value can be used as DECL_INITIAL    for a decl of the indicated TYPE; it is a valid static initializer.    If NELTS is non-NULL, and TYPE is an ARRAY_TYPE, NELTS is the    number of elements in the array.  If STATIC_STORAGE_P is TRUE,    initializers are only generated for entities for which    zero-initialization does not simply mean filling the storage with    zero bytes.  */
end_comment

begin_function
name|tree
name|build_zero_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|nelts
parameter_list|,
name|bool
name|static_storage_p
parameter_list|)
block|{
name|tree
name|init
init|=
name|NULL_TREE
decl_stmt|;
comment|/* [dcl.init]       To zero-initialization storage for an object of type T means:       -- if T is a scalar type, the storage is set to the value of zero 	converted to T.       -- if T is a non-union class type, the storage for each nonstatic 	data member and each base-class subobject is zero-initialized.       -- if T is a union type, the storage for its first data member is 	zero-initialized.       -- if T is an array type, the storage for each element is 	zero-initialized.       -- if T is a reference type, no initialization is performed.  */
name|gcc_assert
argument_list|(
name|nelts
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|nelts
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|static_storage_p
operator|&&
name|zero_init_p
argument_list|(
name|type
argument_list|)
condition|)
comment|/* In order to save space, we do not explicitly build initializers        for items that do not need them.  GCC's semantics are that        items with static storage duration that are not otherwise        initialized are initialized to zero.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|SCALAR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|init
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
comment|/* Iterate over the fields, building initializations.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* Note that for class types there will be FIELD_DECLs 	     corresponding to base classes as well.  Thus, iterating 	     over TYPE_FIELDs will result in correct initialization of 	     all of the subobjects.  */
if|if
condition|(
operator|!
name|static_storage_p
operator|||
operator|!
name|zero_init_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|build_zero_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
comment|/*nelts=*/
name|NULL_TREE
argument_list|,
name|static_storage_p
argument_list|)
decl_stmt|;
name|CONSTRUCTOR_APPEND_ELT
argument_list|(
name|v
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* For unions, only the first field is initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
break|break;
block|}
comment|/* Build a constructor to contain the initializations.  */
name|init
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|max_index
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|NULL
expr_stmt|;
comment|/* Iterate over the array elements, building initializations.  */
if|if
condition|(
name|nelts
condition|)
name|max_index
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|nelts
argument_list|)
argument_list|,
name|nelts
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
else|else
name|max_index
operator|=
name|array_type_nelts
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If we have an error_mark here, we should just return error mark 	 as we don't know the size of the array yet.  */
if|if
condition|(
name|max_index
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|max_index
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
comment|/* A zero-sized array, which is accepted as an extension, will 	 have an upper bound of -1.  */
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|max_index
argument_list|,
name|integer_minus_one_node
argument_list|)
condition|)
block|{
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|v
operator|=
name|VEC_alloc
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ce
operator|=
name|VEC_quick_push
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a one element array, we just use a regular init.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|size_zero_node
argument_list|,
name|max_index
argument_list|)
condition|)
name|ce
operator|->
name|index
operator|=
name|size_zero_node
expr_stmt|;
else|else
name|ce
operator|->
name|index
operator|=
name|build2
argument_list|(
name|RANGE_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size_zero_node
argument_list|,
name|max_index
argument_list|)
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|build_zero_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*nelts=*/
name|NULL_TREE
argument_list|,
name|static_storage_p
argument_list|)
expr_stmt|;
block|}
comment|/* Build a constructor to contain the initializations.  */
name|init
operator|=
name|build_constructor
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|init
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
comment|/* In all cases, the initializer is a constant.  */
if|if
condition|(
name|init
condition|)
block|{
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* Build an expression for the default-initialization of an object of    the indicated TYPE.  If NELTS is non-NULL, and TYPE is an    ARRAY_TYPE, NELTS is the number of elements in the array.  If    initialization of TYPE requires calling constructors, this function    returns NULL_TREE; the caller is responsible for arranging for the    constructors to be called.  */
end_comment

begin_function
specifier|static
name|tree
name|build_default_init
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|nelts
parameter_list|)
block|{
comment|/* [dcl.init]:      To default-initialize an object of type T means:      --if T is a non-POD class type (clause _class_), the default construc-       tor  for  T is called (and the initialization is ill-formed if T has       no accessible default constructor);      --if T is an array type, each element is default-initialized;      --otherwise, the storage for the object is zero-initialized.      A program that calls for default-initialization of an entity of refer-     ence type is ill-formed.  */
comment|/* If TYPE_NEEDS_CONSTRUCTING is true, the caller is responsible for      performing the initialization.  This is confusing in that some      non-PODs do not have TYPE_NEEDS_CONSTRUCTING set.  (For example,      a class with a pointer-to-data member as a non-static data member      does not have TYPE_NEEDS_CONSTRUCTING set.)  Therefore, we end up      passing non-PODs to build_zero_init below, which is contrary to      the semantics quoted above from [dcl.init].       It happens, however, that the behavior of the constructor the      standard says we should have generated would be precisely the      same as that obtained by calling build_zero_init below, so things      work out OK.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|nelts
operator|&&
name|TREE_CODE
argument_list|(
name|nelts
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* At this point, TYPE is either a POD class type, an array of POD      classes, or something even more innocuous.  */
return|return
name|build_zero_init
argument_list|(
name|type
argument_list|,
name|nelts
argument_list|,
comment|/*static_storage_p=*/
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize MEMBER, a FIELD_DECL, with INIT, a TREE_LIST of    arguments.  If TREE_LIST is void_type_node, an empty initializer    list was given; if NULL_TREE no initializer was given.  */
end_comment

begin_function
specifier|static
name|void
name|perform_member_init
parameter_list|(
name|tree
name|member
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|bool
name|explicit
decl_stmt|;
name|explicit
operator|=
operator|(
name|init
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* Effective C++ rule 12 requires that all data members be      initialized.  */
if|if
condition|(
name|warn_ecpp
operator|&&
operator|!
name|explicit
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|warning
argument_list|(
name|OPT_Weffc__
argument_list|,
literal|"%J%qD should be initialized in the member initialization "
literal|"list"
argument_list|,
name|current_function_decl
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Get an lvalue for the data member.  */
name|decl
operator|=
name|build_class_member_access_expr
argument_list|(
name|current_class_ref
argument_list|,
name|member
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*preserve_reference=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Deal with this here, as we will get confused if we try to call the      assignment op for an anonymous union.  This can happen in a      synthesized copy constructor.  */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
name|init
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|explicit
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Initialization of one array from another.  */
name|finish_expr_stmt
argument_list|(
name|build_vec_init
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|,
comment|/*explicit_default_init_p=*/
name|false
argument_list|,
comment|/* from_array=*/
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_expr_stmt
argument_list|(
name|build_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|explicit
condition|)
block|{
name|init
operator|=
name|build_default_init
argument_list|(
name|type
argument_list|,
comment|/*nelts=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Jdefault-initialization of %q#D, "
literal|"which has reference type"
argument_list|,
name|current_function_decl
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
comment|/* member traversal: note it leaves init NULL */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"%Juninitialized reference member %qD"
argument_list|,
name|current_function_decl
argument_list|,
name|member
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%Juninitialized member %qD with %<const%> type %qT"
argument_list|,
name|current_function_decl
argument_list|,
name|member
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* There was an explicit member initialization.  Do some work 	   in that case.  */
name|init
operator|=
name|build_x_compound_expr_from_list
argument_list|(
name|init
argument_list|,
literal|"member initializer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|build_class_member_access_expr
argument_list|(
name|current_class_ref
argument_list|,
name|member
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
name|finish_eh_cleanup
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a TREE_LIST containing (as the TREE_PURPOSE of each node) all    the FIELD_DECLs on the TYPE_FIELDS list for T, in reverse order.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_list
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|list
parameter_list|,
name|int
modifier|*
name|uses_unions_p
parameter_list|)
block|{
name|tree
name|fields
decl_stmt|;
operator|*
name|uses_unions_p
operator|=
literal|0
expr_stmt|;
comment|/* Note whether or not T is a union.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
operator|*
name|uses_unions_p
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
comment|/* Skip CONST_DECLs for enumeration constants and so forth.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|fields
argument_list|)
condition|)
continue|continue;
comment|/* Keep track of whether or not any fields are unions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
operator|*
name|uses_unions_p
operator|=
literal|1
expr_stmt|;
comment|/* For an anonymous struct or union, we must recursively 	 consider the fields of the anonymous type.  They can be 	 directly initialized from the constructor.  */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Add this field itself.  Synthesized copy constructors 	     initialize the entire aggregate.  */
name|list
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* And now add the fields in the anonymous aggregate.  */
name|list
operator|=
name|build_field_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|,
name|list
argument_list|,
name|uses_unions_p
argument_list|)
expr_stmt|;
block|}
comment|/* Add this field.  */
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
condition|)
name|list
operator|=
name|tree_cons
argument_list|(
name|fields
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* The MEM_INITS are a TREE_LIST.  The TREE_PURPOSE of each list gives    a FIELD_DECL or BINFO in T that needs initialization.  The    TREE_VALUE gives the initializer, or list of initializer arguments.     Return a TREE_LIST containing all of the initializations required    for T, in the order in which they should be performed.  The output    list has the same format as the input.  */
end_comment

begin_function
specifier|static
name|tree
name|sort_mem_initializers
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|mem_inits
parameter_list|)
block|{
name|tree
name|init
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|tree
name|sorted_inits
decl_stmt|;
name|tree
name|next_subobject
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vbases
expr_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|uses_unions_p
decl_stmt|;
comment|/* Build up a list of initializations.  The TREE_PURPOSE of entry      will be the subobject (a FIELD_DECL or BINFO) to initialize.  The      TREE_VALUE will be the constructor arguments, or NULL if no      explicit initialization was provided.  */
name|sorted_inits
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Process the virtual bases.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vbases
argument_list|,
name|i
argument_list|,
name|base
argument_list|)
condition|;
name|i
operator|++
control|)
name|sorted_inits
operator|=
name|tree_cons
argument_list|(
name|base
argument_list|,
name|NULL_TREE
argument_list|,
name|sorted_inits
argument_list|)
expr_stmt|;
comment|/* Process the direct bases.  */
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|sorted_inits
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|NULL_TREE
argument_list|,
name|sorted_inits
argument_list|)
expr_stmt|;
comment|/* Process the non-static data members.  */
name|sorted_inits
operator|=
name|build_field_list
argument_list|(
name|t
argument_list|,
name|sorted_inits
argument_list|,
operator|&
name|uses_unions_p
argument_list|)
expr_stmt|;
comment|/* Reverse the entire list of initializations, so that they are in      the order that they will actually be performed.  */
name|sorted_inits
operator|=
name|nreverse
argument_list|(
name|sorted_inits
argument_list|)
expr_stmt|;
comment|/* If the user presented the initializers in an order different from      that in which they will actually occur, we issue a warning.  Keep      track of the next subobject which can be explicitly initialized      without issuing a warning.  */
name|next_subobject
operator|=
name|sorted_inits
expr_stmt|;
comment|/* Go through the explicit initializers, filling in TREE_PURPOSE in      the SORTED_INITS.  */
for|for
control|(
name|init
operator|=
name|mem_inits
init|;
name|init
condition|;
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
control|)
block|{
name|tree
name|subobject
decl_stmt|;
name|tree
name|subobject_init
decl_stmt|;
name|subobject
operator|=
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* If the explicit initializers are in sorted order, then 	 SUBOBJECT will be NEXT_SUBOBJECT, or something following 	 it.  */
for|for
control|(
name|subobject_init
operator|=
name|next_subobject
init|;
name|subobject_init
condition|;
name|subobject_init
operator|=
name|TREE_CHAIN
argument_list|(
name|subobject_init
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|subobject_init
argument_list|)
operator|==
name|subobject
condition|)
break|break;
comment|/* Issue a warning if the explicit initializer order does not 	 match that which will actually occur. 	 ??? Are all these on the correct lines?  */
if|if
condition|(
name|warn_reorder
operator|&&
operator|!
name|subobject_init
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|next_subobject
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|warning
argument_list|(
name|OPT_Wreorder
argument_list|,
literal|"%q+D will be initialized after"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|next_subobject
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wreorder
argument_list|,
literal|"base %qT will be initialized after"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|next_subobject
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|subobject
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|warning
argument_list|(
name|OPT_Wreorder
argument_list|,
literal|"  %q+#D"
argument_list|,
name|subobject
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wreorder
argument_list|,
literal|"  base %qT"
argument_list|,
name|subobject
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wreorder
argument_list|,
literal|"%J  when initialized here"
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
comment|/* Look again, from the beginning of the list.  */
if|if
condition|(
operator|!
name|subobject_init
condition|)
block|{
name|subobject_init
operator|=
name|sorted_inits
expr_stmt|;
while|while
condition|(
name|TREE_PURPOSE
argument_list|(
name|subobject_init
argument_list|)
operator|!=
name|subobject
condition|)
name|subobject_init
operator|=
name|TREE_CHAIN
argument_list|(
name|subobject_init
argument_list|)
expr_stmt|;
block|}
comment|/* It is invalid to initialize the same subobject more than 	 once.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|subobject_init
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|subobject
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error
argument_list|(
literal|"%Jmultiple initializations given for %qD"
argument_list|,
name|current_function_decl
argument_list|,
name|subobject
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%Jmultiple initializations given for base %qT"
argument_list|,
name|current_function_decl
argument_list|,
name|subobject
argument_list|)
expr_stmt|;
block|}
comment|/* Record the initialization.  */
name|TREE_VALUE
argument_list|(
name|subobject_init
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|next_subobject
operator|=
name|subobject_init
expr_stmt|;
block|}
comment|/* [class.base.init]       If a ctor-initializer specifies more than one mem-initializer for      multiple members of the same union (including members of      anonymous unions), the ctor-initializer is ill-formed.  */
if|if
condition|(
name|uses_unions_p
condition|)
block|{
name|tree
name|last_field
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|init
operator|=
name|sorted_inits
init|;
name|init
condition|;
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
control|)
block|{
name|tree
name|field
decl_stmt|;
name|tree
name|field_type
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* Skip uninitialized members and base classes.  */
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* See if this field is a member of a union, or a member of a 	     structure contained in a union, etc.  */
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
expr_stmt|;
for|for
control|(
name|field_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
init|;
operator|!
name|same_type_p
argument_list|(
name|field_type
argument_list|,
name|t
argument_list|)
condition|;
name|field_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|field_type
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
break|break;
comment|/* If this field is not a member of a union, skip it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
comment|/* It's only an error if we have two initializers for the same 	     union type.  */
if|if
condition|(
operator|!
name|last_field
condition|)
block|{
name|last_field
operator|=
name|field
expr_stmt|;
continue|continue;
block|}
comment|/* See if LAST_FIELD and the field initialized by INIT are 	     members of the same union.  If so, there's a problem, 	     unless they're actually members of the same structure 	     which is itself a member of a union.  For example, given:  	       union { struct { int i; int j; }; };  	     initializing both `i' and `j' makes sense.  */
name|field_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|tree
name|last_field_type
decl_stmt|;
name|last_field_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|last_field
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|last_field_type
argument_list|,
name|field_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"%Jinitializations for multiple members of %qT"
argument_list|,
name|current_function_decl
argument_list|,
name|last_field_type
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|same_type_p
argument_list|(
name|last_field_type
argument_list|,
name|t
argument_list|)
condition|)
break|break;
name|last_field_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|last_field_type
argument_list|)
expr_stmt|;
block|}
comment|/* If we've reached the outermost class, then we're 		 done.  */
if|if
condition|(
name|same_type_p
argument_list|(
name|field_type
argument_list|,
name|t
argument_list|)
condition|)
break|break;
name|field_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|last_field
operator|=
name|field
expr_stmt|;
block|}
block|}
return|return
name|sorted_inits
return|;
block|}
end_function

begin_comment
comment|/* Initialize all bases and members of CURRENT_CLASS_TYPE.  MEM_INITS    is a TREE_LIST giving the explicit mem-initializer-list for the    constructor.  The TREE_PURPOSE of each entry is a subobject (a    FIELD_DECL or a BINFO) of the CURRENT_CLASS_TYPE.  The TREE_VALUE    is a TREE_LIST giving the arguments to the constructor or    void_type_node for an empty list of arguments.  */
end_comment

begin_function
name|void
name|emit_mem_initializers
parameter_list|(
name|tree
name|mem_inits
parameter_list|)
block|{
comment|/* We will already have issued an error message about the fact that      the type is incomplete.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
return|return;
comment|/* Sort the mem-initializers into the order in which the      initializations should be performed.  */
name|mem_inits
operator|=
name|sort_mem_initializers
argument_list|(
name|current_class_type
argument_list|,
name|mem_inits
argument_list|)
expr_stmt|;
name|in_base_initializer
operator|=
literal|1
expr_stmt|;
comment|/* Initialize base classes.  */
while|while
condition|(
name|mem_inits
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|mem_inits
argument_list|)
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|tree
name|subobject
init|=
name|TREE_PURPOSE
argument_list|(
name|mem_inits
argument_list|)
decl_stmt|;
name|tree
name|arguments
init|=
name|TREE_VALUE
argument_list|(
name|mem_inits
argument_list|)
decl_stmt|;
comment|/* If these initializations are taking place in a copy 	 constructor, the base class should probably be explicitly 	 initialized.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|arguments
operator|&&
name|DECL_COPY_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|subobject
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"%Jbase class %q#T should be explicitly initialized in the "
literal|"copy constructor"
argument_list|,
name|current_function_decl
argument_list|,
name|BINFO_TYPE
argument_list|(
name|subobject
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If an explicit -- but empty -- initializer list was present, 	 treat it just like default initialization at this point.  */
if|if
condition|(
name|arguments
operator|==
name|void_type_node
condition|)
name|arguments
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Initialize the base.  */
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|subobject
argument_list|)
condition|)
name|construct_virtual_base
argument_list|(
name|subobject
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|current_class_ptr
argument_list|,
name|subobject
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|subobject
argument_list|,
name|NULL_TREE
argument_list|,
name|build_indirect_ref
argument_list|(
name|base_addr
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|arguments
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|expand_cleanup_for_base
argument_list|(
name|subobject
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|mem_inits
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_inits
argument_list|)
expr_stmt|;
block|}
name|in_base_initializer
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the vptrs.  */
name|initialize_vtbl_ptrs
argument_list|(
name|current_class_ptr
argument_list|)
expr_stmt|;
comment|/* Initialize the data members.  */
while|while
condition|(
name|mem_inits
condition|)
block|{
name|perform_member_init
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|mem_inits
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|mem_inits
argument_list|)
argument_list|)
expr_stmt|;
name|mem_inits
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_inits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the address of the vtable (i.e., the value that should be    assigned to the vptr) for BINFO.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtbl_address
parameter_list|(
name|tree
name|binfo
parameter_list|)
block|{
name|tree
name|binfo_for
init|=
name|binfo
decl_stmt|;
name|tree
name|vtbl
decl_stmt|;
if|if
condition|(
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
operator|&&
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
comment|/* If this is a virtual primary base, then the vtable we want to store        is that for the base this is being used as the primary base of.  We        can't simply skip the initialization, because we may be expanding the        inits of a subobject constructor where the virtual base layout        can be different.  */
while|while
condition|(
name|BINFO_PRIMARY_P
argument_list|(
name|binfo_for
argument_list|)
condition|)
name|binfo_for
operator|=
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|binfo_for
argument_list|)
expr_stmt|;
comment|/* Figure out what vtable BINFO's vtable is based on, and mark it as      used.  */
name|vtbl
operator|=
name|get_vtbl_decl_for_binfo
argument_list|(
name|binfo_for
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Now compute the address to use when initializing the vptr.  */
name|vtbl
operator|=
name|unshare_expr
argument_list|(
name|BINFO_VTABLE
argument_list|(
name|binfo_for
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vtbl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
return|return
name|vtbl
return|;
block|}
end_function

begin_comment
comment|/* This code sets up the virtual function tables appropriate for    the pointer DECL.  It is a one-ply initialization.     BINFO is the exact type that DECL is supposed to be.  In    multiple inheritance, this might mean "C's A" if C : A, B.  */
end_comment

begin_function
specifier|static
name|void
name|expand_virtual_init
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|vtbl
decl_stmt|,
name|vtbl_ptr
decl_stmt|;
name|tree
name|vtt_index
decl_stmt|;
comment|/* Compute the initializer for vptr.  */
name|vtbl
operator|=
name|build_vtbl_address
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
comment|/* We may get this vptr from a VTT, if this is a subobject      constructor or subobject destructor.  */
name|vtt_index
operator|=
name|BINFO_VPTR_INDEX
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtt_index
condition|)
block|{
name|tree
name|vtbl2
decl_stmt|;
name|tree
name|vtt_parm
decl_stmt|;
comment|/* Compute the value to use, when there's a VTT.  */
name|vtt_parm
operator|=
name|current_vtt_parm
expr_stmt|;
name|vtbl2
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtt_parm
argument_list|)
argument_list|,
name|vtt_parm
argument_list|,
name|vtt_index
argument_list|)
expr_stmt|;
name|vtbl2
operator|=
name|build_indirect_ref
argument_list|(
name|vtbl2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vtbl2
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|vtbl2
argument_list|)
expr_stmt|;
comment|/* The actual initializer is the VTT value only in the subobject 	 constructor.  In maybe_clone_body we'll substitute NULL for 	 the vtt_parm in the case of the non-subobject constructor.  */
name|vtbl
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|,
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|vtbl2
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the location of the vtpr.  */
name|vtbl_ptr
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|vtbl_ptr
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* Assign the vtable to the vptr.  */
name|vtbl
operator|=
name|convert_force
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl_ptr
argument_list|)
argument_list|,
name|vtbl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|vtbl_ptr
argument_list|,
name|NOP_EXPR
argument_list|,
name|vtbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If an exception is thrown in a constructor, those base classes already    constructed must be destroyed.  This function creates the cleanup    for BINFO, which has just been constructed.  If FLAG is non-NULL,    it is a DECL which is nonzero when this base needs to be    destroyed.  */
end_comment

begin_function
specifier|static
name|void
name|expand_cleanup_for_base
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|flag
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Call the destructor.  */
name|expr
operator|=
name|build_special_member_call
argument_list|(
name|current_class_ref
argument_list|,
name|base_dtor_identifier
argument_list|,
name|NULL_TREE
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|expr
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|flag
argument_list|)
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|finish_eh_cleanup
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct the virtual base-class VBASE passing the ARGUMENTS to its    constructor.  */
end_comment

begin_function
specifier|static
name|void
name|construct_virtual_base
parameter_list|(
name|tree
name|vbase
parameter_list|,
name|tree
name|arguments
parameter_list|)
block|{
name|tree
name|inner_if_stmt
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|tree
name|flag
decl_stmt|;
comment|/* If there are virtual base classes with destructors, we need to      emit cleanups to destroy them if an exception is thrown during      the construction process.  These exception regions (i.e., the      period during which the cleanups must occur) begin from the time      the construction is complete to the end of the function.  If we      create a conditional block in which to initialize the      base-classes, then the cleanup region for the virtual base begins      inside a block, and ends outside of that block.  This situation      confuses the sjlj exception-handling code.  Therefore, we do not      create a single conditional block, but one for each      initialization.  (That way the cleanup regions always begin      in the outer block.)  We trust the back-end to figure out      that the FLAG will not change across initializations, and      avoid doing multiple tests.  */
name|flag
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|inner_if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|flag
argument_list|,
name|inner_if_stmt
argument_list|)
expr_stmt|;
comment|/* Compute the location of the virtual base.  If we're      constructing virtual bases, then we must be the most derived      class.  Therefore, we don't have to look up the virtual base;      we already know where it is.  */
name|exp
operator|=
name|convert_to_base_statically
argument_list|(
name|current_class_ref
argument_list|,
name|vbase
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|vbase
argument_list|,
name|current_class_ref
argument_list|,
name|exp
argument_list|,
name|arguments
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|inner_if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|inner_if_stmt
argument_list|)
expr_stmt|;
name|expand_cleanup_for_base
argument_list|(
name|vbase
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the context in which this FIELD can be initialized.  */
end_comment

begin_function
specifier|static
name|tree
name|initializing_context
parameter_list|(
name|tree
name|field
parameter_list|)
block|{
name|tree
name|t
init|=
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* Anonymous union members can be initialized in the first enclosing      non-anonymous union context.  */
while|while
condition|(
name|t
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Function to give error message if member initialization specification    is erroneous.  FIELD is the member we decided to initialize.    TYPE is the type for which the initialization is being performed.    FIELD must be a member of TYPE.     MEMBER_NAME is the name of the member.  */
end_comment

begin_function
specifier|static
name|int
name|member_init_ok_or_else
parameter_list|(
name|tree
name|field
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|member_name
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
literal|"class %qT does not have any field named %qD"
argument_list|,
name|type
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%q#D is a static data member; it can only be "
literal|"initialized at its definition"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%q#D is not a non-static data member of %qT"
argument_list|,
name|field
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|initializing_context
argument_list|(
name|field
argument_list|)
operator|!=
name|type
condition|)
block|{
name|error
argument_list|(
literal|"class %qT does not have any field named %qD"
argument_list|,
name|type
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* NAME is a FIELD_DECL, an IDENTIFIER_NODE which names a field, or it    is a _TYPE node or TYPE_DECL which names a base for that type.    Check the validity of NAME, and return either the base _TYPE, base    binfo, or the FIELD_DECL of the member.  If NAME is invalid, return    NULL_TREE and issue a diagnostic.     An old style unnamed direct single base construction is permitted,    where NAME is NULL.  */
end_comment

begin_function
name|tree
name|expand_member_init
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|field
decl_stmt|;
if|if
condition|(
operator|!
name|current_class_ref
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
comment|/* This is an obsolete unnamed base class initializer.  The 	 parser will already have warned about its use.  */
switch|switch
condition|(
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"unnamed initializer for %qT, which has no base classes"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
case|case
literal|1
case|:
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|BINFO_BASE_BINFO
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unnamed initializer for %qT, which uses multiple inheritance"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|basetype
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
block|{
name|tree
name|class_binfo
decl_stmt|;
name|tree
name|direct_binfo
decl_stmt|;
name|tree
name|virtual_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_template_parms
condition|)
return|return
name|basetype
return|;
name|class_binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|direct_binfo
operator|=
name|NULL_TREE
expr_stmt|;
name|virtual_binfo
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Look for a direct base.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|class_binfo
argument_list|,
name|i
argument_list|,
name|direct_binfo
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|SAME_BINFO_TYPE_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|direct_binfo
argument_list|)
argument_list|,
name|basetype
argument_list|)
condition|)
break|break;
comment|/* Look for a virtual base -- unless the direct base is itself 	 virtual.  */
if|if
condition|(
operator|!
name|direct_binfo
operator|||
operator|!
name|BINFO_VIRTUAL_P
argument_list|(
name|direct_binfo
argument_list|)
condition|)
name|virtual_binfo
operator|=
name|binfo_for_vbase
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* [class.base.init]  	 If a mem-initializer-id is ambiguous because it designates 	 both a direct non-virtual base class and an inherited virtual 	 base class, the mem-initializer is ill-formed.  */
if|if
condition|(
name|direct_binfo
operator|&&
name|virtual_binfo
condition|)
block|{
name|error
argument_list|(
literal|"%qD is both a direct base and an indirect virtual base"
argument_list|,
name|basetype
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|direct_binfo
operator|&&
operator|!
name|virtual_binfo
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|error
argument_list|(
literal|"type %qT is not a direct or virtual base of %qT"
argument_list|,
name|basetype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type %qT is not a direct base of %qT"
argument_list|,
name|basetype
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|direct_binfo
condition|?
name|direct_binfo
else|:
name|virtual_binfo
return|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|field
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|field
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|current_class_type
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|field
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* This is like `expand_member_init', only it stores one aggregate    value into another.     INIT comes in two flavors: it is either a value which    is to be stored in EXP, or it is a parameter list    to go to a constructor, which will operate on EXP.    If INIT is not a parameter list for a constructor, then set    LOOKUP_ONLYCONVERTING.    If FLAGS is LOOKUP_ONLYCONVERTING then it is the = init form of    the initializer, if FLAGS is 0, then it is the (init) form.    If `init' is a CONSTRUCTOR, then we emit a warning message,    explaining that such initializations are invalid.     If INIT resolves to a CALL_EXPR which happens to return    something of the type we are looking for, then we know    that we can safely use that call to perform the    initialization.     The virtual function table pointer cannot be set up here, because    we do not really know its type.     This never calls operator=().     When initializing, nothing is CONST.     A default copy constructor may have to be used to perform the    initialization.     A constructor or a conversion operator may have to be used to    perform the initialization, but not both, as it would be ambiguous.  */
end_comment

begin_function
name|tree
name|build_aggr_init
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|init
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|stmt_expr
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|int
name|destroy_temps
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_const
init|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_volatile
init|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|is_global
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|itype
decl_stmt|;
comment|/* An array may not be initialized use the parenthesized 	 initialization form -- unless the initializer is "()".  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"bad array initializer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Must arrange to initialize each element of EXP 	 from elements of INIT.  */
name|itype
operator|=
name|init
condition|?
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|itype
operator|&&
name|cp_type_quals
argument_list|(
name|itype
argument_list|)
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|build_vec_init
argument_list|(
name|exp
argument_list|,
name|NULL_TREE
argument_list|,
name|init
argument_list|,
comment|/*explicit_default_init_p=*/
name|false
argument_list|,
name|itype
operator|&&
name|same_type_p
argument_list|(
name|itype
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|itype
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
comment|/* Just know that we've seen something for this node.  */
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|is_global
operator|=
name|begin_init_stmts
argument_list|(
operator|&
name|stmt_expr
argument_list|,
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
name|destroy_temps
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
operator||
name|flags
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|finish_init_stmts
argument_list|(
name|is_global
argument_list|,
name|stmt_expr
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|destroy_temps
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_default_init
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|true_exp
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree
name|init
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|ctor_name
decl_stmt|;
comment|/* It fails because there may not be a constructor which takes      its own type as the first (or only parameter), but which does      take other types via a conversion.  So, if the thing initializing      the expression is a unit element of type X, first try X(X&),      followed by initialization by X.  If neither of these work      out, then look hard.  */
name|tree
name|rval
decl_stmt|;
name|tree
name|parms
decl_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
operator|)
condition|)
block|{
comment|/* Base subobjects should only get direct-initialization.  */
name|gcc_assert
argument_list|(
name|true_exp
operator|==
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DIRECT_BIND
condition|)
comment|/* Do nothing.  We hit this in two cases:  Reference initialization, 	   where we aren't initializing a real variable, so we don't want 	   to run a new constructor; and catching an exception, where we 	   have already built up the constructor call so we could wrap it 	   in an exception region.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|BRACE_ENCLOSED_INITIALIZER_P
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* A brace-enclosed initializer for an aggregate.  */
name|gcc_assert
argument_list|(
name|CP_AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_FORCE_TEMP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|MUST_NOT_THROW_EXPR
condition|)
comment|/* We need to protect the initialization of a catch parm with a 	   call to terminate(), which shows up as a MUST_NOT_THROW_EXPR 	   around the TARGET_EXPR for the copy constructor.  See 	   initialize_handler_parm.  */
block|{
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
else|else
name|init
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|)
condition|)
block|{
name|parms
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|parms
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_exp
operator|==
name|exp
condition|)
name|ctor_name
operator|=
name|complete_ctor_identifier
expr_stmt|;
else|else
name|ctor_name
operator|=
name|base_ctor_identifier
expr_stmt|;
name|rval
operator|=
name|build_special_member_call
argument_list|(
name|exp
argument_list|,
name|ctor_name
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
condition|)
name|finish_expr_stmt
argument_list|(
name|convert_to_void
argument_list|(
name|rval
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is responsible for initializing EXP with INIT    (if any).     BINFO is the binfo of the type for who we are performing the    initialization.  For example, if W is a virtual base class of A and B,    and C : A, B.    If we are initializing B, then W must contain B's W vtable, whereas    were we initializing C, W must contain C's W vtable.     TRUE_EXP is nonzero if it is the true expression being initialized.    In this case, it may be EXP, or may just contain EXP.  The reason we    need this is because if EXP is a base element of TRUE_EXP, we    don't necessarily know by looking at EXP where its virtual    baseclass fields should really be pointing.  But we do know    from TRUE_EXP.  In constructors, we don't know anything about    the value being initialized.     FLAGS is just passed to `build_new_method_call'.  See that function    for its description.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|true_exp
parameter_list|,
name|tree
name|exp
parameter_list|,
name|tree
name|init
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|init
operator|!=
name|error_mark_node
operator|&&
name|type
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|building_stmt_tree
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Use a function returning the desired type to initialize EXP for us.      If the function is a constructor, and its first argument is      NULL_TREE, know that it was meant for us--just slide exp on      in and expand the constructor.  Constructors now come      as TARGET_EXPRs.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|COMPOUND_LITERAL_P
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* If store_init_value returns NULL_TREE, the INIT has been 	 recorded as the DECL_INITIAL for EXP.  That means there's 	 nothing more we have to do.  */
name|init
operator|=
name|store_init_value
argument_list|(
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We know that expand_default_init can handle everything we want      at this point.  */
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error if TYPE is not a user-defined, aggregate type.  If    OR_ELSE is nonzero, give an error message.  */
end_comment

begin_function
name|int
name|is_aggr_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|or_else
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|error
argument_list|(
literal|"%qT is not an aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|tree
name|get_type_value
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build a reference to a member of an aggregate.  This is not a C++    `&', but really something which can have its address taken, and    then act as a pointer to member, for example TYPE :: FIELD can have    its address taken by saying& TYPE :: FIELD.  ADDRESS_P is true if    this expression is the operand of "&".     @@ Prints out lousy diagnostics for operator<typename>    @@ fields.     @@ This function should be rewritten and placed in search.c.  */
end_comment

begin_function
name|tree
name|build_offset_ref
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|member
parameter_list|,
name|bool
name|address_p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|basebinfo
init|=
name|NULL_TREE
decl_stmt|;
comment|/* class templates can come in as TEMPLATE_DECLs here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|member
return|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|type
argument_list|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|member
argument_list|)
condition|)
return|return
name|build_qualified_name
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|member
argument_list|,
comment|/*template_p=*/
name|false
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|member
argument_list|)
operator|||
name|BASELINK_P
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Callers should call mark_used before this point.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_P
argument_list|(
name|member
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incomplete type %qT does not have member %qD"
argument_list|,
name|type
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Entities other than non-static members need no further      processing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|member
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|CONST_DECL
condition|)
return|return
name|convert_from_reference
argument_list|(
name|member
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid pointer to bit-field %qD"
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Set up BASEBINFO for member lookup.  */
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|type
argument_list|,
operator|&
name|basebinfo
argument_list|)
expr_stmt|;
comment|/* A lot of this logic is now handled in lookup_member.  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
comment|/* Go from the TREE_BASELINK to the member function info.  */
name|tree
name|t
init|=
name|BASELINK_FUNCTIONS
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Get rid of a potential OVERLOAD around it.  */
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Unique functions are handled easily.  */
comment|/* For non-static member of base class, we need a special rule 	     for access checking [class.protected]:  	       If the access is to form a pointer to member, the 	       nested-name-specifier shall name the derived class 	       (or any class derived from that class).  */
if|if
condition|(
name|address_p
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|t
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|perform_or_defer_access_check
argument_list|(
name|basebinfo
argument_list|,
name|t
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
name|member
operator|=
name|t
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|address_p
operator|&&
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
comment|/* We need additional test besides the one in        check_accessibility_of_qualified_id in case it is        a pointer to non-static member.  */
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|member
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|address_p
condition|)
block|{
comment|/* If MEMBER is non-static, then the program has fallen afoul of 	 [expr.prim]:  	   An id-expression that denotes a nonstatic data member or 	   nonstatic member function of a class can only be used:  	   -- as part of a class member access (_expr.ref_) in which the 	   object-expression refers to the member's class or a class 	   derived from that class, or  	   -- to form a pointer to member (_expr.unary.op_), or  	   -- in the body of a nonstatic member function of that class or 	   of a class derived from that class (_class.mfct.nonstatic_), or  	   -- in a mem-initializer for a constructor for that class or for 	   a class derived from that class (_class.base.init_).  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
comment|/* Build a representation of a the qualified name suitable 	     for use as the operand to "&" -- even though the "&" is 	     not actually present.  */
name|member
operator|=
name|build2
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|decl
argument_list|,
name|member
argument_list|)
expr_stmt|;
comment|/* In Microsoft mode, treat a non-static member function as if 	     it were a pointer-to-member.  */
if|if
condition|(
name|flag_ms_extensions
condition|)
block|{
name|PTRMEM_OK_P
argument_list|(
name|member
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|member
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"invalid use of non-static member function %qD"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-static data member %qD"
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|member
return|;
block|}
name|member
operator|=
name|build2
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|decl
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|PTRMEM_OK_P
argument_list|(
name|member
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|member
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a scalar enumeration constant or variable with a    constant initializer, return the initializer (or, its initializers,    recursively); otherwise, return DECL.  If INTEGRAL_P, the    initializer is only returned if DECL is an integral    constant-expression.  */
end_comment

begin_function
specifier|static
name|tree
name|constant_value_1
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|integral_p
parameter_list|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
operator|||
operator|(
name|integral_p
condition|?
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|decl
argument_list|)
else|:
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|CP_TYPE_CONST_NON_VOLATILE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tree
name|init
decl_stmt|;
comment|/* Static data members in template classes may have 	 non-dependent initializers.  References to such non-static 	 data members are not value-dependent, so we must retrieve the 	 initializer here.  The DECL_INITIAL will have the right type, 	 but will not have been folded because that would prevent us 	 from performing all appropriate semantic checks at 	 instantiation time.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|processing_template_decl
expr_stmt|;
name|init
operator|=
name|fold_non_dependent_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
block|}
else|else
block|{
comment|/* If DECL is a static data member in a template 	     specialization, we must instantiate it here.  The 	     initializer for the static data member is not processed 	     until needed; we need it now.  */
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|decl
return|;
if|if
condition|(
operator|!
name|init
operator|||
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|||
operator|(
name|integral_p
condition|?
operator|!
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
else|:
operator|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
comment|/* Do not return an aggregate constant (of which 		    string literals are a special case), as we do not 		    want to make inadvertent copies of such entities, 		    and we must be sure that their addresses are the 		    same everywhere.  */
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
break|break;
name|decl
operator|=
name|unshare_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a CONST_DECL, or a constant VAR_DECL initialized by    constant of integral or enumeration type, then return that value.    These are those variables permitted in constant expressions by    [5.19/1].  */
end_comment

begin_function
name|tree
name|integral_constant_value
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|constant_value_1
argument_list|(
name|decl
argument_list|,
comment|/*integral_p=*/
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A more relaxed version of integral_constant_value, used by the    common C/C++ code and by the C++ front-end for optimization    purposes.  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|constant_value_1
argument_list|(
name|decl
argument_list|,
comment|/*integral_p=*/
name|processing_template_decl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common subroutines of build_new and build_vec_delete.  */
end_comment

begin_comment
comment|/* Call the global __builtin_delete to delete ADDR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_builtin_delete_call
parameter_list|(
name|tree
name|addr
parameter_list|)
block|{
name|mark_used
argument_list|(
name|global_delete_fndecl
argument_list|)
expr_stmt|;
return|return
name|build_call
argument_list|(
name|global_delete_fndecl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a NEW_EXPR.  If NELTS is non-NULL, TYPE[NELTS] is    the type of the object being allocated; otherwise, it's just TYPE.    INIT is the initializer, if any.  USE_GLOBAL_NEW is true if the    user explicitly wrote "::operator new".  PLACEMENT, if non-NULL, is    the TREE_LIST of arguments to be provided as arguments to a    placement new operator.  This routine performs no semantic checks;    it just creates and returns a NEW_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|build_raw_new_expr
parameter_list|(
name|tree
name|placement
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|nelts
parameter_list|,
name|tree
name|init
parameter_list|,
name|int
name|use_global_new
parameter_list|)
block|{
name|tree
name|new_expr
decl_stmt|;
name|new_expr
operator|=
name|build4
argument_list|(
name|NEW_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|placement
argument_list|,
name|type
argument_list|,
name|nelts
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|new_expr
argument_list|)
operator|=
name|use_global_new
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|new_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|new_expr
return|;
block|}
end_function

begin_comment
comment|/* Generate code for a new-expression, including calling the "operator    new" function, initializing the object, and, if an exception occurs    during construction, cleaning up.  The arguments are as for    build_raw_new_expr.  */
end_comment

begin_function
specifier|static
name|tree
name|build_new_1
parameter_list|(
name|tree
name|placement
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|nelts
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|globally_qualified_p
parameter_list|)
block|{
name|tree
name|size
decl_stmt|,
name|rval
decl_stmt|;
comment|/* True iff this is a call to "operator new[]" instead of just      "operator new".  */
name|bool
name|array_p
init|=
name|false
decl_stmt|;
comment|/* True iff ARRAY_P is true and the bound of the array type is      not necessarily a compile time constant.  For example, VLA_P is      true for "new int[f()]".  */
name|bool
name|vla_p
init|=
name|false
decl_stmt|;
comment|/* The type being allocated.  If ARRAY_P is true, this will be an      ARRAY_TYPE.  */
name|tree
name|full_type
decl_stmt|;
comment|/* If ARRAY_P is true, the element type of the array.  This is an      never ARRAY_TYPE; for something like "new int[3][4]", the      ELT_TYPE is "int".  If ARRAY_P is false, this is the same type as      FULL_TYPE.  */
name|tree
name|elt_type
decl_stmt|;
comment|/* The type of the new-expression.  (This type is always a pointer      type.)  */
name|tree
name|pointer_type
decl_stmt|;
comment|/* A pointer type pointing to the FULL_TYPE.  */
name|tree
name|full_pointer_type
decl_stmt|;
name|tree
name|outer_nelts
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|alloc_call
decl_stmt|,
name|alloc_expr
decl_stmt|;
comment|/* The address returned by the call to "operator new".  This node is      a VAR_DECL and is therefore reusable.  */
name|tree
name|alloc_node
decl_stmt|;
name|tree
name|alloc_fn
decl_stmt|;
name|tree
name|cookie_expr
decl_stmt|,
name|init_expr
decl_stmt|;
name|int
name|nothrow
decl_stmt|,
name|check_new
decl_stmt|;
name|int
name|use_java_new
init|=
literal|0
decl_stmt|;
comment|/* If non-NULL, the number of extra bytes to allocate at the      beginning of the storage allocated for an array-new expression in      order to store the number of elements.  */
name|tree
name|cookie_size
init|=
name|NULL_TREE
decl_stmt|;
comment|/* True if the function we are calling is a placement allocation      function.  */
name|bool
name|placement_allocation_fn_p
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
comment|/* True if the storage must be initialized, either by a constructor      or due to an explicit new-initializer.  */
name|bool
name|is_initialized
decl_stmt|;
comment|/* The address of the thing allocated, not including any cookie.  In      particular, if an array cookie is in use, DATA_ADDR is the      address of the first array element.  This node is a VAR_DECL, and      is therefore reusable.  */
name|tree
name|data_addr
decl_stmt|;
name|tree
name|init_preeval_expr
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|nelts
condition|)
block|{
name|tree
name|index
decl_stmt|;
name|outer_nelts
operator|=
name|nelts
expr_stmt|;
name|array_p
operator|=
name|true
expr_stmt|;
comment|/* ??? The middle-end will error on us for building a VLA outside a 	 function context.  Methinks that's not it's purvey.  So we'll do 	 our own VLA layout later.  */
name|vla_p
operator|=
name|true
expr_stmt|;
name|index
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
name|index
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
name|index
operator|=
name|build_index_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|full_type
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We need a copy of the type as build_array_type will return a shared copy          of the incomplete array type.  */
name|full_type
operator|=
name|build_distinct_type_copy
argument_list|(
name|full_type
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|full_type
argument_list|)
operator|=
name|index
expr_stmt|;
block|}
else|else
block|{
name|full_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|array_p
operator|=
name|true
expr_stmt|;
name|nelts
operator|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|outer_nelts
operator|=
name|nelts
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|complete_type_or_else
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If our base type is an array, then make sure we know how many elements      it has.  */
for|for
control|(
name|elt_type
operator|=
name|type
init|;
name|TREE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|elt_type
operator|=
name|TREE_TYPE
argument_list|(
name|elt_type
argument_list|)
control|)
name|nelts
operator|=
name|cp_build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|array_type_nelts_top
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid type %<void%> for new"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|elt_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|is_initialized
operator|=
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|elt_type
argument_list|)
operator|||
name|init
operator|)
expr_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|elt_type
argument_list|)
operator|&&
operator|!
name|is_initialized
condition|)
block|{
name|error
argument_list|(
literal|"uninitialized const in %<new%> of %q#T"
argument_list|,
name|elt_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|size
operator|=
name|size_in_bytes
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_p
condition|)
block|{
name|size
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vla_p
condition|)
block|{
name|tree
name|n
decl_stmt|,
name|bitsize
decl_stmt|;
comment|/* Do our own VLA layout.  Setting TYPE_SIZE/_UNIT is 	     necessary in order for the<INIT_EXPR<*foo><CONSTRUCTOR 	     ...>> to be valid.  */
name|TYPE_SIZE_UNIT
argument_list|(
name|full_type
argument_list|)
operator|=
name|size
expr_stmt|;
name|n
operator|=
name|convert
argument_list|(
name|bitsizetype
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|elt_type
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|full_type
argument_list|)
operator|=
name|bitsize
expr_stmt|;
block|}
block|}
name|alloc_fn
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Allocate the object.  */
if|if
condition|(
operator|!
name|placement
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|elt_type
argument_list|)
condition|)
block|{
name|tree
name|class_addr
decl_stmt|;
name|tree
name|class_decl
init|=
name|build_java_class_ref
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|alloc_name
index|[]
init|=
literal|"_Jv_AllocObject"
decl_stmt|;
if|if
condition|(
name|class_decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|use_java_new
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|get_global_value_if_present
argument_list|(
name|get_identifier
argument_list|(
name|alloc_name
argument_list|)
argument_list|,
operator|&
name|alloc_fn
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"call to Java constructor with %qs undefined"
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|alloc_fn
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD should never be overloaded"
argument_list|,
name|alloc_fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|alloc_fn
operator|=
name|OVL_CURRENT
argument_list|(
name|alloc_fn
argument_list|)
expr_stmt|;
name|class_addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|jclass_node
argument_list|,
name|class_decl
argument_list|)
expr_stmt|;
name|alloc_call
operator|=
operator|(
name|build_function_call
argument_list|(
name|alloc_fn
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|class_addr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fnname
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|fnname
operator|=
name|ansi_opname
argument_list|(
name|array_p
condition|?
name|VEC_NEW_EXPR
else|:
name|NEW_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|globally_qualified_p
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|elt_type
argument_list|)
operator|&&
operator|(
name|array_p
condition|?
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|elt_type
argument_list|)
else|:
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|elt_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Use a class-specific operator new.  */
comment|/* If a cookie is required, add some extra space.  */
if|if
condition|(
name|array_p
operator|&&
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|elt_type
argument_list|)
condition|)
block|{
name|cookie_size
operator|=
name|targetm
operator|.
name|cxx
operator|.
name|get_cookie_size
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|cookie_size
argument_list|)
expr_stmt|;
block|}
comment|/* Create the argument list.  */
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
expr_stmt|;
comment|/* Do name-lookup to find the appropriate operator.  */
name|fns
operator|=
name|lookup_fnfields
argument_list|(
name|elt_type
argument_list|,
name|fnname
argument_list|,
comment|/*protect=*/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"no suitable %qD found in class %qT"
argument_list|,
name|fnname
argument_list|,
name|elt_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"request for member %qD is ambiguous"
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|fns
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|alloc_call
operator|=
name|build_new_method_call
argument_list|(
name|build_dummy_object
argument_list|(
name|elt_type
argument_list|)
argument_list|,
name|fns
argument_list|,
name|args
argument_list|,
comment|/*conversion_path=*/
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
operator|&
name|alloc_fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use a global operator new.  */
comment|/* See if a cookie might be required.  */
if|if
condition|(
name|array_p
operator|&&
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|elt_type
argument_list|)
condition|)
name|cookie_size
operator|=
name|targetm
operator|.
name|cxx
operator|.
name|get_cookie_size
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
else|else
name|cookie_size
operator|=
name|NULL_TREE
expr_stmt|;
name|alloc_call
operator|=
name|build_operator_new_call
argument_list|(
name|fnname
argument_list|,
name|placement
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|cookie_size
argument_list|,
operator|&
name|alloc_fn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alloc_call
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|alloc_fn
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* In the simple case, we can stop now.  */
name|pointer_type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie_size
operator|&&
operator|!
name|is_initialized
condition|)
return|return
name|build_nop
argument_list|(
name|pointer_type
argument_list|,
name|alloc_call
argument_list|)
return|;
comment|/* While we're working, use a pointer to the type we've actually      allocated. Store the result of the call in a variable so that we      can use it more than once.  */
name|full_pointer_type
operator|=
name|build_pointer_type
argument_list|(
name|full_type
argument_list|)
expr_stmt|;
name|alloc_expr
operator|=
name|get_target_expr
argument_list|(
name|build_nop
argument_list|(
name|full_pointer_type
argument_list|,
name|alloc_call
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_node
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|alloc_expr
argument_list|)
expr_stmt|;
comment|/* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|alloc_call
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|alloc_call
operator|=
name|TREE_OPERAND
argument_list|(
name|alloc_call
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now, check to see if this function is actually a placement      allocation function.  This can happen even when PLACEMENT is NULL      because we might have something like:         struct S { void* operator new (size_t, int i = 0); };       A call to `new S' will get this allocation function, even though      there is no explicit placement argument.  If there is more than      one argument, or there are variable arguments, then this is a      placement allocation function.  */
name|placement_allocation_fn_p
operator|=
operator|(
name|type_num_arguments
argument_list|(
name|TREE_TYPE
argument_list|(
name|alloc_fn
argument_list|)
argument_list|)
operator|>
literal|1
operator|||
name|varargs_function_p
argument_list|(
name|alloc_fn
argument_list|)
operator|)
expr_stmt|;
comment|/* Preevaluate the placement args so that we don't reevaluate them for a      placement delete.  */
if|if
condition|(
name|placement_allocation_fn_p
condition|)
block|{
name|tree
name|inits
decl_stmt|;
name|stabilize_call
argument_list|(
name|alloc_call
argument_list|,
operator|&
name|inits
argument_list|)
expr_stmt|;
if|if
condition|(
name|inits
condition|)
name|alloc_expr
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|alloc_expr
argument_list|)
argument_list|,
name|inits
argument_list|,
name|alloc_expr
argument_list|)
expr_stmt|;
block|}
comment|/*        unless an allocation function is declared with an empty  excep-      tion-specification  (_except.spec_),  throw(), it indicates failure to      allocate storage by throwing a bad_alloc exception  (clause  _except_,      _lib.bad.alloc_); it returns a non-null pointer otherwise If the allo-      cation function is declared  with  an  empty  exception-specification,      throw(), it returns null to indicate failure to allocate storage and a      non-null pointer otherwise.       So check for a null exception spec on the op new we just called.  */
name|nothrow
operator|=
name|TYPE_NOTHROW_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|alloc_fn
argument_list|)
argument_list|)
expr_stmt|;
name|check_new
operator|=
operator|(
name|flag_check_new
operator|||
name|nothrow
operator|)
operator|&&
operator|!
name|use_java_new
expr_stmt|;
if|if
condition|(
name|cookie_size
condition|)
block|{
name|tree
name|cookie
decl_stmt|;
name|tree
name|cookie_ptr
decl_stmt|;
comment|/* Adjust so we're pointing to the start of the object.  */
name|data_addr
operator|=
name|get_target_expr
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|full_pointer_type
argument_list|,
name|alloc_node
argument_list|,
name|cookie_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the number of bytes allocated so that we can know how 	 many elements to destroy later.  We use the last sizeof 	 (size_t) bytes to store the number of elements.  */
name|cookie_ptr
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|data_addr
argument_list|,
name|size_in_bytes
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|cookie_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cookie_expr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|sizetype
argument_list|,
name|cookie
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cookie_has_size
argument_list|()
condition|)
block|{
comment|/* Also store the element size.  */
name|cookie_ptr
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|cookie_ptr
argument_list|,
name|size_in_bytes
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|cookie_ptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|sizetype
argument_list|,
name|cookie
argument_list|,
name|size_in_bytes
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|cookie_expr
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|cookie_expr
argument_list|)
argument_list|,
name|cookie
argument_list|,
name|cookie_expr
argument_list|)
expr_stmt|;
block|}
name|data_addr
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|data_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cookie_expr
operator|=
name|NULL_TREE
expr_stmt|;
name|data_addr
operator|=
name|alloc_node
expr_stmt|;
block|}
comment|/* Now initialize the allocated object.  Note that we preevaluate the      initialization expression, apart from the actual constructor call or      assignment--we do this because we want to delay the allocation as long      as possible in order to minimize the size of the exception region for      placement delete.  */
if|if
condition|(
name|is_initialized
condition|)
block|{
name|bool
name|stable
decl_stmt|;
name|init_expr
operator|=
name|build_indirect_ref
argument_list|(
name|data_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_p
condition|)
block|{
name|bool
name|explicit_default_init_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|void_zero_node
condition|)
block|{
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|explicit_default_init_p
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids initialization in array new"
argument_list|)
expr_stmt|;
name|init_expr
operator|=
name|build_vec_init
argument_list|(
name|init_expr
argument_list|,
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|outer_nelts
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|init
argument_list|,
name|explicit_default_init_p
argument_list|,
comment|/*from_array=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* An array initialization is stable because the initialization 	     of each element is a full-expression, so the temporaries don't 	     leak out.  */
name|stable
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|void_zero_node
condition|)
name|init
operator|=
name|build_default_init
argument_list|(
name|full_type
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|init_expr
operator|=
name|build_special_member_call
argument_list|(
name|init_expr
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|init
argument_list|,
name|elt_type
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|stable
operator|=
name|stabilize_init
argument_list|(
name|init_expr
argument_list|,
operator|&
name|init_preeval_expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are processing something like `new int (10)', which 		 means allocate an int, and initialize it with 10.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|init
operator|=
name|build_x_compound_expr_from_list
argument_list|(
name|init
argument_list|,
literal|"new initializer"
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|||
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|init_expr
operator|=
name|build_modify_expr
argument_list|(
name|init_expr
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|stable
operator|=
name|stabilize_init
argument_list|(
name|init_expr
argument_list|,
operator|&
name|init_preeval_expr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|init_expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If any part of the object initialization terminates by throwing an 	 exception and a suitable deallocation function can be found, the 	 deallocation function is called to free the memory in which the 	 object was being constructed, after which the exception continues 	 to propagate in the context of the new-expression. If no 	 unambiguous matching deallocation function can be found, 	 propagating the exception does not cause the object's memory to be 	 freed.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|use_java_new
condition|)
block|{
name|enum
name|tree_code
name|dcode
init|=
name|array_p
condition|?
name|VEC_DELETE_EXPR
else|:
name|DELETE_EXPR
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* The Standard is unclear here, but the right thing to do 	     is to use the same method for finding deallocation 	     functions that we use for finding allocation functions.  */
name|cleanup
operator|=
name|build_op_delete_call
argument_list|(
name|dcode
argument_list|,
name|alloc_node
argument_list|,
name|size
argument_list|,
name|globally_qualified_p
argument_list|,
operator|(
name|placement_allocation_fn_p
condition|?
name|alloc_call
else|:
name|NULL_TREE
operator|)
argument_list|,
name|alloc_fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleanup
condition|)
comment|/* We're done.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|stable
condition|)
comment|/* This is much simpler if we were able to preevaluate all of 	       the arguments to the constructor call.  */
name|init_expr
operator|=
name|build2
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|init_expr
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
else|else
comment|/* Ack!  First we allocate the memory.  Then we set our sentry 	       variable to true, and expand a cleanup that deletes the 	       memory if sentry is true.  Then we run the constructor, and 	       finally clear the sentry.  	       We need to do this because we allocate the space first, so 	       if there are any temporaries with cleanups in the 	       constructor args and we weren't able to preevaluate them, we 	       need this EH region to extend until end of full-expression 	       to preserve nesting.  */
block|{
name|tree
name|end
decl_stmt|,
name|sentry
decl_stmt|,
name|begin
decl_stmt|;
name|begin
operator|=
name|get_target_expr
argument_list|(
name|boolean_true_node
argument_list|)
expr_stmt|;
name|CLEANUP_EH_ONLY
argument_list|(
name|begin
argument_list|)
operator|=
literal|1
expr_stmt|;
name|sentry
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|begin
argument_list|)
expr_stmt|;
name|TARGET_EXPR_CLEANUP
argument_list|(
name|begin
argument_list|)
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|sentry
argument_list|,
name|cleanup
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|end
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sentry
argument_list|)
argument_list|,
name|sentry
argument_list|,
name|boolean_false_node
argument_list|)
expr_stmt|;
name|init_expr
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|begin
argument_list|,
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|init_expr
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|init_expr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now build up the return value in reverse order.  */
name|rval
operator|=
name|data_addr
expr_stmt|;
if|if
condition|(
name|init_expr
condition|)
name|rval
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|init_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie_expr
condition|)
name|rval
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|cookie_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|alloc_node
condition|)
comment|/* If we don't have an initializer or a cookie, strip the TARGET_EXPR        and return the call (which doesn't need to be adjusted).  */
name|rval
operator|=
name|TARGET_EXPR_INITIAL
argument_list|(
name|alloc_expr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|check_new
condition|)
block|{
name|tree
name|ifexp
init|=
name|cp_build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|alloc_node
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|rval
argument_list|,
name|alloc_node
argument_list|)
expr_stmt|;
block|}
comment|/* Perform the allocation before anything else, so that ALLOC_NODE 	 has been initialized before we start using it.  */
name|rval
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|alloc_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_preeval_expr
condition|)
name|rval
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|init_preeval_expr
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* Convert to the final type.  */
name|rval
operator|=
name|build_nop
argument_list|(
name|pointer_type
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* A new-expression is never an lvalue.  */
name|gcc_assert
argument_list|(
operator|!
name|lvalue_p
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Generate a representation for a C++ "new" expression.  PLACEMENT is    a TREE_LIST of placement-new arguments (or NULL_TREE if none).  If    NELTS is NULL, TYPE is the type of the storage to be allocated.  If    NELTS is not NULL, then this is an array-new allocation; TYPE is    the type of the elements in the array and NELTS is the number of    elements in the array.  INIT, if non-NULL, is the initializer for    the new object, or void_zero_node to indicate an initializer of    "()".  If USE_GLOBAL_NEW is true, then the user explicitly wrote    "::new" rather than just "new".  */
end_comment

begin_function
name|tree
name|build_new
parameter_list|(
name|tree
name|placement
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|nelts
parameter_list|,
name|tree
name|init
parameter_list|,
name|int
name|use_global_new
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|orig_placement
decl_stmt|;
name|tree
name|orig_nelts
decl_stmt|;
name|tree
name|orig_init
decl_stmt|;
if|if
condition|(
name|placement
operator|==
name|error_mark_node
operator|||
name|type
operator|==
name|error_mark_node
operator|||
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|orig_placement
operator|=
name|placement
expr_stmt|;
name|orig_nelts
operator|=
name|nelts
expr_stmt|;
name|orig_init
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|dependent_type_p
argument_list|(
name|type
argument_list|)
operator|||
name|any_type_dependent_arguments_p
argument_list|(
name|placement
argument_list|)
operator|||
operator|(
name|nelts
operator|&&
name|type_dependent_expression_p
argument_list|(
name|nelts
argument_list|)
operator|)
operator|||
operator|(
name|init
operator|!=
name|void_zero_node
operator|&&
name|any_type_dependent_arguments_p
argument_list|(
name|init
argument_list|)
operator|)
condition|)
return|return
name|build_raw_new_expr
argument_list|(
name|placement
argument_list|,
name|type
argument_list|,
name|nelts
argument_list|,
name|init
argument_list|,
name|use_global_new
argument_list|)
return|;
name|placement
operator|=
name|build_non_dependent_args
argument_list|(
name|placement
argument_list|)
expr_stmt|;
if|if
condition|(
name|nelts
condition|)
name|nelts
operator|=
name|build_non_dependent_expr
argument_list|(
name|nelts
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|void_zero_node
condition|)
name|init
operator|=
name|build_non_dependent_args
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nelts
condition|)
block|{
if|if
condition|(
operator|!
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|nelts
argument_list|,
name|false
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"size in array new must have integral type"
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|cp_save_expr
argument_list|(
name|cp_convert
argument_list|(
name|sizetype
argument_list|,
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It is valid to allocate a zero-element array:  	   [expr.new]  	   When the value of the expression in a direct-new-declarator 	   is zero, the allocation function is called to allocate an 	   array with no elements.  The pointer returned by the 	   new-expression is non-null.  [Note: If the library allocation 	   function is called, the pointer returned is distinct from the 	   pointer to any other object.]  	 However, that is not generally useful, so we issue a 	 warning.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|nelts
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"allocating zero-element array"
argument_list|)
expr_stmt|;
block|}
comment|/* ``A reference cannot be created by the new operator.  A reference      is not an object (8.2.2, 8.4.3), so a pointer to it could not be      returned by new.'' ARM 5.3.3 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a reference type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rval
operator|=
name|build_new_1
argument_list|(
name|placement
argument_list|,
name|type
argument_list|,
name|nelts
argument_list|,
name|init
argument_list|,
name|use_global_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_raw_new_expr
argument_list|(
name|orig_placement
argument_list|,
name|type
argument_list|,
name|orig_nelts
argument_list|,
name|orig_init
argument_list|,
name|use_global_new
argument_list|)
return|;
comment|/* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Given a Java class, return a decl for the corresponding java.lang.Class.  */
end_comment

begin_function
name|tree
name|build_java_class_ref
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|,
name|class_decl
decl_stmt|;
specifier|static
name|tree
name|CL_suffix
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|CL_suffix
operator|==
name|NULL_TREE
condition|)
name|CL_suffix
operator|=
name|get_identifier
argument_list|(
literal|"class$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jclass_node
operator|==
name|NULL_TREE
condition|)
block|{
name|jclass_node
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
literal|"jclass"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jclass_node
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"call to Java constructor, while %<jclass%> undefined"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|jclass_node
operator|=
name|TREE_TYPE
argument_list|(
name|jclass_node
argument_list|)
expr_stmt|;
block|}
comment|/* Mangle the class$ field.  */
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|CL_suffix
condition|)
block|{
name|mangle_decl
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
literal|"can't find %<class$%> in %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|class_decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|class_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|jclass_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|class_decl
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|class_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|class_decl
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|build_vec_delete_1
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|maxindex
parameter_list|,
name|tree
name|type
parameter_list|,
name|special_function_kind
name|auto_delete_vec
parameter_list|,
name|int
name|use_global_delete
parameter_list|)
block|{
name|tree
name|virtual_size
decl_stmt|;
name|tree
name|ptype
init|=
name|build_pointer_type
argument_list|(
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|size_exp
init|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Temporary variables used by the loop.  */
name|tree
name|tbase
decl_stmt|,
name|tbase_init
decl_stmt|;
comment|/* This is the body of the loop that implements the deletion of a      single element, and moves temp variables to next elements.  */
name|tree
name|body
decl_stmt|;
comment|/* This is the LOOP_EXPR that governs the deletion of the elements.  */
name|tree
name|loop
init|=
literal|0
decl_stmt|;
comment|/* This is the thing that governs what to do after the loop has run.  */
name|tree
name|deallocate_expr
init|=
literal|0
decl_stmt|;
comment|/* This is the BIND_EXPR which holds the outermost iterator of the      loop.  It is convenient to set this variable up and test it before      executing any other code in the loop.      This is also the containing expression returned by this function.  */
name|tree
name|controller
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We should only have 1-D arrays here.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|no_destructor
goto|;
comment|/* The below is short by the cookie size.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
name|tbase
operator|=
name|create_temporary_var
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
name|tbase_init
operator|=
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|base
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|tbase
argument_list|)
operator|=
literal|1
expr_stmt|;
name|controller
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tbase
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|controller
argument_list|)
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|build1
argument_list|(
name|EXIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|tbase
argument_list|,
name|fold_convert
argument_list|(
name|ptype
argument_list|,
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|,
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|tbase
argument_list|,
name|size_exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|,
name|build_delete
argument_list|(
name|ptype
argument_list|,
name|tbase
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build1
argument_list|(
name|LOOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build_compound_expr
argument_list|(
name|tbase_init
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|no_destructor
label|:
comment|/* If the delete flag is one, or anything else with the low bit set,      delete the storage.  */
if|if
condition|(
name|auto_delete_vec
operator|!=
name|sfk_base_destructor
condition|)
block|{
name|tree
name|base_tbd
decl_stmt|;
comment|/* The below is short by the cookie size.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|convert
argument_list|(
name|sizetype
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* no header */
name|base_tbd
operator|=
name|base
expr_stmt|;
else|else
block|{
name|tree
name|cookie_size
decl_stmt|;
name|cookie_size
operator|=
name|targetm
operator|.
name|cxx
operator|.
name|get_cookie_size
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base_tbd
operator|=
name|cp_convert
argument_list|(
name|ptype
argument_list|,
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|cp_convert
argument_list|(
name|string_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|cookie_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* True size with header.  */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|cookie_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auto_delete_vec
operator|==
name|sfk_deleting_destructor
condition|)
name|deallocate_expr
operator|=
name|build_op_delete_call
argument_list|(
name|VEC_DELETE_EXPR
argument_list|,
name|base_tbd
argument_list|,
name|virtual_size
argument_list|,
name|use_global_delete
operator|&
literal|1
argument_list|,
comment|/*placement=*/
name|NULL_TREE
argument_list|,
comment|/*alloc_fn=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|body
operator|=
name|loop
expr_stmt|;
if|if
condition|(
operator|!
name|deallocate_expr
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|deallocate_expr
expr_stmt|;
else|else
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|,
name|deallocate_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Outermost wrapper: If pointer is null, punt.  */
name|body
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|fold_build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|body
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|controller
argument_list|,
literal|1
argument_list|)
operator|=
name|body
expr_stmt|;
name|body
operator|=
name|controller
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
comment|/* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */
name|body
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|base
argument_list|,
name|body
argument_list|)
expr_stmt|;
return|return
name|convert_to_void
argument_list|(
name|body
argument_list|,
comment|/*implicit=*/
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an unnamed variable of the indicated TYPE.  */
end_comment

begin_function
name|tree
name|create_temporary_var
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a new temporary variable of the indicated TYPE, initialized    to INIT.     It is not entered into current_binding_level, because that breaks    things when it comes time to do final cleanups (which take place    "outside" the binding contour of the function).  */
end_comment

begin_function
specifier|static
name|tree
name|get_temp_regvar
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|create_temporary_var
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|add_decl_expr
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* `build_vec_init' returns tree structure that performs    initialization of a vector of aggregate types.     BASE is a reference to the vector, of ARRAY_TYPE.    MAXINDEX is the maximum index of the array (one less than the      number of elements).  It is only used if      TYPE_DOMAIN (TREE_TYPE (BASE)) == NULL_TREE.     INIT is the (possibly NULL) initializer.     If EXPLICIT_DEFAULT_INIT_P is true, then INIT must be NULL.  All    elements in the array are default-initialized.     FROM_ARRAY is 0 if we should init everything with INIT    (i.e., every element initialized from INIT).    FROM_ARRAY is 1 if we should index into INIT in parallel    with initialization of DECL.    FROM_ARRAY is 2 if we should index into INIT in parallel,    but use assignment instead of initialization.  */
end_comment

begin_function
name|tree
name|build_vec_init
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|maxindex
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|explicit_default_init_p
parameter_list|,
name|int
name|from_array
parameter_list|)
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|base2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|iterator
decl_stmt|;
comment|/* The type of the array.  */
name|tree
name|atype
init|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
decl_stmt|;
comment|/* The type of an element in the array.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|atype
argument_list|)
decl_stmt|;
comment|/* The element type reached after removing all outer array      types.  */
name|tree
name|inner_elt_type
decl_stmt|;
comment|/* The type of a pointer to an element in the array.  */
name|tree
name|ptype
decl_stmt|;
name|tree
name|stmt_expr
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|int
name|destroy_temps
decl_stmt|;
name|tree
name|try_block
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|num_initialized_elts
init|=
literal|0
decl_stmt|;
name|bool
name|is_global
decl_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|atype
argument_list|)
condition|)
name|maxindex
operator|=
name|array_type_nelts
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxindex
operator|==
name|NULL_TREE
operator|||
name|maxindex
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|explicit_default_init_p
condition|)
name|gcc_assert
argument_list|(
operator|!
name|init
argument_list|)
expr_stmt|;
name|inner_elt_type
operator|=
name|strip_array_types
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|&&
operator|(
name|from_array
operator|==
literal|2
condition|?
operator|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|inner_elt_type
argument_list|)
operator|||
operator|!
name|TYPE_HAS_COMPLEX_ASSIGN_REF
argument_list|(
name|inner_elt_type
argument_list|)
operator|)
else|:
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
comment|/* Don't do this if the CONSTRUCTOR might contain something 	      that might throw and require us to clean up.  */
operator|&&
operator|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|||
operator|!
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|inner_elt_type
argument_list|)
operator|)
operator|)
operator|||
name|from_array
operator|)
condition|)
block|{
comment|/* Do non-default initialization of POD arrays resulting from 	 brace-enclosed initializers.  In this case, digest_init and 	 store_constructor will handle the semantics for us.  */
name|stmt_expr
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|atype
argument_list|,
name|base
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
name|maxindex
operator|=
name|cp_convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|base
operator|=
name|cp_convert
argument_list|(
name|ptype
argument_list|,
name|decay_conversion
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The code we are generating looks like:      ({        T* t1 = (T*) base;        T* rval = t1;        ptrdiff_t iterator = maxindex;        try { 	 for (; iterator != -1; --iterator) { 	   ... initialize *t1 ... 	   ++t1; 	 }        } catch (...) { 	 ... destroy elements that were constructed ...        }        rval;      })       We can omit the try and catch blocks if we know that the      initialization will never throw an exception, or if the array      elements do not have destructors.  We can omit the loop completely if      the elements of the array do not have constructors.       We actually wrap the entire body of the above in a STMT_EXPR, for      tidiness.       When copying from array to another, when the array elements have      only trivial copy constructors, we should use __builtin_memcpy      rather than generating a loop.  That way, we could take advantage      of whatever cleverness the back-end has for dealing with copies      of blocks of memory.  */
name|is_global
operator|=
name|begin_init_stmts
argument_list|(
operator|&
name|stmt_expr
argument_list|,
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
name|destroy_temps
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|get_temp_regvar
argument_list|(
name|ptype
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_temp_regvar
argument_list|(
name|ptype
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
comment|/* Protect the entire array initialization so that we can destroy      the partially constructed array if an exception is thrown.      But don't do this if we're assigning.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|from_array
operator|!=
literal|2
condition|)
block|{
name|try_block
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* Do non-default initialization of non-POD arrays resulting from 	 brace-enclosed initializers.  */
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|elt
decl_stmt|;
name|from_array
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (init)
argument_list|,
argument|idx
argument_list|,
argument|elt
argument_list|)
block|{
name|tree
name|baseref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|num_initialized_elts
operator|++
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|finish_expr_stmt
argument_list|(
name|build_aggr_init
argument_list|(
name|baseref
argument_list|,
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|baseref
argument_list|,
name|NOP_EXPR
argument_list|,
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|iterator
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear out INIT so that we don't get confused below.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_array
condition|)
block|{
comment|/* If initializing one array from another, initialize element by 	 element.  We rely upon the below calls the do argument 	 checking.  */
if|if
condition|(
name|init
condition|)
block|{
name|base2
operator|=
name|decay_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|base2
argument_list|)
expr_stmt|;
name|base2
operator|=
name|get_temp_regvar
argument_list|(
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer ends prematurely"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Now, default-initialize any remaining elements.  We don't need to      do that if a) the type does not need constructing, or b) we've      already initialized all the elements.       We do need to keep going if we're copying an array.  */
if|if
condition|(
name|from_array
operator|||
operator|(
operator|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|explicit_default_init_p
operator|)
operator|&&
operator|!
operator|(
name|host_integerp
argument_list|(
name|maxindex
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|num_initialized_elts
operator|==
name|tree_low_cst
argument_list|(
name|maxindex
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* If the ITERATOR is equal to -1, then we don't have to loop; 	 we've already initialized all the elements.  */
name|tree
name|for_stmt
decl_stmt|;
name|tree
name|elt_init
decl_stmt|;
name|tree
name|to
decl_stmt|;
name|for_stmt
operator|=
name|begin_for_stmt
argument_list|()
expr_stmt|;
name|finish_for_init_stmt
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iterator
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|iterator
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|for_stmt
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|iterator
argument_list|,
literal|0
argument_list|)
argument_list|,
name|for_stmt
argument_list|)
expr_stmt|;
name|to
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_array
condition|)
block|{
name|tree
name|from
decl_stmt|;
if|if
condition|(
name|base2
condition|)
name|from
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
else|else
name|from
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|from_array
operator|==
literal|2
condition|)
name|elt_init
operator|=
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|elt_init
operator|=
name|build_aggr_init
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from
condition|)
name|elt_init
operator|=
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|init
operator|!=
literal|0
condition|)
name|sorry
argument_list|(
literal|"cannot initialize multi-dimensional array with initializer"
argument_list|)
expr_stmt|;
name|elt_init
operator|=
name|build_vec_init
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/*explicit_default_init_p=*/
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|elt_init
operator|=
operator|(
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|INIT_EXPR
argument_list|,
name|build_zero_init
argument_list|(
name|type
argument_list|,
name|size_one_node
argument_list|,
comment|/*static_storage_p=*/
name|false
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|elt_init
operator|=
name|build_aggr_init
argument_list|(
name|to
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|1
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|elt_init
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
literal|0
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|finish_expr_stmt
argument_list|(
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|base2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|finish_for_stmt
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure to cleanup any partially constructed elements.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|from_array
operator|!=
literal|2
condition|)
block|{
name|tree
name|e
decl_stmt|;
name|tree
name|m
init|=
name|cp_build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|iterator
argument_list|)
decl_stmt|;
comment|/* Flatten multi-dimensional array since build_vec_delete only 	 expects one-dimensional array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|m
operator|=
name|cp_build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|m
argument_list|,
name|array_type_nelts_total
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|finish_cleanup_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
name|e
operator|=
name|build_vec_delete_1
argument_list|(
name|rval
argument_list|,
name|m
argument_list|,
name|inner_elt_type
argument_list|,
name|sfk_base_destructor
argument_list|,
comment|/*use_global_delete=*/
literal|0
argument_list|)
expr_stmt|;
name|finish_cleanup
argument_list|(
name|e
argument_list|,
name|try_block
argument_list|)
expr_stmt|;
block|}
comment|/* The value of the array initialization is the array itself, RVAL      is a pointer to the first element.  */
name|finish_stmt_expr_expr
argument_list|(
name|rval
argument_list|,
name|stmt_expr
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|finish_init_stmts
argument_list|(
name|is_global
argument_list|,
name|stmt_expr
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
comment|/* Now convert make the result have the correct type.  */
name|atype
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|atype
argument_list|,
name|stmt_expr
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|build_indirect_ref
argument_list|(
name|stmt_expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|destroy_temps
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
end_function

begin_comment
comment|/* Call the DTOR_KIND destructor for EXP.  FLAGS are as for    build_delete.  */
end_comment

begin_function
specifier|static
name|tree
name|build_dtor_call
parameter_list|(
name|tree
name|exp
parameter_list|,
name|special_function_kind
name|dtor_kind
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|fn
decl_stmt|;
switch|switch
condition|(
name|dtor_kind
condition|)
block|{
case|case
name|sfk_complete_destructor
case|:
name|name
operator|=
name|complete_dtor_identifier
expr_stmt|;
break|break;
case|case
name|sfk_base_destructor
case|:
name|name
operator|=
name|base_dtor_identifier
expr_stmt|;
break|break;
case|case
name|sfk_deleting_destructor
case|:
name|name
operator|=
name|deleting_dtor_identifier
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fn
operator|=
name|lookup_fnfields
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|2
argument_list|)
expr_stmt|;
return|return
name|build_new_method_call
argument_list|(
name|exp
argument_list|,
name|fn
argument_list|,
comment|/*args=*/
name|NULL_TREE
argument_list|,
comment|/*conversion_path=*/
name|NULL_TREE
argument_list|,
name|flags
argument_list|,
comment|/*fn_p=*/
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a call to a destructor. TYPE is the type to cast ADDR to.    ADDR is an expression which yields the store to be destroyed.    AUTO_DELETE is the name of the destructor to call, i.e., either    sfk_complete_destructor, sfk_base_destructor, or    sfk_deleting_destructor.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.  */
end_comment

begin_function
name|tree
name|build_delete
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|addr
parameter_list|,
name|special_function_kind
name|auto_delete
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|use_global_delete
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Can happen when CURRENT_EXCEPTION_OBJECT gets its type      set to `error_mark_node' before it gets properly cleaned up.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|bool
name|complete_p
init|=
name|true
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
goto|goto
name|handle_array
goto|;
comment|/* We don't want to warn about delete of void*, only other 	  incomplete types.  Deleting other incomplete types 	  invokes undefined behavior, but it is not ill-formed, so 	  compile to something that would even do The Right Thing 	  (TM) should the type have a trivial dtor and no delete 	  operator.  */
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"possible problem detected in invocation of "
literal|"delete operator:"
argument_list|)
expr_stmt|;
name|cxx_incomplete_type_diagnostic
argument_list|(
name|addr
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"neither the destructor nor the class-specific "
literal|"operator delete will be called, even if they are "
literal|"declared when the class is defined."
argument_list|)
expr_stmt|;
name|complete_p
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|complete_p
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Call the builtin operator delete.  */
return|return
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
return|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Throw away const and volatile on target type of addr.  */
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|handle_array
label|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"unknown array size in delete"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete
argument_list|(
name|addr
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|auto_delete
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Don't check PROTECT here; leave that decision to the 	 destructor.  If the destructor is accessible, call it, 	 else report error.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|auto_delete
operator|!=
name|sfk_deleting_destructor
condition|)
return|return
name|void_zero_node
return|;
return|return
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|addr
argument_list|,
name|cxx_sizeof_nowarn
argument_list|(
name|type
argument_list|)
argument_list|,
name|use_global_delete
argument_list|,
comment|/*placement=*/
name|NULL_TREE
argument_list|,
comment|/*alloc_fn=*/
name|NULL_TREE
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|do_delete
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ifexp
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_LAZY_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_destructor
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* For `::delete x', we must not use the deleting destructor 	 since then we would not be sure to get the global `operator 	 delete'.  */
if|if
condition|(
name|use_global_delete
operator|&&
name|auto_delete
operator|==
name|sfk_deleting_destructor
condition|)
block|{
comment|/* We will use ADDR multiple times so we must save it.  */
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Delete the object.  */
name|do_delete
operator|=
name|build_builtin_delete_call
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Otherwise, treat this like a complete object destructor 	     call.  */
name|auto_delete
operator|=
name|sfk_complete_destructor
expr_stmt|;
block|}
comment|/* If the destructor is non-virtual, there is no deleting 	 variant.  Instead, we must explicitly call the appropriate 	 `operator delete' here.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|auto_delete
operator|==
name|sfk_deleting_destructor
condition|)
block|{
comment|/* We will use ADDR multiple times so we must save it.  */
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Build the call.  */
name|do_delete
operator|=
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|addr
argument_list|,
name|cxx_sizeof_nowarn
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*global_p=*/
name|false
argument_list|,
comment|/*placement=*/
name|NULL_TREE
argument_list|,
comment|/*alloc_fn=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Call the complete object destructor.  */
name|auto_delete
operator|=
name|sfk_complete_destructor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auto_delete
operator|==
name|sfk_deleting_destructor
operator|&&
name|TYPE_GETS_REG_DELETE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Make sure we have access to the member op delete, even though 	     we'll actually be calling it from the destructor.  */
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|addr
argument_list|,
name|cxx_sizeof_nowarn
argument_list|(
name|type
argument_list|)
argument_list|,
comment|/*global_p=*/
name|false
argument_list|,
comment|/*placement=*/
name|NULL_TREE
argument_list|,
comment|/*alloc_fn=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_dtor_call
argument_list|(
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|auto_delete
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_delete
condition|)
name|expr
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|,
name|do_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
condition|)
comment|/* Explicit destructor call; don't check for null pointer.  */
name|ifexp
operator|=
name|integer_one_node
expr_stmt|;
else|else
comment|/* Handle deleting a null pointer.  */
name|ifexp
operator|=
name|fold
argument_list|(
name|cp_build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifexp
operator|!=
name|integer_one_node
condition|)
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
block|}
end_function

begin_comment
comment|/* At the beginning of a destructor, push cleanups that will call the    destructors for our base classes and members.     Called from begin_destructor_body.  */
end_comment

begin_function
name|void
name|push_base_cleanups
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vbases
expr_stmt|;
comment|/* Run destructors for all virtual baseclasses.  */
if|if
condition|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|cond
init|=
operator|(
name|condition_conversion
argument_list|(
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|current_in_charge_parm
argument_list|,
name|integer_two_node
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* The CLASSTYPE_VBASECLASSES vector is in initialization 	 order, which is also the right order for pushing cleanups.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vbases
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|expr
operator|=
name|build_special_member_call
argument_list|(
name|current_class_ref
argument_list|,
name|base_dtor_identifier
argument_list|,
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
operator|(
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Take care of the remaining baseclasses.  */
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|expr
operator|=
name|build_special_member_call
argument_list|(
name|current_class_ref
argument_list|,
name|base_dtor_identifier
argument_list|,
name|NULL_TREE
argument_list|,
name|base_binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
expr_stmt|;
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_member
init|=
operator|(
name|build_class_member_access_expr
argument_list|(
name|current_class_ref
argument_list|,
name|member
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
operator|)
decl_stmt|;
name|tree
name|this_type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|this_type
argument_list|,
name|this_member
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
operator||
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Build a C++ vector delete expression.    MAXINDEX is the number of elements to be deleted.    ELT_SIZE is the nominal size of each element in the vector.    BASE is the expression that should yield the store to be deleted.    This function expands (or synthesizes) these calls itself.    AUTO_DELETE_VEC says whether the container (vector) should be deallocated.     This also calls delete for virtual baseclasses of elements of the vector.     Update: MAXINDEX is no longer needed.  The size can be extracted from the    start of the vector for pointers, and from the type for arrays.  We still    use MAXINDEX for arrays because it happens to already have one of the    values we'd have to extract.  (We could use MAXINDEX with pointers to    confirm the size, and trap if the numbers differ; not clear that it'd    be worth bothering.)  */
end_comment

begin_function
name|tree
name|build_vec_delete
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|maxindex
parameter_list|,
name|special_function_kind
name|auto_delete_vec
parameter_list|,
name|int
name|use_global_delete
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|tree
name|base_init
init|=
name|NULL_TREE
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Step back one from start of vector, and read dimension.  */
name|tree
name|cookie_addr
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|base_init
operator|=
name|get_target_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|base_init
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cookie_addr
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|base
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
name|maxindex
operator|=
name|build_indirect_ref
argument_list|(
name|cookie_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Get the total number of things in the array, maxindex is a 	 bad name.  */
name|maxindex
operator|=
name|array_type_nelts_total
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|base_init
operator|=
name|get_target_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|TARGET_EXPR_SLOT
argument_list|(
name|base_init
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|base
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"type to vector delete is neither pointer or array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rval
operator|=
name|build_vec_delete_1
argument_list|(
name|base
argument_list|,
name|maxindex
argument_list|,
name|type
argument_list|,
name|auto_delete_vec
argument_list|,
name|use_global_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_init
condition|)
name|rval
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|base_init
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

end_unit

