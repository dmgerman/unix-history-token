begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle initialization things in C++.    Copyright (C) 1987, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* In C++, structures with well-defined constructors are initialized by    those constructors, unasked.  CURRENT_BASE_INIT_LIST    holds a list of stmts for a BASE_INIT term in the grammar.    This list has one element for each base class which must be    initialized.  The list elements are [basename, init], with    type basetype.  This allows the possibly anachronistic form    (assuming d : a, b, c) "d (int a) : c(a+5), b (a-4), a (a+3)"    where each successive term can be handed down the constructor    line.  Perhaps this was not intended.  */
end_comment

begin_decl_stmt
name|tree
name|current_base_init_list
decl_stmt|,
name|current_member_init_list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|emit_base_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|check_base_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_aggr_vbase_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|expand_member_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|expand_aggr_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_recursive_init_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_recursive_init
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|expand_virtual_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|tree
name|expand_vec_init
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|add_friend
argument_list|()
decl_stmt|,
name|add_friends
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache _builtin_new and _builtin_delete exprs.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BIN
decl_stmt|,
name|BID
decl_stmt|,
name|BIVN
decl_stmt|,
name|BIVD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache the identifier nodes for the two magic field of a new cookie.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|nc_nelts_field_id
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static tree nc_ptr_2comp_field_id;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|minus_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up local variable for this file.  MUST BE CALLED AFTER    INIT_DECL_PROCESSING.  */
end_comment

begin_decl_stmt
name|tree
name|BI_header_type
decl_stmt|,
name|BI_header_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_init_processing
parameter_list|()
block|{
name|tree
name|fields
index|[
literal|1
index|]
decl_stmt|;
comment|/* Define implicit `operator new' and `operator delete' functions.  */
name|BIN
operator|=
name|default_conversion
argument_list|(
name|get_first_fn
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|BIN
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BID
operator|=
name|default_conversion
argument_list|(
name|get_first_fn
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|BID
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BIVN
operator|=
name|default_conversion
argument_list|(
name|get_first_fn
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|BIVN
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BIVD
operator|=
name|default_conversion
argument_list|(
name|get_first_fn
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|BIVD
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|minus_one
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Define the structure that holds header information for      arrays allocated via operator new.  */
name|BI_header_type
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|nc_nelts_field_id
operator|=
name|get_identifier
argument_list|(
literal|"nelts"
argument_list|)
expr_stmt|;
name|fields
index|[
literal|0
index|]
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|nc_nelts_field_id
argument_list|,
name|sizetype
argument_list|)
expr_stmt|;
name|finish_builtin_type
argument_list|(
name|BI_header_type
argument_list|,
literal|"__new_cookie"
argument_list|,
name|fields
argument_list|,
literal|0
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|BI_header_size
operator|=
name|size_in_bytes
argument_list|(
name|BI_header_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of emit_base_init.  For BINFO, initialize all the    virtual function table pointers, except those that come from    virtual base classes.  Initialize binfo's vtable pointer, if    INIT_SELF is true.  CAN_ELIDE is true when we know that all virtual    function table pointers in all bases have been initialized already,    probably because their constructors have just be run.  ADDR is the    pointer to the object whos vtables we are going to initialize.     REAL_BINFO is usually the same as BINFO, except when addr is not of    pointer to the type of the real derived type that we want to    initialize for.  This is the case when addr is a pointer to a sub    object of a complete object, and we only want to do part of the    complete object's initialization of vtable pointers.  This is done    for all virtual table pointers in virtual base classes.  REAL_BINFO    is used to find the BINFO_VTABLE that we initialize with.  BINFO is    used for conversions of addr to subobjects.     BINFO_TYPE (real_binfo) must be BINFO_TYPE (binfo).     Relies upon binfo being inside TYPE_BINFO (TREE_TYPE (TREE_TYPE    (addr))).  */
end_comment

begin_function
name|void
name|expand_direct_vtbls_init
parameter_list|(
name|real_binfo
parameter_list|,
name|binfo
parameter_list|,
name|init_self
parameter_list|,
name|can_elide
parameter_list|,
name|addr
parameter_list|)
name|tree
name|real_binfo
decl_stmt|,
name|binfo
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|init_self
decl_stmt|,
name|can_elide
decl_stmt|;
block|{
name|tree
name|real_binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|real_binfo
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|real_binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|real_binfos
argument_list|)
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baselinks
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|real_base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|real_binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_not_base_vtable
init|=
name|i
operator|!=
name|CLASSTYPE_VFIELD_PARENT
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|real_base_binfo
argument_list|)
condition|)
name|expand_direct_vtbls_init
argument_list|(
name|real_base_binfo
argument_list|,
name|base_binfo
argument_list|,
name|is_not_base_vtable
argument_list|,
name|can_elide
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Before turning this on, make sure it is correct.  */
block|if (can_elide&& ! BINFO_MODIFIED (binfo))     return;
endif|#
directive|endif
comment|/* Should we use something besides CLASSTYPE_VFIELDS? */
if|if
condition|(
name|init_self
operator|&&
name|CLASSTYPE_VFIELDS
argument_list|(
name|BINFO_TYPE
argument_list|(
name|real_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|base_ptr
init|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|expand_virtual_init
argument_list|(
name|real_binfo
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 348 - 351 */
end_comment

begin_comment
comment|/* Subroutine of emit_base_init.  */
end_comment

begin_function
specifier|static
name|void
name|perform_member_init
parameter_list|(
name|member
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|,
name|explicit
parameter_list|,
name|protect_list
parameter_list|)
name|tree
name|member
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|protect_list
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|explicit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|init
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
comment|/* Since `init' is already a TREE_LIST on the current_member_init_list, 	 only build it into one if we aren't already a list.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Initialization of one array from another.  */
name|expand_vec_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decl
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|explicit
condition|)
block|{
name|cp_error
argument_list|(
literal|"incomplete initializer for member `%D' of class `%T' which has no constructor"
argument_list|,
name|member
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* member traversal: note it leaves init NULL */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|cp_pedwarn
argument_list|(
literal|"uninitialized reference member `%D'"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* There was an explicit member initialization.  Do some 	     work in that case.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"initializer list treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
comment|/* We only build this with a null init if we got it from the 	 current_member_init_list.  */
if|if
condition|(
name|init
operator|||
name|explicit
condition|)
block|{
name|decl
operator|=
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|explicit
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|expr
init|=
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|explicit
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|error_mark_node
condition|)
block|{
name|start_protect
argument_list|()
expr_stmt|;
operator|*
name|protect_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
operator|*
name|protect_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|warn_reorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine of emit_member_init.  */
end_comment

begin_function
specifier|static
name|tree
name|sort_member_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|,
name|member
decl_stmt|,
name|name
decl_stmt|,
name|field
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|init_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fields_to_unmark
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|last_pos
init|=
literal|0
decl_stmt|;
name|tree
name|last_field
decl_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
name|int
name|pos
decl_stmt|;
comment|/* member could be, for example, a CONST_DECL for an enumerated 	 tag; we don't want to try to initialize that, since it already 	 has a value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_NAME
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|current_member_init_list
operator|,
name|pos
operator|=
literal|0
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|,
operator|++
name|pos
control|)
block|{
comment|/* If we cleared this out, then pay no attention to it.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|field = (TREE_CODE (name) == COMPONENT_REF 		   ? TREE_OPERAND (name, 1) : IDENTIFIER_CLASS_VALUE (name));
else|#
directive|else
comment|/* Let's find out when this happens.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|COMPONENT_REF
argument_list|,
literal|348
argument_list|)
expr_stmt|;
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If one member shadows another, get the outermost one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|member
condition|)
block|{
if|if
condition|(
name|warn_reorder
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|last_pos
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"member initializers for `%#D'"
argument_list|,
name|last_field
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  and `%#D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will be re-ordered to match declaration order"
argument_list|)
expr_stmt|;
block|}
name|last_pos
operator|=
name|pos
expr_stmt|;
name|last_field
operator|=
name|field
expr_stmt|;
block|}
comment|/* Make sure we won't try to work on this init again.  */
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|x
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
comment|/* If we didn't find MEMBER in the list, create a dummy entry 	 so the two lists (INIT_LIST and the list of members) will be 	 symmetrical.  */
name|x
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|got_it
label|:
name|init_list
operator|=
name|chainon
argument_list|(
name|init_list
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Initializers for base members go at the end.  */
for|for
control|(
name|x
operator|=
name|current_member_init_list
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|init_list
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"multiple initializations given for member `%D'"
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|init_list
operator|=
name|chainon
argument_list|(
name|init_list
argument_list|,
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
return|return
name|init_list
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_base_init
parameter_list|(
name|t
parameter_list|,
name|rbase_ptr
parameter_list|,
name|vbase_ptr
parameter_list|)
name|tree
name|t
decl_stmt|,
decl|*
name|rbase_ptr
decl_stmt|,
modifier|*
name|vbase_ptr
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|x
decl_stmt|;
name|tree
name|last
decl_stmt|;
comment|/* For warn_reorder.  */
name|int
name|last_pos
init|=
literal|0
decl_stmt|;
name|tree
name|last_base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|rbases
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vbases
init|=
name|NULL_TREE
decl_stmt|;
comment|/* First walk through and splice out vbase and invalid initializers.      Also replace names with binfos.  */
name|last
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|basename
init|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Initializer for single base class.  Must not 	     use multiple inheritance or this is ambiguous.  */
switch|switch
condition|(
name|n_baseclasses
condition|)
block|{
case|case
literal|0
case|:
name|cp_error
argument_list|(
literal|"`%T' does not have a base class to initialize"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
break|break;
default|default:
name|cp_error
argument_list|(
literal|"unnamed initializer ambiguous for `%T' which uses multiple inheritance"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_aggr_typedef
argument_list|(
name|basename
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|binfo_or_else
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basename
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
continue|continue;
comment|/* Virtual base classes are special cases.  Their initializers 	     are recorded with this constructor, and they are used when 	     this constructor is the top-level constructor called.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|tree
name|v
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|BINFO_TYPE
argument_list|(
name|v
argument_list|)
operator|!=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
condition|)
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|tree_cons
argument_list|(
name|v
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
name|vbases
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Otherwise, if it is not an immediate base class, complain.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is not an immediate base class of `%T'"
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|basename
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|365
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|binfo
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|x
expr_stmt|;
name|last
operator|=
name|x
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Now walk through our regular bases and make sure they're initialized.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|current_base_init_list
operator|,
name|pos
operator|=
literal|0
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|,
operator|++
name|pos
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|binfo
operator|==
name|base_binfo
condition|)
block|{
if|if
condition|(
name|warn_reorder
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|last_pos
condition|)
block|{
name|cp_warning_at
argument_list|(
literal|"base initializers for `%#T'"
argument_list|,
name|last_base
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  and `%#T'"
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  will be re-ordered to match inheritance order"
argument_list|)
expr_stmt|;
block|}
name|last_pos
operator|=
name|pos
expr_stmt|;
name|last_base
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we won't try to work on this init again.  */
name|TREE_PURPOSE
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|x
operator|=
name|build_tree_list
argument_list|(
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
comment|/* If we didn't find BASE_BINFO in the list, create a dummy entry 	 so the two lists (RBASES and the list of bases) will be 	 symmetrical.  */
name|x
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|got_it
label|:
name|rbases
operator|=
name|chainon
argument_list|(
name|rbases
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
operator|*
name|rbase_ptr
operator|=
name|rbases
expr_stmt|;
operator|*
name|vbase_ptr
operator|=
name|vbases
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Perform partial cleanups for a base for exception handling.  */
end_comment

begin_function
specifier|static
name|tree
name|build_partial_cleanup_for
parameter_list|(
name|binfo
parameter_list|)
name|tree
name|binfo
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|C_C_D
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform whatever initializations have yet to be done on the base    class of the class variable.  These actions are in the global    variable CURRENT_BASE_INIT_LIST.  Such an action could be    NULL_TREE, meaning that the user has explicitly called the base    class constructor with no arguments.     If there is a need for a call to a constructor, we must surround    that call with a pushlevel/poplevel pair, since we are technically    at the PARM level of scope.     Argument IMMEDIATELY, if zero, forces a new sequence to be    generated to contain these new insns, so it can be emitted later.    This sequence is saved in the global variable BASE_INIT_EXPR.    Otherwise, the insns are emitted into the current sequence.     Note that emit_base_init does *not* initialize virtual base    classes.  That is done specially, elsewhere.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|base_init_expr
decl_stmt|,
name|rtl_expr_chain
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|emit_base_init
parameter_list|(
name|t
parameter_list|,
name|immediately
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|immediately
decl_stmt|;
block|{
specifier|extern
name|tree
name|in_charge_identifier
decl_stmt|;
name|tree
name|member
decl_stmt|,
name|x
decl_stmt|;
name|tree
name|mem_init_list
decl_stmt|;
name|tree
name|rbase_init_list
decl_stmt|,
name|vbase_init_list
decl_stmt|;
name|tree
name|t_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|t_binfo
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|protect_list
operator|==
name|NULL_TREE
argument_list|,
literal|999
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|immediately
condition|)
block|{
name|int
name|momentary
decl_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Make the RTL_EXPR node temporary, not momentary, 	 so that rtl_expr_chain doesn't become garbage.  */
name|momentary
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
name|expr
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|momentary
argument_list|)
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* Always emit a line number note so we can step into constructors.  */
name|emit_line_note_force
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|mem_init_list
operator|=
name|sort_member_init
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|sort_base_init
argument_list|(
name|t
argument_list|,
operator|&
name|rbase_init_list
argument_list|,
operator|&
name|vbase_init_list
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|first_arg
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|expand_start_cond
argument_list|(
name|first_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_vbase_init
argument_list|(
name|t_binfo
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
name|vbase_init_list
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* Now, perform initialization of non-virtual base classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base
init|=
name|current_class_decl
decl_stmt|;
name|tree
name|base_binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|void_list_node
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* Once unsharing happens soon enough.  */
block|my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo);
else|#
directive|else
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|base_binfo
argument_list|)
operator|=
name|t_binfo
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|rbase_init_list
argument_list|)
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|rbase_init_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|void_list_node
condition|)
block|{
name|member
operator|=
name|convert_pointer_to_real
argument_list|(
name|base_binfo
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|base_binfo
argument_list|,
literal|0
argument_list|,
name|build_indirect_ref
argument_list|(
name|member
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|init
argument_list|,
name|BINFO_OFFSET_ZEROP
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|start_protect
argument_list|()
expr_stmt|;
name|protect_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_partial_cleanup_for
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|protect_list
argument_list|)
expr_stmt|;
block|}
name|rbase_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|rbase_init_list
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize all the virtual function table fields that      do come from virtual base classes. */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|expand_indirect_vtbls_init
argument_list|(
name|t_binfo
argument_list|,
name|C_C_D
argument_list|,
name|current_class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize all the virtual function table fields that      do not come from virtual base classes.  */
name|expand_direct_vtbls_init
argument_list|(
name|t_binfo
argument_list|,
name|t_binfo
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
name|tree
name|init
decl_stmt|,
name|name
decl_stmt|;
name|int
name|from_init_list
decl_stmt|;
comment|/* member could be, for example, a CONST_DECL for an enumerated 	 tag; we don't want to try to initialize that, since it already 	 has a value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_NAME
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
comment|/* See if we had a user-specified member initialization.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
condition|)
block|{
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|from_init_list
operator|=
literal|1
expr_stmt|;
comment|/* Also see if it's ever a COMPONENT_REF here.  If it is, we 	     need to do `expand_assignment (name, init, 0, 0);' and 	     a continue.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|COMPONENT_REF
argument_list|,
literal|349
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|from_init_list
operator|=
literal|0
expr_stmt|;
block|}
name|perform_member_init
argument_list|(
name|member
argument_list|,
name|name
argument_list|,
name|init
argument_list|,
name|from_init_list
argument_list|,
operator|&
name|protect_list
argument_list|)
expr_stmt|;
name|mem_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
block|}
comment|/* Now initialize any members from our bases.  */
while|while
condition|(
name|mem_init_list
condition|)
block|{
name|tree
name|name
decl_stmt|,
name|init
decl_stmt|,
name|field
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
condition|)
block|{
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
comment|/* XXX: this may need the COMPONENT_REF operand 0 check if 	     it turns out we actually get them.  */
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* If one member shadows another, get the outermost one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_type_context
argument_list|(
name|field
argument_list|)
operator|!=
name|current_class_type
condition|)
name|cp_error
argument_list|(
literal|"field `%D' not in immediate context"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* It turns out if you have an anonymous union in the 	     class, a member from it can end up not being on the 	     list of fields (rather, the type is), and therefore 	     won't be seen by the for loop above.  */
comment|/* The code in this for loop is derived from a general loop 	     which had this check in it.  Theoretically, we've hit 	     every initialization for the list of members in T, so 	     we shouldn't have anything but these left in this list.  */
block|my_friendly_assert (DECL_FIELD_CONTEXT (field) != t, 351);
endif|#
directive|endif
name|perform_member_init
argument_list|(
name|field
argument_list|,
name|name
argument_list|,
name|init
argument_list|,
literal|1
argument_list|,
operator|&
name|protect_list
argument_list|)
expr_stmt|;
block|}
name|mem_init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|mem_init_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|immediately
condition|)
block|{
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|base_init_expr
operator|==
literal|0
argument_list|,
literal|207
argument_list|)
expr_stmt|;
name|base_init_expr
operator|=
name|expr
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|expr
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|expr
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|rtl_expr_chain
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|rtl_expr_chain
argument_list|)
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* All the implicit try blocks we built up will be zapped      when we come to a real binding contour boundary.  */
block|}
end_function

begin_comment
comment|/* Check that all fields are properly initialized after    an assignment to `this'.  */
end_comment

begin_function
name|void
name|check_base_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|member
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|member
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"field `%D' used before initialized (after assignment to `this')"
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This code sets up the virtual function tables appropriate for    the pointer DECL.  It is a one-ply initialization.     BINFO is the exact type that DECL is supposed to be.  In    multiple inheritance, this might mean "C's A" if C : A, B.  */
end_comment

begin_function
specifier|static
name|void
name|expand_virtual_init
parameter_list|(
name|binfo
parameter_list|,
name|decl
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|tree
name|vtbl
decl_stmt|,
name|vtbl_ptr
decl_stmt|;
name|tree
name|vtype
decl_stmt|,
name|vtype_binfo
decl_stmt|;
comment|/* This code is crusty.  Should be simple, like:      vtbl = BINFO_VTABLE (binfo);      */
name|vtype
operator|=
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|vtype_binfo
operator|=
name|get_binfo
argument_list|(
name|vtype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vtbl
operator|=
name|BINFO_VTABLE
argument_list|(
name|binfo_value
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vtbl
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl
argument_list|)
argument_list|)
argument_list|,
name|vtbl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|convert_pointer_to_real
argument_list|(
name|vtype_binfo
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|vtbl_ptr
operator|=
name|build_vfield_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtbl_ptr
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Have to convert VTBL since array sizes may be different.  */
name|vtbl
operator|=
name|convert_force
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtbl_ptr
argument_list|)
argument_list|,
name|vtbl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|vtbl_ptr
argument_list|,
name|NOP_EXPR
argument_list|,
name|vtbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of `expand_aggr_vbase_init'.    BINFO is the binfo of the type that is being initialized.    INIT_LIST is the list of initializers for the virtual baseclass.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_vbase_init_1
parameter_list|(
name|binfo
parameter_list|,
name|exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|exp
decl_stmt|,
name|addr
decl_stmt|,
name|init_list
decl_stmt|;
block|{
name|tree
name|init
init|=
name|purpose_member
argument_list|(
name|binfo
argument_list|,
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Call constructors, but don't set up vtables.  */
name|expand_aggr_init_1
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|ref
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
name|expand_cleanups_to
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize this object's virtual base class pointers.  This must be    done only at the top-level of the object being constructed.     INIT_LIST is list of initialization for constructor to perform.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_vbase_init
parameter_list|(
name|binfo
parameter_list|,
name|exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|tree
name|addr
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
block|{
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|result
init|=
name|init_vbase_pointers
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|tree
name|vbases
decl_stmt|;
if|if
condition|(
name|result
condition|)
name|expand_expr_stmt
argument_list|(
name|build_compound_expr
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|tmp
init|=
name|purpose_member
argument_list|(
name|vbases
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|expand_aggr_vbase_init_1
argument_list|(
name|vbases
argument_list|,
name|exp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine to perform parser actions for member initialization.    S_ID is the scoped identifier.    NAME is the name of the member.    INIT is the initializer, or `void_type_node' if none.  */
end_comment

begin_function
name|void
name|do_member_init
parameter_list|(
name|s_id
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|)
name|tree
name|s_id
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|binfo
decl_stmt|,
name|base
decl_stmt|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|s_id
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|binfo
operator|=
name|get_binfo
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|s_id
argument_list|)
argument_list|,
name|current_class_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|s_id
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|base
operator|=
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|expand_member_init
argument_list|(
name|build_indirect_ref
argument_list|(
name|base
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to give error message if member initialization specification    is erroneous.  FIELD is the member we decided to initialize.    TYPE is the type for which the initialization is being performed.    FIELD must be a member of TYPE, or the base type from which FIELD    comes must not need a constructor.        MEMBER_NAME is the name of the member.  */
end_comment

begin_function
specifier|static
name|int
name|member_init_ok_or_else
parameter_list|(
name|field
parameter_list|,
name|type
parameter_list|,
name|member_name
parameter_list|)
name|tree
name|field
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|member_name
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"class `%T' does not have any field named `%s'"
argument_list|,
name|type
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|type
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"initialization of `%D' inside constructor for `%T'"
argument_list|,
name|field
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"member `%D' comes from base class needing constructor"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"field `%#D' is static; only point of initialization is its declaration"
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If NAME is a viable field name for the aggregate DECL,    and PARMS is a viable parameter list, then expand an _EXPR    which describes this initialization.     Note that we do not need to chase through the class's base classes    to look for NAME, because if it's in that list, it will be handled    by the constructor for that base class.     We do not yet have a fixed-point finder to instantiate types    being fed to overloaded constructors.  If there is a unique    constructor, then argument types can be got from that one.     If INIT is non-NULL, then it the initialization should    be placed in `current_base_init_list', where it will be processed    by `emit_base_init'.  */
end_comment

begin_function
name|void
name|expand_member_init
parameter_list|(
name|exp
parameter_list|,
name|name
parameter_list|,
name|init
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|name
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|extern
name|tree
name|ptr_type_node
decl_stmt|;
comment|/* should be in tree.h */
name|tree
name|basetype
init|=
name|NULL_TREE
decl_stmt|,
name|field
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|actual_name
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* complain about this later */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
switch|switch
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"base class initializer specified, but no base class to initialize"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"initializer for unnamed base class ambiguous"
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"(type `%T' uses multiple inheritance)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
condition|)
block|{
comment|/* The grammar should not allow fields which have names 	 that are TYPENAMEs.  Therefore, if the field has 	 a non-NULL TREE_TYPE, we may assume that this is an 	 attempt to initialize a base class member of the current 	 type.  Otherwise, it is an attempt to initialize a 	 member field.  */
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
operator|||
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|base_init
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* 	      if (basetype) 		name = TYPE_IDENTIFIER (basetype); 	      else 		{ 		  error ("no base class to initialize"); 		  return; 		} */
block|}
else|else
block|{
name|basetype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|!=
name|type
operator|&&
operator|!
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|binfo_member
argument_list|(
name|basetype
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
condition|)
goto|goto
name|try_member
goto|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"type `%s' is not an immediate or virtual basetype for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type `%s' is not an immediate basetype for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|current_base_init_list
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"base class `%s' already initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|base_init
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_init
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|current_base_init_list
operator|=
name|chainon
argument_list|(
name|current_base_init_list
argument_list|,
name|base_init
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|member_init
decl_stmt|;
name|try_member
label|:
name|field
operator|=
name|lookup_field
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|current_member_init_list
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' already initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|member_init
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|member_init
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|chainon
argument_list|(
name|current_member_init_list
argument_list|,
name|member_init
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
block|{
name|compiler_error
argument_list|(
literal|"expand_member_init: name == NULL_TREE"
argument_list|)
expr_stmt|;
return|return;
block|}
name|basetype
operator|=
name|type
expr_stmt|;
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|member_init_ok_or_else
argument_list|(
name|field
argument_list|,
name|basetype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* now see if there is a constructor for this type      which will take these args. */
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|parmtypes
decl_stmt|,
name|fndecl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* just know that we've seen something for this node */
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|actual_name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now get to the constructor.  */
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get past destructor, if any.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
condition|)
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|209
argument_list|)
expr_stmt|;
comment|/* If the field is unique, we can use the parameter 	 types to guide possible type instantiation.  */
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* There was a confusion here between 	     FIELD and FNDECL.  The following code 	     should be correct, but abort is here 	     to make sure.  */
name|my_friendly_abort
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parmtypes
operator|=
name|NULL_TREE
expr_stmt|;
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|init
operator|=
name|convert_arguments
argument_list|(
name|parm
argument_list|,
name|parmtypes
argument_list|,
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|rval
operator|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|actual_name
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Now, fill in the first parm with our guy */
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|ptr_type_node
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|parm
operator|=
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Now initialize the member.  It does not have to      be of aggregate type to receive initialization.  */
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is like `expand_member_init', only it stores one aggregate    value into another.     INIT comes in two flavors: it is either a value which    is to be stored in EXP, or it is a parameter list    to go to a constructor, which will operate on EXP.    If INIT is not a parameter list for a constructor, then set    LOOKUP_ONLYCONVERTING.    If FLAGS is LOOKUP_ONLYCONVERTING then it is the = init form of    the initializer, if FLAGS is 0, then it is the (init) form.    If `init' is a CONSTRUCTOR, then we emit a warning message,    explaining that such initializations are invalid.     ALIAS_THIS is nonzero iff we are initializing something which is    essentially an alias for C_C_D.  In this case, the base constructor    may move it on us, and we must keep track of such deviations.     If INIT resolves to a CALL_EXPR which happens to return    something of the type we are looking for, then we know    that we can safely use that call to perform the    initialization.     The virtual function table pointer cannot be set up here, because    we do not really know its type.     Virtual baseclass pointers are also set up here.     This never calls operator=().     When initializing, nothing is CONST.     A default copy constructor may have to be used to perform the    initialization.     A constructor or a conversion operator may have to be used to    perform the initialization, but not both, as it would be ambiguous.    */
end_comment

begin_function
name|void
name|expand_aggr_init
parameter_list|(
name|exp
parameter_list|,
name|init
parameter_list|,
name|alias_this
parameter_list|,
name|flags
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|init
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_const
init|=
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|int
name|was_volatile
init|=
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|flags
operator||=
name|LOOKUP_ONLYCONVERTING
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Must arrange to initialize each element of EXP 	 from elements of INIT.  */
name|tree
name|itype
init|=
name|init
condition|?
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Handle bad initializers like: 	     class COMPLEX { 	     public: 	       double re, im; 	       COMPLEX(double r = 0.0, double i = 0.0) {re = r; im = i;}; 	       ~COMPLEX() {}; 	     };  	     int main(int argc, char **argv) { 	       COMPLEX zees(1.0, 0.0)[10]; 	     } 	  */
name|error
argument_list|(
literal|"bad array initializer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|expand_vec_init
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
name|init
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|itype
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARM_DECL
condition|)
comment|/* just know that we've seen something for this node */
name|TREE_USED
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If initializing from a GNU C CONSTRUCTOR, consider the elts in the      constructor as parameters to an implicit GNU C++ constructor.  */
block|if (init&& TREE_CODE (init) == CONSTRUCTOR&& TYPE_HAS_CONSTRUCTOR (type)&& TREE_TYPE (init) == type)     init = CONSTRUCTOR_ELTS (init);
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expand_aggr_init_1
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|alias_this
argument_list|,
name|LOOKUP_NORMAL
operator||
name|flags
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|=
name|was_const
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|=
name|was_volatile
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_default_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|alias_this
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* It fails because there may not be a constructor which takes      its own type as the first (or only parameter), but which does      take other types via a conversion.  So, if the thing initializing      the expression is a unit element of type X, first try X(X&),      followed by initialization by X.  If neither of these work      out, then look hard.  */
name|tree
name|rval
decl_stmt|;
name|tree
name|parms
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|)
condition|)
block|{
name|parms
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|parms
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
name|rval
operator|=
name|convert_for_initialization
argument_list|(
name|exp
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|true_exp
operator|==
name|exp
condition|)
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
else|else
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
name|rval
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_ONLYCONVERTING
condition|)
name|flags
operator||=
name|LOOKUP_NO_CONVERSION
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name_full
argument_list|(
name|type
argument_list|)
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Private, protected, or otherwise unavailable.  */
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|cp_error
argument_list|(
literal|"in base initialization for %sclass `%T'"
argument_list|,
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|?
literal|"virtual base "
else|:
literal|""
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rval
operator|==
name|NULL_TREE
condition|)
name|my_friendly_abort
argument_list|(
literal|361
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* p. 222: if the base class assigns to `this', then that 	     value is used in the derived class.  */
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|&&
name|alias_this
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|current_class_decl
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr_stmt
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function is responsible for initializing EXP with INIT    (if any).     BINFO is the binfo of the type for who we are performing the    initialization.  For example, if W is a virtual base class of A and B,    and C : A, B.    If we are initializing B, then W must contain B's W vtable, whereas    were we initializing C, W must contain C's W vtable.     TRUE_EXP is nonzero if it is the true expression being initialized.    In this case, it may be EXP, or may just contain EXP.  The reason we    need this is because if EXP is a base element of TRUE_EXP, we    don't necessarily know by looking at EXP where its virtual    baseclass fields should really be pointing.  But we do know    from TRUE_EXP.  In constructors, we don't know anything about    the value being initialized.     ALIAS_THIS serves the same purpose it serves for expand_aggr_init.     FLAGS is just passes to `build_method_call'.  See that function for    its description.  */
end_comment

begin_function
specifier|static
name|void
name|expand_aggr_init_1
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|alias_this
parameter_list|,
name|flags
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|true_exp
decl_stmt|,
name|exp
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|init_type
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|init
operator|!=
name|error_mark_node
operator|&&
name|type
operator|!=
name|error_mark_node
argument_list|,
literal|211
argument_list|)
expr_stmt|;
comment|/* Use a function returning the desired type to initialize EXP for us.      If the function is a constructor, and its first argument is      NULL_TREE, know that it was meant for us--just slide exp on      in and expand the constructor.  Constructors now come      as TARGET_EXPRs.  */
if|if
condition|(
name|init
condition|)
block|{
name|tree
name|init_list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|init_list
operator|=
name|init
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|init_type
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|#
directive|if
literal|0
comment|/* These lines are found troublesome 5/11/89.  */
block|if (TREE_CODE (init_type) == REFERENCE_TYPE) 	    init_type = TREE_TYPE (init_type);
endif|#
directive|endif
comment|/* This happens when we use C++'s functional cast notation. 	     If the types match, then just use the TARGET_EXPR 	     directly.  Otherwise, we need to create the initializer 	     separately from the object being initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|init_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|RESULT_DECL
condition|)
comment|/* Unify the initialization targets.  */
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|init_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|init_list
condition|)
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
block|}
if|if
condition|(
name|init_type
operator|==
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CALL_EXPR
if|#
directive|if
literal|0
comment|/* It is valid to directly initialize from a CALL_EXPR 		 without going through X(X&), apparently.  */
condition|&& ! TYPE_GETS_INIT_REF (type)
endif|#
directive|endif
condition|)
block|{
comment|/* A CALL_EXPR is a legitimate form of initialization, so 		 we should not print this warning message.  */
if|#
directive|if
literal|0
comment|/* Should have gone away due to 5/11/89 change.  */
block|if (TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE) 		init = convert_from_reference (init);
endif|#
directive|endif
name|expand_assignment
argument_list|(
name|exp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
comment|/* Failing this assertion means that the return value 		     from receives multiple initializations.  */
name|my_friendly_assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|==
name|error_mark_node
argument_list|,
literal|212
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|init_type
operator|==
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* Push value to be initialized into the cond, where possible. 	         Avoid spurious warning messages when initializing the 		 result of this function.  */
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
operator|=
name|build_modify_expr
argument_list|(
name|exp
argument_list|,
name|INIT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
operator|=
name|build_modify_expr
argument_list|(
name|exp
argument_list|,
name|INIT_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|init
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* We did not know what we were initializing before.  Now we do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
block|{
name|tree
name|tmp
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|integer_zero_node
condition|)
block|{
comment|/* In order for this to work for RESULT_DECLs, if their 		 type has a constructor, then they must be BLKmode 		 so that they will be meaningfully addressable.  */
name|tree
name|arg
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias_this
condition|)
block|{
name|expand_assignment
argument_list|(
name|current_function_decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp
operator|==
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"return value from function receives multiple initializations"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
operator|=
name|init
expr_stmt|;
block|}
name|expand_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|init
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|store_init_value
argument_list|(
name|exp
argument_list|,
name|init
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|expand_decl_init
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|exp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle this case: when calling a constructor: xyzzy foo(bar); 	 which really means:  xyzzy foo = bar; Ugh!  	 More useful for this case: xyzzy *foo = new xyzzy (bar);  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|init_list
operator|&&
name|TREE_CHAIN
argument_list|(
name|init_list
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|build_compound_expr
argument_list|(
name|init_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return;
block|}
name|expand_assignment
argument_list|(
name|exp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See whether we can go through a type conversion operator. 	 This wins over going through a non-existent constructor.  If 	 there is a constructor, it is ambiguous.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
name|tree
name|ttype
init|=
name|TREE_CODE
argument_list|(
name|init_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|init_type
argument_list|)
else|:
name|init_type
decl_stmt|;
if|if
condition|(
name|ttype
operator|!=
name|type
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttype
argument_list|)
condition|)
block|{
name|tree
name|rval
init|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
comment|/* See if there is a constructor for``type'' that takes a 		     ``ttype''-typed object. */
name|tree
name|parms
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
decl_stmt|;
name|tree
name|as_cons
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|as_cons
operator|=
name|build_method_call
argument_list|(
name|exp
argument_list|,
name|constructor_name_full
argument_list|(
name|type
argument_list|)
argument_list|,
name|parms
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_NO_CONVERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|as_cons
operator|!=
name|NULL_TREE
operator|&&
name|as_cons
operator|!=
name|error_mark_node
condition|)
comment|/* ANSI C++ June 5 1992 WP 12.3.2.6.1 */
name|cp_error
argument_list|(
literal|"ambiguity between conversion to `%T' and constructor"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|expand_assignment
argument_list|(
name|exp
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/* Handle default copy constructors here, does not matter if there is      a constructor or not.  */
if|if
condition|(
name|type
operator|==
name|init_type
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|alias_this
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Not sure why this is here... */
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|expand_default_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|alias_this
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|expand_vec_init
argument_list|(
name|exp
argument_list|,
name|exp
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"arrays of objects with virtual functions but no constructors"
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_recursive_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|exp
argument_list|,
name|init
argument_list|,
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A pointer which holds the initializer.  First call to    expand_aggr_init gets this value pointed to, and sets it to init_null.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|init_ptr
decl_stmt|,
name|init_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine of expand_recursive_init:     ADDR is the address of the expression being initialized.    INIT_LIST is the cons-list of initializations to be performed.    ALIAS_THIS is its same, lovable self.  */
end_comment

begin_function
specifier|static
name|void
name|expand_recursive_init_1
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|addr
parameter_list|,
name|init_list
parameter_list|,
name|alias_this
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|true_exp
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
while|while
condition|(
name|init_list
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|member
init|=
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
decl_stmt|;
name|tree
name|subexp
init|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|tree
name|member_base
init|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|subexp
argument_list|,
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|member_base
argument_list|,
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|member_base
operator|=
name|save_expr
argument_list|(
name|default_conversion
argument_list|(
name|member_base
argument_list|)
argument_list|)
expr_stmt|;
name|expand_vec_init
argument_list|(
name|member
argument_list|,
name|member_base
argument_list|,
name|array_type_nelts
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|member_base
argument_list|,
name|INIT_EXPR
argument_list|,
name|DECL_INITIAL
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|expand_recursive_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
name|expand_recursive_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
comment|/* Only initialize the virtual function tables if we 		 are initializing the ultimate users of those vtables.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
condition|)
block|{
comment|/* We have to ensure that the first argment to 		     expand_virtual_init is in binfo's hierarchy.  */
comment|/* Is it the case that this is exactly the right binfo? */
comment|/* If it is ok, then fixup expand_virtual_init, to make 		     it much simpler. */
name|expand_virtual_init
argument_list|(
name|get_binfo
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|binfo
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
operator|==
name|binfo
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
name|expand_indirect_vtbls_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|49
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|tree
name|subexp
init|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|,
name|addr
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|expand_aggr_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|subexp
argument_list|,
operator|*
name|init_ptr
argument_list|,
name|alias_this
operator|&&
name|BINFO_OFFSET_ZEROP
argument_list|(
name|TREE_VALUE
argument_list|(
name|init_list
argument_list|)
argument_list|)
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
comment|/* INIT_PTR is used up.  */
name|init_ptr
operator|=
operator|&
name|init_null
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|init_list
operator|=
name|TREE_CHAIN
argument_list|(
name|init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize EXP with INIT.  Type EXP does not have a constructor,    but it has a baseclass with a constructor or a virtual function    table which needs initializing.     INIT_LIST is a cons-list describing what parts of EXP actually    need to be initialized.  INIT is given to the *unique*, first    constructor within INIT_LIST.  If there are multiple first    constructors, such as with multiple inheritance, INIT must    be zero or an ambiguity error is reported.     ALIAS_THIS is passed from `expand_aggr_init'.  See comments    there.  */
end_comment

begin_function
specifier|static
name|void
name|expand_recursive_init
parameter_list|(
name|binfo
parameter_list|,
name|true_exp
parameter_list|,
name|exp
parameter_list|,
name|init
parameter_list|,
name|init_list
parameter_list|,
name|alias_this
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|true_exp
decl_stmt|,
name|exp
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|init_list
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
name|tree
modifier|*
name|old_init_ptr
init|=
name|init_ptr
decl_stmt|;
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|init_ptr
operator|=
operator|&
name|init
expr_stmt|;
if|if
condition|(
name|true_exp
operator|==
name|exp
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
condition|)
block|{
name|expand_aggr_vbase_init
argument_list|(
name|binfo
argument_list|,
name|exp
argument_list|,
name|addr
argument_list|,
name|init_list
argument_list|)
expr_stmt|;
name|expand_indirect_vtbls_init
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|expand_recursive_init_1
argument_list|(
name|binfo
argument_list|,
name|true_exp
argument_list|,
name|addr
argument_list|,
name|init_list
argument_list|,
name|alias_this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|init_ptr
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"unexpected argument to constructor `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unexpected argument to constructor"
argument_list|)
expr_stmt|;
block|}
name|init_ptr
operator|=
name|old_init_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an error if NAME is not the name of a user-defined,    aggregate type.  If OR_ELSE is nonzero, give an error message.  */
end_comment

begin_function
name|int
name|is_aggr_typedef
parameter_list|(
name|name
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not an aggregate typedef"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not an aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like is_aggr_typedef, but returns typedef if successful.  */
end_comment

begin_function
name|tree
name|get_aggr_from_typedef
parameter_list|(
name|name
parameter_list|,
name|or_else
parameter_list|)
name|tree
name|name
decl_stmt|;
name|int
name|or_else
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"`%T' fails to be an aggregate typedef"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
condition|)
block|{
if|if
condition|(
name|or_else
condition|)
name|cp_error
argument_list|(
literal|"type `%T' is of non-aggregate type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|get_type_value
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This code could just as well go in `class.c', but is placed here for    modularity.  */
end_comment

begin_comment
comment|/* For an expression of the form CNAME :: NAME (PARMLIST), build    the appropriate function call.  */
end_comment

begin_function
name|tree
name|build_member_call
parameter_list|(
name|cname
parameter_list|,
name|name
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|name
decl_stmt|,
name|parmlist
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|method_name
init|=
name|name
decl_stmt|;
name|int
name|dtor
init|=
literal|0
decl_stmt|;
name|int
name|dont_use_this
init|=
literal|0
decl_stmt|;
name|tree
name|basetype_path
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|method_name
operator|=
name|TREE_OPERAND
argument_list|(
name|method_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtor
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|cname
operator|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|cname
argument_list|)
expr_stmt|;
comment|/* This shouldn't be here, and build_member_call shouldn't appear in      parse.y!  (mrs)  */
if|if
condition|(
name|cname
operator|&&
name|get_aggr_from_typedef
argument_list|(
name|cname
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|ns
init|=
name|lookup_name
argument_list|(
name|cname
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|&&
name|TREE_CODE
argument_list|(
name|ns
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
return|return
name|build_x_function_call
argument_list|(
name|build_offset_ref
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|current_class_decl
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
operator|||
operator|!
operator|(
name|type
operator|=
name|get_aggr_from_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* An operator we did not like.  */
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|dtor
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Everything can explicitly call a destructor; see 12.4 */
block|if (! TYPE_HAS_DESTRUCTOR (type)) 	cp_error ("type `%#T' does not have a destructor", type);       else
endif|#
directive|endif
name|cp_error
argument_list|(
literal|"cannot call destructor `%T::~%T' without object"
argument_list|,
name|type
argument_list|,
name|method_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* No object?  Then just fake one up, and let build_method_call      figure out what to do.  */
if|if
condition|(
name|current_class_type
operator|==
literal|0
operator|||
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|basetype_path
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dont_use_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dont_use_this
condition|)
block|{
name|basetype_path
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_class_decl
operator|==
literal|0
condition|)
block|{
name|dont_use_this
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|olddecl
init|=
name|current_class_decl
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldtype
operator|!=
name|type
condition|)
block|{
name|tree
name|newtype
init|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
decl_stmt|;
name|decl
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|olddecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|olddecl
expr_stmt|;
block|}
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_name
operator|==
name|constructor_name
argument_list|(
name|type
argument_list|)
operator|||
name|method_name
operator|==
name|constructor_name_full
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|parmlist
argument_list|)
return|;
if|if
condition|(
name|t
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|method_name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|method_name
argument_list|,
name|parmlist
argument_list|,
name|basetype_path
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
operator|(
name|t
operator|=
name|lookup_field
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|dont_use_this
condition|)
block|{
name|cp_error
argument_list|(
literal|"invalid use of non-static field `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|decl
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|decl
operator|=
name|t
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"invalid use of member `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|decl
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|build_function_call
argument_list|(
name|decl
argument_list|,
name|parmlist
argument_list|)
return|;
block|}
else|else
block|{
name|cp_error
argument_list|(
literal|"no method `%T::%D'"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build a reference to a member of an aggregate.  This is not a    C++ `&', but really something which can have its address taken,    and then act as a pointer to member, for example CNAME :: FIELD    can have its address taken by saying& CNAME :: FIELD.     @@ Prints out lousy diagnostics for operator<typename>    @@ fields.     @@ This function should be rewritten and placed in search.c.  */
end_comment

begin_function
name|tree
name|build_offset_ref
parameter_list|(
name|cname
parameter_list|,
name|name
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|fnfields
decl_stmt|,
name|fields
decl_stmt|,
name|t
init|=
name|error_mark_node
decl_stmt|;
name|tree
name|basetypes
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|dtor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|cname
operator|=
name|resolve_scope_to_name
argument_list|(
name|NULL_TREE
argument_list|,
name|cname
argument_list|)
expr_stmt|;
comment|/* Handle namespace names fully here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|get_aggr_from_typedef
argument_list|(
name|cname
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|ns
init|=
name|lookup_name
argument_list|(
name|cname
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|ns
operator|&&
name|TREE_CODE
argument_list|(
name|ns
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|val
operator|=
name|lookup_namespace_name
argument_list|(
name|ns
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|cp_error
argument_list|(
literal|"namespace `%D' has no member named `%D'"
argument_list|,
name|ns
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|cname
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|dtor
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"incomplete type `%T' does not have member `%D'"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|sorry
argument_list|(
literal|"use of member in incomplete aggregate type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|sorry
argument_list|(
literal|"use of member function in incomplete aggregate type"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|52
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|#
directive|if
literal|0
block|if (TREE_CODE (name) == TYPE_EXPR)
comment|/* Pass a TYPE_DECL to build_component_type_expr.  */
block|return build_component_type_expr (TYPE_NAME (TREE_TYPE (cname)), 				      name, NULL_TREE, 1);
endif|#
directive|endif
if|if
condition|(
name|current_class_type
operator|==
literal|0
operator|||
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|basetypes
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|basetypes
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_class_decl
operator|==
literal|0
condition|)
name|decl
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|C_C_D
expr_stmt|;
name|fnfields
operator|=
name|lookup_fnfields
argument_list|(
name|basetypes
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fields
operator|=
name|lookup_field
argument_list|(
name|basetypes
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|==
name|error_mark_node
operator|||
name|fnfields
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* A lot of this logic is now handled in lookup_field and      lookup_fnfield. */
if|if
condition|(
name|fnfields
condition|)
block|{
name|basetypes
operator|=
name|TREE_PURPOSE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
comment|/* Go from the TREE_BASELINK to the member function info.  */
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
condition|)
block|{
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
operator|==
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous member reference: member `%s' defined as both field and function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|UNIQUELY_DERIVED_FROM_P
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|fields
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"ambiguous member reference: member `%s' derives from distinct classes in multiple inheritance lattice"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|flag_save_memoized_contexts
decl_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|dtor
condition|)
block|{
name|enum
name|access_type
name|access
decl_stmt|;
comment|/* unique functions are handled easily.  */
name|unique
label|:
name|access
operator|=
name|compute_access
argument_list|(
name|basetypes
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_protected
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member function `%#D' is protected"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|access
operator|==
name|access_private
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member function `%#D' is private"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|assemble_external
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
return|;
block|}
comment|/* overloaded functions may need more work.  */
if|if
condition|(
name|cname
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_CHAIN
argument_list|(
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|unique
goto|;
block|}
block|}
comment|/* FNFIELDS is most likely allocated on the search_obstack, 	     which will go away after this class scope.  If we need 	     to save this value for later (either for memoization 	     or for use as an initializer for a static variable), then 	     do so here.  	     ??? The smart thing to do for the case of saving initializers 	     is to resolve them before we're done with this scope.  */
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|fnfields
argument_list|)
operator|&&
operator|(
operator|(
name|flag_save_memoized_contexts
operator|&&
name|global_bindings_p
argument_list|()
operator|)
operator|||
operator|!
name|allocation_temporary_p
argument_list|()
operator|)
condition|)
name|fnfields
operator|=
name|copy_list
argument_list|(
name|fnfields
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fnfields
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|assemble_external
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|fnfields
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_offset_type
argument_list|(
name|type
argument_list|,
name|unknown_type_node
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/* Now that we know we are looking for a field, see if we      have access to that field.  Lookup_field will give us the      error message.  */
name|t
operator|=
name|lookup_field
argument_list|(
name|basetypes
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' is not a member of type `%T'"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* static class members and class-specific enum      values can be returned without further ado.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|assemble_external
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"illegal pointer to bit field `%D'"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* static class functions too.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|my_friendly_abort
argument_list|(
literal|53
argument_list|)
expr_stmt|;
comment|/* In member functions, the form `cname::name' is no longer      equivalent to `this->cname::name'.  */
return|return
name|build
argument_list|(
name|OFFSET_REF
argument_list|,
name|build_offset_type
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an object EXP and a member function reference MEMBER,    return the address of the actual member function.  */
end_comment

begin_function
name|tree
name|get_member_function
parameter_list|(
name|exp_addr_ptr
parameter_list|,
name|exp
parameter_list|,
name|member
parameter_list|)
name|tree
modifier|*
name|exp_addr_ptr
decl_stmt|;
name|tree
name|exp
decl_stmt|,
name|member
decl_stmt|;
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|function
init|=
name|save_expr
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|flag_all_virtual
operator|==
literal|1
operator|&&
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|ctype
argument_list|)
operator|)
condition|)
block|{
name|tree
name|e0
decl_stmt|,
name|e1
decl_stmt|,
name|e3
decl_stmt|;
name|tree
name|exp_addr
decl_stmt|;
comment|/* Save away the unadulterated `this' pointer.  */
name|exp_addr
operator|=
name|save_expr
argument_list|(
operator|*
name|exp_addr_ptr
argument_list|)
expr_stmt|;
comment|/* Cast function to signed integer.  */
name|e0
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* There is a hack here that takes advantage of 	 twos complement arithmetic, and the fact that 	 there are more than one UNITS to the WORD. 	 If the high bit is set for the `function', 	 then we pretend it is a virtual function, 	 and the array indexing will knock this bit 	 out the top, leaving a valid index.  */
if|if
condition|(
name|UNITS_PER_WORD
operator|<=
literal|1
condition|)
name|my_friendly_abort
argument_list|(
literal|54
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build
argument_list|(
name|GT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|e0
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|e1
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp_addr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|e1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|save_expr
argument_list|(
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|exp_addr_ptr
argument_list|)
condition|)
block|{
name|exp
operator|=
name|build_indirect_ref
argument_list|(
name|exp_addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
operator|*
name|exp_addr_ptr
operator|=
name|exp_addr
expr_stmt|;
block|}
comment|/* This is really hairy: if the function pointer is a pointer 	 to a non-virtual member function, then we can't go mucking 	 with the `this' pointer (any more than we already have to 	 this point).  If it is a pointer to a virtual member function, 	 then we have to adjust the `this' pointer according to 	 what the virtual function table tells us.  */
name|e3
operator|=
name|build_vfn_ref
argument_list|(
name|exp_addr_ptr
argument_list|,
name|exp
argument_list|,
name|e0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|e3
operator|!=
name|error_mark_node
argument_list|,
literal|213
argument_list|)
expr_stmt|;
comment|/* Change this pointer type from `void *' to the 	 type it is really supposed to be.  */
name|TREE_TYPE
argument_list|(
name|e3
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* If non-virtual, use what we had originally.  Otherwise, 	 use the value we get from the virtual function table.  */
operator|*
name|exp_addr_ptr
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|exp_addr
argument_list|,
operator|*
name|exp_addr_ptr
argument_list|)
expr_stmt|;
name|function
operator|=
name|build_conditional_expr
argument_list|(
name|e1
argument_list|,
name|function
argument_list|,
name|e3
argument_list|)
expr_stmt|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|function
argument_list|,
name|NULL_PTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If a OFFSET_REF made it through to here, then it did    not have its address taken.  */
end_comment

begin_function
name|tree
name|resolve_offset_ref
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
argument_list|,
literal|214
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|error
argument_list|(
literal|"object missing in use of pointer-to-member construct"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|member
operator|=
name|exp
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|C_C_D
expr_stmt|;
block|}
else|else
block|{
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* These were static members.  */
if|if
condition|(
name|mark_addressable
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|member
return|;
block|}
comment|/* Syntax error can cause a member which should      have been seen as static to be grok'd as non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|C_C_D
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|member
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member `%D' is non-static but referenced as a static member"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|member
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* The first case is really just a reference to a member of `this'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|base
operator|==
name|C_C_D
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
condition|)
block|{
name|tree
name|basetype_path
decl_stmt|;
name|enum
name|access_type
name|access
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|base
operator|=
name|current_class_decl
expr_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|basetype_path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|access
operator|=
name|compute_access
argument_list|(
name|basetype_path
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_public
condition|)
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|,
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|member
argument_list|)
return|;
if|if
condition|(
name|access
operator|==
name|access_protected
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member `%D' is protected"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|access
operator|==
name|access_private
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"member `%D' is private"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"in this context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|55
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a reference to a member function, then return      the address of the member function (which may involve going      through the object's vtable), otherwise, return an expression      for the dereferenced pointer-to-member construct.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|get_member_function
argument_list|(
operator|&
name|addr
argument_list|,
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|member
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|basetype
operator|=
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|member
operator|=
name|convert
argument_list|(
name|ptrdiff_type_node
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
name|member
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|addr
argument_list|,
name|member
argument_list|)
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|56
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
if|#
directive|if
literal|0
comment|/* These may be necessary for C, but they break C++.  */
expr|! TREE_PUBLIC (decl)
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  */
expr|&& ! pedantic
endif|#
directive|endif
comment|/* 0 */
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
if|#
directive|if
literal|0
comment|/* We must allow this to work outside of functions so that 	 static constants can be used for array sizes.  */
condition|&& current_function_decl != 0&& DECL_MODE (decl) != BLKmode
endif|#
directive|endif
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Friend handling routines.  */
end_comment

begin_comment
comment|/* Friend data structures:     Lists of friend functions come from TYPE_DECL nodes.  Since all    aggregate types are automatically typedef'd, these nodes are guaranteed    to exist.     The TREE_PURPOSE of a friend list is the name of the friend,    and its TREE_VALUE is another list.     For each element of that list, either the TREE_VALUE or the TREE_PURPOSE    will be filled in, but not both.  The TREE_VALUE of that list is an    individual function which is a friend.  The TREE_PURPOSE of that list    indicates a type in which all functions by that name are friends.     Lists of friend classes come from _TYPE nodes.  Love that consistency    thang.  */
end_comment

begin_function
name|int
name|is_friend_type
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
block|{
return|return
name|is_friend
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|is_friend
parameter_list|(
name|type
parameter_list|,
name|supplicant
parameter_list|)
name|tree
name|type
decl_stmt|,
name|supplicant
decl_stmt|;
block|{
name|int
name|declp
decl_stmt|;
specifier|register
name|tree
name|list
decl_stmt|;
if|if
condition|(
name|supplicant
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|declp
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|supplicant
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
if|if
condition|(
name|declp
condition|)
comment|/* It's a function decl.  */
block|{
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|supplicant
argument_list|)
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|ctype
operator|==
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|name
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
break|break;
block|}
block|}
block|}
else|else
comment|/* It's a type. */
block|{
if|if
condition|(
name|type
operator|==
name|supplicant
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
if|if
condition|(
name|supplicant
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
operator|!
name|declp
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|supplicant
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
condition|)
return|return
name|is_friend
argument_list|(
name|type
argument_list|,
name|context
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new friend to the friends of the aggregate type TYPE.    DECL is the FUNCTION_DECL of the friend being added.  */
end_comment

begin_function
specifier|static
name|void
name|add_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%D' is already a friend of class `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous friend declaration of `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parmtypes
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
condition|)
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Declare that every member function NAME in FRIEND_TYPE    (which may be NULL_TREE) is a friend of type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|add_friends
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
while|while
condition|(
name|friends
operator|&&
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
operator|!=
name|friend_type
condition|)
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
expr_stmt|;
if|if
condition|(
name|friends
condition|)
if|if
condition|(
name|friend_type
condition|)
name|warning
argument_list|(
literal|"method `%s::%s' is already a friend of class"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|friend_type
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"function `%s' is already a friend of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|typedecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|build_tree_list
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|sorry
argument_list|(
literal|"declaring \"friend operator =\" will not find \"operator = (X&)\" if it exists"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up a cross reference so that type TYPE will make member function    CTYPE::DECL a friend when CTYPE is finally defined.  For more than    one, set up a cross reference so that functions with the name DECL    and type CTYPE know that they are friends of TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|xref_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|,
name|ctype
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|,
name|ctype
decl_stmt|;
block|{
name|tree
name|friend_decl
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|tree typedecl = TYPE_NAME (type);   tree t = tree_cons (NULL_TREE, ctype, DECL_UNDEFINED_FRIENDS (typedecl));    DECL_UNDEFINED_FRIENDS (typedecl) = t;
else|#
directive|else
name|tree
name|t
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|SET_DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|,
name|tree_cons
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_WAITING_FRIENDS
argument_list|(
name|friend_decl
argument_list|)
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already    been defined, we make all of its member functions friends of    TYPE.  If not, we make it a pending friend, which can later be added    when its definition is seen.  If a type is defined, then its TYPE_DECL's    DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend    classes that are not defined.  If a type has not yet been defined,    then the DECL_WAITING_FRIENDS contains a list of types    waiting to make it their friend.  Note that these two can both    be in use at the same time!  */
end_comment

begin_function
name|void
name|make_friend_class
parameter_list|(
name|type
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|classes
decl_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`friend' declaration in signature definition"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"signature type `%s' declared `friend'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|friend_type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
name|friend_type
condition|)
block|{
name|pedwarn
argument_list|(
literal|"class `%s' is implicitly friends with itself"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|GNU_xref_hier
argument_list|(
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|friend_type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|classes
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|classes
operator|&&
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
operator|!=
name|friend_type
condition|)
name|classes
operator|=
name|TREE_CHAIN
argument_list|(
name|classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|classes
condition|)
name|warning
argument_list|(
literal|"class `%s' is already friends with class `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|friend_type
argument_list|,
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main friend processor.  This is large, and for modularity purposes,    has been removed from grokdeclarator.  It returns `void_type_node'    to indicate that something happened, though a FIELD_DECL is    not returned.     CTYPE is the class this friend belongs to.     DECLARATOR is the name of the friend.     DECL is the FUNCTION_DECL that the friend is.     In case we are parsing a friend which is part of an inline    definition, we will need to store PARM_DECL chain that comes    with it into the DECL_ARGUMENTS slot of the FUNCTION_DECL.     FLAGS is just used for `grokclassfn'.     QUALS say what special qualifies should apply to the object    pointed to by `this'.  */
end_comment

begin_function
name|tree
name|do_friend
parameter_list|(
name|ctype
parameter_list|,
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|parmdecls
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|declarator
decl_stmt|,
name|decl
decl_stmt|,
name|parmdecls
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|;
block|{
comment|/* Every decl that gets here is a friend of something.  */
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* A method friend.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|declarator
operator|==
name|cname
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This will set up DECL_ARGUMENTS for us.  */
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|!=
literal|0
condition|)
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* We don't call pushdecl here yet, or ever on this 		     actual FUNCTION_DECL.  We must preserve its TREE_CHAIN 		     until the end.  */
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|classname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"member declared as friend before type `%s' defined"
argument_list|,
name|classname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Possibly a bunch of method friends.  */
comment|/* Get the class they belong to.  */
name|tree
name|ctype
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
decl_stmt|;
comment|/* This class is defined, use its methods now.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
condition|)
name|add_friends
argument_list|(
name|current_class_type
argument_list|,
name|declarator
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"method `%s' is not a member of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Note: DECLARATOR actually has more than one; in this 	       case, we're making sure that fns with the name DECLARATOR 	       and type CTYPE know they are friends of the current 	       class type.  */
name|xref_friend
argument_list|(
name|current_class_type
argument_list|,
name|declarator
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* raw "main", and builtin functions never gets overloaded, 	 but they can become friends.  */
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
comment|/* A global friend.      @@ or possibly a friend from a base class ?!?  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Friends must all go through the overload machinery, 	 even though they may not technically be overloaded.  	 Note that because classes all wind up being top-level 	 in their scope, their friend wind up in top-level scope as well.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|declarator
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|parmdecls
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* We can call pushdecl here, because the TREE_CHAIN of this 	 FUNCTION_DECL is not needed for other purposes.  */
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|TREE_OVERLOADED (declarator) = 1;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* @@ Should be able to ingest later definitions of this function 	 before use.  */
name|tree
name|decl
init|=
name|lookup_name_nonclass
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"implicitly declaring `%s' as struct"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|xref_tag
argument_list|(
name|record_type_node
argument_list|,
name|declarator
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Allow abbreviated declarations of overloaded functions, 	 but not if those functions are really class names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`friend %s' archaic, use `friend class %s' instead"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|add_friends
argument_list|(
name|current_class_type
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* TYPE has now been defined.  It may, however, have a number of things    waiting make make it their friend.  We resolve these references    here.  */
end_comment

begin_function
name|void
name|embrace_waiting_friends
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|waiters
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return;
for|for
control|(
name|waiters
operator|=
name|DECL_WAITING_FRIENDS
argument_list|(
name|decl
argument_list|)
init|;
name|waiters
condition|;
name|waiters
operator|=
name|TREE_CHAIN
argument_list|(
name|waiters
argument_list|)
control|)
block|{
name|tree
name|waiter
init|=
name|TREE_PURPOSE
argument_list|(
name|waiters
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|tree waiter_prev = TREE_VALUE (waiters);
endif|#
directive|endif
name|tree
name|decl
init|=
name|TREE_TYPE
argument_list|(
name|waiters
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|decl
condition|?
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|?
name|decl
else|:
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* @@ There may be work to be done since we have not verified 	     @@ consistency between original and friend declarations 	     @@ of the functions waiting to become friends.  */
name|tree
name|field
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
condition|)
if|if
condition|(
name|decl
operator|==
name|name
condition|)
name|add_friends
argument_list|(
name|waiter
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|add_friend
argument_list|(
name|waiter
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|TYPE_NAME
argument_list|(
name|waiter
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|TYPE_NAME
argument_list|(
name|waiter
argument_list|)
argument_list|)
argument_list|,
literal|"no method `%s' defined in class `%s' to be friend"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|waiters
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|make_friend_class
argument_list|(
name|type
argument_list|,
name|waiter
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CHAIN (waiter_prev)) 	TREE_CHAIN (waiter_prev) = TREE_CHAIN (TREE_CHAIN (waiter_prev));       else 	DECL_UNDEFINED_FRIENDS (TYPE_NAME (waiter)) = NULL_TREE;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common subroutines of build_new and build_vec_delete.  */
end_comment

begin_comment
comment|/* Common interface for calling "builtin" functions that are not    really builtin.  */
end_comment

begin_function
name|tree
name|build_builtin_call
parameter_list|(
name|type
parameter_list|,
name|node
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|tree
name|rval
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|node
argument_list|,
name|arglist
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a C++ "new" expression. DECL is either a TREE_LIST    (which needs to go through some sort of groktypename) or it    is the name of the class we are newing. INIT is an initialization value.    It is either an EXPRLIST, an EXPR_NO_COMMAS, or something in braces.    If INIT is void_type_node, it means do *not* call a constructor    for this instance.     For types with constructors, the data returned is initialized    by the appropriate constructor.     Whether the type has a constructor or not, if it has a pointer    to a virtual function table, then that pointer is set up    here.     Unless I am mistaken, a call to new () will return initialized    data regardless of whether the constructor itself is private or    not.  NOPE; new fails if the constructor is private (jcm).     Note that build_new does nothing to assure that any special    alignment requirements of the type are met.  Rather, it leaves    it up to malloc to do the right thing.  Otherwise, folding to    the right alignment cal cause problems if the user tries to later    free the memory returned by `new'.     PLACEMENT is the `placement' list for user-defined operator new ().  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_check_new
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_new
parameter_list|(
name|placement
parameter_list|,
name|decl
parameter_list|,
name|init
parameter_list|,
name|use_global_new
parameter_list|)
name|tree
name|placement
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|int
name|use_global_new
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|,
name|true_type
decl_stmt|,
name|size
decl_stmt|,
name|rval
decl_stmt|;
name|tree
name|nelts
decl_stmt|;
name|tree
name|alloc_expr
decl_stmt|,
name|alloc_temp
decl_stmt|;
name|int
name|has_array
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|NEW_EXPR
decl_stmt|;
name|tree
name|pending_sizes
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|absdcl
init|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|last_absdcl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|old_immediate_size_expand
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|old_immediate_size_expand
operator|=
name|immediate_size_expand
expr_stmt|;
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
block|}
name|nelts
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|my_friendly_abort
argument_list|(
literal|215
argument_list|)
expr_stmt|;
while|while
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absdcl
operator|&&
name|TREE_CODE
argument_list|(
name|absdcl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
comment|/* probably meant to be a vec new */
name|tree
name|this_nelts
decl_stmt|;
while|while
condition|(
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|last_absdcl
operator|=
name|absdcl
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|has_array
operator|=
literal|1
expr_stmt|;
name|this_nelts
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|this_nelts
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"new of array type fails to specify size"
argument_list|)
expr_stmt|;
else|else
block|{
name|this_nelts
operator|=
name|save_expr
argument_list|(
name|convert
argument_list|(
name|sizetype
argument_list|,
name|this_nelts
argument_list|)
argument_list|)
expr_stmt|;
name|absdcl
operator|=
name|TREE_OPERAND
argument_list|(
name|absdcl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_nelts
operator|==
name|integer_zero_node
condition|)
block|{
name|warning
argument_list|(
literal|"zero size array reserves no space"
argument_list|)
expr_stmt|;
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
name|nelts
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nelts
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|last_absdcl
condition|)
name|TREE_OPERAND
argument_list|(
name|last_absdcl
argument_list|,
literal|0
argument_list|)
operator|=
name|absdcl
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|absdcl
expr_stmt|;
name|type
operator|=
name|true_type
operator|=
name|groktypename
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|pending_sizes
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_HAS_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* An aggregate type.  */
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A builtin type.  */
name|decl
operator|=
name|lookup_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|215
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|true_type
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|true_type
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|decl
expr_stmt|;
name|true_type
operator|=
name|type
expr_stmt|;
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* ``A reference cannot be created by the new operator.  A reference      is not an object (8.2.2, 8.4.3), so a pointer to it could not be      returned by new.'' ARM 5.3.3 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a reference type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|true_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"new cannot be applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* When the object being created is an array, the new-expression yields a      pointer to the initial element (if any) of the array.  For example,      both new int and new int[10] return an int*.  5.3.4.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|has_array
operator|==
literal|0
condition|)
block|{
name|nelts
operator|=
name|array_type_nelts_top
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|has_array
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|true_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If our base type is an array, then make sure we know how many elements      it has.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|true_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|this_nelts
init|=
name|array_type_nelts_top
argument_list|(
name|true_type
argument_list|)
decl_stmt|;
name|nelts
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|nelts
argument_list|,
name|this_nelts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|true_type
operator|=
name|TREE_TYPE
argument_list|(
name|true_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_array
condition|)
name|size
operator|=
name|fold
argument_list|(
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_in_bytes
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|nelts
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_type
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"invalid type `void' for new"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|true_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|true_type
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|abstract_virtuals_error
argument_list|(
name|NULL_TREE
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|true_type
argument_list|)
operator|&&
name|IS_SIGNATURE
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|signature_error
argument_list|(
name|NULL_TREE
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Get a little extra space to store a couple of things before the new'ed      array. */
if|if
condition|(
name|has_array
operator|&&
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|tree
name|extra
init|=
name|BI_header_size
decl_stmt|;
name|size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_array
condition|)
name|code
operator|=
name|VEC_NEW_EXPR
expr_stmt|;
comment|/* Allocate the object. */
if|if
condition|(
operator|!
name|use_global_new
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|true_type
argument_list|)
operator|&&
operator|(
name|TYPE_GETS_NEW
argument_list|(
name|true_type
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|has_array
operator|)
operator|)
condition|)
name|rval
operator|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|placement
condition|)
block|{
name|rval
operator|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_GLOBAL
operator||
name|LOOKUP_COMPLAIN
argument_list|,
name|ptr_type_node
argument_list|,
name|size
argument_list|,
name|placement
argument_list|)
expr_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|has_array
operator|&&
name|flag_this_is_variable
operator|>
literal|0
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|true_type
argument_list|)
operator|&&
name|init
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|rval
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"constructors take parameter lists"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|rval
operator|=
name|build_builtin_call
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|has_array
condition|?
name|BIVN
else|:
name|BIN
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* See comment above as to why this is disabled.  */
block|if (alignment) 	{ 	  rval = build (PLUS_EXPR, build_pointer_type (true_type), rval, 			alignment); 	  rval = build (BIT_AND_EXPR, build_pointer_type (true_type), 			rval, build1 (BIT_NOT_EXPR, integer_type_node, 				      alignment)); 	}
endif|#
directive|endif
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag_check_new
operator|&&
name|rval
condition|)
block|{
comment|/* For array new, we need to make sure that the call to new is 	 not expanded as part of the RTL_EXPR for the initialization, 	 so we can't just use save_expr here.  */
name|alloc_temp
operator|=
name|get_temp_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alloc_expr
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|alloc_temp
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|alloc_expr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|alloc_temp
expr_stmt|;
block|}
else|else
name|alloc_expr
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* if rval is NULL_TREE I don't have to allocate it, but are we totally      sure we have some extra bytes in that case for the BI_header_size      cookies? And how does that interact with the code below? (mrs) */
comment|/* Finish up some magic for new'ed arrays */
if|if
condition|(
name|has_array
operator|&&
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|true_type
argument_list|)
operator|&&
name|rval
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|extra
init|=
name|BI_header_size
decl_stmt|;
name|tree
name|cookie
decl_stmt|,
name|exp1
decl_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* convert to void * first */
name|rval
operator|=
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|rval
argument_list|)
expr_stmt|;
comment|/* lets not add void* and ints */
name|rval
operator|=
name|save_expr
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|rval
argument_list|,
name|extra
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store header info.  */
name|cookie
operator|=
name|build_indirect_ref
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|rval
argument_list|,
name|extra
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|exp1
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|nc_nelts_field_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|exp1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|exp1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Don't call any constructors or do any initialization.  */
if|if
condition|(
name|init
operator|==
name|void_type_node
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|||
name|init
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|has_array
condition|)
block|{
comment|/* New 2.0 interpretation: `new int (10)' means 	     allocate an int, and initialize it with 10.  */
name|tree
name|deref
decl_stmt|;
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|deref
operator|=
name|build_indirect_ref
argument_list|(
name|rval
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|deref
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"initializer list being treated as compound expression"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|pedwarn
argument_list|(
literal|"initializer list appears where operand should be used"
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|build_compound_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|convert_for_initialization
argument_list|(
name|deref
argument_list|,
name|type
argument_list|,
name|init
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|"new"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|deref
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|has_array
condition|)
block|{
name|tree
name|newrval
decl_stmt|;
comment|/* Constructors are never virtual. If it has an initialization, we 	     need to complain if we aren't allowed to use the ctor that took 	     that argument.  */
name|int
name|flags
init|=
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_COMPLAIN
decl_stmt|;
if|if
condition|(
name|rval
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|true_type
argument_list|)
condition|)
block|{
name|init
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
block|}
name|newrval
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|newrval
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrval
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|newrval
operator|=
name|build_indirect_ref
argument_list|(
name|newrval
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|newrval
operator|=
name|build_method_call
argument_list|(
name|newrval
argument_list|,
name|constructor_name_full
argument_list|(
name|true_type
argument_list|)
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrval
condition|)
block|{
name|rval
operator|=
name|newrval
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
specifier|extern
name|tree
name|static_aggregates
decl_stmt|;
comment|/* In case of static initialization, SAVE_EXPR is good enough.  */
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|copy_to_permanent
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|init
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|rval
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|nelts
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|copy_to_permanent
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|static_aggregates
operator|=
name|perm_tree_cons
argument_list|(
name|init
argument_list|,
name|rval
argument_list|,
name|static_aggregates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Have to wrap this in RTL_EXPR for two cases: 	     in base or member initialization and if we 	     are a branch of a ?: operator.  Since we 	     can't easily know the latter, just do it always.  */
name|tree
name|xval
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
comment|/* If we want to check the value of the allocation expression,              and the number of elements in the array is not a constant, we              *must* expand the SAVE_EXPR for nelts in alloc_expr before we              expand it in the actual initialization.  So we need to build up              an RTL_EXPR for alloc_expr.  Sigh.  */
if|if
condition|(
name|alloc_expr
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|nelts
argument_list|)
condition|)
block|{
name|tree
name|xval
init|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
decl_stmt|;
name|rtx
name|rtxval
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|xval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|alloc_expr
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|xval
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rtxval
operator|=
name|expand_expr
argument_list|(
name|alloc_expr
argument_list|,
name|NULL
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|xval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|xval
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|xval
argument_list|)
operator|=
name|rtxval
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|xval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|alloc_expr
argument_list|)
expr_stmt|;
name|alloc_expr
operator|=
name|xval
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|xval
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|start_sequence_for_rtl_expr
argument_list|(
name|xval
argument_list|)
expr_stmt|;
comment|/* As a matter of principle, `start_sequence' should do this.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|rval
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|nelts
argument_list|,
name|integer_one_node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|xval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|xval
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTL_EXPR_SEQUENCE
argument_list|(
name|xval
argument_list|)
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
block|{
comment|/* Errors may cause this to not get evaluated.  */
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|rval
argument_list|)
operator|==
literal|0
condition|)
name|SAVE_EXPR_RTL
argument_list|(
name|rval
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|xval
argument_list|)
operator|=
name|SAVE_EXPR_RTL
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|217
argument_list|)
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|xval
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|xval
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|true_type
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"uninitialized const in `new' of `%#T'"
argument_list|,
name|true_type
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|alloc_expr
condition|)
block|{
comment|/* Did we modify the storage?  */
if|if
condition|(
name|rval
operator|!=
name|alloc_temp
condition|)
block|{
name|tree
name|ifexp
init|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|alloc_expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build_conditional_expr
argument_list|(
name|ifexp
argument_list|,
name|rval
argument_list|,
name|alloc_temp
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|alloc_expr
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|&&
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|!=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The type of new int [3][3] is not int *, but int [3] * */
name|rval
operator|=
name|build_c_cast
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pending_sizes
condition|)
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|chainon
argument_list|(
name|pending_sizes
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gc
condition|)
block|{
specifier|extern
name|tree
name|gc_visible
decl_stmt|;
name|tree
name|objbits
decl_stmt|;
name|tree
name|update_expr
decl_stmt|;
name|rval
operator|=
name|save_expr
argument_list|(
name|rval
argument_list|)
expr_stmt|;
comment|/* We don't need a `headof' operation to do this because 	 we know where the object starts.  */
name|objbits
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|unsigned_type_node
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|rval
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|update_expr
operator|=
name|build_modify_expr
argument_list|(
name|objbits
argument_list|,
name|BIT_IOR_EXPR
argument_list|,
name|gc_visible
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|update_expr
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|build_vec_delete_1
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|type
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|auto_delete
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|auto_delete_vec
decl_stmt|,
name|auto_delete
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|virtual_size
decl_stmt|;
name|tree
name|ptype
init|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|size_exp
init|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Temporary variables used by the loop.  */
name|tree
name|tbase
decl_stmt|,
name|tbase_init
decl_stmt|;
comment|/* This is the body of the loop that implements the deletion of a      single element, and moves temp variables to next elements.  */
name|tree
name|body
decl_stmt|;
comment|/* This is the LOOP_EXPR that governs the deletion of the elements.  */
name|tree
name|loop
decl_stmt|;
comment|/* This is the thing that governs what to do after the loop has run.  */
name|tree
name|deallocate_expr
init|=
literal|0
decl_stmt|;
comment|/* This is the BIND_EXPR which holds the outermost iterator of the      loop.  It is convenient to set this variable up and test it before      executing any other code in the loop.      This is also the containing expression returned by this function.  */
name|tree
name|controller
init|=
name|NULL_TREE
decl_stmt|;
comment|/* This is the BLOCK to record the symbol binding for debugging.  */
name|tree
name|block
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|loop
operator|=
name|integer_zero_node
expr_stmt|;
goto|goto
name|no_destructor
goto|;
block|}
comment|/* The below is short by BI_header_size */
name|virtual_size
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
name|tbase
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|tbase_init
operator|=
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|base
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|tbase
argument_list|)
operator|=
literal|1
expr_stmt|;
name|controller
operator|=
name|build
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tbase
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|controller
argument_list|)
operator|=
literal|1
expr_stmt|;
name|block
operator|=
name|build_block
argument_list|(
name|tbase
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_block_current_level
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_delete
operator|!=
name|integer_zero_node
operator|&&
name|auto_delete
operator|!=
name|integer_two_node
condition|)
block|{
name|tree
name|base_tbd
init|=
name|convert
argument_list|(
name|ptype
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|ptr_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|BI_header_size
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This is the real size */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_x_delete
argument_list|(
name|ptype
argument_list|,
name|base_tbd
argument_list|,
literal|2
operator||
name|use_global_delete
argument_list|,
name|virtual_size
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|ptype
argument_list|,
name|tbase
argument_list|,
name|auto_delete
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|1
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_modify_expr
argument_list|(
name|tbase
argument_list|,
name|NOP_EXPR
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|ptype
argument_list|,
name|tbase
argument_list|,
name|size_exp
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build
argument_list|(
name|EXIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|tbase
argument_list|)
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build
argument_list|(
name|LOOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build_compound_expr
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tbase_init
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|=
name|build_compound_expr
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|no_destructor
label|:
comment|/* If the delete flag is one, or anything else with the low bit set,      delete the storage.  */
if|if
condition|(
name|auto_delete_vec
operator|==
name|integer_zero_node
operator|||
name|auto_delete_vec
operator|==
name|integer_two_node
condition|)
name|deallocate_expr
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|tree
name|base_tbd
decl_stmt|;
comment|/* The below is short by BI_header_size */
name|virtual_size
operator|=
name|fold
argument_list|(
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_exp
argument_list|,
name|maxindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VEC_NEW_USES_COOKIE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* no header */
name|base_tbd
operator|=
name|base
expr_stmt|;
else|else
block|{
name|base_tbd
operator|=
name|convert
argument_list|(
name|ptype
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|string_type_node
argument_list|,
name|base
argument_list|)
argument_list|,
name|BI_header_size
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* True size with header. */
name|virtual_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|virtual_size
argument_list|,
name|BI_header_size
argument_list|)
expr_stmt|;
block|}
name|deallocate_expr
operator|=
name|build_x_delete
argument_list|(
name|ptype
argument_list|,
name|base_tbd
argument_list|,
literal|2
operator||
name|use_global_delete
argument_list|,
name|virtual_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_delete_vec
operator|!=
name|integer_one_node
condition|)
name|deallocate_expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete_vec
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|deallocate_expr
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|&&
name|deallocate_expr
operator|!=
name|integer_zero_node
condition|)
block|{
name|body
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|deallocate_expr
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_compound_expr
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
else|else
name|body
operator|=
name|loop
expr_stmt|;
comment|/* Outermost wrapper: If pointer is null, punt.  */
name|body
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|body
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|body
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|controller
argument_list|,
literal|1
argument_list|)
operator|=
name|body
expr_stmt|;
return|return
name|controller
return|;
block|}
else|else
return|return
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|body
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a tree to cleanup partially built arrays.    BASE is that starting address of the array.    COUNT is the count of objects that have been built, that need destroying.    TYPE is the type of elements in the array.  */
end_comment

begin_function
specifier|static
name|tree
name|build_array_eh_cleanup
parameter_list|(
name|base
parameter_list|,
name|count
parameter_list|,
name|type
parameter_list|)
name|tree
name|base
decl_stmt|,
name|count
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|build_vec_delete_1
argument_list|(
name|base
argument_list|,
name|count
argument_list|,
name|type
argument_list|,
name|integer_two_node
argument_list|,
name|integer_zero_node
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* `expand_vec_init' performs initialization of a vector of aggregate    types.     DECL is passed only for error reporting, and provides line number    and source file name information.    BASE is the space where the vector will be.    MAXINDEX is the maximum index of the array (one less than the 	    number of elements).    INIT is the (possibly NULL) initializer.     FROM_ARRAY is 0 if we should init everything with INIT    (i.e., every element initialized from INIT).    FROM_ARRAY is 1 if we should index into INIT in parallel    with initialization of DECL.    FROM_ARRAY is 2 if we should index into INIT in parallel,    but use assignment instead of initialization.  */
end_comment

begin_function
name|tree
name|expand_vec_init
parameter_list|(
name|decl
parameter_list|,
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|init
parameter_list|,
name|from_array
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|init
decl_stmt|;
name|int
name|from_array
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|iterator
decl_stmt|,
name|base2
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|maxindex
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxindex
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|rval
operator|=
name|make_tree_vec
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
operator|=
name|base
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
operator|=
name|maxindex
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|rval
argument_list|,
literal|2
argument_list|)
operator|=
name|init
expr_stmt|;
return|return
name|rval
return|;
block|}
name|size
operator|=
name|size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Set to zero in case size is<= 0.  Optimizer will delete this if      it is not needed.  */
name|rval
operator|=
name|get_temp_regvar
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|default_conversion
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|rval
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_temp_regvar
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Initialization of array from {...}.  */
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
decl_stmt|;
name|tree
name|baseref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|baseinc
init|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int
name|host_i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|maxindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
while|while
condition|(
name|elts
condition|)
block|{
name|host_i
operator|-=
literal|1
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|baseref
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|baseinc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize any elements by default if possible.  */
if|if
condition|(
name|host_i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done_init
goto|;
block|}
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|integer_type_node
argument_list|,
name|build_int_2
argument_list|(
name|host_i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|init_by_default
goto|;
block|}
block|}
else|else
while|while
condition|(
name|elts
condition|)
block|{
name|expand_assignment
argument_list|(
name|baseref
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|baseinc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|itype
decl_stmt|;
name|iterator
operator|=
name|get_temp_regvar
argument_list|(
name|integer_type_node
argument_list|,
name|maxindex
argument_list|)
expr_stmt|;
name|init_by_default
label|:
comment|/* If initializing one array from another, 	 initialize element by element.  */
if|if
condition|(
name|from_array
condition|)
block|{
comment|/* We rely upon the below calls the do argument checking */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|sorry
argument_list|(
literal|"initialization of array from dissimilar array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|init
condition|)
block|{
name|base2
operator|=
name|default_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|base2
argument_list|)
expr_stmt|;
name|base2
operator|=
name|get_temp_regvar
argument_list|(
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"initializer ends prematurely"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|start_protect
argument_list|()
expr_stmt|;
name|expand_start_loop_continue_elsewhere
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_array
condition|)
block|{
name|tree
name|to
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|tree
name|from
decl_stmt|;
if|if
condition|(
name|base2
condition|)
name|from
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|itype
argument_list|,
name|base2
argument_list|)
expr_stmt|;
else|else
name|from
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|from_array
operator|==
literal|2
condition|)
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|to
argument_list|,
name|NOP_EXPR
argument_list|,
name|from
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from
condition|)
name|expand_assignment
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|57
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|init
operator|!=
literal|0
condition|)
name|sorry
argument_list|(
literal|"cannot initialize multi-dimensional array with initializer"
argument_list|)
expr_stmt|;
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|base
argument_list|)
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|expand_aggr_init
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|base
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_assignment
argument_list|(
name|base
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|expand_assignment
argument_list|(
name|base2
argument_list|,
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|base2
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_loop_continue_here
argument_list|()
expr_stmt|;
name|expand_exit_loop_if_false
argument_list|(
literal|0
argument_list|,
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|build
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|iterator
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|minus_one
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base2
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|base2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_end_loop
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|end_protect
argument_list|(
name|build_array_eh_cleanup
argument_list|(
name|rval
argument_list|,
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|iterator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|done_init
label|:
if|if
condition|(
name|obey_regdecls
condition|)
name|use_variable
argument_list|(
name|DECL_RTL
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Free up storage of type TYPE, at address ADDR.     TYPE is a POINTER_TYPE and can be ptr_type_node for no special type    of pointer.     VIRTUAL_SIZE is the amount of storage that was allocated, and is    used as the second argument to operator delete.  It can include    things like padding and magic size cookies.  It has virtual in it,    because if you have a base pointer and you delete through a virtual    destructor, it should be the size of the dynamic object, not the    static object, see Free Store 12.5 ANSI C++ WP.     This does not call any destructors.  */
end_comment

begin_function
name|tree
name|build_x_delete
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|,
name|which_delete
parameter_list|,
name|virtual_size
parameter_list|)
name|tree
name|type
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|which_delete
decl_stmt|;
name|tree
name|virtual_size
decl_stmt|;
block|{
name|int
name|use_global_delete
init|=
name|which_delete
operator|&
literal|1
decl_stmt|;
name|int
name|use_vec_delete
init|=
operator|!
operator|!
operator|(
name|which_delete
operator|&
literal|2
operator|)
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|use_vec_delete
condition|?
name|VEC_DELETE_EXPR
else|:
name|DELETE_EXPR
decl_stmt|;
if|if
condition|(
operator|!
name|use_global_delete
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_GETS_DELETE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|use_vec_delete
operator|)
operator|)
condition|)
name|rval
operator|=
name|build_opfncall
argument_list|(
name|code
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|use_vec_delete
condition|?
name|BIVD
else|:
name|BID
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Generate a call to a destructor. TYPE is the type to cast ADDR to.    ADDR is an expression which yields the store to be destroyed.    AUTO_DELETE is nonzero if a call to DELETE should be made or not.    If in the program, (AUTO_DELETE& 2) is non-zero, we tear down the    virtual baseclasses.    If in the program, (AUTO_DELETE& 1) is non-zero, then we deallocate.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cp-tree.h for more info.     This function does not delete an object's virtual base classes.  */
end_comment

begin_function
name|tree
name|build_delete
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|,
name|auto_delete
parameter_list|,
name|flags
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|type
decl_stmt|,
name|addr
decl_stmt|;
name|tree
name|auto_delete
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|function
decl_stmt|,
name|parms
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|ref
decl_stmt|;
name|int
name|ptr
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Can happen when CURRENT_EXCEPTION_OBJECT gets its type      set to `error_mark_node' before it gets properly cleaned up.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
goto|goto
name|handle_array
goto|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Call the builtin operator delete.  */
return|return
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* throw away const and volatile on target type of addr */
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|handle_array
label|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"unknown array size in delete"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete
argument_list|(
name|addr
argument_list|,
name|array_type_nelts
argument_list|(
name|type
argument_list|)
argument_list|,
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|auto_delete
argument_list|,
name|integer_two_node
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Don't check PROTECT here; leave that decision to the 	 destructor.  If the destructor is accessible, call it, 	 else report error.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|convert_pointer_to
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|current_class_decl
condition|)
name|ref
operator|=
name|C_C_D
expr_stmt|;
else|else
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|220
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|auto_delete
operator|==
name|integer_zero_node
condition|)
return|return
name|void_zero_node
return|;
comment|/* Pass the size of the object down to the operator delete() in 	 addition to the ADDR.  */
if|if
condition|(
name|TYPE_GETS_REG_DELETE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|use_global_delete
condition|)
block|{
name|tree
name|virtual_size
init|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
comment|/* Call the builtin operator delete.  */
return|return
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
return|;
block|}
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Below, we will reverse the order in which these calls are made.      If we have a destructor, then that destructor will take care      of the base classes; otherwise, we must do that here.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|dtor
init|=
name|DECL_MAIN_VARIANT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|basetypes
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|passed_auto_delete
decl_stmt|;
name|tree
name|do_delete
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|use_global_delete
condition|)
block|{
name|tree
name|cond
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|call
init|=
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
decl_stmt|;
name|cond
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|call
argument_list|,
name|void_zero_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|void_zero_node
condition|)
name|do_delete
operator|=
name|cond
expr_stmt|;
name|passed_auto_delete
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_two_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|passed_auto_delete
operator|=
name|auto_delete
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
block|{
name|enum
name|access_type
name|access
init|=
name|compute_access
argument_list|(
name|basetypes
argument_list|,
name|dtor
argument_list|)
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|access_private
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|cp_error
argument_list|(
literal|"destructor for type `%T' is private in this scope"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|access
operator|==
name|access_protected
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|cp_error
argument_list|(
literal|"destructor for type `%T' is protected in this scope"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Once we are in a destructor, try not going through 	 the virtual function table to find the next destructor.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|auto_delete
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
operator|(
name|ptr
operator|==
literal|1
operator|||
operator|!
name|resolves_to_fixed_type_p
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|,
name|basetype
decl_stmt|;
comment|/* The code below is probably all broken.  See call.c for the 	     complete right way to do this. this offsets may not be right 	     in the below.  (mrs) */
comment|/* This destructor must be called via virtual function table.  */
name|dtor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|dtor
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|dtor
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_pointer_to_real
argument_list|(
name|binfo
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|expr
operator|=
name|fold
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ref
operator|=
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|expr
expr_stmt|;
block|}
name|function
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|ref
argument_list|,
name|DECL_VINDEX
argument_list|(
name|dtor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|dtor
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|passed_auto_delete
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_function_call
argument_list|(
name|function
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_delete
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|,
name|do_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Handle the case where a virtual destructor is 		 being called on an item that is 0.  		 @@ Does this really need to be done?  */
name|tree
name|ifexp
init|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|if (TREE_CODE (ref) == VAR_DECL 		  || TREE_CODE (ref) == COMPONENT_REF) 		warning ("losing in build_delete");
endif|#
directive|endif
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|ifexp
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_DESTRUCTOR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
comment|/* These can't be 0.  */
name|ifexp
operator|=
name|integer_one_node
expr_stmt|;
else|else
comment|/* Handle the case where a non-virtual destructor is 	       being called on an item that is 0.  */
name|ifexp
operator|=
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Used to mean that this destructor was known to be empty, 	     but that's now obsolete.  */
name|my_friendly_assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|dtor
argument_list|)
operator|!=
name|void_type_node
argument_list|,
literal|221
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|passed_auto_delete
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_function_call
argument_list|(
name|dtor
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_delete
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|expr
argument_list|,
name|do_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifexp
operator|!=
name|integer_one_node
condition|)
name|expr
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ifexp
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
else|else
block|{
comment|/* This can get visibilities wrong.  */
name|tree
name|binfos
init|=
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|binfos
condition|?
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
else|:
literal|0
decl_stmt|;
name|tree
name|base_binfo
init|=
name|n_baseclasses
operator|>
literal|0
condition|?
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
literal|0
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
name|tree
name|exprstmt
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|parent_auto_delete
init|=
name|auto_delete
decl_stmt|;
name|tree
name|cond
decl_stmt|;
comment|/* If this type does not have a destructor, but does have 	 operator delete, call the parent parent destructor (if any), 	 but let this node do the deleting.  Otherwise, it is ok 	 to let the parent destructor do the deleting.  */
if|if
condition|(
name|TYPE_GETS_REG_DELETE
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|use_global_delete
condition|)
block|{
name|parent_auto_delete
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|auto_delete
operator|==
name|integer_zero_node
condition|)
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is probably wrong. It should be the size of the 		   virtual object being deleted.  */
name|virtual_size
operator|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_opfncall
argument_list|(
name|DELETE_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|addr
argument_list|,
name|virtual_size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|auto_delete
operator|!=
name|integer_one_node
condition|)
name|cond
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|expr
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
else|else
name|cond
operator|=
name|expr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|base_binfo
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|virtual_size
decl_stmt|;
comment|/* This is probably wrong. It should be the size of the virtual 	     object being deleted.  */
name|virtual_size
operator|=
name|c_sizeof_nowarn
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cond
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|auto_delete
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
name|build_builtin_call
argument_list|(
name|void_type_node
argument_list|,
name|BID
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|)
argument_list|)
argument_list|,
name|void_zero_node
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|exprstmt
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_binfo
operator|&&
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_auto_delete
decl_stmt|;
if|if
condition|(
name|BINFO_OFFSET_ZEROP
argument_list|(
name|base_binfo
argument_list|)
condition|)
name|this_auto_delete
operator|=
name|parent_auto_delete
expr_stmt|;
else|else
name|this_auto_delete
operator|=
name|integer_zero_node
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
name|this_auto_delete
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of the remaining baseclasses.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|base_binfo
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
operator|||
name|TREE_VIA_VIRTUAL
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
comment|/* May be zero offset if other baseclasses are virtual.  */
name|expr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|this_member
init|=
name|build_component_ref
argument_list|(
name|ref
argument_list|,
name|DECL_NAME
argument_list|(
name|member
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|this_type
init|=
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build_delete
argument_list|(
name|this_type
argument_list|,
name|this_member
argument_list|,
name|integer_two_node
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exprstmt
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|,
name|exprstmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exprstmt
condition|)
return|return
name|build_compound_expr
argument_list|(
name|exprstmt
argument_list|)
return|;
comment|/* Virtual base classes make this function do nothing.  */
return|return
name|void_zero_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* For type TYPE, delete the virtual baseclass objects of DECL.  */
end_comment

begin_function
name|tree
name|build_vbase_delete
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|vbases
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|addr
operator|!=
name|error_mark_node
argument_list|,
literal|222
argument_list|)
expr_stmt|;
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|this_addr
init|=
name|convert_force
argument_list|(
name|build_pointer_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|this_addr
argument_list|)
argument_list|,
name|this_addr
argument_list|,
name|integer_zero_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
return|return
name|build_compound_expr
argument_list|(
name|nreverse
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a C++ vector delete expression.    MAXINDEX is the number of elements to be deleted.    ELT_SIZE is the nominal size of each element in the vector.    BASE is the expression that should yield the store to be deleted.    This function expands (or synthesizes) these calls itself.    AUTO_DELETE_VEC says whether the container (vector) should be deallocated.    AUTO_DELETE say whether each item in the container should be deallocated.     This also calls delete for virtual baseclasses of elements of the vector.     Update: MAXINDEX is no longer needed.  The size can be extracted from the    start of the vector for pointers, and from the type for arrays.  We still    use MAXINDEX for arrays because it happens to already have one of the    values we'd have to extract.  (We could use MAXINDEX with pointers to    confirm the size, and trap if the numbers differ; not clear that it'd    be worth bothering.)  */
end_comment

begin_function
name|tree
name|build_vec_delete
parameter_list|(
name|base
parameter_list|,
name|maxindex
parameter_list|,
name|elt_size
parameter_list|,
name|auto_delete_vec
parameter_list|,
name|auto_delete
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|base
decl_stmt|,
name|maxindex
decl_stmt|,
name|elt_size
decl_stmt|;
name|tree
name|auto_delete_vec
decl_stmt|,
name|auto_delete
decl_stmt|;
name|int
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|base
operator|=
name|resolve_offset_ref
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|stabilize_reference
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Since we can use base many times, save_expr it. */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|base
argument_list|)
condition|)
name|base
operator|=
name|save_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Step back one from start of vector, and read dimension.  */
name|tree
name|cookie_addr
init|=
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|BI_header_type
argument_list|)
argument_list|,
name|base
argument_list|,
name|BI_header_size
argument_list|)
decl_stmt|;
name|tree
name|cookie
init|=
name|build_indirect_ref
argument_list|(
name|cookie_addr
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_component_ref
argument_list|(
name|cookie
argument_list|,
name|nc_nelts_field_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
do|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* get the total number of things in the array, maxindex is a bad name */
name|maxindex
operator|=
name|array_type_nelts_total
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"type to vector delete is neither pointer or array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vec_delete_1
argument_list|(
name|base
argument_list|,
name|maxindex
argument_list|,
name|type
argument_list|,
name|auto_delete_vec
argument_list|,
name|auto_delete
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
end_function

end_unit

