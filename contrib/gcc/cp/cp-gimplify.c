begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C++-specific tree lowering bits; see also c-gimplify.c and tree-gimple.c.     Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Jason Merrill<jason@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_comment
comment|/* Local declarations.  */
end_comment

begin_enum
enum|enum
name|bc_t
block|{
name|bc_break
init|=
literal|0
block|,
name|bc_continue
init|=
literal|1
block|}
enum|;
end_enum

begin_comment
comment|/* Stack of labels which are targets for "break" or "continue",    linked through TREE_CHAIN.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|bc_label
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin a scope which can be exited by a break or continue statement.  BC    indicates which.     Just creates a label and pushes it into the current context.  */
end_comment

begin_function
specifier|static
name|tree
name|begin_bc_block
parameter_list|(
name|enum
name|bc_t
name|bc
parameter_list|)
block|{
name|tree
name|label
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|bc_label
index|[
name|bc
index|]
expr_stmt|;
name|bc_label
index|[
name|bc
index|]
operator|=
name|label
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Finish a scope which can be exited by a break or continue statement.    LABEL was returned from the most recent call to begin_bc_block.  BODY is    an expression for the contents of the scope.     If we saw a break (or continue) in the scope, append a LABEL_EXPR to    body.  Otherwise, just forget the label.  */
end_comment

begin_function
specifier|static
name|tree
name|finish_bc_block
parameter_list|(
name|enum
name|bc_t
name|bc
parameter_list|,
name|tree
name|label
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|label
operator|==
name|bc_label
index|[
name|bc
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|sl
init|=
name|NULL
decl_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|body
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|sl
argument_list|)
expr_stmt|;
name|body
operator|=
name|sl
expr_stmt|;
block|}
name|bc_label
index|[
name|bc
index|]
operator|=
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_comment
comment|/* Build a GOTO_EXPR to represent a break or continue statement.  BC    indicates which.  */
end_comment

begin_function
specifier|static
name|tree
name|build_bc_goto
parameter_list|(
name|enum
name|bc_t
name|bc
parameter_list|)
block|{
name|tree
name|label
init|=
name|bc_label
index|[
name|bc
index|]
decl_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|bc
operator|==
name|bc_break
condition|)
name|error
argument_list|(
literal|"break statement not within loop or switch"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"continue statement not within loop or switch"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Mark the label used for finish_bc_block.  */
name|TREE_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Genericize a TRY_BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|genericize_try_block
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|body
init|=
name|TRY_STMTS
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|tree
name|cleanup
init|=
name|TRY_HANDLERS
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLEANUP_P
argument_list|(
operator|*
name|stmt_p
argument_list|)
condition|)
comment|/* A cleanup is an expression, so it doesn't need to be genericized.  */
empty_stmt|;
else|else
name|gimplify_stmt
argument_list|(
operator|&
name|cleanup
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|build2
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|body
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Genericize a HANDLER by converting to a CATCH_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|genericize_catch_block
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|type
init|=
name|HANDLER_TYPE
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|tree
name|body
init|=
name|HANDLER_BODY
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|body
argument_list|)
expr_stmt|;
comment|/* FIXME should the caught type go in TREE_TYPE?  */
operator|*
name|stmt_p
operator|=
name|build2
argument_list|(
name|CATCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|type
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Genericize an EH_SPEC_BLOCK by converting it to a    TRY_CATCH_EXPR/EH_FILTER_EXPR pair.  */
end_comment

begin_function
specifier|static
name|void
name|genericize_eh_spec_block
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|body
init|=
name|EH_SPEC_STMTS
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|tree
name|allowed
init|=
name|EH_SPEC_RAISES
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
name|tree
name|failure
init|=
name|build_call
argument_list|(
name|call_unexpected_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_exc_ptr
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
decl_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|body
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|gimple_build_eh_filter
argument_list|(
name|body
argument_list|,
name|allowed
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Genericize an IF_STMT by turning it into a COND_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_if_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|cond
decl_stmt|,
name|then_
decl_stmt|,
name|else_
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|cond
operator|=
name|IF_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|then_
operator|=
name|THEN_CLAUSE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|else_
operator|=
name|ELSE_CLAUSE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|then_
condition|)
name|then_
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|else_
condition|)
name|else_
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|else_
argument_list|)
condition|)
name|stmt
operator|=
name|then_
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|cond
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|then_
argument_list|)
condition|)
name|stmt
operator|=
name|else_
expr_stmt|;
else|else
name|stmt
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|then_
argument_list|,
name|else_
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a generic representation of one of the C loop forms.  COND is the    loop condition or NULL_TREE.  BODY is the (possibly compound) statement    controlled by the loop.  INCR is the increment expression of a for-loop,    or NULL_TREE.  COND_IS_FIRST indicates whether the condition is    evaluated before the loop body as in while and for loops, or after the    loop body as in do-while loops.  */
end_comment

begin_function
specifier|static
name|tree
name|gimplify_cp_loop
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|body
parameter_list|,
name|tree
name|incr
parameter_list|,
name|bool
name|cond_is_first
parameter_list|)
block|{
name|tree
name|top
decl_stmt|,
name|entry
decl_stmt|,
name|exit
decl_stmt|,
name|cont_block
decl_stmt|,
name|break_block
decl_stmt|,
name|stmt_list
decl_stmt|,
name|t
decl_stmt|;
name|location_t
name|stmt_locus
decl_stmt|;
name|stmt_locus
operator|=
name|input_location
expr_stmt|;
name|stmt_list
operator|=
name|NULL_TREE
expr_stmt|;
name|entry
operator|=
name|NULL_TREE
expr_stmt|;
name|break_block
operator|=
name|begin_bc_block
argument_list|(
name|bc_break
argument_list|)
expr_stmt|;
name|cont_block
operator|=
name|begin_bc_block
argument_list|(
name|bc_continue
argument_list|)
expr_stmt|;
comment|/* If condition is zero don't generate a loop construct.  */
if|if
condition|(
name|cond
operator|&&
name|integer_zerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|top
operator|=
name|NULL_TREE
expr_stmt|;
name|exit
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|cond_is_first
condition|)
block|{
name|t
operator|=
name|build_bc_goto
argument_list|(
name|bc_break
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we use a LOOP_EXPR here, we have to feed the whole thing 	 back through the main gimplifier to lower it.  Given that we 	 have to gimplify the loop body NOW so that we can resolve 	 break/continue stmts, seems easier to just expand to gotos.  */
name|top
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If we have an exit condition, then we build an IF with gotos either 	 out of the loop, or to the top of it.  If there's no exit condition, 	 then we just build a jump back to the top.  */
name|exit
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|top
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
operator|!
name|integer_nonzerop
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|t
operator|=
name|build_bc_goto
argument_list|(
name|bc_break
argument_list|)
expr_stmt|;
name|exit
operator|=
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|exit
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond_is_first
condition|)
block|{
if|if
condition|(
name|incr
condition|)
block|{
name|entry
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|build_bc_goto
argument_list|(
name|bc_continue
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|gimplify_stmt
argument_list|(
operator|&
name|body
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|incr
argument_list|)
expr_stmt|;
name|body
operator|=
name|finish_bc_block
argument_list|(
name|bc_continue
argument_list|,
name|cont_block
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|top
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|body
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|incr
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|entry
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|exit
argument_list|,
operator|&
name|stmt_list
argument_list|)
expr_stmt|;
name|annotate_all_with_locus
argument_list|(
operator|&
name|stmt_list
argument_list|,
name|stmt_locus
argument_list|)
expr_stmt|;
return|return
name|finish_bc_block
argument_list|(
name|bc_break
argument_list|,
name|break_block
argument_list|,
name|stmt_list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Gimplify a FOR_STMT node.  Move the stuff in the for-init-stmt into the    prequeue and hand off to gimplify_cp_loop.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_for_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
if|if
condition|(
name|FOR_INIT_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
name|gimplify_and_add
argument_list|(
name|FOR_INIT_STMT
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|gimplify_cp_loop
argument_list|(
name|FOR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|FOR_EXPR
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify a WHILE_STMT node.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_while_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
operator|*
name|stmt_p
operator|=
name|gimplify_cp_loop
argument_list|(
name|WHILE_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|WHILE_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify a DO_STMT node.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_do_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
operator|*
name|stmt_p
operator|=
name|gimplify_cp_loop
argument_list|(
name|DO_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|DO_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_switch_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
name|tree
name|break_block
decl_stmt|,
name|body
decl_stmt|;
name|location_t
name|stmt_locus
init|=
name|input_location
decl_stmt|;
name|break_block
operator|=
name|begin_bc_block
argument_list|(
name|bc_break
argument_list|)
expr_stmt|;
name|body
operator|=
name|SWITCH_STMT_BODY
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|build3
argument_list|(
name|SWITCH_EXPR
argument_list|,
name|SWITCH_STMT_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|SWITCH_STMT_COND
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|body
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
operator|*
name|stmt_p
argument_list|,
name|stmt_locus
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
name|stmt_p
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|finish_bc_block
argument_list|(
name|bc_break
argument_list|,
name|break_block
argument_list|,
operator|*
name|stmt_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook into the middle of gimplifying an OMP_FOR node.  This is required    in order to properly gimplify CONTINUE statements.  Here we merely    manage the continue stack; the rest of the job is performed by the    regular gimplifier.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|cp_gimplify_omp_for
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|for_stmt
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|cont_block
decl_stmt|;
comment|/* Protect ourselves from recursion.  */
if|if
condition|(
name|OMP_FOR_GIMPLIFYING_P
argument_list|(
name|for_stmt
argument_list|)
condition|)
return|return
name|GS_UNHANDLED
return|;
name|OMP_FOR_GIMPLIFYING_P
argument_list|(
name|for_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Note that while technically the continue label is enabled too soon      here, we should have already diagnosed invalid continues nested within      statement expressions within the INIT, COND, or INCR expressions.  */
name|cont_block
operator|=
name|begin_bc_block
argument_list|(
name|bc_continue
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|OMP_FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|finish_bc_block
argument_list|(
name|bc_continue
argument_list|,
name|cont_block
argument_list|,
name|OMP_FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_FOR_GIMPLIFYING_P
argument_list|(
name|for_stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/*  Gimplify an EXPR_STMT node.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_expr_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|EXPR_STMT_EXPR
argument_list|(
operator|*
name|stmt_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|error_mark_node
condition|)
name|stmt
operator|=
name|NULL
expr_stmt|;
comment|/* Gimplification of a statement expression will nullify the      statement if all its side effects are moved to *PRE_P and *POST_P.       In this case we will not want to emit the gimplified statement.      However, we may still want to emit a warning, so we do that before      gimplification.  */
if|if
condition|(
name|stmt
operator|&&
operator|(
name|extra_warnings
operator|||
name|warn_unused_value
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|stmt
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"statement with no effect"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused_value
condition|)
name|warn_if_unused_value
argument_list|(
name|stmt
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
condition|)
name|stmt
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify initialization from an AGGR_INIT_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|cp_gimplify_init_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|from
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|to
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|sub
decl_stmt|;
comment|/* What about code that pulls out the temp and uses it elsewhere?  I      think that such code never uses the TARGET_EXPR as an initializer.  If      I'm wrong, we'll abort because the temp won't have any RTL.  In that      case, I guess we'll need to replace references somehow.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|TARGET_EXPR
condition|)
name|from
operator|=
name|TARGET_EXPR_INITIAL
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* Look through any COMPOUND_EXPRs, since build_compound_expr pushes them      inside the TARGET_EXPR.  */
name|sub
operator|=
name|expr_last
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and      replace the slot operand with our target.       Should we add a target parm to gimplify_expr instead?  No, as in this      case we want to replace the INIT_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|AGGR_INIT_EXPR
condition|)
block|{
name|gimplify_expr
argument_list|(
operator|&
name|to
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|sub
argument_list|,
literal|2
argument_list|)
operator|=
name|to
expr_stmt|;
operator|*
name|expr_p
operator|=
name|from
expr_stmt|;
comment|/* The initialization is now a side-effect, so the container can 	 become void.  */
if|if
condition|(
name|from
operator|!=
name|sub
condition|)
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Gimplify a MUST_NOT_THROW_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_must_not_throw_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|temp
init|=
name|voidify_wrapper_expr
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|body
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|body
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|gimple_build_eh_filter
argument_list|(
name|body
argument_list|,
name|NULL_TREE
argument_list|,
name|build_call
argument_list|(
name|terminate_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|append_to_statement_list
argument_list|(
name|stmt
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|temp
expr_stmt|;
block|}
else|else
operator|*
name|expr_p
operator|=
name|stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do C++-specific gimplification.  Args are as for gimplify_expr.  */
end_comment

begin_function
name|int
name|cp_gimplify_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|int
name|saved_stmts_are_full_exprs_p
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
if|if
condition|(
name|STATEMENT_CODE_P
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|saved_stmts_are_full_exprs_p
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|STMT_IS_FULL_EXPR_P
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PTRMEM_CST
case|:
operator|*
name|expr_p
operator|=
name|cplus_expand_constant
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|AGGR_INIT_EXPR
case|:
name|simplify_aggr_init_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|THROW_EXPR
case|:
comment|/* FIXME communicate throw type to backend, probably by moving 	 THROW_EXPR into ../tree.def.  */
operator|*
name|expr_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|MUST_NOT_THROW_EXPR
case|:
name|gimplify_must_not_throw_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
comment|/* We used to do this for MODIFY_EXPR as well, but that's unsafe; the 	 LHS of an assignment might also be involved in the RHS, as in bug 	 25979.  */
case|case
name|INIT_EXPR
case|:
name|cp_gimplify_init_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|EMPTY_CLASS_EXPR
case|:
comment|/* We create an empty CONSTRUCTOR with RECORD_TYPE.  */
operator|*
name|expr_p
operator|=
name|build_constructor
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
operator|*
name|expr_p
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|TRY_BLOCK
case|:
name|genericize_try_block
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|HANDLER
case|:
name|genericize_catch_block
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|EH_SPEC_BLOCK
case|:
name|genericize_eh_spec_block
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|USING_STMT
case|:
comment|/* Just ignore for now.  Eventually we will want to pass this on to 	 the debugger.  */
operator|*
name|expr_p
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|gimplify_if_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|FOR_STMT
case|:
name|gimplify_for_stmt
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|WHILE_STMT
case|:
name|gimplify_while_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|DO_STMT
case|:
name|gimplify_do_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|SWITCH_STMT
case|:
name|gimplify_switch_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|ret
operator|=
name|cp_gimplify_omp_for
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTINUE_STMT
case|:
operator|*
name|expr_p
operator|=
name|build_bc_goto
argument_list|(
name|bc_continue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|BREAK_STMT
case|:
operator|*
name|expr_p
operator|=
name|build_bc_goto
argument_list|(
name|bc_break
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
name|gimplify_expr_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|UNARY_PLUS_EXPR
case|:
block|{
name|tree
name|arg
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
operator|*
name|expr_p
operator|=
operator|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|type
operator|)
condition|?
name|fold_convert
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
else|:
name|arg
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
name|c_gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restore saved state.  */
if|if
condition|(
name|STATEMENT_CODE_P
argument_list|(
name|code
argument_list|)
condition|)
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|saved_stmts_are_full_exprs_p
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|is_invisiref_parm
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESULT_DECL
operator|)
operator|&&
name|DECL_BY_REFERENCE
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the uid in both int tree maps are equal.  */
end_comment

begin_function
name|int
name|cxx_int_tree_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|cxx_int_tree_map
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|cxx_int_tree_map
operator|*
operator|)
name|va
decl_stmt|;
specifier|const
name|struct
name|cxx_int_tree_map
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|cxx_int_tree_map
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|uid
operator|==
name|b
operator|->
name|uid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hash a UID in a cxx_int_tree_map.  */
end_comment

begin_function
name|unsigned
name|int
name|cxx_int_tree_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|cxx_int_tree_map
operator|*
operator|)
name|item
operator|)
operator|->
name|uid
return|;
block|}
end_function

begin_comment
comment|/* Perform any pre-gimplification lowering of C++ front end trees to    GENERIC.  */
end_comment

begin_function
specifier|static
name|tree
name|cp_genericize_r
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|p_set
init|=
operator|(
expr|struct
name|pointer_set_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|is_invisiref_parm
argument_list|(
name|stmt
argument_list|)
comment|/* Don't dereference parms in a thunk, pass the references through. */
operator|&&
operator|!
operator|(
name|DECL_THUNK_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|convert_from_reference
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Map block scope extern declarations to visible declarations with the      same name and type in outer scopes if any.  */
if|if
condition|(
name|cp_function_chain
operator|->
name|extern_decl_map
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|struct
name|cxx_int_tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|uid
operator|=
name|DECL_UID
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|cxx_int_tree_map
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|cp_function_chain
operator|->
name|extern_decl_map
argument_list|,
operator|&
name|in
argument_list|,
name|in
operator|.
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|h
operator|->
name|to
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Other than invisiref parms, don't walk the same tree twice.  */
if|if
condition|(
name|pointer_set_contains
argument_list|(
name|p_set
argument_list|,
name|stmt
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|is_invisiref_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|&&
name|is_invisiref_parm
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Don't dereference an invisiref RESULT_DECL inside a RETURN_EXPR.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|OMP_CLAUSE
condition|)
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
comment|/* Don't dereference an invisiref in OpenMP clauses.  */
if|if
condition|(
name|is_invisiref_parm
argument_list|(
name|OMP_CLAUSE_DECL
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|gcc_assert
argument_list|(
operator|!
name|is_invisiref_parm
argument_list|(
name|OMP_CLAUSE_DECL
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
elseif|else
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|stmt
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Due to the way voidify_wrapper_expr is written, we don't get a chance      to lower this construct before scanning it, so we need to lower these      before doing anything else.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CLEANUP_STMT
condition|)
operator|*
name|stmt_p
operator|=
name|build2
argument_list|(
name|CLEANUP_EH_ONLY
argument_list|(
name|stmt
argument_list|)
condition|?
name|TRY_CATCH_EXPR
else|:
name|TRY_FINALLY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|CLEANUP_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|CLEANUP_EXPR
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pointer_set_insert
argument_list|(
name|p_set
argument_list|,
operator|*
name|stmt_p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|cp_genericize
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|p_set
decl_stmt|;
comment|/* Fix up the types of parms passed by invisible reference.  */
for|for
control|(
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If a function's arguments are copied to create a thunk, 	   then DECL_BY_REFERENCE will be set -- but the type of the 	   argument will be a pointer type, so we will never get 	   here.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_BY_REFERENCE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_BY_REFERENCE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|relayout_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Do the same for the return value.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_BY_REFERENCE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|relayout_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If we're a clone, the body is already GIMPLE.  */
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return;
comment|/* We do want to see every occurrence of the parms, so we can't just use      walk_tree's hash functionality.  */
name|p_set
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|cp_genericize_r
argument_list|,
name|p_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|p_set
argument_list|)
expr_stmt|;
comment|/* Do everything else.  */
name|c_genericize
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bc_label
index|[
name|bc_break
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bc_label
index|[
name|bc_continue
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build code to apply FN to each member of ARG1 and ARG2.  FN may be    NULL if there is in fact nothing to do.  ARG2 may be null if FN    actually only takes one argument.  */
end_comment

begin_function
specifier|static
name|tree
name|cxx_omp_clause_apply_fn
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|arg1
parameter_list|,
name|tree
name|arg2
parameter_list|)
block|{
name|tree
name|defparm
decl_stmt|,
name|parm
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|defparm
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|defparm
operator|=
name|TREE_CHAIN
argument_list|(
name|defparm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|inner_type
init|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|start1
decl_stmt|,
name|end1
decl_stmt|,
name|p1
decl_stmt|;
name|tree
name|start2
init|=
name|NULL
decl_stmt|,
name|p2
init|=
name|NULL
decl_stmt|;
name|tree
name|ret
init|=
name|NULL
decl_stmt|,
name|lab
decl_stmt|,
name|t
decl_stmt|;
name|start1
operator|=
name|arg1
expr_stmt|;
name|start2
operator|=
name|arg2
expr_stmt|;
do|do
block|{
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
name|start1
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|inner_type
argument_list|,
name|start1
argument_list|,
name|size_zero_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|start2
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|inner_type
argument_list|,
name|start2
argument_list|,
name|size_zero_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
do|;
name|start1
operator|=
name|build_fold_addr_expr
argument_list|(
name|start1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|start2
operator|=
name|build_fold_addr_expr
argument_list|(
name|start2
argument_list|)
expr_stmt|;
name|end1
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|end1
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|start1
argument_list|)
argument_list|,
name|end1
argument_list|)
expr_stmt|;
name|end1
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|start1
argument_list|)
argument_list|,
name|start1
argument_list|,
name|end1
argument_list|)
expr_stmt|;
name|p1
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|start1
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|p1
argument_list|,
name|start1
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
block|{
name|p2
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|start2
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|p2
argument_list|,
name|start2
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
block|}
name|lab
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|p1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|p2
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Handle default arguments.  */
name|i
operator|=
literal|1
operator|+
operator|(
name|arg2
operator|!=
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|defparm
init|;
name|parm
operator|!=
name|void_list_node
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|i
operator|++
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|nreverse
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|inner_type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|p1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|p1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
block|{
name|t
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|inner_type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|p2
argument_list|)
argument_list|,
name|p2
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|p2
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|p1
argument_list|,
name|end1
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|build_and_jump
argument_list|(
operator|&
name|lab
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg2
condition|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Handle default arguments.  */
name|i
operator|=
literal|1
operator|+
operator|(
name|arg2
operator|!=
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|defparm
init|;
name|parm
operator|!=
name|void_list_node
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|convert_default_arg
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|i
operator|++
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|build_call
argument_list|(
name|fn
argument_list|,
name|nreverse
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return code to initialize DECL with its default constructor, or    NULL if there's nothing to do.  */
end_comment

begin_function
name|tree
name|cxx_omp_clause_default_ctor
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|info
init|=
name|CP_OMP_CLAUSE_INFO
argument_list|(
name|clause
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|info
condition|)
name|ret
operator|=
name|cxx_omp_clause_apply_fn
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return code to initialize DST with a copy constructor from SRC.  */
end_comment

begin_function
name|tree
name|cxx_omp_clause_copy_ctor
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|dst
parameter_list|,
name|tree
name|src
parameter_list|)
block|{
name|tree
name|info
init|=
name|CP_OMP_CLAUSE_INFO
argument_list|(
name|clause
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|info
condition|)
name|ret
operator|=
name|cxx_omp_clause_apply_fn
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Similarly, except use an assignment operator instead.  */
end_comment

begin_function
name|tree
name|cxx_omp_clause_assign_op
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|dst
parameter_list|,
name|tree
name|src
parameter_list|)
block|{
name|tree
name|info
init|=
name|CP_OMP_CLAUSE_INFO
argument_list|(
name|clause
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|info
condition|)
name|ret
operator|=
name|cxx_omp_clause_apply_fn
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return code to destroy DECL.  */
end_comment

begin_function
name|tree
name|cxx_omp_clause_dtor
parameter_list|(
name|tree
name|clause
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|info
init|=
name|CP_OMP_CLAUSE_INFO
argument_list|(
name|clause
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|info
condition|)
name|ret
operator|=
name|cxx_omp_clause_apply_fn
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* True if OpenMP should privatize what this DECL points to rather    than the DECL itself.  */
end_comment

begin_function
name|bool
name|cxx_omp_privatize_by_reference
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|is_invisiref_parm
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

end_unit

