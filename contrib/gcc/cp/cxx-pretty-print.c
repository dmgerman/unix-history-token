begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of subroutines for the GNU C++ pretty-printer.    Copyright (C) 2003 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"cxx-pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_function_decl
specifier|static
name|void
name|pp_cxx_unqualified_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_nested_name_specifier
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_qualified_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_assignment_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_template_argument_list
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_type_specifier_seq
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_ptr_operator
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_type_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_direct_abstract_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_abstract_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_cxx_template_parameter
parameter_list|(
name|cxx_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_define
define|#
directive|define
name|pp_cxx_whitespace
parameter_list|(
name|PP
parameter_list|)
value|pp_c_whitespace (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_left_paren
parameter_list|(
name|PP
parameter_list|)
value|pp_c_left_paren (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_right_paren
parameter_list|(
name|PP
parameter_list|)
value|pp_c_right_paren (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_left_brace
parameter_list|(
name|PP
parameter_list|)
value|pp_c_left_brace (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_right_brace
parameter_list|(
name|PP
parameter_list|)
value|pp_c_right_brace (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_dot
parameter_list|(
name|PP
parameter_list|)
value|pp_c_dot (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_arrow
parameter_list|(
name|PP
parameter_list|)
value|pp_c_arrow (pp_c_base (PP))
end_define

begin_define
define|#
directive|define
name|pp_cxx_semicolon
parameter_list|(
name|PP
parameter_list|)
value|pp_c_semicolon (pp_c_base (PP))
end_define

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_nonconsecutive_character
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|pp_last_position_in_text
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|==
name|c
condition|)
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|pp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|pp_cxx_begin_template_argument_list
parameter_list|(
name|PP
parameter_list|)
define|\
value|pp_cxx_nonconsecutive_character (PP, '<')
end_define

begin_define
define|#
directive|define
name|pp_cxx_end_template_argument_list
parameter_list|(
name|PP
parameter_list|)
define|\
value|pp_cxx_nonconsecutive_character (PP, '>')
end_define

begin_define
define|#
directive|define
name|pp_cxx_identifier
parameter_list|(
name|PP
parameter_list|,
name|ID
parameter_list|)
value|pp_c_identifier (pp_c_base (PP), ID)
end_define

begin_define
define|#
directive|define
name|pp_cxx_tree_identifier
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
value|pp_c_tree_identifier (pp_c_base (PP), T)
end_define

begin_define
define|#
directive|define
name|pp_cxx_cv_qualifier_seq
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
define|\
value|pp_c_type_qualifier_list (pp_c_base (PP), T)
end_define

begin_define
define|#
directive|define
name|pp_cxx_storage_class_specifier
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
define|\
value|pp_c_storage_class_specifier (pp_c_base (PP), T)
end_define

begin_define
define|#
directive|define
name|pp_cxx_expression_list
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
define|\
value|pp_c_expression_list (pp_c_base (PP), T)
end_define

begin_define
define|#
directive|define
name|pp_cxx_space_for_pointer_operator
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
define|\
value|pp_c_space_for_pointer_operator (pp_c_base (PP), T)
end_define

begin_define
define|#
directive|define
name|pp_cxx_init_declarator
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
define|\
value|pp_c_init_declarator (pp_c_base (PP), T)
end_define

begin_define
define|#
directive|define
name|pp_cxx_call_argument_list
parameter_list|(
name|PP
parameter_list|,
name|T
parameter_list|)
define|\
value|pp_c_call_argument_list (pp_c_base (PP), T)
end_define

begin_function
specifier|static
name|void
name|pp_cxx_colon_colon
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_colon_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expressions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_destructor_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
return|return
name|name
operator|==
name|complete_dtor_identifier
operator|||
name|name
operator|==
name|base_dtor_identifier
operator|||
name|name
operator|==
name|deleting_dtor_identifier
return|;
block|}
end_function

begin_comment
comment|/* conversion-function-id:       operator conversion-type-id     conversion-type-id:       type-specifier-seq conversion-declarator(opt)     conversion-declarator:       ptr-operator conversion-declarator(opt)  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_conversion_function_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|pp_cxx_type_specifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_template_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_template_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unqualified-id:      identifier      operator-function-id      conversion-function-id      ~ class-name      template-id  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_unqualified_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RESULT_DECL
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"<return-value>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|USING_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_conversion_function_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|is_destructor_name
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_complement
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* FIXME: Why is this necessary? */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|constructor_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_tree_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_ID_EXPR
case|:
name|pp_cxx_template_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_template_keyword_if_needed
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"template"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nested-name-specifier:       class-or-namespace-name :: nested-name-specifier(opt)       class-or-namespace-name :: template nested-name-specifier   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_nested_name_specifier
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|!=
name|pp
operator|->
name|enclosing_scope
condition|)
block|{
name|tree
name|scope
init|=
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|pp_cxx_template_keyword_if_needed
argument_list|(
name|pp
argument_list|,
name|scope
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* qualified-id:       nested-name-specifier template(opt) unqualified-id  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_qualified_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PTRMEM_CST
case|:
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|PTRMEM_CST_CLASS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
else|:
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_REF
case|:
case|case
name|SCOPE_REF
case|:
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|tree
name|scope
init|=
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
name|pp
operator|->
name|enclosing_scope
condition|)
block|{
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|pp_cxx_template_keyword_if_needed
argument_list|(
name|pp
argument_list|,
name|scope
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* id-expression:       unqualified-id       qualified-id   */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_id_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* primary-expression:      literal      this      :: identifier      :: operator-function-id      :: qualifier-id      ( expression )      id-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_primary_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|STRING_CST
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
name|pp_c_constant
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
name|t
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|OVERLOAD
case|:
case|case
name|CONST_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|pp_cxx_id_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_primary_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* postfix-expression:      primary-expression      postfix-expression [ expression ]      postfix-expression ( expression-list(opt) )      simple-type-specifier ( expression-list(opt) )      typename ::(opt) nested-name-specifier identifier ( expression-list(opt) )      typename ::(opt) nested-name-specifier template(opt)                                        template-id ( expression-list(opt) )      postfix-expression . template(opt) ::(opt) id-expression      postfix-expression -> template(opt) ::(opt) id-expression      postfix-expression . pseudo-destructor-name      postfix-expression -> pseudo-destructor-name      postfix-expression ++      postfix-expression --      dynamic_cast< type-id> ( expression )      static_cast< type-id> ( expression )      reinterpret_cast< type-id> ( expression )      const_cast< type-id> ( expression )      typeid ( expression )      typeif ( type-id )  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_postfix_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AGGR_INIT_EXPR
case|:
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|fun
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|saved_scope
init|=
name|pp
operator|->
name|enclosing_scope
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fun
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fun
operator|=
name|TREE_OPERAND
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In templates, where there is no way to tell whether a given            call uses an actual member function.  So the parser builds            FUN as a COMPONENT_REF or a plain IDENTIFIER_NODE until            instantiation time.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fun
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|tree
name|object
init|=
name|code
operator|==
name|AGGR_INIT_EXPR
operator|&&
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
else|:
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|object
operator|=
name|TREE_OPERAND
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|object
operator|=
name|TREE_OPERAND
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|pp_cxx_postfix_expression
argument_list|(
name|pp
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_cxx_postfix_expression
argument_list|(
name|pp
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|pp_cxx_arrow
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pp
operator|->
name|enclosing_scope
operator|=
name|strip_pointer_operator
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_postfix_expression
argument_list|(
name|pp
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|pp
operator|->
name|enclosing_scope
operator|=
name|saved_scope
expr_stmt|;
name|pp_cxx_call_argument_list
argument_list|(
name|pp
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|AGGR_INIT_EXPR
operator|&&
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_cxx_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BASELINK
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|OVERLOAD
case|:
case|case
name|CONST_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|RESULT_DECL
case|:
name|pp_cxx_primary_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
if|if
condition|(
name|code
operator|==
name|DYNAMIC_CAST_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"dynamic_cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|STATIC_CAST_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"static_cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|REINTERPRET_CAST_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"reinterpret_cast"
argument_list|)
expr_stmt|;
else|else
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"const_cast"
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EMPTY_CLASS_EXPR
case|:
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPEID_EXPR
case|:
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"typeid"
argument_list|)
expr_stmt|;
name|pp_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSEUDO_DTOR_EXPR
case|:
name|pp_cxx_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_colon_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_complement
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_postfix_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* new-expression:       ::(opt) new new-placement(opt) new-type-id new-initializer(opt)       ::(opt) new new-placement(opt) ( type-id ) new-initializer(opt)     new-placement:       ( expression-list )     new-type-id:       type-specifier-seq new-declarator(opt)     new-declarator:       ptr-operator new-declarator(opt)       direct-new-declarator     direct-new-declarator       [ expression ]       direct-new-declarator [ constant-expression ]     new-initializer:       ( expression-list(opt) )  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_new_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
case|case
name|VEC_NEW_EXPR
case|:
if|if
condition|(
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_colon_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|pp_cxx_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: array-types are built with one more element.  */
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|pp_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|pp_c_expression_list
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|void_zero_node
condition|)
empty_stmt|;
comment|/* OK, empty initializer list.  */
else|else
name|pp_cxx_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* delete-expression:       ::(opt) delete cast-expression       ::(opt) delete [ ] cast-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_delete_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DELETE_EXPR
case|:
case|case
name|VEC_DELETE_EXPR
case|:
if|if
condition|(
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_colon_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|VEC_DELETE_EXPR
condition|)
block|{
name|pp_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp_c_cast_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* unary-expression:       postfix-expression       ++ cast-expression       -- cast-expression       unary-operator cast-expression       sizeof unary-expression       sizeof ( type-id )       new-expression       delete-expression     unary-operator: one of       *&   +   -  !     GNU extensions:       __alignof__ unary-expression       __alignof__ ( type-id )  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_unary_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
case|case
name|VEC_NEW_EXPR
case|:
name|pp_cxx_new_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE_EXPR
case|:
case|case
name|VEC_DELETE_EXPR
case|:
name|pp_cxx_delete_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_unary_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* cast-expression:       unary-expression       ( type-id ) cast-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_cast_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|CAST_EXPR
case|:
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_cast_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* pm-expression:       cast-expression       pm-expression .* cast-expression       pm-expression ->* cast-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_pm_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Handle unfortunate OFFESET_REF overloading here.  */
case|case
name|OFFSET_REF
case|:
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else fall through.  */
case|case
name|MEMBER_REF
case|:
case|case
name|DOTSTAR_EXPR
case|:
name|pp_cxx_pm_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_cxx_cast_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* multiplicative-expression:       pm-expression       multiplicative-expression * pm-expression       multiplicative-expression / pm-expression       multiplicative-expression % pm-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_multiplicative_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
name|pp_cxx_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
name|pp_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TRUNC_DIV_EXPR
condition|)
name|pp_slash
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_modulo
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_pm_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_cxx_pm_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* conditional-expression:       logical-or-expression       logical-or-expression ?  expression  : assignment-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_conditional_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|pp_c_logical_or_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_question
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_logical_or_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pp_cxx_assignment_operator
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|op
operator|=
literal|"="
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|op
operator|=
literal|"+="
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|op
operator|=
literal|"-="
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
name|op
operator|=
literal|"/="
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
name|op
operator|=
literal|"%="
expr_stmt|;
break|break;
default|default:
name|op
operator|=
name|tree_code_name
index|[
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* assignment-expression:       conditional-expression       logical-or-expression assignment-operator assignment-expression       throw-expression     throw-expression:        throw assignment-expression(opt)     assignment-operator: one of       =    *=    /=    %=    +=    -=>>=<<=&=    ^=    |=  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_assignment_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
name|pp_c_logical_or_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|THROW_EXPR
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"throw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
condition|)
name|pp_cxx_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODOP_EXPR
case|:
name|pp_c_logical_or_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_assignment_operator
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_cxx_conditional_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pp_cxx_expression
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|STRING_CST
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
name|pp_c_constant
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case OFFSET_REF:
endif|#
directive|endif
case|case
name|SCOPE_REF
case|:
case|case
name|PTRMEM_CST
case|:
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERLOAD
case|:
name|t
operator|=
name|OVL_CURRENT
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|BASELINK
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|pp_cxx_primary_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
if|#
directive|if
literal|0
block|case MEMBER_REF:
endif|#
directive|endif
case|case
name|EMPTY_CLASS_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
case|case
name|PSEUDO_DTOR_EXPR
case|:
case|case
name|AGGR_INIT_EXPR
case|:
name|pp_cxx_postfix_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEW_EXPR
case|:
case|case
name|VEC_NEW_EXPR
case|:
name|pp_cxx_new_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE_EXPR
case|:
case|case
name|VEC_DELETE_EXPR
case|:
name|pp_cxx_delete_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAST_EXPR
case|:
name|pp_cxx_cast_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_REF
case|:
case|case
name|MEMBER_REF
case|:
case|case
name|DOTSTAR_EXPR
case|:
name|pp_cxx_pm_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
name|pp_cxx_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|pp_cxx_conditional_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
case|case
name|THROW_EXPR
case|:
case|case
name|MODOP_EXPR
case|:
name|pp_cxx_assignment_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_expression
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Declarations.  */
end_comment

begin_comment
comment|/* function-specifier:       inline       virtual       explicit   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_function_specifier
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"virtual"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_NONCONVERTING_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"explicit"
argument_list|)
expr_stmt|;
else|else
name|pp_c_function_specifier
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* decl-specifier-seq:       decl-specifier-seq(opt) decl-specifier     decl-specifier:       storage-class-specifier       type-specifier       function-specifier       friend       typedef  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_decl_specifier_seq
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FIELD_DECL
case|:
name|pp_cxx_storage_class_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|pfm
init|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pfm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_ptr_operator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Constructors don't have return types.  And conversion functions          do not have a type-specifier in their return types.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_CONV_FN_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_function_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
default|default:
name|pp_c_declaration_specifiers
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* simple-type-specifier:       ::(opt) nested-name-specifier(opt) type-name       ::(opt) nested-name-specifier(opt) template(opt) template-id       char       wchar_t       bool       short       int       long       signed       unsigned       float       double       void  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_simple_type_specifier
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"typename"
argument_list|)
expr_stmt|;
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_type_specifier
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* type-specifier-seq:       type-specifier type-specifier-seq(opt)     type-specifier:       simple-type-specifier       class-specifier       enum-specifier       elaborated-type-specifier       cv-qualifier   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_type_specifier_seq
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|pp_c_type_qualifier_list
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_simple_type_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|pp_cxx_type_specifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ptr-operator:       * cv-qualifier-seq(opt)&       ::(opt) nested-name-specifier * cv-qualifier-seq(opt)  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_ptr_operator
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|REFERENCE_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|pp_cxx_ptr_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|pp_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through.  */
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|tree
name|pp_cxx_implicit_parameter_type
parameter_list|(
name|tree
name|mf
parameter_list|)
block|{
return|return
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|mf
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    parameter-declaration:       decl-specifier-seq declarator       decl-specifier-seq declarator = assignment-expression       decl-specifier-seq abstract-declarator(opt)       decl-specifier-seq abstract-declarator(opt) assignment-expression  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_parameter_declaration
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parameter-declaration-clause:       parameter-declaration-list(opt) ...(opt)       parameter-declaration-list , ...     parameter-declaration-list:       parameter-declaration       parameter-declaration-list , parameter-declaration  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_parameter_declaration_clause
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|args
init|=
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|NULL
else|:
name|FUNCTION_FIRST_USER_PARM
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|types
init|=
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
else|:
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|abstract
init|=
name|args
operator|==
name|NULL
operator|||
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
operator|&
name|pp_c_flag_abstract
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
comment|/* Skip artificial parameter for nonstatic member functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|,
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|pp_cxx_parameter_declaration
argument_list|(
name|pp
argument_list|,
name|abstract
condition|?
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
else|:
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abstract
operator|&&
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
operator|&
name|pp_cxx_flag_default_argument
condition|)
block|{
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|types
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_cxx_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exception-specification:       throw ( type-id-list(opt) )     type-id-list       type-id       type-id-list , type-id   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_exception_specification
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|ex_spec
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_NOTHROW_P
argument_list|(
name|t
argument_list|)
operator|&&
name|ex_spec
operator|==
name|NULL
condition|)
return|return;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"throw"
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ex_spec
operator|&&
name|TREE_VALUE
argument_list|(
name|ex_spec
argument_list|)
condition|;
name|ex_spec
operator|=
name|TREE_CHAIN
argument_list|(
name|ex_spec
argument_list|)
control|)
block|{
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|ex_spec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|ex_spec
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* direct-declarator:       declarator-id       direct-declarator ( parameter-declaration-clause ) cv-qualifier-seq(opt)                                             exception-specification(opt)       direct-declaration [ constant-expression(opt) ]       ( declarator )  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_direct_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_cxx_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_id_expression
argument_list|(
name|pp
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|pp_cxx_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_id_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_parameter_declaration_clause
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|pp
argument_list|,
name|pp_cxx_implicit_parameter_type
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_exception_specification
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
break|break;
default|default:
name|pp_c_direct_declarator
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* declarator:    direct-declarator    ptr-operator declarator  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_direct_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ctor-initializer:       : mem-initializer-list     mem-initializer-list:       mem-initializer       mem-initializer , mem-initializer-list     mem-initializer:       mem-initializer-id ( expression-list(opt) )     mem-initializer-id:       ::(opt) nested-name-specifier(opt) class-name       identifier   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_ctor_initializer
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|pp_cxx_primary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* function-definition:       decl-specifier-seq(opt) declarator ctor-initializer(opt) function-body       decl-specifier-seq(opt) declarator function-try-block  */
end_comment

begin_function
name|void
name|pp_cxx_function_definition
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|saved_scope
init|=
name|pp
operator|->
name|enclosing_scope
decl_stmt|;
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
name|pp
operator|->
name|enclosing_scope
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|body
init|=
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|COMPOUND_STMT
operator|&&
name|TREE_CODE
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|CTOR_INITIALIZER
condition|)
block|{
name|body
operator|=
name|COMPOUND_BODY
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|pp_cxx_ctor_initializer
argument_list|(
name|pp
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|TREE_CHAIN
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_statement
argument_list|(
name|pp
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_cxx_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
name|pp_flush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|enclosing_scope
operator|=
name|saved_scope
expr_stmt|;
block|}
end_function

begin_comment
comment|/* abstract-declarator:       ptr-operator abstract-declarator(opt)       direct-abstract-declarator  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_abstract_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pp_cxx_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* direct-abstract-declarator:       direct-abstract-declarator(opt) ( parameter-declaration-clause )                            cv-qualifier-seq(opt) exception-specification(opt)       direct-abstract-declarator(opt) [ constant-expression(opt) ]       ( abstract-declarator )  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_direct_abstract_declarator
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|REFERENCE_TYPE
case|:
name|pp_cxx_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|pp_cxx_parameter_declaration_clause
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
name|pp_cxx_cv_qualifier_seq
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_cxx_exception_specification
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
break|break;
default|default:
name|pp_c_direct_abstract_declarator
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* type-id:      type-specifier-seq abstract-declarator(opt) */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_type_id
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_flags
name|saved_flags
init|=
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
decl_stmt|;
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
operator||=
name|pp_c_flag_abstract
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|TEMPLATE_DECL
case|:
case|case
name|TYPEOF_TYPE
case|:
case|case
name|TEMPLATE_ID_EXPR
case|:
comment|/* FIXME: Should be pp_cxx_type_specifier_seq.  */
name|pp_cxx_type_specifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_type_id
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
operator|=
name|saved_flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* template-argument-list:       template-argument       template-argument-list, template-argument     template-argument:       assignment-expression       type-id       template-name   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_template_argument_list
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TYPE_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|)
condition|)
name|pp_cxx_type_id
argument_list|(
name|pp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_expression
argument_list|(
name|pp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pp_cxx_exception_declaration
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|t
operator|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_type_specifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Statements.  */
end_comment

begin_function
name|void
name|pp_cxx_statement
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|USING_STMT
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"using"
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"namespace"
argument_list|)
expr_stmt|;
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|USING_STMT_NAMESPACE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_DECL
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"using"
argument_list|)
expr_stmt|;
name|pp_cxx_nested_name_specifier
argument_list|(
name|pp
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_SPEC_BLOCK
case|:
break|break;
comment|/* try-block:             try compound-statement handler-seq  */
case|case
name|TRY_BLOCK
case|:
name|pp_maybe_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"try"
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp_cxx_statement
argument_list|(
name|pp
argument_list|,
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLEANUP_P
argument_list|(
name|t
argument_list|)
condition|)
empty_stmt|;
else|else
name|pp_cxx_statement
argument_list|(
name|pp
argument_list|,
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*          handler-seq:             handler handler-seq(opt)           handler:          catch ( exception-declaration ) compound-statement            exception-declaration:             type-specifier-seq declarator             type-specifier-seq abstract-declarator             ...   */
case|case
name|HANDLER
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"catch"
argument_list|)
expr_stmt|;
name|pp_cxx_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_exception_declaration
argument_list|(
name|pp
argument_list|,
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|+=
literal|3
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
name|pp_cxx_statement
argument_list|(
name|pp
argument_list|,
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|-=
literal|3
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|pp_c_statement
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* original-namespace-definition:       namespace identifier { namespace-body }    As an edge case, we also handle unnamed namespace definition here.  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_original_namespace_definition
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"namespace"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* We do not print the namespace-body.  */
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* namespace-alias:       identifier     namespace-alias-definition:       namespace identifier = qualified-namespace-specifier ;     qualified-namespace-specifier:       ::(opt) nested-name-specifier(opt) namespace-name   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_namespace_alias_definition
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"namespace"
argument_list|)
expr_stmt|;
name|pp_cxx_unqualified_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_qualified_id
argument_list|(
name|pp
argument_list|,
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* simple-declaration:       decl-specifier-seq(opt) init-declarator-list(opt)  */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_simple_declaration
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_cxx_decl_specifier_seq
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_init_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_cxx_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   template-parameter-list:      template-parameter      template-parameter-list , template-parameter  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_cxx_template_parameter_list
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|int
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_cxx_template_parameter
argument_list|(
name|pp
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* template-parameter:       type-parameter       parameter-declaration     type-parameter:      class identifier(opt)      class identifier(op) = type-id      typename identifier(opt)      typename identifier(opt) = type-id      template< template-parameter-list> class identifier(opt)      template< template-parameter-list> class identifier(opt) = template-name */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_template_parameter
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|parameter
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parameter
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parameter
argument_list|)
condition|)
name|pp_cxx_tree_identifier
argument_list|(
name|pp
argument_list|,
name|DECL_NAME
argument_list|(
name|parameter
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: Chech if we should print also default argument.  */
break|break;
case|case
name|PARM_DECL
case|:
name|pp_cxx_parameter_declaration
argument_list|(
name|pp
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_DECL
case|:
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Pretty-print a template parameter in the canonical form    "template-parameter-<level>-<position in parameter list>".  */
end_comment

begin_function
name|void
name|pp_cxx_canonical_template_parameter
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|parm
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
comment|/* Brings type template parameters to the canonical forms.  */
if|if
condition|(
name|code
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|code
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
name|parm
operator|=
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"template-parameter-"
argument_list|)
expr_stmt|;
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|pp_minus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   template-declaration:      export(opt) template< template-parameter-list> declaration   */
end_comment

begin_function
specifier|static
name|void
name|pp_cxx_template_declaration
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|tree
name|tmpl
init|=
name|most_general_template
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|level
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|pp_maybe_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|level
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
init|;
name|level
condition|;
name|level
operator|=
name|TREE_CHAIN
argument_list|(
name|level
argument_list|)
control|)
block|{
name|pp_cxx_identifier
argument_list|(
name|pp
argument_list|,
literal|"template"
argument_list|)
expr_stmt|;
name|pp_cxx_begin_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_cxx_template_parameter_list
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
name|pp_cxx_end_template_argument_list
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_function_definition
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_simple_declaration
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pp_cxx_explicit_specialization
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pp_cxx_explicit_instantiation
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     declaration:        block-declaration        function-definition        template-declaration        explicit-instantiation        explicit-specialization        linkage-specification        namespace-definition      block-declaration:        simple-declaration        asm-definition        namespace-alias-definition        using-declaration        using-directive  */
end_comment

begin_function
name|void
name|pp_cxx_declaration
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_simple_declaration
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|pp_cxx_template_declaration
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pp_cxx_explicit_specialization
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pp_cxx_explicit_instantiation
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
else|else
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|TYPE_DECL
case|:
name|pp_cxx_simple_declaration
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_function_definition
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_simple_declaration
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|t
argument_list|)
condition|)
name|pp_cxx_namespace_alias_definition
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_cxx_original_namespace_definition
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
name|c_pretty_print_fn
name|pp_fun
typedef|;
end_typedef

begin_function
name|void
name|pp_cxx_pretty_printer_init
parameter_list|(
name|cxx_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_c_pretty_printer_init
argument_list|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|pp_set_line_maximum_length
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|declaration
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_declaration
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|declaration_specifiers
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_decl_specifier_seq
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|function_specifier
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_function_specifier
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|type_specifier_seq
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_type_specifier_seq
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|declarator
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_declarator
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|direct_declarator
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_direct_declarator
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|parameter_list
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_parameter_declaration_clause
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|type_id
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_type_id
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|abstract_declarator
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_abstract_declarator
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|direct_abstract_declarator
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_direct_abstract_declarator
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|simple_type_specifier
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_simple_type_specifier
expr_stmt|;
comment|/* pp->c_base.statement = (pp_fun) pp_cxx_statement;  */
name|pp
operator|->
name|c_base
operator|.
name|id_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_id_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|primary_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_primary_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|postfix_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_postfix_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|unary_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_unary_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|multiplicative_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_multiplicative_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|conditional_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_conditional_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|assignment_expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_assignment_expression
expr_stmt|;
name|pp
operator|->
name|c_base
operator|.
name|expression
operator|=
operator|(
name|pp_fun
operator|)
name|pp_cxx_expression
expr_stmt|;
name|pp
operator|->
name|enclosing_scope
operator|=
name|global_namespace
expr_stmt|;
block|}
end_function

end_unit

