begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform optimizations on tree structure.    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005    Free Software Foundation, Inc.    Written by Mark Michell (mark@codesourcery.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_comment
comment|/* Prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|update_cloned_parm
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* CLONED_PARM is a copy of CLONE, generated for a cloned constructor    or destructor.  Update it to ensure that the source-position for    the cloned parameter matches that for the original, and that the    debugging generation code will be able to find the original PARM.  */
end_comment

begin_function
specifier|static
name|void
name|update_cloned_parm
parameter_list|(
name|tree
name|parm
parameter_list|,
name|tree
name|cloned_parm
parameter_list|,
name|bool
name|first
parameter_list|)
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|parm
expr_stmt|;
comment|/* We may have taken its address.  */
name|TREE_ADDRESSABLE
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* The definition might have different constness.  */
name|TREE_READONLY
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|cloned_parm
argument_list|)
operator|=
operator|!
name|first
operator|||
name|TREE_USED
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* The name may have changed from the declaration.  */
name|DECL_NAME
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FN is a function that has a complete body.  Clone the body as    necessary.  Returns nonzero if there's no longer any need to    process the main body.  */
end_comment

begin_function
name|bool
name|maybe_clone_body
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|clone
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
comment|/* We only clone constructors and destructors.  */
if|if
condition|(
operator|!
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Emit the DWARF1 abstract instance.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* We know that any clones immediately follow FN in the TYPE_METHODS      list.  */
name|push_to_top_level
argument_list|()
expr_stmt|;
name|FOR_EACH_CLONE
argument_list|(
argument|clone
argument_list|,
argument|fn
argument_list|)
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|clone_parm
decl_stmt|;
name|int
name|parmno
decl_stmt|;
name|splay_tree
name|decl_map
decl_stmt|;
comment|/* Update CLONE's source position information to match FN's.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_COMDAT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_WEAK
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_ONE_ONLY
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_USE_TEMPLATE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_INTERFACE_KNOWN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|clone
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Adjust the parameter names and locations.  */
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
expr_stmt|;
comment|/* Update the `this' parameter, which is always first.  */
name|update_cloned_parm
argument_list|(
name|parm
argument_list|,
name|clone_parm
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
control|)
comment|/* Update this parameter.  */
name|update_cloned_parm
argument_list|(
name|parm
argument_list|,
name|clone_parm
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* Start processing the function.  */
name|start_preparsed_function
argument_list|(
name|clone
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* Remap the parameters.  */
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|parmno
operator|=
literal|0
operator|,
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
operator|,
name|clone_parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
init|;
name|parm
condition|;
operator|++
name|parmno
operator|,
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
comment|/* Map the in-charge parameter to an appropriate constant.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|parmno
operator|==
literal|1
condition|)
block|{
name|tree
name|in_charge
decl_stmt|;
name|in_charge
operator|=
name|in_charge_arg_for_name
argument_list|(
name|DECL_NAME
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|in_charge
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|vtt_parm_identifier
condition|)
block|{
comment|/* For a subobject constructor or destructor, the next 		 argument is the VTT parameter.  Remap the VTT_PARM 		 from the CLONE to this parameter.  */
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|clone_parm
argument_list|)
operator|=
name|parm
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|clone_parm
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, map the VTT parameter to `NULL'.  */
else|else
block|{
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|null_pointer_node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Map other parameters to their equivalents in the cloned 	     function.  */
else|else
block|{
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|clone_parm
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
condition|)
block|{
name|parm
operator|=
name|DECL_RESULT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|DECL_RESULT
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|clone_parm
argument_list|)
expr_stmt|;
block|}
comment|/* Clone the body.  */
name|clone_body
argument_list|(
name|clone
argument_list|,
name|fn
argument_list|,
name|decl_map
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|decl_map
argument_list|)
expr_stmt|;
comment|/* The clone can throw iff the original function can throw.  */
name|cp_function_chain
operator|->
name|can_throw
operator|=
operator|!
name|TREE_NOTHROW
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Now, expand this function into RTL, if appropriate.  */
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|expand_or_defer_fn
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
comment|/* We don't need to process the original function any further.  */
return|return
literal|1
return|;
block|}
end_function

end_unit

