begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform optimizations on tree structure.    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Written by Mark Michell (mark@codesourcery.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|calls_setjmp_r
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_cloned_parm
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_function
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_dump_index
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optimize the body of FN. */
end_comment

begin_function
name|void
name|optimize_function
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|dump_function
argument_list|(
name|TDI_original
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* While in this function, we may choose to go off and compile      another function.  For example, we might instantiate a function      in the hopes of inlining it.  Normally, that wouldn't trigger any      actual RTL code-generation -- but it will if the template is      actually needed.  (For example, if it's address is taken, or if      some other function already refers to the template.)  If      code-generation occurs, then garbage collection will occur, so we      must protect ourselves, just as we do while building up the body      of the function.  */
operator|++
name|function_depth
expr_stmt|;
if|if
condition|(
name|flag_inline_trees
comment|/* We do not inline thunks, as (a) the backend tries to optimize          the call to the thunkee, (b) tree based inlining breaks that          optimization, (c) virtual functions are rarely inlineable,          and (d) ASM_OUTPUT_MI_THUNK is there to DTRT anyway.  */
operator|&&
operator|!
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|optimize_inline_calls
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|dump_function
argument_list|(
name|TDI_inlined
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Undo the call to ggc_push_context above.  */
operator|--
name|function_depth
expr_stmt|;
name|dump_function
argument_list|(
name|TDI_optimized
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from calls_setjmp_p via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|calls_setjmp_r
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We're only interested in FUNCTION_DECLS.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|setjmp_call_p
argument_list|(
operator|*
name|tp
argument_list|)
condition|?
operator|*
name|tp
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if FN calls `setjmp' or some other function that    can return more than once.  This function is conservative; it may    occasionally return a non-zero value even when FN does not actually    call `setjmp'.  */
end_comment

begin_function
name|int
name|calls_setjmp_p
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
return|return
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|calls_setjmp_r
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* CLONED_PARM is a copy of CLONE, generated for a cloned constructor    or destructor.  Update it to ensure that the source-position for    the cloned parameter matches that for the original, and that the    debugging generation code will be able to find the original PARM.  */
end_comment

begin_function
specifier|static
name|void
name|update_cloned_parm
parameter_list|(
name|parm
parameter_list|,
name|cloned_parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
name|tree
name|cloned_parm
decl_stmt|;
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|parm
expr_stmt|;
comment|/* We may have taken its address. */
name|TREE_ADDRESSABLE
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* The definition might have different constness. */
name|TREE_READONLY
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* The name may have changed from the declaration. */
name|DECL_NAME
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|cloned_parm
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FN is a function that has a complete body.  Clone the body as    necessary.  Returns non-zero if there's no longer any need to    process the main body.  */
end_comment

begin_function
name|int
name|maybe_clone_body
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|tree
name|clone
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* We only clone constructors and destructors.  */
if|if
condition|(
operator|!
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Emit the DWARF1 abstract instance.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* We know that any clones immediately follow FN in the TYPE_METHODS      list.  */
for|for
control|(
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
init|;
name|clone
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|clone
argument_list|)
condition|;
name|clone
operator|=
name|TREE_CHAIN
argument_list|(
name|clone
argument_list|)
operator|,
name|first
operator|=
literal|0
control|)
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|clone_parm
decl_stmt|;
name|int
name|parmno
decl_stmt|;
name|splay_tree
name|decl_map
decl_stmt|;
comment|/* Update CLONE's source position information to match FN's.  */
name|DECL_SOURCE_FILE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_COMDAT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_WEAK
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_WEAK
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_ONE_ONLY
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_USE_TEMPLATE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_INTERFACE_KNOWN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|clone
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Adjust the parameter names and locations. */
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
expr_stmt|;
comment|/* Update the `this' parameter, which is always first.  */
name|update_cloned_parm
argument_list|(
name|parm
argument_list|,
name|clone_parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
control|)
block|{
comment|/* Update this parameter.  */
name|update_cloned_parm
argument_list|(
name|parm
argument_list|,
name|clone_parm
argument_list|)
expr_stmt|;
comment|/* We should only give unused information for one clone. */
if|if
condition|(
operator|!
name|first
condition|)
name|TREE_USED
argument_list|(
name|clone_parm
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Start processing the function.  */
name|push_to_top_level
argument_list|()
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|clone
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* Remap the parameters.  */
name|decl_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|parmno
operator|=
literal|0
operator|,
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
operator|,
name|clone_parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|clone
argument_list|)
init|;
name|parm
condition|;
operator|++
name|parmno
operator|,
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
comment|/* Map the in-charge parameter to an appropriate constant.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|parmno
operator|==
literal|1
condition|)
block|{
name|tree
name|in_charge
decl_stmt|;
name|in_charge
operator|=
name|in_charge_arg_for_name
argument_list|(
name|DECL_NAME
argument_list|(
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|in_charge
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
name|vtt_parm_identifier
condition|)
block|{
comment|/* For a subobject constructor or destructor, the next 		 argument is the VTT parameter.  Remap the VTT_PARM 		 from the CLONE to this parameter.  */
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|clone
argument_list|)
condition|)
block|{
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|clone_parm
argument_list|)
operator|=
name|parm
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|clone_parm
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, map the VTT parameter to `NULL'.  */
else|else
block|{
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|null_pointer_node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Map other parameters to their equivalents in the cloned 	     function.  */
else|else
block|{
name|splay_tree_insert
argument_list|(
name|decl_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|parm
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|clone_parm
argument_list|)
expr_stmt|;
name|clone_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|clone_parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clone the body.  */
name|clone_body
argument_list|(
name|clone
argument_list|,
name|fn
argument_list|,
name|decl_map
argument_list|)
expr_stmt|;
comment|/* There are as many statements in the clone as in the 	 original.  */
name|DECL_NUM_STMTS
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_NUM_STMTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|splay_tree_delete
argument_list|(
name|decl_map
argument_list|)
expr_stmt|;
comment|/* Now, expand this function into RTL, if appropriate.  */
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|clone
argument_list|)
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|expand_body
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
comment|/* We don't need to process the original function any further.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dump FUNCTION_DECL FN as tree dump PHASE. */
end_comment

begin_function
specifier|static
name|void
name|dump_function
parameter_list|(
name|phase
parameter_list|,
name|fn
parameter_list|)
name|enum
name|tree_dump_index
name|phase
decl_stmt|;
name|tree
name|fn
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|stream
operator|=
name|dump_begin
argument_list|(
name|phase
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n;; Function %s"
argument_list|,
name|decl_as_string
argument_list|(
name|fn
argument_list|,
name|TFF_DECL_SPECIFIERS
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" (%s)\n"
argument_list|,
name|decl_as_string
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|";; enabled by -%s\n"
argument_list|,
name|dump_flag_name
argument_list|(
name|phase
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_node
argument_list|(
name|fn
argument_list|,
name|TDF_SLIM
operator||
name|flags
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|phase
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

