begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interface to LUCID Cadillac system for GNU compiler.    Copyright (C) 1988, 1992, 1993 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CADILLAC
end_ifdef

begin_include
include|#
directive|include
file|<compilerreq.h>
end_include

begin_include
include|#
directive|include
file|<compilerconn.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
name|void
name|init_cadillac
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put random information we might want to get back from    Cadillac here.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The connection to the Cadillac kernel.  */
name|Connection
modifier|*
name|conn
decl_stmt|;
comment|/* Input and output file descriptors for Cadillac.  */
name|short
name|fd_input
decl_stmt|,
name|fd_output
decl_stmt|;
comment|/* #include nesting of current file.  */
name|short
name|depth
decl_stmt|;
comment|/* State variables for the connection.  */
name|char
name|messages
decl_stmt|;
name|char
name|conversion
decl_stmt|;
name|char
name|emission
decl_stmt|;
name|char
name|process_until
decl_stmt|;
comment|/* #if level of current file.  */
name|int
name|iflevel
decl_stmt|;
comment|/* Line number that starts current source file.  */
name|int
name|lineno
decl_stmt|;
comment|/* Name of current file.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Where to stop processing (if process_until is set).  */
name|char
modifier|*
name|end_filename
decl_stmt|;
name|int
name|end_position
decl_stmt|;
block|}
name|cadillac_struct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|cadillac_struct
name|cadillacObj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if in the process of exiting.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exiting
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|cadillac_note_source
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CWriteLanguageDecl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CWriteLanguageType
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CWriteTopLevel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cadillac_note_filepos
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|cadillac_process_request
argument_list|()
decl_stmt|,
name|cadillac_process_requests
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cadillac_switch_source
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exit_cadillac
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Blocking test.  */
end_comment

begin_function
specifier|static
name|int
name|readable_p
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|fd_set
name|f
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
return|return
name|select
argument_list|(
literal|32
argument_list|,
operator|&
name|f
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CObjectType
modifier|*
name|tree_to_cadillac_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|cadillac_obstack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_include
include|#
directive|include
file|"stack.h"
end_include

begin_struct
struct|struct
name|context_level
block|{
name|struct
name|stack_level
name|base
decl_stmt|;
name|tree
name|context
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Stack for maintaining contexts (in case functions or types are nested).    When defining a struct type, the `context' field is the RECORD_TYPE.    When defining a function, the `context' field is the FUNCTION_DECL.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|context_level
modifier|*
name|context_stack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|context_level
modifier|*
name|push_context_level
parameter_list|(
name|stack
parameter_list|,
name|obstack
parameter_list|)
name|struct
name|stack_level
modifier|*
name|stack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
name|struct
name|context_level
name|tem
decl_stmt|;
name|tem
operator|.
name|base
operator|.
name|prev
operator|=
name|stack
expr_stmt|;
return|return
operator|(
expr|struct
name|context_level
operator|*
operator|)
name|push_stack_level
argument_list|(
name|obstack
argument_list|,
operator|&
name|tem
argument_list|,
sizeof|sizeof
argument_list|(
name|tem
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discard a level of search allocation.  */
end_comment

begin_function
specifier|static
name|struct
name|context_level
modifier|*
name|pop_context_level
parameter_list|(
name|stack
parameter_list|)
name|struct
name|context_level
modifier|*
name|stack
decl_stmt|;
block|{
name|stack
operator|=
operator|(
expr|struct
name|context_level
operator|*
operator|)
name|pop_stack_level
argument_list|(
name|stack
argument_list|)
expr_stmt|;
return|return
name|stack
return|;
block|}
end_function

begin_function
name|void
name|init_cadillac
parameter_list|()
block|{
specifier|extern
name|FILE
modifier|*
name|finput
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|CCompilerMessage
modifier|*
name|req
decl_stmt|;
name|cadillac_struct
modifier|*
name|cp
init|=
operator|&
name|cadillacObj
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|flag_cadillac
condition|)
return|return;
name|tree_to_cadillac_map
operator|=
operator|(
name|CObjectType
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CObjectType
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
name|tree_to_cadillac_map
index|[
name|i
index|]
operator|=
name|MiscOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|RECORD_TYPE
index|]
operator|=
name|StructOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|UNION_TYPE
index|]
operator|=
name|UnionOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|ENUMERAL_TYPE
index|]
operator|=
name|EnumTypeOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|TYPE_DECL
index|]
operator|=
name|TypedefOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|VAR_DECL
index|]
operator|=
name|VariableOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|CONST_DECL
index|]
operator|=
name|EnumConstantOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|FUNCTION_DECL
index|]
operator|=
name|FunctionOType
expr_stmt|;
name|tree_to_cadillac_map
index|[
name|FIELD_DECL
index|]
operator|=
name|FieldOType
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
name|on_exit
argument_list|(
operator|&
name|exit_cadillac
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_obstack_init
argument_list|(
operator|&
name|cadillac_obstack
argument_list|)
expr_stmt|;
comment|/* Yow!  This is the way Cadillac was designed to deal with      Oregon C++ compiler!  */
name|cp
operator|->
name|fd_input
operator|=
name|flag_cadillac
expr_stmt|;
name|cp
operator|->
name|fd_output
operator|=
name|flag_cadillac
expr_stmt|;
comment|/* Start in "turned-on" state.  */
name|cp
operator|->
name|messages
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|conversion
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|emission
operator|=
literal|1
expr_stmt|;
comment|/* Establish a connection with Cadillac here.  */
name|cp
operator|->
name|conn
operator|=
name|NewConnection
argument_list|(
name|cp
argument_list|,
name|cp
operator|->
name|fd_input
argument_list|,
name|cp
operator|->
name|fd_output
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|cp
operator|->
name|conn
argument_list|,
name|WaitingMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|cp
operator|->
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readable_p
argument_list|(
name|cp
operator|->
name|fd_input
argument_list|)
condition|)
empty_stmt|;
name|req
operator|=
name|CReadCompilerMessage
argument_list|(
name|cp
operator|->
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EWOULDBLOCK
case|:
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|fatal
argument_list|(
literal|"init_cadillac: EOF on connection to kernel, exiting\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"Editor to kernel connection"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cadillac_process_requests
parameter_list|(
name|conn
parameter_list|)
name|Connection
modifier|*
name|conn
decl_stmt|;
block|{
name|CCompilerMessage
modifier|*
name|req
decl_stmt|;
while|while
condition|(
name|req
operator|=
operator|(
name|CCompilerMessage
operator|*
operator|)
name|CPeekNextRequest
argument_list|(
name|conn
argument_list|)
condition|)
block|{
name|req
operator|=
name|CReadCompilerMessage
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_request
argument_list|(
operator|&
name|cadillacObj
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cadillac_process_request
parameter_list|(
name|cp
parameter_list|,
name|req
parameter_list|)
name|cadillac_struct
modifier|*
name|cp
decl_stmt|;
name|CCompilerMessage
modifier|*
name|req
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|req
condition|)
return|return;
switch|switch
condition|(
name|req
operator|->
name|reqType
condition|)
block|{
case|case
name|ProcessUntilMType
case|:
if|if
condition|(
name|cp
operator|->
name|process_until
condition|)
name|my_friendly_abort
argument_list|(
literal|23
argument_list|)
expr_stmt|;
name|cp
operator|->
name|process_until
operator|=
literal|1
expr_stmt|;
comment|/* This is not really right.  */
name|cp
operator|->
name|end_position
operator|=
operator|(
operator|(
name|CCompilerCommand
operator|*
operator|)
name|req
operator|)
operator|->
name|processuntil
operator|.
name|position
expr_stmt|;
if|#
directive|if
literal|0
block|cp->end_filename = req->processuntil.filename;
endif|#
directive|endif
break|break;
case|case
name|CommandMType
case|:
switch|switch
condition|(
name|req
operator|->
name|header
operator|.
name|data
condition|)
block|{
case|case
name|MessagesOnCType
case|:
name|cp
operator|->
name|messages
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MessagesOffCType
case|:
name|cp
operator|->
name|messages
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ConversionOnCType
case|:
name|cp
operator|->
name|conversion
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ConversionOffCType
case|:
name|cp
operator|->
name|conversion
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EmissionOnCType
case|:
name|cp
operator|->
name|emission
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EmissionOffCType
case|:
name|cp
operator|->
name|emission
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FinishAnalysisCType
case|:
return|return;
case|case
name|PuntAnalysisCType
case|:
case|case
name|ContinueAnalysisCType
case|:
case|case
name|GotoFileposCType
case|:
case|case
name|OpenSucceededCType
case|:
case|case
name|OpenFailedCType
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"request type %d not implemented\n"
argument_list|,
name|req
operator|->
name|reqType
argument_list|)
expr_stmt|;
return|return;
case|case
name|DieCType
case|:
if|if
condition|(
operator|!
name|exiting
condition|)
name|my_friendly_abort
argument_list|(
literal|24
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown request type %d"
argument_list|,
name|req
operator|->
name|reqType
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cadillac_start
parameter_list|()
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|CCompilerMessage
modifier|*
name|req
decl_stmt|;
comment|/* Let Cadillac know that we start in C++ language scope.  */
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|ForeignLinkageMType
argument_list|,
name|LinkCPlus
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cadillac_printf
parameter_list|(
name|msg
parameter_list|,
name|name
parameter_list|)
block|{
if|if
condition|(
name|cadillacObj
operator|.
name|messages
condition|)
name|printf
argument_list|(
literal|"[%s,%4d] %s `%s'\n"
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|msg
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_start_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|CObjectType
name|object_type
init|=
name|tree_to_cadillac_map
index|[
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|context_stack
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context_stack
operator|->
name|context
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Currently, cadillac only implements top-level forms.  */
return|return;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|cadillac_printf
argument_list|(
literal|"start class-level decl"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|25
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cadillac_printf
argument_list|(
literal|"start top-level decl"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StartMType
argument_list|)
expr_stmt|;
block|}
name|CWriteLanguageDecl
argument_list|(
name|conn
argument_list|,
name|decl
argument_list|,
name|tree_to_cadillac_map
index|[
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
if|if
condition|(
name|context_stack
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context_stack
operator|->
name|context
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
return|return;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|cadillac_printf
argument_list|(
literal|"end class-level decl"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|26
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cadillac_printf
argument_list|(
literal|"end top-level decl"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StopMType
argument_list|)
expr_stmt|;
block|}
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_start_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
if|if
condition|(
name|context_stack
condition|)
comment|/* nested functions not yet handled.  */
name|my_friendly_abort
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|cadillac_printf
argument_list|(
literal|"start top-level function"
argument_list|,
name|lang_printable_name
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|context_stack
operator|=
name|push_context_level
argument_list|(
name|context_stack
argument_list|,
operator|&
name|cadillac_obstack
argument_list|)
expr_stmt|;
name|context_stack
operator|->
name|context
operator|=
name|fndecl
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StartMType
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|202
argument_list|)
expr_stmt|;
name|CWriteLanguageDecl
argument_list|(
name|conn
argument_list|,
name|fndecl
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|MemberFnOType
else|:
name|FunctionOType
operator|)
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|cadillac_printf
argument_list|(
literal|"end top-level function"
argument_list|,
name|lang_printable_name
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|context_stack
operator|=
name|pop_context_level
argument_list|(
name|context_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack
condition|)
comment|/* nested functions not yet implemented.  */
name|my_friendly_abort
argument_list|(
literal|28
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StopMType
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_anon_union
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
if|if
condition|(
operator|!
name|global_bindings_p
argument_list|()
condition|)
return|return;
name|cadillac_printf
argument_list|(
literal|"finish top-level anon union"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StopMType
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_start_enum
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context_stack
operator|->
name|context
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
return|return;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|29
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cadillac_printf
argument_list|(
literal|"start top-level enum"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StartMType
argument_list|)
expr_stmt|;
block|}
name|CWriteLanguageType
argument_list|(
name|conn
argument_list|,
name|type
argument_list|,
name|tree_to_cadillac_map
index|[
name|ENUMERAL_TYPE
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_enum
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context_stack
operator|->
name|context
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
return|return;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_printf
argument_list|(
literal|"finish top-level enum"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StopMType
argument_list|)
expr_stmt|;
block|}
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_start_struct
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|context_stack
operator|->
name|context
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
return|return;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
return|return;
default|default:
name|my_friendly_abort
argument_list|(
literal|31
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cadillac_printf
argument_list|(
literal|"start struct"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StartMType
argument_list|)
expr_stmt|;
block|}
name|context_stack
operator|=
name|push_context_level
argument_list|(
name|context_stack
argument_list|,
operator|&
name|cadillac_obstack
argument_list|)
expr_stmt|;
name|context_stack
operator|->
name|context
operator|=
name|type
expr_stmt|;
name|CWriteLanguageType
argument_list|(
name|conn
argument_list|,
name|type
argument_list|,
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|type
argument_list|)
condition|?
name|ClassOType
else|:
name|tree_to_cadillac_map
index|[
name|TREE_CODE
argument_list|(
name|type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_struct
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|context_stack
operator|=
name|pop_context_level
argument_list|(
name|context_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack
condition|)
return|return;
name|cadillac_printf
argument_list|(
literal|"finish struct"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StopMType
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_exception
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|fatal
argument_list|(
literal|"cadillac_finish_exception"
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|EndDefMType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteTopLevel
argument_list|(
name|conn
argument_list|,
name|StopMType
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_push_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|cadillac_pop_class
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|cadillac_push_lang
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|CLinkLanguageType
name|m
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
name|m
operator|=
name|LinkCPlus
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
name|m
operator|=
name|LinkC
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|ForeignLinkageMType
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_pop_lang
parameter_list|()
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|ForeignLinkageMType
argument_list|,
name|LinkPop
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_finish_stmt
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_function
name|void
name|cadillac_note_source
parameter_list|()
block|{
name|cadillacObj
operator|.
name|lineno
operator|=
name|lineno
expr_stmt|;
name|cadillacObj
operator|.
name|filename
operator|=
name|input_filename
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CWriteTopLevel
parameter_list|(
name|conn
parameter_list|,
name|m
parameter_list|)
name|Connection
modifier|*
name|conn
decl_stmt|;
name|CMessageSubType
name|m
decl_stmt|;
block|{
specifier|static
name|context_id
operator|=
literal|0
expr_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|TopLevelFormMType
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cadillac_note_filepos
argument_list|()
expr_stmt|;
comment|/* Eventually, this will point somewhere into the digest file.  */
name|context_id
operator|+=
literal|1
expr_stmt|;
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|context_id
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS32
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|cadillacObj
operator|.
name|iflevel
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS32
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cadillac_note_filepos
parameter_list|()
block|{
specifier|extern
name|FILE
modifier|*
name|finput
decl_stmt|;
name|int
name|pos
init|=
name|ftell
argument_list|(
name|finput
argument_list|)
decl_stmt|;
name|CWriteSomething
argument_list|(
name|cadillacObj
operator|.
name|conn
argument_list|,
operator|&
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_switch_source
parameter_list|(
name|startflag
parameter_list|)
name|int
name|startflag
decl_stmt|;
block|{
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
comment|/* Send out the name of the source file being compiled.  */
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|SourceFileMType
argument_list|,
name|startflag
condition|?
name|StartMType
else|:
name|StopMType
argument_list|)
expr_stmt|;
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|cadillacObj
operator|.
name|depth
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS16
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteVstring0
argument_list|(
name|conn
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_push_source
parameter_list|()
block|{
name|cadillacObj
operator|.
name|depth
operator|+=
literal|1
expr_stmt|;
name|cadillac_switch_source
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cadillac_pop_source
parameter_list|()
block|{
name|cadillacObj
operator|.
name|depth
operator|-=
literal|1
expr_stmt|;
name|cadillac_switch_source
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|cadillac_mdep
block|{
name|short
name|object_type
decl_stmt|;
name|char
name|linkage
decl_stmt|;
name|char
name|access
decl_stmt|;
name|short
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|CWriteLanguageElem
parameter_list|(
name|conn
parameter_list|,
name|p
parameter_list|,
name|name
parameter_list|)
name|Connection
modifier|*
name|conn
decl_stmt|;
name|struct
name|cadillac_mdep
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|p
operator|->
name|object_type
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS16
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|p
operator|->
name|linkage
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS8
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|p
operator|->
name|access
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS8
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteSomething
argument_list|(
name|conn
argument_list|,
operator|&
name|p
operator|->
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|BITS16
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteVstring0
argument_list|(
name|conn
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Don't write date_type.  */
block|CWriteVstring0 (conn, "");
endif|#
directive|endif
name|CWriteLength
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CWriteLanguageDecl
parameter_list|(
name|conn
parameter_list|,
name|decl
parameter_list|,
name|object_type
parameter_list|)
name|Connection
modifier|*
name|conn
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|CObjectType
name|object_type
decl_stmt|;
block|{
name|struct
name|cadillac_mdep
name|foo
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|LanguageElementMType
argument_list|,
name|StartDefineMType
argument_list|)
expr_stmt|;
name|foo
operator|.
name|object_type
operator|=
name|object_type
expr_stmt|;
if|if
condition|(
name|decl_type_context
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|foo
operator|.
name|linkage
operator|=
name|ParentLinkage
expr_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|foo
operator|.
name|access
operator|=
name|PrivateAccess
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|foo
operator|.
name|access
operator|=
name|ProtectedAccess
expr_stmt|;
else|else
name|foo
operator|.
name|access
operator|=
name|PublicAccess
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|foo
operator|.
name|linkage
operator|=
name|GlobalLinkage
expr_stmt|;
else|else
name|foo
operator|.
name|linkage
operator|=
name|FileLinkage
expr_stmt|;
name|foo
operator|.
name|access
operator|=
name|PublicAccess
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|foo
operator|.
name|length
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|CWriteLanguageElem
argument_list|(
name|conn
argument_list|,
operator|&
name|foo
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CWriteLanguageType
parameter_list|(
name|conn
parameter_list|,
name|type
parameter_list|,
name|object_type
parameter_list|)
name|Connection
modifier|*
name|conn
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|CObjectType
name|object_type
decl_stmt|;
block|{
name|struct
name|cadillac_mdep
name|foo
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|LanguageElementMType
argument_list|,
name|StartDefineMType
argument_list|)
expr_stmt|;
name|foo
operator|.
name|object_type
operator|=
name|object_type
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
block|{
name|foo
operator|.
name|linkage
operator|=
name|ParentLinkage
expr_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|type
argument_list|)
condition|)
name|foo
operator|.
name|access
operator|=
name|PrivateAccess
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|type
argument_list|)
condition|)
name|foo
operator|.
name|access
operator|=
name|ProtectedAccess
expr_stmt|;
else|else
name|foo
operator|.
name|access
operator|=
name|PublicAccess
expr_stmt|;
block|}
else|else
block|{
name|foo
operator|.
name|linkage
operator|=
name|NoLinkage
expr_stmt|;
name|foo
operator|.
name|access
operator|=
name|PublicAccess
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|foo
operator|.
name|length
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|CWriteLanguageElem
argument_list|(
name|conn
argument_list|,
operator|&
name|foo
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CWriteUseObject
parameter_list|(
name|conn
parameter_list|,
name|type
parameter_list|,
name|object_type
parameter_list|,
name|use
parameter_list|)
name|Connection
modifier|*
name|conn
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|CObjectType
name|object_type
decl_stmt|;
name|CMessageSubType
name|use
decl_stmt|;
block|{
name|struct
name|cadillac_mdep
name|foo
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|LanguageElementMType
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|foo
operator|.
name|object_type
operator|=
name|object_type
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
block|{
name|foo
operator|.
name|linkage
operator|=
name|ParentLinkage
expr_stmt|;
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|type
argument_list|)
condition|)
name|foo
operator|.
name|access
operator|=
name|PrivateAccess
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|type
argument_list|)
condition|)
name|foo
operator|.
name|access
operator|=
name|ProtectedAccess
expr_stmt|;
else|else
name|foo
operator|.
name|access
operator|=
name|PublicAccess
expr_stmt|;
block|}
else|else
block|{
name|foo
operator|.
name|linkage
operator|=
name|NoLinkage
expr_stmt|;
name|foo
operator|.
name|access
operator|=
name|PublicAccess
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|name
operator|=
name|DECL_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|33
argument_list|)
expr_stmt|;
block|}
name|foo
operator|.
name|length
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|CWriteLanguageElem
argument_list|(
name|conn
argument_list|,
operator|&
name|foo
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_requests
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here's how we exit under cadillac.  */
end_comment

begin_function
specifier|static
name|void
name|exit_cadillac
parameter_list|()
block|{
specifier|extern
name|int
name|errorcount
decl_stmt|;
name|Connection
modifier|*
name|conn
init|=
name|cadillacObj
operator|.
name|conn
decl_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
block|{
name|CCompilerMessage
modifier|*
name|req
decl_stmt|;
name|CWriteHeader
argument_list|(
name|conn
argument_list|,
name|FinishedMType
argument_list|,
name|errorcount
condition|?
literal|0
else|:
name|CsObjectWritten
operator||
name|CsComplete
argument_list|)
expr_stmt|;
comment|/* Bye, bye!  */
name|CWriteRequestBuffer
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* Block on read.  */
while|while
condition|(
operator|!
name|readable_p
argument_list|(
name|cadillacObj
operator|.
name|fd_input
argument_list|)
condition|)
block|{
if|if
condition|(
name|exiting
condition|)
name|my_friendly_abort
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
block|}
name|exiting
operator|=
literal|1
expr_stmt|;
name|req
operator|=
name|CReadCompilerMessage
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cadillac_process_request
argument_list|(
operator|&
name|cadillacObj
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Stubs.  */
end_comment

begin_function
name|void
name|init_cadillac
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_start
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_start_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_finish_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_start_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_finish_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_finish_anon_union
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_start_enum
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_finish_enum
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_start_struct
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_finish_struct
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_finish_exception
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_push_class
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_pop_class
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_push_lang
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{}
end_function

begin_function
name|void
name|cadillac_pop_lang
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_note_source
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_finish_stmt
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_switch_source
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_push_source
parameter_list|()
block|{}
end_function

begin_function
name|void
name|cadillac_pop_source
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

