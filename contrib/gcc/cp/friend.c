begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Help friends in C++.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Friend data structures are described in cp-tree.h.  */
end_comment

begin_comment
comment|/* Returns nonzero if SUPPLICANT is a friend of TYPE.  */
end_comment

begin_function
name|int
name|is_friend
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|supplicant
parameter_list|)
block|{
name|int
name|declp
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|supplicant
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|declp
operator|=
name|DECL_P
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
if|if
condition|(
name|declp
condition|)
comment|/* It's a function decl.  */
block|{
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|supplicant
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
name|tree
name|friend
init|=
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
decl_stmt|;
if|if
condition|(
name|friend
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|supplicant
operator|==
name|friend
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_specialization_of_friend
argument_list|(
name|supplicant
argument_list|,
name|friend
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
break|break;
block|}
block|}
block|}
else|else
comment|/* It's a type.  */
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|supplicant
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|is_specialization_of_friend
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|,
name|t
argument_list|)
else|:
name|same_type_p
argument_list|(
name|supplicant
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|declp
condition|)
block|{
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_CLASS_SCOPE_P
argument_list|(
name|supplicant
argument_list|)
condition|)
comment|/* Nested classes get the same access as their enclosing types, as 	   per DR 45 (this is a change from the standard).  */
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
else|else
comment|/* Local classes have the same access as the enclosing function.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A namespace is not friend to anybody.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
condition|)
return|return
name|is_friend
argument_list|(
name|type
argument_list|,
name|context
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new friend to the friends of the aggregate type TYPE.    DECL is the FUNCTION_DECL of the friend being added.     If COMPLAIN is true, warning about duplicate friend is issued.    We want to have this diagnostics during parsing but not    when a template is being instantiated.  */
end_comment

begin_function
name|void
name|add_friend
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|typedecl
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qD is already a friend of class %qT"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|ctx
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already    been defined, we make all of its member functions friends of    TYPE.  If not, we make it a pending friend, which can later be added    when its definition is seen.  If a type is defined, then its TYPE_DECL's    DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend    classes that are not defined.  If a type has not yet been defined,    then the DECL_WAITING_FRIENDS contains a list of types    waiting to make it their friend.  Note that these two can both    be in use at the same time!     If COMPLAIN is true, warning about duplicate friend is issued.    We want to have this diagnostics during parsing but not    when a template is being instantiated.  */
end_comment

begin_function
name|void
name|make_friend_class
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|friend_type
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|classes
decl_stmt|;
comment|/* CLASS_TEMPLATE_DEPTH counts the number of template headers for      the enclosing class.  FRIEND_DEPTH counts the number of template      headers used for this friend declaration.  TEMPLATE_MEMBER_P,      defined inside the `if' block for TYPENAME_TYPE case, is true if      a template header in FRIEND_DEPTH is intended for DECLARATOR.      For example, the code         template<class T> struct A { 	 template<class U> struct B { 	   template<class V> template<class W> 	     friend class C<V>::D; 	 };        };       will eventually give the following results       1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U').      2. FRIEND_DEPTH equals 2 (for `V' and `W').      3. TEMPLATE_MEMBER_P is true (for `W').       The friend is a template friend iff FRIEND_DEPTH is nonzero.  */
name|int
name|class_template_depth
init|=
name|template_class_depth
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|friend_depth
init|=
name|processing_template_decl
operator|-
name|class_template_depth
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid type %qT declared %<friend%>"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|friend_depth
condition|)
comment|/* If the TYPE is a template then it makes sense for it to be        friends with itself; this means that each instantiation is        friends with all other instantiations.  */
block|{
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
comment|/* [temp.friend] 	     Friend declarations shall not declare partial 	     specializations.  */
name|error
argument_list|(
literal|"partial specialization %qT declared %<friend%>"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|pedwarn
argument_list|(
literal|"class %qT is implicitly friends with itself"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* [temp.friend]       A friend of a class or class template can be a function or      class template, a specialization of a function template or      class template, or an ordinary (nontemplate) function or      class.  */
if|if
condition|(
operator|!
name|friend_depth
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|friend_type
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* template<class U> friend class T::X<U>; */
comment|/* [temp.friend] 	     Friend declarations shall not declare partial 	     specializations.  */
name|error
argument_list|(
literal|"partial specialization %qT declared %<friend%>"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* We will figure this out later.  */
name|bool
name|template_member_p
init|=
name|false
decl_stmt|;
name|tree
name|ctype
init|=
name|TYPE_CONTEXT
argument_list|(
name|friend_type
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|friend_type
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms_level
argument_list|(
name|ctype
argument_list|,
name|class_template_depth
operator|+
name|friend_depth
argument_list|)
condition|)
name|template_member_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|class_template_depth
condition|)
block|{
comment|/* We rely on tsubst_friend_class to check the 		 validity of the declaration later.  */
if|if
condition|(
name|template_member_p
condition|)
name|friend_type
operator|=
name|make_unbound_class_template
argument_list|(
name|ctype
argument_list|,
name|name
argument_list|,
name|current_template_parms
argument_list|,
name|tf_error
argument_list|)
expr_stmt|;
else|else
name|friend_type
operator|=
name|make_typename_type
argument_list|(
name|ctype
argument_list|,
name|name
argument_list|,
name|class_type
argument_list|,
name|tf_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|lookup_member
argument_list|(
name|ctype
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
name|error
argument_list|(
literal|"%qT is not a member of %qT"
argument_list|,
name|name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|template_member_p
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qT is not a member class template of %qT"
argument_list|,
name|name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+D declared here"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|template_member_p
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
operator|!
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%qT is not a nested class of %qT"
argument_list|,
name|name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%q+D declared here"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
name|friend_type
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
comment|/* template<class T> friend class T; */
name|error
argument_list|(
literal|"template parameter type %qT declared %<friend%>"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
comment|/* template<class T> friend class A; where A is not a template */
name|error
argument_list|(
literal|"%q#T is not a template"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* template<class T> friend class A; where A is a template */
name|friend_type
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|friend_type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* See if it is already a friend.  */
for|for
control|(
name|classes
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
init|;
name|classes
condition|;
name|classes
operator|=
name|TREE_CHAIN
argument_list|(
name|classes
argument_list|)
control|)
block|{
name|tree
name|probe
init|=
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|friend_type
operator|==
name|probe
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qD is already a friend of %qT"
argument_list|,
name|probe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|probe
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|probe
argument_list|,
name|friend_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qT is already a friend of %qT"
argument_list|,
name|probe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|classes
condition|)
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|friend_type
argument_list|,
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|friend_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|friend_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record DECL (a FUNCTION_DECL) as a friend of the    CURRENT_CLASS_TYPE.  If DECL is a member function, CTYPE is the    class of which it is a member, as named in the friend declaration.    DECLARATOR is the name of the friend.  FUNCDEF_FLAG is true if the    friend declaration is a definition of the function.  FLAGS is as    for grokclass fn.  */
end_comment

begin_function
name|tree
name|do_friend
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|declarator
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|attrlist
parameter_list|,
name|enum
name|overload_flags
name|flags
parameter_list|,
name|bool
name|funcdef_flag
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|ctype
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Every decl that gets here is a friend of something.  */
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|declarator
argument_list|)
condition|)
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctype
condition|)
block|{
comment|/* CLASS_TEMPLATE_DEPTH counts the number of template headers for 	 the enclosing class.  FRIEND_DEPTH counts the number of template 	 headers used for this friend declaration.  TEMPLATE_MEMBER_P is 	 true if a template header in FRIEND_DEPTH is intended for 	 DECLARATOR.  For example, the code  	   template<class T> struct A { 	     template<class U> struct B { 	       template<class V> template<class W> 		 friend void C<V>::f(W); 	     }; 	   };  	 will eventually give the following results  	 1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U'). 	 2. FRIEND_DEPTH equals 2 (for `V' and `W'). 	 3. TEMPLATE_MEMBER_P is true (for `W').  */
name|int
name|class_template_depth
init|=
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|friend_depth
init|=
name|processing_template_decl
operator|-
name|class_template_depth
decl_stmt|;
comment|/* We will figure this out later.  */
name|bool
name|template_member_p
init|=
name|false
decl_stmt|;
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* A method friend.  */
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|declarator
operator|==
name|cname
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|friend_depth
condition|)
block|{
if|if
condition|(
operator|!
name|uses_template_parms_level
argument_list|(
name|ctype
argument_list|,
name|class_template_depth
operator|+
name|friend_depth
argument_list|)
condition|)
name|template_member_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* A nested class may declare a member of an enclosing class 	 to be a friend, so we do lookup here even if CTYPE is in 	 the process of being defined.  */
if|if
condition|(
name|class_template_depth
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* DECL is a template specialization.  No need to 	       build a new TEMPLATE_DECL.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|class_template_depth
condition|)
comment|/* We rely on tsubst_friend_function to check the 	       validity of the declaration later.  */
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
name|true
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|template_member_p
condition|?
name|current_template_parms
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_member_p
operator|&&
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"member %qD declared as friend before type %qT defined"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
comment|/* A global friend.      @@ or possibly a friend from a base class ?!?  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|is_friend_template
init|=
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
decl_stmt|;
comment|/* Friends must all go through the overload machinery, 	 even though they may not technically be overloaded.  	 Note that because classes all wind up being top-level 	 in their scope, their friend wind up in top-level scope as well.  */
if|if
condition|(
name|funcdef_flag
condition|)
name|SET_DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We must check whether the decl refers to template 	     arguments before push_template_decl_real adds a 	     reference to the containing template class.  */
name|int
name|warn
init|=
operator|(
name|warn_nontemplate_friend
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|is_friend_template
operator|&&
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|is_friend_template
operator|||
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|!=
literal|0
condition|)
comment|/* We can't call pushdecl for a template class, since in 	       general, such a declaration depends on template 	       parameters.  Instead, we call pushdecl when the class 	       is instantiated.  */
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
comment|/* This must be a local class, so pushdecl will be ok, and 	       insert an unqualified friend into the local scope 	       (rather than the containing namespace scope, which the 	       next choice will do).  */
name|decl
operator|=
name|pushdecl_maybe_friend
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
name|true
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We can't use pushdecl, as we might be in a template 		 class specialization, and pushdecl will insert an 		 unqualified friend decl into the template parameter 		 scope, rather than the namespace containing it.  */
name|tree
name|ns
init|=
name|decl_namespace_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
name|true
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"friend declaration %q#D declares a non-template "
literal|"function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"(if this is not what you intended, make sure "
literal|"the function template has already been declared "
literal|"and add<> after the function name here) "
literal|"-Wno-non-template-friend disables this warning"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|is_friend_template
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
else|:
name|decl
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Unfortunately, we have to handle attributes here.  Normally we would      handle them in start_decl_1, but since this is a friend decl start_decl_1      never gets to see it.  */
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

end_unit

