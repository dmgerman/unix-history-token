begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Help friends in C++.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Friend data structures are described in cp-tree.h.  */
end_comment

begin_comment
comment|/* Returns nonzero if SUPPLICANT is a friend of TYPE.  */
end_comment

begin_function
name|int
name|is_friend
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|supplicant
parameter_list|)
block|{
name|int
name|declp
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|supplicant
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|declp
operator|=
name|DECL_P
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
if|if
condition|(
name|declp
condition|)
comment|/* It's a function decl.  */
block|{
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|supplicant
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
name|tree
name|friend
init|=
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
decl_stmt|;
if|if
condition|(
name|friend
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|supplicant
operator|==
name|friend
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is_specialization_of_friend
argument_list|(
name|supplicant
argument_list|,
name|friend
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
break|break;
block|}
block|}
block|}
else|else
comment|/* It's a type.  */
block|{
comment|/* Nested classes are implicitly friends of their enclosing types, as 	 per core issue 45 (this is a change from the standard).  */
for|for
control|(
name|context
operator|=
name|supplicant
init|;
name|context
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|;
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
control|)
if|if
condition|(
name|type
operator|==
name|context
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|is_specialization_of
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|,
name|t
argument_list|)
else|:
name|same_type_p
argument_list|(
name|supplicant
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|declp
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|declp
condition|)
comment|/* Local classes have the same access as the enclosing function.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* A namespace is not friend to anybody.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
condition|)
return|return
name|is_friend
argument_list|(
name|type
argument_list|,
name|context
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new friend to the friends of the aggregate type TYPE.    DECL is the FUNCTION_DECL of the friend being added.     If COMPLAIN is true, warning about duplicate friend is issued.    We want to have this diagnostics during parsing but not    when a template is being instantiated.  */
end_comment

begin_function
name|void
name|add_friend
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|typedecl
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|warning
argument_list|(
literal|"`%D' is already a friend of class `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|class_binfo
init|=
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|BINFO_TYPE
argument_list|(
name|class_binfo
argument_list|)
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|class_binfo
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already    been defined, we make all of its member functions friends of    TYPE.  If not, we make it a pending friend, which can later be added    when its definition is seen.  If a type is defined, then its TYPE_DECL's    DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend    classes that are not defined.  If a type has not yet been defined,    then the DECL_WAITING_FRIENDS contains a list of types    waiting to make it their friend.  Note that these two can both    be in use at the same time!     If COMPLAIN is true, warning about duplicate friend is issued.    We want to have this diagnostics during parsing but not    when a template is being instantiated.  */
end_comment

begin_function
name|void
name|make_friend_class
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|friend_type
parameter_list|,
name|bool
name|complain
parameter_list|)
block|{
name|tree
name|classes
decl_stmt|;
name|int
name|is_template_friend
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid type `%T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|type
argument_list|)
condition|)
comment|/* If the TYPE is a template then it makes sense for it to be        friends with itself; this means that each instantiation is        friends with all other instantiations.  */
block|{
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
comment|/* [temp.friend] 	     Friend declarations shall not declare partial 	     specializations.  */
name|error
argument_list|(
literal|"partial specialization `%T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|is_template_friend
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|pedwarn
argument_list|(
literal|"class `%T' is implicitly friends with itself"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|is_template_friend
operator|=
literal|0
expr_stmt|;
comment|/* [temp.friend]       A friend of a class or class template can be a function or      class template, a specialization of a function template or      class template, or an ordinary (nontemplate) function or      class.  */
if|if
condition|(
operator|!
name|is_template_friend
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
comment|/* template<class T> friend typename S<T>::X; */
name|error
argument_list|(
literal|"typename type `%#T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
comment|/* template<class T> friend class T; */
name|error
argument_list|(
literal|"template parameter type `%T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
comment|/* template<class T> friend class A; where A is not a template */
name|error
argument_list|(
literal|"`%#T' is not a template"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_template_friend
condition|)
name|friend_type
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
comment|/* See if it is already a friend.  */
for|for
control|(
name|classes
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
init|;
name|classes
condition|;
name|classes
operator|=
name|TREE_CHAIN
argument_list|(
name|classes
argument_list|)
control|)
block|{
name|tree
name|probe
init|=
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|friend_type
operator|==
name|probe
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|warning
argument_list|(
literal|"`%D' is already a friend of `%T'"
argument_list|,
name|probe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|probe
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|probe
argument_list|,
name|friend_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|warning
argument_list|(
literal|"`%T' is already a friend of `%T'"
argument_list|,
name|probe
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|classes
condition|)
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|friend_type
argument_list|,
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_template_friend
condition|)
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|friend_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|friend_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main friend processor.      CTYPE is the class this friend belongs to.     DECLARATOR is the name of the friend.     DECL is the FUNCTION_DECL that the friend is.     FLAGS is just used for `grokclassfn'.     QUALS say what special qualifies should apply to the object    pointed to by `this'.  */
end_comment

begin_function
name|tree
name|do_friend
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|declarator
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|attrlist
parameter_list|,
name|enum
name|overload_flags
name|flags
parameter_list|,
name|tree
name|quals
parameter_list|,
name|int
name|funcdef_flag
parameter_list|)
block|{
comment|/* Every decl that gets here is a friend of something.  */
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|declarator
argument_list|)
condition|)
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
comment|/* CLASS_TEMPLATE_DEPTH counts the number of template headers for 	 the enclosing class.  FRIEND_DEPTH counts the number of template 	 headers used for this friend declaration.  TEMPLATE_MEMBER_P is 	 true if a template header in FRIEND_DEPTH is intended for 	 DECLARATOR.  For example, the code  	   template<class T> struct A { 	     template<class U> struct B { 	       template<class V> template<class W> 		 friend void C<V>::f(W); 	     }; 	   };  	 will eventually give the following results  	 1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U'). 	 2. FRIEND_DEPTH equals 2 (for `V' and `W'). 	 3. TEMPLATE_MEMBER_P is true (for `W').  */
name|int
name|class_template_depth
init|=
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|friend_depth
init|=
name|processing_template_decl
operator|-
name|class_template_depth
decl_stmt|;
comment|/* We will figure this out later.  */
name|bool
name|template_member_p
init|=
name|false
decl_stmt|;
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* A method friend.  */
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|declarator
operator|==
name|cname
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This will set up DECL_ARGUMENTS for us.  */
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|friend_depth
condition|)
block|{
if|if
condition|(
operator|!
name|uses_template_parms_level
argument_list|(
name|ctype
argument_list|,
name|class_template_depth
operator|+
name|friend_depth
argument_list|)
condition|)
name|template_member_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* A nested class may declare a member of an enclosing class 	 to be a friend, so we do lookup here even if CTYPE is in 	 the process of being defined.  */
if|if
condition|(
name|class_template_depth
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* DECL is a template specialization.  No need to 	       build a new TEMPLATE_DECL.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|class_template_depth
condition|)
comment|/* We rely on tsubst_friend_function to check the 	       validity of the declaration later.  */
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
literal|1
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|template_member_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_member_p
operator|&&
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"member `%D' declared as friend before type `%T' defined"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
comment|/* A global friend.      @@ or possibly a friend from a base class ?!?  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|int
name|is_friend_template
init|=
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
decl_stmt|;
comment|/* Friends must all go through the overload machinery, 	 even though they may not technically be overloaded.  	 Note that because classes all wind up being top-level 	 in their scope, their friend wind up in top-level scope as well.  */
if|if
condition|(
name|funcdef_flag
condition|)
name|SET_DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We must check whether the decl refers to template 	     arguments before push_template_decl_real adds a 	     reference to the containing template class.  */
name|int
name|warn
init|=
operator|(
name|warn_nontemplate_friend
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|is_friend_template
operator|&&
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|is_friend_template
operator|||
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|!=
literal|0
condition|)
comment|/* We can't call pushdecl for a template class, since in 	       general, such a declaration depends on template 	       parameters.  Instead, we call pushdecl when the class 	       is instantiated.  */
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
comment|/* This must be a local class, so pushdecl will be ok, and 	       insert an unqualified friend into the local scope 	       (rather than the containing namespace scope, which the 	       next choice will do).  */
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We can't use pushdecl, as we might be in a template 	         class specialization, and pushdecl will insert an 	         unqualified friend decl into the template parameter 	         scope, rather than the namespace containing it.  */
name|tree
name|ns
init|=
name|decl_namespace_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
name|warning
argument_list|(
literal|"friend declaration `%#D' declares a non-template function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|"(if this is not what you intended, make sure the function template has already been declared and add<> after the function name here) -Wno-non-template-friend disables this warning"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|is_friend_template
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
else|:
name|decl
argument_list|,
comment|/*complain=*/
name|true
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Unfortunately, we have to handle attributes here.  Normally we would      handle them in start_decl_1, but since this is a friend decl start_decl_1      never gets to see it.  */
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

end_unit

