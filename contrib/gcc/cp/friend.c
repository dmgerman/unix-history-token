begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Help friends in C++.    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Friend data structures are described in cp-tree.h.  */
end_comment

begin_comment
comment|/* Returns nonzero if SUPPLICANT is a friend of TYPE.  */
end_comment

begin_function
name|int
name|is_friend
parameter_list|(
name|type
parameter_list|,
name|supplicant
parameter_list|)
name|tree
name|type
decl_stmt|,
name|supplicant
decl_stmt|;
block|{
name|int
name|declp
decl_stmt|;
specifier|register
name|tree
name|list
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|supplicant
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|declp
operator|=
name|DECL_P
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
if|if
condition|(
name|declp
condition|)
comment|/* It's a function decl.  */
block|{
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|supplicant
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|supplicant
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We haven't completed the instantiation yet.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|supplicant
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
literal|1
return|;
comment|/* Temporarily, we are more lenient to deal with 		     nested friend functions, for which there can be 		     more than one FUNCTION_DECL, despite being the 		     same function.  When that's fixed, this bit can 		     go.  */
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|supplicant
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|is_specialization_of
argument_list|(
name|supplicant
argument_list|,
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
break|break;
block|}
block|}
block|}
else|else
comment|/* It's a type.  */
block|{
comment|/* Nested classes are implicitly friends of their enclosing types, as 	 per core issue 45 (this is a change from the standard).  */
for|for
control|(
name|context
operator|=
name|supplicant
init|;
name|context
operator|&&
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|;
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
control|)
if|if
condition|(
name|type
operator|==
name|context
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|is_specialization_of
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|,
name|t
argument_list|)
else|:
name|same_type_p
argument_list|(
name|supplicant
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|declp
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|declp
condition|)
comment|/* Local classes have the same access as the enclosing function.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* A namespace is not friend to anybody.  */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
condition|)
return|return
name|is_friend
argument_list|(
name|type
argument_list|,
name|context
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new friend to the friends of the aggregate type TYPE.    DECL is the FUNCTION_DECL of the friend being added.  */
end_comment

begin_function
name|void
name|add_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|typedecl
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|FRIEND_NAME
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|FRIEND_DECLS
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%D' is already a friend of class `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous friend declaration of `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already    been defined, we make all of its member functions friends of    TYPE.  If not, we make it a pending friend, which can later be added    when its definition is seen.  If a type is defined, then its TYPE_DECL's    DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend    classes that are not defined.  If a type has not yet been defined,    then the DECL_WAITING_FRIENDS contains a list of types    waiting to make it their friend.  Note that these two can both    be in use at the same time!  */
end_comment

begin_function
name|void
name|make_friend_class
parameter_list|(
name|type
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|classes
decl_stmt|;
name|int
name|is_template_friend
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid type `%T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|type
argument_list|)
condition|)
comment|/* If the TYPE is a template then it makes sense for it to be        friends with itself; this means that each instantiation is        friends with all other instantiations.  */
block|{
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
comment|/* [temp.friend] 	     Friend declarations shall not declare partial 	     specializations.  */
name|error
argument_list|(
literal|"partial specialization `%T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|is_template_friend
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"class `%T' is implicitly friends with itself"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|is_template_friend
operator|=
literal|0
expr_stmt|;
comment|/* [temp.friend]       A friend of a class or class template can be a function or      class template, a specialization of a function template or      class template, or an ordinary (nontemplate) function or      class.  */
if|if
condition|(
operator|!
name|is_template_friend
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
comment|/* template<class T> friend typename S<T>::X; */
name|error
argument_list|(
literal|"typename type `%#T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
comment|/* template<class T> friend class T; */
name|error
argument_list|(
literal|"template parameter type `%T' declared `friend'"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
comment|/* template<class T> friend class A; where A is not a template */
name|error
argument_list|(
literal|"`%#T' is not a template"
argument_list|,
name|friend_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_template_friend
condition|)
name|friend_type
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
name|classes
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|classes
comment|/* Stop if we find the same type on the list.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|friend_type
operator|==
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
else|:
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|,
name|friend_type
argument_list|)
operator|)
condition|)
name|classes
operator|=
name|TREE_CHAIN
argument_list|(
name|classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|classes
condition|)
name|warning
argument_list|(
literal|"`%T' is already a friend of `%T'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|,
comment|/*friend_p=*/
literal|1
argument_list|)
expr_stmt|;
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|friend_type
argument_list|,
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_template_friend
condition|)
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|friend_type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|CLASSTYPE_BEFRIENDING_CLASSES
argument_list|(
name|friend_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main friend processor.  This is large, and for modularity purposes,    has been removed from grokdeclarator.  It returns `void_type_node'    to indicate that something happened, though a FIELD_DECL is    not returned.     CTYPE is the class this friend belongs to.     DECLARATOR is the name of the friend.     DECL is the FUNCTION_DECL that the friend is.     In case we are parsing a friend which is part of an inline    definition, we will need to store PARM_DECL chain that comes    with it into the DECL_ARGUMENTS slot of the FUNCTION_DECL.     FLAGS is just used for `grokclassfn'.     QUALS say what special qualifies should apply to the object    pointed to by `this'.  */
end_comment

begin_function
name|tree
name|do_friend
parameter_list|(
name|ctype
parameter_list|,
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|parmdecls
parameter_list|,
name|attrlist
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|declarator
decl_stmt|,
name|decl
decl_stmt|,
name|parmdecls
decl_stmt|,
name|attrlist
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|int
name|is_friend_template
init|=
literal|0
decl_stmt|;
comment|/* Every decl that gets here is a friend of something.  */
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|declarator
argument_list|)
condition|)
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|is_friend_template
operator|=
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* A method friend.  */
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|declarator
operator|==
name|cname
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This will set up DECL_ARGUMENTS for us.  */
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_friend_template
condition|)
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|push_template_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't do lookup in a type that involves template 	 parameters.  Instead, we rely on tsubst_friend_function 	 to check the validity of the declaration later.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* A nested class may declare a member of an enclosing class 	 to be a friend, so we do lookup here even if CTYPE is in 	 the process of being defined.  */
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|decl
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"member `%D' declared as friend before type `%T' defined"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
comment|/* A global friend.      @@ or possibly a friend from a base class ?!?  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Friends must all go through the overload machinery, 	 even though they may not technically be overloaded.  	 Note that because classes all wind up being top-level 	 in their scope, their friend wind up in top-level scope as well.  */
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|parmdecls
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
name|SET_DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We must check whether the decl refers to template 	     arguments before push_template_decl_real adds a 	     reference to the containing template class.  */
name|int
name|warn
init|=
operator|(
name|warn_nontemplate_friend
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|is_friend_template
operator|&&
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|is_friend_template
operator|||
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|!=
literal|0
condition|)
comment|/* We can't call pushdecl for a template class, since in 	       general, such a declaration depends on template 	       parameters.  Instead, we call pushdecl when the class 	       is instantiated.  */
name|decl
operator|=
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
comment|/*is_friend=*/
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
comment|/* This must be a local class, so pushdecl will be ok, and 	       insert an unqualified friend into the local scope 	       (rather than the containing namespace scope, which the 	       next choice will do).  */
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We can't use pushdecl, as we might be in a template 	         class specialization, and pushdecl will insert an 	         unqualified friend decl into the template parameter 	         scope, rather than the namespace containing it.  */
name|tree
name|ns
init|=
name|decl_namespace_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
name|warning
argument_list|(
literal|"friend declaration `%#D' declares a non-template function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|"(if this is not what you intended, make sure the function template has already been declared and add<> after the function name here) -Wno-non-template-friend disables this warning"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|is_friend_template
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
else|:
name|decl
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Unfortunately, we have to handle attributes here.  Normally we would      handle them in start_decl_1, but since this is a friend decl start_decl_1      never gets to see it.  */
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

end_unit

