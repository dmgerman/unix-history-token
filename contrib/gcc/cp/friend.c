begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Help friends in C++.    Copyright (C) 1997 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|add_friend
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_friends
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Friend data structures are described in cp-tree.h.  */
end_comment

begin_function
name|int
name|is_friend
parameter_list|(
name|type
parameter_list|,
name|supplicant
parameter_list|)
name|tree
name|type
decl_stmt|,
name|supplicant
decl_stmt|;
block|{
name|int
name|declp
decl_stmt|;
specifier|register
name|tree
name|list
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|supplicant
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|declp
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|supplicant
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
if|if
condition|(
name|declp
condition|)
comment|/* It's a function decl.  */
block|{
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|supplicant
argument_list|)
decl_stmt|;
name|tree
name|ctype
decl_stmt|;
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|ctype
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
else|else
name|ctype
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|ctype
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|is_specialization_of
argument_list|(
name|supplicant
argument_list|,
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
comment|/* FIXME: The use of comptypes here is bogus, since 		     two specializations of a template with non-type 		     parameters may have the same type, but be 		     different.  */
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|supplicant
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
break|break;
block|}
block|}
block|}
else|else
comment|/* It's a type.  */
block|{
if|if
condition|(
name|type
operator|==
name|supplicant
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|is_specialization_of
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|,
name|t
argument_list|)
else|:
name|comptypes
argument_list|(
name|supplicant
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|declp
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|supplicant
argument_list|)
condition|)
name|context
operator|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|supplicant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|declp
condition|)
comment|/* Local classes have the same access as the enclosing function.  */
name|context
operator|=
name|hack_decl_function_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|supplicant
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* A namespace is not friend to anybody. */
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|context
condition|)
return|return
name|is_friend
argument_list|(
name|type
argument_list|,
name|context
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new friend to the friends of the aggregate type TYPE.    DECL is the FUNCTION_DECL of the friend being added.  */
end_comment

begin_function
specifier|static
name|void
name|add_friend
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`%D' is already a friend of class `%T'"
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"previous friend declaration of `%D'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|friends
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|decl
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parmtypes
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|parmtypes
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
condition|)
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Declare that every member function NAME in FRIEND_TYPE    (which may be NULL_TREE) is a friend of type TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|add_friends
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|typedecl
init|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|tree
name|friends
init|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
decl_stmt|;
while|while
condition|(
name|friends
operator|&&
name|TREE_PURPOSE
argument_list|(
name|friends
argument_list|)
operator|!=
name|friend_type
condition|)
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
expr_stmt|;
if|if
condition|(
name|friends
condition|)
block|{
if|if
condition|(
name|friend_type
condition|)
name|warning
argument_list|(
literal|"method `%s::%s' is already a friend of class"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|friend_type
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"function `%s' is already a friend of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|typedecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|build_tree_list
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|DECL_FRIENDLIST
argument_list|(
name|typedecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|typedecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|sorry
argument_list|(
literal|"declaring \"friend operator =\" will not find \"operator = (X&)\" if it exists"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already    been defined, we make all of its member functions friends of    TYPE.  If not, we make it a pending friend, which can later be added    when its definition is seen.  If a type is defined, then its TYPE_DECL's    DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend    classes that are not defined.  If a type has not yet been defined,    then the DECL_WAITING_FRIENDS contains a list of types    waiting to make it their friend.  Note that these two can both    be in use at the same time!  */
end_comment

begin_function
name|void
name|make_friend_class
parameter_list|(
name|type
parameter_list|,
name|friend_type
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_type
decl_stmt|;
block|{
name|tree
name|classes
decl_stmt|;
name|int
name|is_template_friend
decl_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`friend' declaration in signature definition"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|friend_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"signature type `%s' declared `friend'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|friend_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|type
argument_list|)
condition|)
comment|/* If the TYPE is a template then it makes sense for it to be        friends with itself; this means that each instantiation is        friends with all other instantiations.  */
name|is_template_friend
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|comptypes
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"class `%s' is implicitly friends with itself"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|is_template_friend
operator|=
literal|0
expr_stmt|;
name|GNU_xref_hier
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_template_friend
condition|)
name|friend_type
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
name|classes
operator|=
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|classes
comment|/* Stop if we find the same type on the list.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|friend_type
operator|==
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
else|:
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|,
name|friend_type
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|classes
operator|=
name|TREE_CHAIN
argument_list|(
name|classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|classes
condition|)
name|cp_warning
argument_list|(
literal|"`%T' is already a friend of `%T'"
argument_list|,
name|TREE_VALUE
argument_list|(
name|classes
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|friend_type
argument_list|,
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main friend processor.  This is large, and for modularity purposes,    has been removed from grokdeclarator.  It returns `void_type_node'    to indicate that something happened, though a FIELD_DECL is    not returned.     CTYPE is the class this friend belongs to.     DECLARATOR is the name of the friend.     DECL is the FUNCTION_DECL that the friend is.     In case we are parsing a friend which is part of an inline    definition, we will need to store PARM_DECL chain that comes    with it into the DECL_ARGUMENTS slot of the FUNCTION_DECL.     FLAGS is just used for `grokclassfn'.     QUALS say what special qualifies should apply to the object    pointed to by `this'.  */
end_comment

begin_function
name|tree
name|do_friend
parameter_list|(
name|ctype
parameter_list|,
name|declarator
parameter_list|,
name|decl
parameter_list|,
name|parmdecls
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|declarator
decl_stmt|,
name|decl
decl_stmt|,
name|parmdecls
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|int
name|is_friend_template
init|=
literal|0
decl_stmt|;
comment|/* Every decl that gets here is a friend of something.  */
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|LOOKUP_EXPR
condition|)
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|declarator
argument_list|)
condition|)
name|declarator
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|is_friend_template
operator|=
name|processing_template_decl
operator|>
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
block|{
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
comment|/* A method friend.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|NO_SPECIAL
operator|&&
name|ctype
operator|&&
name|declarator
operator|==
name|cname
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This will set up DECL_ARGUMENTS for us.  */
name|grokclassfn
argument_list|(
name|ctype
argument_list|,
name|cname
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|,
name|quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_friend_template
condition|)
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|push_template_decl
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|!=
literal|0
operator|&&
name|template_class_depth
argument_list|(
name|ctype
argument_list|)
operator|==
literal|0
condition|)
name|decl
operator|=
name|check_classfn
argument_list|(
name|ctype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* TYPE_BEING_DEFINED is a hack for nested classes having              member functions of the enclosing class as friends. Will              go away as parsing of classes gets rewritten. */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
operator|||
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|||
name|template_class_depth
argument_list|(
name|ctype
argument_list|)
operator|>
literal|0
condition|)
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"member `%D' declared as friend before type `%T' defined"
argument_list|,
name|decl
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Possibly a bunch of method friends.  */
comment|/* Get the class they belong to.  */
name|tree
name|ctype
init|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
decl_stmt|;
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
condition|)
name|add_friends
argument_list|(
name|current_class_type
argument_list|,
name|declarator
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"method `%D' is not a member of class `%T'"
argument_list|,
name|declarator
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|MAIN_NAME_P
argument_list|(
name|declarator
argument_list|)
operator|||
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|declarator
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* raw "main", and builtin functions never gets overloaded, 	 but they can become friends.  */
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
comment|/* A global friend.      @@ or possibly a friend from a base class ?!?  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Friends must all go through the overload machinery, 	 even though they may not technically be overloaded.  	 Note that because classes all wind up being top-level 	 in their scope, their friend wind up in top-level scope as well.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|declarator
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|parmdecls
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We can call pushdecl here, because the TREE_CHAIN of this 	     FUNCTION_DECL is not needed for other purposes.  Don't do this 	     for a template instantiation.  */
if|if
condition|(
operator|!
name|is_friend_template
condition|)
block|{
comment|/* However, we don't call pushdecl() for a friend 		 function of a template class, since in general, 		 such a declaration depends on template 		 parameters.  Instead, we call pushdecl when the 		 class is instantiated.  */
if|if
condition|(
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|push_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|funcdef_flag
operator|&&
operator|!
name|flag_guiding_decls
operator|&&
operator|!
name|is_friend_template
operator|&&
name|current_template_parms
operator|&&
name|uses_template_parms
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|static
name|int
name|explained
decl_stmt|;
name|cp_warning
argument_list|(
literal|"friend declaration `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  declares a non-template function"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|warning
argument_list|(
literal|"  (if this is not what you intended, make sure"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  the function template has already been declared,"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"  and add<> after the function name here)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_friend
argument_list|(
name|current_class_type
argument_list|,
name|is_friend_template
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
else|:
name|decl
argument_list|)
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* @@ Should be able to ingest later definitions of this function 	 before use.  */
name|tree
name|decl
init|=
name|lookup_name_nonclass
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
block|{
name|cp_warning
argument_list|(
literal|"implicitly declaring `%T' as struct"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|decl
operator|=
name|xref_tag
argument_list|(
name|record_type_node
argument_list|,
name|declarator
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Allow abbreviated declarations of overloaded functions, 	 but not if those functions are really class names.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|cp_warning
argument_list|(
literal|"`friend %T' archaic, use `friend class %T' instead"
argument_list|,
name|declarator
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|add_friends
argument_list|(
name|current_class_type
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|make_friend_class
argument_list|(
name|current_class_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|void_type_node
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

end_unit

