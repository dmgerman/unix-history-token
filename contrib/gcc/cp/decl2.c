begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C++ compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C++ front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_decl_stmt
specifier|extern
name|cpp_reader
modifier|*
name|parse_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure contains information about the initializations    and/or destructions required for a particular priority level.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|priority_info_s
block|{
comment|/* Nonzero if there have been any initializations at this priority      throughout the translation unit.  */
name|int
name|initializations_p
decl_stmt|;
comment|/* Nonzero if there have been any destructions at this priority      throughout the translation unit.  */
name|int
name|destructions_p
decl_stmt|;
block|}
typedef|*
name|priority_info
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|mark_vtable_entries
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|maybe_emit_vtables
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|acceptable_java_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|start_objects
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_objects
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|start_static_storage_duration_function
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_static_storage_duration_function
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|priority_info
name|get_priority_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_static_initialization_or_destruction
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|one_static_initialization_or_destruction
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_ctor_or_dtor_function
parameter_list|(
name|bool
parameter_list|,
name|int
parameter_list|,
name|location_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|generate_ctor_and_dtor_functions_for_priority
parameter_list|(
name|splay_tree_node
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|prune_vars_needing_no_initialization
parameter_list|(
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_out_vars
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|import_export_class
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_guard_bits
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|determine_visibility_from_class
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A list of static class variables.  This is needed, because a    static class variable can be declared inside the class without    an initializer, and then initialized, statically, outside the class.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|pending_statics
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A list of functions which were declared inline, but which we    may need to emit outline anyway.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|deferred_fns
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Nonzero if we're done parsing and into end-of-file activities.  */
end_comment

begin_decl_stmt
name|int
name|at_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions called along with real static constructors and destructors.  */
end_comment

begin_decl_stmt
name|tree
name|static_ctors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|static_dtors
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return a member function type (a METHOD_TYPE), given FNTYPE (a    FUNCTION_TYPE), CTYPE (class type), and QUALS (the cv-qualifiers    that apply to the function).  */
end_comment

begin_function
name|tree
name|build_memfn_type
parameter_list|(
name|tree
name|fntype
parameter_list|,
name|tree
name|ctype
parameter_list|,
name|cp_cv_quals
name|quals
parameter_list|)
block|{
name|tree
name|raises
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
operator|||
name|ctype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type_quals
operator|=
name|quals
operator|&
operator|~
name|TYPE_QUAL_RESTRICT
expr_stmt|;
name|ctype
operator|=
name|cp_build_qualified_type
argument_list|(
name|ctype
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_method_type_directly
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|raises
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|raises
argument_list|)
expr_stmt|;
return|return
name|fntype
return|;
block|}
end_function

begin_comment
comment|/* Build a PARM_DECL with NAME and TYPE, and set DECL_ARG_TYPE    appropriately.  */
end_comment

begin_function
name|tree
name|cp_build_parm_decl
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|parm
init|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* DECL_ARG_TYPE is only used by the back end and the back end never      sees templates.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|type_passed_as
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|parm
return|;
block|}
end_function

begin_comment
comment|/* Returns a PARM_DECL for a parameter of the indicated TYPE, with the    indicated NAME.  */
end_comment

begin_function
name|tree
name|build_artificial_parm
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|parm
init|=
name|cp_build_parm_decl
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* All our artificial parms are implicitly `const'; they cannot be      assigned to.  */
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|parm
return|;
block|}
end_function

begin_comment
comment|/* Constructors for types with virtual baseclasses need an "in-charge" flag    saying whether this constructor is responsible for initialization of    virtual baseclasses or not.  All destructors also need this "in-charge"    flag, which additionally determines whether or not the destructor should    free the memory for the object.     This function adds the "in-charge" flag to member function FN if    appropriate.  It is called from grokclassfn and tsubst.    FN must be either a constructor or destructor.     The in-charge flag follows the 'this' parameter, and is followed by the    VTT parm (if any), then the user-written parms.  */
end_comment

begin_function
name|void
name|maybe_retrofit_in_chrg
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|basetype
decl_stmt|,
name|arg_types
decl_stmt|,
name|parms
decl_stmt|,
name|parm
decl_stmt|,
name|fntype
decl_stmt|;
comment|/* If we've already add the in-charge parameter don't do it again.  */
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return;
comment|/* When processing templates we can't know, in general, whether or      not we're going to have virtual baseclasses.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return;
comment|/* We don't need an in-charge parameter for constructors that don't      have virtual bases.  */
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
return|return;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a subobject constructor or destructor, our caller will      pass us a pointer to our VTT.  */
if|if
condition|(
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
name|parm
operator|=
name|build_artificial_parm
argument_list|(
name|vtt_parm_identifier
argument_list|,
name|vtt_parm_type
argument_list|)
expr_stmt|;
comment|/* First add it to DECL_ARGUMENTS between 'this' and the real args...  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|parms
expr_stmt|;
name|parms
operator|=
name|parm
expr_stmt|;
comment|/* ...and then to TYPE_ARG_TYPES.  */
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|vtt_parm_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Then add the in-charge parm (before the VTT parm).  */
name|parm
operator|=
name|build_artificial_parm
argument_list|(
name|in_charge_identifier
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|parms
expr_stmt|;
name|parms
operator|=
name|parm
expr_stmt|;
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
comment|/* Insert our new parameter(s) into the list.  */
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|=
name|parms
expr_stmt|;
comment|/* And rebuild the function type.  */
name|fntype
operator|=
name|build_method_type_directly
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|=
name|fntype
expr_stmt|;
comment|/* Now we've got the in-charge parameter.  */
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Classes overload their constituent function names automatically.    When a function name is declared in a record structure,    its name is changed to it overloaded name.  Since names for    constructors and destructors can conflict, we place a leading    '$' for destructors.     CNAME is the name of the class we are grokking for.     FUNCTION is a FUNCTION_DECL.  It was created by `grokdeclarator'.     FLAGS contains bits saying what's special about today's    arguments.  1 == DESTRUCTOR.  2 == OPERATOR.     If FUNCTION is a destructor, then we must add the `auto-delete' field    as a second parameter.  There is some hair associated with the fact    that we must "declare" this variable in the manner consistent with the    way the rest of the arguments were declared.     QUALS are the qualifiers for the this pointer.  */
end_comment

begin_function
name|void
name|grokclassfn
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|function
parameter_list|,
name|enum
name|overload_flags
name|flags
parameter_list|)
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
decl_stmt|;
comment|/* Even within an `extern "C"' block, members get C++ linkage.  See      [dcl.link] for details.  */
name|SET_DECL_LANGUAGE
argument_list|(
name|function
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"name missing for member function"
argument_list|)
expr_stmt|;
name|fn_name
operator|=
name|get_identifier
argument_list|(
literal|"<anonymous>"
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|=
name|fn_name
expr_stmt|;
block|}
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|DECL_DESTRUCTOR_P
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
name|maybe_retrofit_in_chrg
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an ARRAY_REF, checking for the user doing things backwards    along the way.  */
end_comment

begin_function
name|tree
name|grok_array_decl
parameter_list|(
name|tree
name|array_expr
parameter_list|,
name|tree
name|index_exp
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|orig_array_expr
init|=
name|array_expr
decl_stmt|;
name|tree
name|orig_index_exp
init|=
name|index_exp
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|array_expr
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|index_exp
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|array_expr
argument_list|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|index_exp
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|array_expr
argument_list|,
name|index_exp
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
name|array_expr
operator|=
name|build_non_dependent_expr
argument_list|(
name|array_expr
argument_list|)
expr_stmt|;
name|index_exp
operator|=
name|build_non_dependent_expr
argument_list|(
name|index_exp
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|array_expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|non_reference
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If they have an `operator[]', use that.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_exp
argument_list|)
argument_list|)
condition|)
name|expr
operator|=
name|build_new_op
argument_list|(
name|ARRAY_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|array_expr
argument_list|,
name|index_exp
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
comment|/* Otherwise, create an ARRAY_REF for a pointer or array type. 	 It is a little-known fact that, if `a' is an array and `i' is 	 an int, you can write `i[a]', which means the same thing as 	 `a[i]'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|p1
operator|=
name|array_expr
expr_stmt|;
else|else
name|p1
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_POINTER
argument_list|,
name|array_expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|p2
operator|=
name|index_exp
expr_stmt|;
else|else
name|p2
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_POINTER
argument_list|,
name|index_exp
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|i1
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|array_expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|i2
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|index_exp
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p1
operator|&&
name|i2
operator|)
operator|&&
operator|(
name|i1
operator|&&
name|p2
operator|)
condition|)
name|error
argument_list|(
literal|"ambiguous conversion for array subscript"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|i2
condition|)
name|array_expr
operator|=
name|p1
operator|,
name|index_exp
operator|=
name|i2
expr_stmt|;
elseif|else
if|if
condition|(
name|i1
operator|&&
name|p2
condition|)
name|array_expr
operator|=
name|p2
operator|,
name|index_exp
operator|=
name|i1
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid types %<%T[%T]%> for array subscript"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|index_exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|array_expr
operator|==
name|error_mark_node
operator|||
name|index_exp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous conversion for array subscript"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_array_ref
argument_list|(
name|array_expr
argument_list|,
name|index_exp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
operator|&&
name|expr
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|ARRAY_REF
argument_list|,
name|expr
argument_list|,
name|orig_array_expr
argument_list|,
name|orig_index_exp
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Given the cast expression EXP, checking out its validity.   Either return    an error_mark_node if there was an unavoidable error, return a cast to    void for trying to delete a pointer w/ the value 0, or return the    call to delete.  If DOING_VEC is true, we handle things differently    for doing an array delete.    Implements ARM $5.3.4.  This is called from the parser.  */
end_comment

begin_function
name|tree
name|delete_sanity
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|size
parameter_list|,
name|bool
name|doing_vec
parameter_list|,
name|int
name|use_global_delete
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|t
operator|=
name|build_min
argument_list|(
name|DELETE_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
operator|=
name|use_global_delete
expr_stmt|;
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|doing_vec
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* An array can't have been allocated by new, so complain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"deleting array %q#D"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_POINTER
argument_list|,
name|exp
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"type %q#T argument given to %<delete%>, expected pointer"
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* As of Valley Forge, you can delete a pointer to const.  */
comment|/* You can't delete functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot delete a function.  Only pointer-to-objects are "
literal|"valid arguments to %<delete%>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Deleting ptr to void is undefined behavior [expr.delete/3].  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"deleting %qT is undefined"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|doing_vec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Deleting a pointer with the value zero is valid and has no effect.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|)
return|;
if|if
condition|(
name|doing_vec
condition|)
return|return
name|build_vec_delete
argument_list|(
name|t
argument_list|,
comment|/*maxindex=*/
name|NULL_TREE
argument_list|,
name|sfk_deleting_destructor
argument_list|,
name|use_global_delete
argument_list|)
return|;
else|else
return|return
name|build_delete
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|sfk_deleting_destructor
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Report an error if the indicated template declaration is not the    sort of thing that should be a member template.  */
end_comment

begin_function
name|void
name|check_member_template
parameter_list|(
name|tree
name|tmpl
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|)
expr_stmt|;
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* The parser rejects template declarations in local classes.  */
name|gcc_assert
argument_list|(
operator|!
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* The parser rejects any use of virtual in a function template.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* The debug-information generating code doesn't know what to do 	 with member templates.  */
name|DECL_IGNORED_P
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"template declaration of %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true iff TYPE is a valid Java parameter or return type.  */
end_comment

begin_function
specifier|static
name|bool
name|acceptable_java_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* For a METHOD in a Java class CTYPE, return true if    the parameter and return types are valid Java types.    Otherwise, print appropriate error messages, and return false.  */
end_comment

begin_function
name|bool
name|check_java_method
parameter_list|(
name|tree
name|method
parameter_list|)
block|{
name|bool
name|jerr
init|=
name|false
decl_stmt|;
name|tree
name|arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|acceptable_java_type
argument_list|(
name|ret_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Java method %qD has non-Java return type %qT"
argument_list|,
name|method
argument_list|,
name|ret_type
argument_list|)
expr_stmt|;
name|jerr
operator|=
name|true
expr_stmt|;
block|}
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|method
argument_list|)
condition|)
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|method
argument_list|)
condition|)
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arg_types
operator|!=
name|NULL_TREE
condition|;
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|acceptable_java_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"Java method %qD has non-Java parameter type %qT"
argument_list|,
name|method
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|jerr
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
operator|!
name|jerr
return|;
block|}
end_function

begin_comment
comment|/* Sanity check: report error if this function FUNCTION is not    really a member of the class (CTYPE) it is supposed to belong to.    TEMPLATE_PARMS is used to specify the template parameters of a member    template passed as FUNCTION_DECL. If the member template is passed as a    TEMPLATE_DECL, it can be NULL since the parameters can be extracted    from the declaration. If the function is not a function template, it    must be NULL.    It returns the original declaration for the function, or NULL_TREE    if no declaration was found (and an error was emitted).  */
end_comment

begin_function
name|tree
name|check_classfn
parameter_list|(
name|tree
name|ctype
parameter_list|,
name|tree
name|function
parameter_list|,
name|tree
name|template_parms
parameter_list|)
block|{
name|int
name|ix
decl_stmt|;
name|bool
name|is_template
decl_stmt|;
name|tree
name|pushed_scope
decl_stmt|;
if|if
condition|(
name|DECL_USE_TEMPLATE
argument_list|(
name|function
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|function
argument_list|)
operator|)
operator|&&
name|DECL_MEMBER_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
comment|/* Since this is a specialization of a member template,        we're not going to find the declaration in the class.        For example, in:  	 struct S { template<typename T> void f(T); }; 	 template<> void S::f(int);         we're not going to find `S::f(int)', but there's no        reason we should, either.  We let our callers know we didn't        find the method, but we don't complain.  */
return|return
name|NULL_TREE
return|;
comment|/* Basic sanity check: for a template function, the template parameters      either were not passed, or they are the same of DECL_TEMPLATE_PARMS.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|template_parms
operator|||
name|comp_template_parms
argument_list|(
name|template_parms
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|template_parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
comment|/* OK, is this a definition of a member template?  */
name|is_template
operator|=
operator|(
name|template_parms
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* We must enter the scope here, because conversion operators are      named by target type, and type equivalence relies on typenames      resolving within the scope of CTYPE.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|ix
operator|=
name|class_method_index_for_fn
argument_list|(
name|complete_type
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
literal|0
condition|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|tree
name|fndecls
decl_stmt|,
name|fndecl
init|=
literal|0
decl_stmt|;
name|bool
name|is_conv_op
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|fndecls
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|,
name|ix
argument_list|)
init|;
name|fndecls
condition|;
name|fndecls
operator|=
name|OVL_NEXT
argument_list|(
name|fndecls
argument_list|)
control|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
name|p1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We cannot simply call decls_match because this doesn't 	     work for static member functions that are pretending to 	     be methods, and because the name may have been changed by 	     asm("new_name").  */
comment|/* Get rid of the this parameter on functions that become 	      static.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* A member template definition only matches a member template 	     declaration.  */
if|if
condition|(
name|is_template
operator|!=
operator|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|&&
operator|(
operator|!
name|is_template
operator|||
name|comp_template_parms
argument_list|(
name|template_parms
argument_list|,
name|DECL_TEMPLATE_PARMS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|function
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_TI_TEMPLATE
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|fndecls
condition|)
block|{
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
return|return
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"prototype for %q#D does not match any in class %qT"
argument_list|,
name|function
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|is_conv_op
operator|=
name|DECL_CONV_FN_P
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_conv_op
condition|)
name|ix
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
expr_stmt|;
name|fndecls
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|,
name|ix
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecls
condition|)
block|{
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
name|fndecls
operator|=
name|OVL_NEXT
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fndecls
operator|&&
name|is_conv_op
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|)
operator|>
operator|(
name|size_t
operator|)
operator|++
name|ix
condition|)
block|{
name|fndecls
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
argument_list|)
condition|)
block|{
name|fndecls
operator|=
name|NULL_TREE
expr_stmt|;
name|is_conv_op
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
name|is_conv_op
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|format
condition|)
name|format
operator|=
literal|"                %+#D"
expr_stmt|;
elseif|else
if|if
condition|(
name|fndecls
condition|)
name|format
operator|=
name|N_
argument_list|(
literal|"candidates are: %+#D"
argument_list|)
expr_stmt|;
else|else
name|format
operator|=
name|N_
argument_list|(
literal|"candidate is: %+#D"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|format
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
condition|)
name|cxx_incomplete_type_error
argument_list|(
name|function
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no %q#D member function declared in class %qT"
argument_list|,
name|function
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
comment|/* If we did not find the method in the class, add it to avoid      spurious errors (unless the CTYPE is not yet defined, in which      case we'll only confuse ourselves when the function is declared      properly within the class.  */
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|ctype
argument_list|)
condition|)
name|add_method
argument_list|(
name|ctype
argument_list|,
name|function
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* DECL is a function with vague linkage.  Remember it so that at the    end of the translation unit we can decide whether or not to emit    it.  */
end_comment

begin_function
name|void
name|note_vague_linkage_fn
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_DEFERRED_FN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_DEFERRED_FN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|deferred_fns
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We have just processed the DECL, which is a static data member.    The other parameters are as for cp_finish_decl.  */
end_comment

begin_function
name|void
name|finish_static_data_member_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|init_const_expr_p
parameter_list|,
name|tree
name|asmspec_tree
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* We cannot call pushdecl here, because that would fill in the      TREE_CHAIN of our decl.  Instead, we modify cp_finish_decl to do      the right thing, namely, to put this decl out straight away.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|pending_statics
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCAL_CLASS_P
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"local class %q#T shall not have static data member %q#D"
argument_list|,
name|current_class_type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Static consts need not be initialized in the class definition.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|int
name|explained
init|=
literal|0
decl_stmt|;
name|error
argument_list|(
literal|"initializer invalid for static member with constructor"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|error
argument_list|(
literal|"(an out of class initialization is required)"
argument_list|)
expr_stmt|;
name|explained
operator|=
literal|1
expr_stmt|;
block|}
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Force the compiler to know when an uninitialized static const      member is being used.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|init
operator|==
literal|0
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|init_const_expr_p
argument_list|,
name|asmspec_tree
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECLARATOR and DECLSPECS correspond to a class member.  The other    parameters are as for cp_finish_decl.  Return the DECL for the    class member declared.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|init_const_expr_p
parameter_list|,
name|tree
name|asmspec_tree
parameter_list|,
name|tree
name|attrlist
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_ONLYCONVERTING
decl_stmt|;
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
operator|==
name|error_mark_node
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
name|init
operator|!=
literal|0
argument_list|,
operator|&
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|||
name|error_operand_p
argument_list|(
name|value
argument_list|)
condition|)
comment|/* friend or constructor went bad.  */
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|init
condition|)
block|{
name|error
argument_list|(
literal|"typedef %qD is initialized (use __typeof__ instead)"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Pass friendly classes back.  */
if|if
condition|(
name|value
operator|==
name|void_type_node
condition|)
return|return
name|value
return|;
comment|/* Pass friend decls back.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|!=
name|current_class_type
condition|)
return|return
name|value
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %qD conflicts with virtual function table field name"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Stash away type declarations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|value
operator|=
name|push_template_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrlist
condition|)
block|{
comment|/* Avoid storing attributes in template parameters: 	     tsubst is not ready to handle them.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
name|sorry
argument_list|(
literal|"applying attributes to template parameters is not implemented"
argument_list|)
expr_stmt|;
else|else
name|cplus_decl_attributes
argument_list|(
operator|&
name|value
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD is already defined in %qT"
argument_list|,
name|value
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|asmspec_tree
operator|&&
name|asmspec_tree
operator|!=
name|error_mark_node
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Initializers for functions are rejected early in the parser. 	     If we get here, it must be a pure specifier for a method.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|gcc_assert
argument_list|(
name|error_operand_p
argument_list|(
name|init
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_PURE_VIRTUAL_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"initializer specified for static member function %qD"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|VAR_DECL
condition|)
comment|/* Already complained in grokdeclarator.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|integral_constant_value
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
name|error_mark_node
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* We can allow references to things that are effectively 		 static, since references are initialized with the 		 address.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|DECL_P
argument_list|(
name|init
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|init
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"field initializer is not constant"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|processing_template_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|value
operator|=
name|push_template_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|attrlist
condition|)
name|cplus_decl_attributes
argument_list|(
operator|&
name|value
argument_list|,
name|attrlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
name|finish_static_data_member_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|init_const_expr_p
argument_list|,
name|asmspec_tree
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|value
return|;
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|asmspec
condition|)
name|error
argument_list|(
literal|"%<asm%> specifiers are not permitted on non-static data members"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|==
name|error_mark_node
condition|)
name|init
operator|=
name|error_mark_node
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|asmspec
condition|)
name|set_user_assembler_name
argument_list|(
name|value
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|value
argument_list|,
comment|/*init=*/
name|NULL_TREE
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
name|asmspec_tree
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Pass friends back this way.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|void_type_node
return|;
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like `grokfield', but for bitfields.    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */
end_comment

begin_function
name|tree
name|grokbitfield
parameter_list|(
specifier|const
name|cp_declarator
modifier|*
name|declarator
parameter_list|,
name|cp_decl_specifier_seq
modifier|*
name|declspecs
parameter_list|,
name|tree
name|width
parameter_list|)
block|{
name|tree
name|value
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|BITFIELD
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
comment|/* friends went bad.  */
comment|/* Pass friendly classes back.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&&
operator|(
name|POINTER_TYPE_P
argument_list|(
name|value
argument_list|)
operator|||
operator|!
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"bit-field %qD with non-integral type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare %qD to be a bit-field type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Usually, finish_struct_1 catches bitfields with invalid types.      But, in the case of bitfields with function type, we confuse      ourselves into thinking they are member functions, so we must      check here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare bit-field %qD with function type"
argument_list|,
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD is already defined in the class %qT"
argument_list|,
name|value
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"static member %qD cannot be a bit-field"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|error_mark_node
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
name|SET_DECL_C_BIT_FIELD
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cplus_decl_attributes
parameter_list|(
name|tree
modifier|*
name|decl
parameter_list|,
name|tree
name|attributes
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|*
name|decl
operator|==
name|NULL_TREE
operator|||
operator|*
name|decl
operator|==
name|void_type_node
operator|||
operator|*
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|decl
operator|=
operator|&
name|DECL_TEMPLATE_RESULT
argument_list|(
operator|*
name|decl
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
name|decl
argument_list|,
name|attributes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
operator|*
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walks through the namespace- or function-scope anonymous union    OBJECT, with the indicated TYPE, building appropriate VAR_DECLs.    Returns one of the fields for use in the mangled name.  */
end_comment

begin_function
specifier|static
name|tree
name|build_anon_union_vars
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|object
parameter_list|)
block|{
name|tree
name|main_decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|field
decl_stmt|;
comment|/* Rather than write the code to handle the non-union case,      just give an error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"anonymous struct not inside named type"
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|!=
name|NULL_TREE
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|ref
decl_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|pedwarn
argument_list|(
literal|"%q+#D invalid; an anonymous union can only "
literal|"have non-static data members"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"private member %q+#D in anonymous union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"protected member %q+#D in anonymous union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|ref
operator|=
name|build_min_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|object
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|ref
operator|=
name|build_class_member_access_expr
argument_list|(
name|object
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|tree
name|base
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ANON_UNION_VAR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|base
operator|=
name|get_base_address
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|decl
operator|=
name|build_anon_union_vars
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|main_decl
operator|==
name|NULL_TREE
condition|)
name|main_decl
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|main_decl
return|;
block|}
end_function

begin_comment
comment|/* Finish off the processing of a UNION_TYPE structure.  If the union is an    anonymous union, then all members must be laid out together.  PUBLIC_P    is nonzero if this union is not declared static.  */
end_comment

begin_function
name|void
name|finish_anon_union
parameter_list|(
name|tree
name|anon_union_decl
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|main_decl
decl_stmt|;
name|bool
name|public_p
decl_stmt|;
if|if
condition|(
name|anon_union_decl
operator|==
name|error_mark_node
condition|)
return|return;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|anon_union_decl
argument_list|)
expr_stmt|;
name|public_p
operator|=
name|TREE_PUBLIC
argument_list|(
name|anon_union_decl
argument_list|)
expr_stmt|;
comment|/* The VAR_DECL's context is the same as the TYPE's context.  */
name|DECL_CONTEXT
argument_list|(
name|anon_union_decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|public_p
condition|)
block|{
name|error
argument_list|(
literal|"namespace-scope anonymous aggregates must be static"
argument_list|)
expr_stmt|;
return|return;
block|}
name|main_decl
operator|=
name|build_anon_union_vars
argument_list|(
name|type
argument_list|,
name|anon_union_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_decl
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|main_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"anonymous union with no members"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* Use main_decl to set the mangled name.  */
name|DECL_NAME
argument_list|(
name|anon_union_decl
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|main_decl
argument_list|)
expr_stmt|;
name|mangle_decl
argument_list|(
name|anon_union_decl
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|anon_union_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|anon_union_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|building_stmt_tree
argument_list|()
operator|&&
name|at_function_scope_p
argument_list|()
condition|)
name|add_decl_expr
argument_list|(
name|anon_union_decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|rest_of_decl_compilation
argument_list|(
name|anon_union_decl
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Auxiliary functions to make type signatures for    `operator new' and `operator delete' correspond to    what compiler will be expecting.  */
end_comment

begin_function
name|tree
name|coerce_new_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|e
init|=
literal|0
decl_stmt|;
name|tree
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
block|{
name|e
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"%<operator new%> must return type %qT"
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|args
operator|||
name|args
operator|==
name|void_list_node
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|size_type_node
argument_list|)
condition|)
block|{
name|e
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"%<operator new%> takes type %<size_t%> (%qT) "
literal|"as first parameter"
argument_list|,
name|size_type_node
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|e
condition|)
block|{
case|case
literal|2
case|:
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size_type_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|1
case|:
name|type
operator|=
name|build_exception_variant
argument_list|(
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|args
argument_list|)
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
default|default:
empty_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|coerce_delete_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|e
init|=
literal|0
decl_stmt|;
name|tree
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
condition|)
block|{
name|e
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"%<operator delete%> must return type %qT"
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|args
operator|||
name|args
operator|==
name|void_list_node
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
block|{
name|e
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%<operator delete%> takes type %qT as first parameter"
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|e
condition|)
block|{
case|case
literal|2
case|:
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|1
case|:
name|type
operator|=
name|build_exception_variant
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|args
argument_list|)
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
default|default:
empty_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|mark_vtable_entries
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|fnaddr
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|CONSTRUCTOR_ELTS (DECL_INITIAL (decl))
argument_list|,
argument|idx
argument_list|,
argument|fnaddr
argument_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|fnaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fnaddr
argument_list|)
operator|!=
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|fnaddr
argument_list|)
operator|!=
name|FDESC_EXPR
condition|)
comment|/* This entry is an offset: a virtual base class offset, a 	   virtual call offset, an RTTI offset, etc.  */
continue|continue;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* When we don't have vcall offsets, we output thunks whenever 	 we output the vtables that contain them.  With vcall offsets, 	 we know all the thunks we'll need when we emit a virtual 	 function, so we emit the thunks there instead.  */
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|fn
argument_list|)
condition|)
name|use_thunk
argument_list|(
name|fn
argument_list|,
comment|/*emit_p=*/
literal|0
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set DECL up to have the closest approximation of "initialized common"    linkage available.  */
end_comment

begin_function
name|void
name|comdat_linkage
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|flag_weak
condition|)
name|make_decl_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We can just emit function and compiler-generated variables        statically; having multiple copies is (for the most part) only        a waste of space.         There are two correctness issues, however: the address of a        template instantiation with external linkage should be the        same, independent of what translation unit asks for the        address, and this will not hold when we emit multiple copies of        the function.  However, there's little else we can do.         Also, by default, the typeinfo implementation assumes that        there will be only one copy of the string used as the name for        each type.  Therefore, if weak symbols are unavailable, the        run-time library should perform a more conservative check; it        should perform a string comparison, rather than an address        comparison.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Static data member template instantiations, however, cannot 	 have multiple copies.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We can't do anything useful; leave vars for explicit 	     instantiation.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For win32 we also want to put explicit instantiations in    linkonce sections, so that they will be merged with implicit    instantiations; otherwise we get duplicate symbol errors.    For Darwin we do not want explicit instantiations to be    linkonce.  */
end_comment

begin_function
name|void
name|maybe_make_one_only
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* We used to say that this was not necessary on targets that support weak      symbols, because the implicit instantiations will defer to the explicit      one.  However, that's not actually the case in SVR4; a strong definition      after a weak one is an error.  Also, not making explicit      instantiations one_only means that we can end up with two copies of      some template instantiations.  */
if|if
condition|(
operator|!
name|flag_weak
condition|)
return|return;
comment|/* We can't set DECL_COMDAT on functions, or cp_finish_file will think      we can get away with not emitting them if they aren't used.  We need      to for variables so that cp_finish_decl will update their linkage,      because their DECL_INITIAL may not have been set properly yet.  */
if|if
condition|(
operator|!
name|TARGET_WEAK_NOT_IN_ARCHIVE_TOC
operator|||
operator|(
operator|!
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|make_decl_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark it needed so we don't forget to emit it.  */
name|mark_decl_referenced
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine whether or not we want to specifically import or export CTYPE,    using various heuristics.  */
end_comment

begin_function
specifier|static
name|void
name|import_export_class
parameter_list|(
name|tree
name|ctype
parameter_list|)
block|{
comment|/* -1 for imported, 1 for exported.  */
name|int
name|import_export
init|=
literal|0
decl_stmt|;
comment|/* It only makes sense to call this function at EOF.  The reason is      that this function looks at whether or not the first non-inline      non-abstract virtual member function has been defined in this      translation unit.  But, we can't possibly know that until we've      seen the entire translation unit.  */
name|gcc_assert
argument_list|(
name|at_eof
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
condition|)
return|return;
comment|/* If MULTIPLE_SYMBOL_SPACES is set and we saw a #pragma interface,      we will have CLASSTYPE_INTERFACE_ONLY set but not      CLASSTYPE_INTERFACE_KNOWN.  In that case, we don't want to use this      heuristic because someone will supply a #pragma implementation      elsewhere, and deducing it here would produce a conflict.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
condition|)
return|return;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|import_export
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|import_export
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|flag_implicit_templates
condition|)
comment|/* For a template class, without -fimplicit-templates, check the        repository.  If the virtual table is assigned to this        translation unit, then export the class; otherwise, import        it.  */
name|import_export
operator|=
name|repo_export_class_p
argument_list|(
name|ctype
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_POLYMORPHIC_P
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* The ABI specifies that the virtual table and associated 	 information are emitted with the key method, if any.  */
name|tree
name|method
init|=
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
comment|/* If weak symbol support is not available, then we must be 	 careful not to emit the vtable when the key function is 	 inline.  An inline function can be defined in multiple 	 translation units.  If we were to emit the vtable in each 	 translation unit containing a definition, we would get 	 multiple definition errors at link-time.  */
if|if
condition|(
name|method
operator|&&
operator|(
name|flag_weak
operator|||
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|method
argument_list|)
operator|)
condition|)
name|import_export
operator|=
operator|(
name|DECL_REALLY_EXTERN
argument_list|(
name|method
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
block|}
comment|/* When MULTIPLE_SYMBOL_SPACES is set, we cannot count on seeing      a definition anywhere else.  */
if|if
condition|(
name|MULTIPLE_SYMBOL_SPACES
operator|&&
name|import_export
operator|==
operator|-
literal|1
condition|)
name|import_export
operator|=
literal|0
expr_stmt|;
comment|/* Allow backends the chance to overrule the decision.  */
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|import_export_class
condition|)
name|import_export
operator|=
name|targetm
operator|.
name|cxx
operator|.
name|import_export_class
argument_list|(
name|ctype
argument_list|,
name|import_export
argument_list|)
expr_stmt|;
if|if
condition|(
name|import_export
condition|)
block|{
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
operator|=
operator|(
name|import_export
operator|<
literal|0
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if VAR has already been provided to the back end; in that    case VAR should not be modified further by the front end.  */
end_comment

begin_function
specifier|static
name|bool
name|var_finalized_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
return|return
name|cgraph_varpool_node
argument_list|(
name|var
argument_list|)
operator|->
name|finalized
return|;
block|}
end_function

begin_comment
comment|/* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,    must be emitted in this translation unit.  Mark it as such.  */
end_comment

begin_function
name|void
name|mark_needed
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* It's possible that we no longer need to set      TREE_SYMBOL_REFERENCED here directly, but doing so is      harmless.  */
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_decl_referenced
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is either a FUNCTION_DECL or a VAR_DECL.  This function    returns true if a definition of this entity should be provided in    this object file.  Callers use this function to determine whether    or not to let the back end know that a definition of DECL is    available in this translation unit.  */
end_comment

begin_function
name|bool
name|decl_needed_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* This function should only be called at the end of the translation      unit.  We cannot be sure of whether or not something will be      COMDAT until that point.  */
name|gcc_assert
argument_list|(
name|at_eof
argument_list|)
expr_stmt|;
comment|/* All entities with external linkage that are not COMDAT should be      emitted; they may be referred to from other object files.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If this entity was used, let the back-end see it; it will decide      whether or not to emit it into the object file.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* Otherwise, DECL does not need to be emitted -- yet.  A subsequent      reference to DECL might cause it to be emitted later.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* If necessary, write out the vtables for the dynamic class CTYPE.    Returns true if any vtables were emitted.  */
end_comment

begin_function
specifier|static
name|bool
name|maybe_emit_vtables
parameter_list|(
name|tree
name|ctype
parameter_list|)
block|{
name|tree
name|vtbl
decl_stmt|;
name|tree
name|primary_vtbl
decl_stmt|;
name|int
name|needed
init|=
literal|0
decl_stmt|;
comment|/* If the vtables for this class have already been emitted there is      nothing more to do.  */
name|primary_vtbl
operator|=
name|CLASSTYPE_VTABLES
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_finalized_p
argument_list|(
name|primary_vtbl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Ignore dummy vtables made by get_vtable_decl.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primary_vtbl
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|false
return|;
comment|/* On some targets, we cannot determine the key method until the end      of the translation unit -- which is when this function is      called.  */
if|if
condition|(
operator|!
name|targetm
operator|.
name|cxx
operator|.
name|key_method_may_be_inline
argument_list|()
condition|)
name|determine_key_method
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
comment|/* See if any of the vtables are needed.  */
for|for
control|(
name|vtbl
operator|=
name|CLASSTYPE_VTABLES
argument_list|(
name|ctype
argument_list|)
init|;
name|vtbl
condition|;
name|vtbl
operator|=
name|TREE_CHAIN
argument_list|(
name|vtbl
argument_list|)
control|)
block|{
name|import_export_decl
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|vtbl
argument_list|)
operator|&&
name|decl_needed_p
argument_list|(
name|vtbl
argument_list|)
condition|)
name|needed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|needed
condition|)
block|{
comment|/* If the references to this class' vtables are optimized away, 	 still emit the appropriate debugging information.  See 	 dfs_debug_mark.  */
if|if
condition|(
name|DECL_COMDAT
argument_list|(
name|primary_vtbl
argument_list|)
operator|&&
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|ctype
argument_list|)
condition|)
name|note_debug_info_needed
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The ABI requires that we emit all of the vtables if we emit any      of them.  */
for|for
control|(
name|vtbl
operator|=
name|CLASSTYPE_VTABLES
argument_list|(
name|ctype
argument_list|)
init|;
name|vtbl
condition|;
name|vtbl
operator|=
name|TREE_CHAIN
argument_list|(
name|vtbl
argument_list|)
control|)
block|{
comment|/* Mark entities references from the virtual table as used.  */
name|mark_vtable_entries
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|vtbl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|expr
init|=
name|store_init_value
argument_list|(
name|vtbl
argument_list|,
name|DECL_INITIAL
argument_list|(
name|vtbl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* It had better be all done at compile-time.  */
name|gcc_assert
argument_list|(
operator|!
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Write it out.  */
name|DECL_EXTERNAL
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|vtbl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Because we're only doing syntax-checking, we'll never end up 	 actually marking the variable as written.  */
if|if
condition|(
name|flag_syntax_only
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|vtbl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Since we're writing out the vtable here, also write the debug      info.  */
name|note_debug_info_needed
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A special return value from type_visibility meaning internal    linkage.  */
end_comment

begin_enum
enum|enum
block|{
name|VISIBILITY_ANON
init|=
name|VISIBILITY_INTERNAL
operator|+
literal|1
block|}
enum|;
end_enum

begin_comment
comment|/* walk_tree helper function for type_visibility.  */
end_comment

begin_function
specifier|static
name|tree
name|min_vis_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|vis_p
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|vis_p
operator|=
name|VISIBILITY_ANON
expr_stmt|;
return|return
operator|*
name|tp
return|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_VISIBILITY
argument_list|(
operator|*
name|tp
argument_list|)
operator|>
operator|*
name|vis_p
condition|)
operator|*
name|vis_p
operator|=
name|CLASSTYPE_VISIBILITY
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns the visibility of TYPE, which is the minimum visibility of its    component types.  */
end_comment

begin_function
specifier|static
name|int
name|type_visibility
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|vis
init|=
name|VISIBILITY_DEFAULT
decl_stmt|;
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|type
argument_list|,
name|min_vis_r
argument_list|,
operator|&
name|vis
argument_list|)
expr_stmt|;
return|return
name|vis
return|;
block|}
end_function

begin_comment
comment|/* Limit the visibility of DECL to VISIBILITY, if not explicitly    specified (or if VISIBILITY is static).  */
end_comment

begin_function
specifier|static
name|bool
name|constrain_visibility
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|visibility
parameter_list|)
block|{
if|if
condition|(
name|visibility
operator|==
name|VISIBILITY_ANON
condition|)
block|{
comment|/* extern "C" declarations aren't affected by the anonymous 	 namespace.  */
if|if
condition|(
operator|!
name|DECL_EXTERN_C_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|visibility
operator|>
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|visibility
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Constrain the visibility of DECL based on the visibility of its template    arguments.  */
end_comment

begin_function
specifier|static
name|void
name|constrain_visibility_for_template
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|targs
parameter_list|)
block|{
comment|/* If this is a template instantiation, check the innermost      template args for visibility constraints.  The outer template      args are covered by the class check.  */
name|tree
name|args
init|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|vis
init|=
literal|0
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
name|vis
operator|=
name|type_visibility
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
block|{
name|STRIP_NOPS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|arg
argument_list|)
condition|)
name|vis
operator|=
name|VISIBILITY_ANON
expr_stmt|;
else|else
name|vis
operator|=
name|DECL_VISIBILITY
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vis
condition|)
name|constrain_visibility
argument_list|(
name|decl
argument_list|,
name|vis
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like c_determine_visibility, but with additional C++-specific    behavior.     Function-scope entities can rely on the function's visibility because    it is set in start_preparsed_function.     Class-scope entities cannot rely on the class's visibility until the end    of the enclosing class definition.     Note that because namespaces have multiple independent definitions,    namespace visibility is handled elsewhere using the #pragma visibility    machinery rather than by decorating the namespace declaration.     The goal is for constraints from the type to give a diagnostic, and    other constraints to be applied silently.  */
end_comment

begin_function
name|void
name|determine_visibility
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|class_type
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|use_template
decl_stmt|;
comment|/* Remember that all decls get VISIBILITY_DEFAULT when built.  */
comment|/* Only relevant for names with external linkage.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Cloned constructors and destructors get the same visibility as      the underlying function.  That should be set up in      maybe_clone_body.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|use_template
operator|=
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|use_template
operator|=
literal|1
expr_stmt|;
else|else
name|use_template
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|use_template
operator|=
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|use_template
operator|=
literal|0
expr_stmt|;
comment|/* Anything that is exported must have default visibility.  */
if|if
condition|(
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If DECL is a member of a class, visibility specifiers on the      class can influence the visibility of the DECL.  */
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|class_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|class_type
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Not a class member.  */
comment|/* Virtual tables have DECL_CONTEXT set to their associated class, 	 so they are automatically handled above.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Local statics and classes get the visibility of their 	     containing function by default, except that 	     -fvisibility-inlines-hidden doesn't affect them.  */
name|tree
name|fn
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|fn
argument_list|)
operator|||
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
name|determine_visibility_from_class
argument_list|(
name|decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Local classes in templates have CLASSTYPE_USE_TEMPLATE set, 	     but have no TEMPLATE_INFO, so don't try to check it.  */
name|use_template
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|flag_visibility_ms_compat
condition|)
block|{
comment|/* Under -fvisibility-ms-compat, types are visible by default, 	     even though their contents aren't.  */
name|tree
name|underlying_type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|underlying_vis
init|=
name|type_visibility
argument_list|(
name|underlying_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|underlying_vis
operator|==
name|VISIBILITY_ANON
operator|||
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|underlying_type
argument_list|)
condition|)
name|constrain_visibility
argument_list|(
name|decl
argument_list|,
name|underlying_vis
argument_list|)
expr_stmt|;
else|else
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* tinfo visibility is based on the type it's for.  */
name|constrain_visibility
argument_list|(
name|decl
argument_list|,
name|type_visibility
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_template
condition|)
comment|/* Template instantiations and specializations get visibility based 	   on their template unless they override it with an attribute.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Set default visibility to whatever the user supplied with 	     #pragma GCC visibility or a namespace visibility attribute.  */
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|default_visibility
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
name|visibility_options
operator|.
name|inpragma
expr_stmt|;
block|}
block|}
if|if
condition|(
name|use_template
condition|)
block|{
comment|/* If the specialization doesn't specify visibility, use the 	 visibility from the template.  */
name|tree
name|tinfo
init|=
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|tree
name|args
init|=
name|TI_ARGS
argument_list|(
name|tinfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|pattern
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TI_TEMPLATE
argument_list|(
name|tinfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME should TMPL_ARGS_DEPTH really return 1 for null input? */
if|if
condition|(
name|args
operator|&&
name|depth
operator|>
name|template_class_depth
argument_list|(
name|class_type
argument_list|)
condition|)
comment|/* Limit visibility based on its template arguments.  */
name|constrain_visibility_for_template
argument_list|(
name|decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|class_type
condition|)
name|determine_visibility_from_class
argument_list|(
name|decl
argument_list|,
name|class_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_anon_ns_mem_p
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Names in an anonymous namespace get internal linkage.        This might change once we implement export.  */
name|constrain_visibility
argument_list|(
name|decl
argument_list|,
name|VISIBILITY_ANON
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
comment|/* Propagate anonymity from type to decl.  */
name|int
name|tvis
init|=
name|type_visibility
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tvis
operator|==
name|VISIBILITY_ANON
condition|)
name|constrain_visibility
argument_list|(
name|decl
argument_list|,
name|tvis
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* By default, static data members and function members receive    the visibility of their containing class.  */
end_comment

begin_function
specifier|static
name|void
name|determine_visibility_from_class
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|class_type
parameter_list|)
block|{
if|if
condition|(
name|visibility_options
operator|.
name|inlines_hidden
comment|/* Don't do this for inline templates; specializations might not be 	 inline, and we don't want them to inherit the hidden 	 visibility.  We'll set it here for all inline instantiations.  */
operator|&&
operator|!
name|processing_template_decl
operator|&&
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Default to the class visibility.  */
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_VISIBILITY
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
block|}
comment|/* Give the target a chance to override the visibility associated      with DECL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
comment|/* Construction virtual tables are not exported because 		 they cannot be referred to from other object files; 		 their name is not standardized by the ABI.  */
operator|&&
operator|!
name|DECL_CONSTRUCTION_VTABLE_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|class_type
argument_list|)
condition|)
name|targetm
operator|.
name|cxx
operator|.
name|determine_class_data_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Constrain the visibility of a class TYPE based on the visibility of its    field types.  Warn if any fields require lesser visibility.  */
end_comment

begin_function
name|void
name|constrain_class_visibility
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|vis
init|=
name|type_visibility
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|vis
operator|==
name|VISIBILITY_ANON
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Don't warn about visibility if the class has explicit visibility.  */
if|if
condition|(
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|type
argument_list|)
condition|)
name|vis
operator|=
name|VISIBILITY_INTERNAL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|ftype
init|=
name|strip_array_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|subvis
init|=
name|type_visibility
argument_list|(
name|ftype
argument_list|)
decl_stmt|;
if|if
condition|(
name|subvis
operator|==
name|VISIBILITY_ANON
condition|)
block|{
if|if
condition|(
operator|!
name|in_main_input_context
argument_list|()
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"\ %qT has a field %qD whose type uses the anonymous namespace"
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ftype
argument_list|)
operator|&&
name|vis
operator|<
name|VISIBILITY_HIDDEN
operator|&&
name|subvis
operator|>=
name|VISIBILITY_HIDDEN
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"\ %qT declared with greater visibility than the type of its field %qD"
argument_list|,
name|type
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|subvis
init|=
name|type_visibility
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|subvis
operator|==
name|VISIBILITY_ANON
condition|)
block|{
if|if
condition|(
operator|!
name|in_main_input_context
argument_list|()
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"\ %qT has a base %qT whose type uses the anonymous namespace"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vis
operator|<
name|VISIBILITY_HIDDEN
operator|&&
name|subvis
operator|>=
name|VISIBILITY_HIDDEN
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"\ %qT declared with greater visibility than its base %qT"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL or VAR_DECL.  If the object file linkage    for DECL has not already been determined, do so now by setting    DECL_EXTERNAL, DECL_COMDAT and other related flags.  Until this    function is called entities with vague linkage whose definitions    are available must have TREE_PUBLIC set.     If this function decides to place DECL in COMDAT, it will set    appropriate flags -- but will not clear DECL_EXTERNAL.  It is up to    the caller to decide whether or not to clear DECL_EXTERNAL.  Some    callers defer that decision until it is clear that DECL is actually    required.  */
end_comment

begin_function
name|void
name|import_export_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|int
name|emit_p
decl_stmt|;
name|bool
name|comdat_p
decl_stmt|;
name|bool
name|import_p
decl_stmt|;
name|tree
name|class_type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* We cannot determine what linkage to give to an entity with vague      linkage until the end of the file.  For example, a virtual table      for a class will be defined if and only if the key method is      defined in this translation unit.  As a further example, consider      that when compiling a translation unit that uses PCH file with      "-frepo" it would be incorrect to make decisions about what      entities to emit when building the PCH; those decisions must be      delayed until the repository information has been processed.  */
name|gcc_assert
argument_list|(
name|at_eof
argument_list|)
expr_stmt|;
comment|/* Object file linkage for explicit instantiations is handled in      mark_decl_instantiated.  For static variables in functions with      vague linkage, maybe_commonize_var is used.       Therefore, the only declarations that should be provided to this      function are those with external linkage that are:       * implicit instantiations of function templates       * inline function       * implicit instantiations of static data members of class        templates       * virtual tables       * typeinfo objects       Furthermore, all entities that reach this point must have a      definition available in this translation unit.       The following assertions check these conditions.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
comment|/* Any code that creates entities with TREE_PUBLIC cleared should      also set DECL_INTERFACE_KNOWN.  */
name|gcc_assert
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gcc_assert
argument_list|(
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that a definition of DECL is available in this translation      unit.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assume that DECL will not have COMDAT linkage.  */
name|comdat_p
operator|=
name|false
expr_stmt|;
comment|/* Assume that DECL will not be imported into this translation      unit.  */
name|import_p
operator|=
name|false
expr_stmt|;
comment|/* See if the repository tells us whether or not to emit DECL in      this translation unit.  */
name|emit_p
operator|=
name|repo_emit_p
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|emit_p
operator|==
literal|0
condition|)
name|import_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|emit_p
operator|==
literal|1
condition|)
block|{
comment|/* The repository indicates that this entity should be defined 	 here.  Make sure the back end honors that request.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|mark_needed
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|clone
decl_stmt|;
name|FOR_EACH_CLONE
argument_list|(
argument|clone
argument_list|,
argument|decl
argument_list|)
name|mark_needed
argument_list|(
name|clone
argument_list|)
expr_stmt|;
block|}
else|else
name|mark_needed
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output the definition as an ordinary strong definition.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|import_p
condition|)
comment|/* We have already decided what to do with this DECL; there is no        need to check anything further.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|class_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|import_export_class
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|class_type
argument_list|)
condition|)
name|import_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|class_type
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|class_type
argument_list|)
condition|)
name|import_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|!
name|flag_weak
operator|||
name|TARGET_WEAK_NOT_IN_ARCHIVE_TOC
operator|)
operator|&&
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|class_type
argument_list|)
operator|&&
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|class_type
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|class_type
argument_list|)
argument_list|)
condition|)
comment|/* The ABI requires that all virtual tables be emitted with 	   COMDAT linkage.  However, on systems where COMDAT symbols 	   don't show up in the table of contents for a static 	   archive, or on systems without weak symbols (where we 	   approximate COMDAT linkage by using internal linkage), the 	   linker will report errors about undefined symbols because 	   it will not see the virtual table definition.  Therefore, 	   in the case that we know that the virtual table will be 	   emitted in only one translation unit, we make the virtual 	   table an ordinary definition with external linkage.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|class_type
argument_list|)
condition|)
block|{
comment|/* CLASS_TYPE is being exported from this translation unit, 	     so DECL should be defined here.  */
if|if
condition|(
operator|!
name|flag_weak
operator|&&
name|CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|class_type
argument_list|)
condition|)
comment|/* If a class is declared in a header with the "extern 	       template" extension, then it will not be instantiated, 	       even in translation units that would normally require 	       it.  Often such classes are explicitly instantiated in 	       one translation unit.  Therefore, the explicit 	       instantiation must be made visible to other translation 	       units.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* The generic C++ ABI says that class data is always 		 COMDAT, even if there is a key function.  Some 		 variants (e.g., the ARM EABI) says that class data 		 only has COMDAT linkage if the class data might be 		 emitted in more than one translation unit.  When the 		 key method can be inline and is inline, we still have 		 to arrange for comdat even though 		 class_data_always_comdat is false.  */
if|if
condition|(
operator|!
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|class_type
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|class_type
argument_list|)
argument_list|)
operator|||
name|targetm
operator|.
name|cxx
operator|.
name|class_data_always_comdat
argument_list|()
condition|)
block|{
comment|/* The ABI requires COMDAT linkage.  Normally, we 		     only emit COMDAT things when they are needed; 		     make sure that we realize that this entity is 		     indeed needed.  */
name|comdat_p
operator|=
name|true
expr_stmt|;
name|mark_needed
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|flag_implicit_templates
operator|&&
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|class_type
argument_list|)
condition|)
name|import_p
operator|=
name|true
expr_stmt|;
else|else
name|comdat_p
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TINFO_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|class_type
operator|=
name|type
expr_stmt|;
name|import_export_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_POLYMORPHIC_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
comment|/* If -fno-rtti was specified, then we cannot be sure 		 that RTTI information will be emitted with the 		 virtual table of the class, so we must emit it 		 wherever it is used.  */
operator|&&
name|flag_rtti
condition|)
name|import_p
operator|=
name|true
expr_stmt|;
else|else
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|comdat_p
operator|=
operator|(
name|targetm
operator|.
name|cxx
operator|.
name|class_data_always_comdat
argument_list|()
operator|||
operator|(
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
name|mark_needed
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_weak
condition|)
block|{
name|comdat_p
operator|=
name|false
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|comdat_p
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
name|comdat_p
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* DECL is an implicit instantiation of a function or static 	 data member.  */
if|if
condition|(
name|flag_implicit_templates
operator|||
operator|(
name|flag_implicit_inline_templates
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|comdat_p
operator|=
name|true
expr_stmt|;
else|else
comment|/* If we are not implicitly generating templates, then mark 	   this entity as undefined in this translation unit.  */
name|import_p
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|ctype
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|import_export_class
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Always make artificials weak.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|flag_weak
condition|)
name|comdat_p
operator|=
name|true
expr_stmt|;
else|else
name|maybe_make_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|comdat_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|comdat_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|import_p
condition|)
block|{
comment|/* If we are importing DECL into this translation unit, mark is 	 an undefined here.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comdat_p
condition|)
block|{
comment|/* If we decided to put DECL in COMDAT, mark it accordingly at 	 this point.  */
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an expression that performs the destruction of DECL, which    must be a VAR_DECL whose type has a non-trivial destructor, or is    an array whose (innermost) elements have a non-trivial destructor.  */
end_comment

begin_function
name|tree
name|build_cleanup
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* This function should only be called for declarations that really      require cleanups.  */
name|gcc_assert
argument_list|(
operator|!
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Treat all objects with destructors as used; the destructor may do      something substantive.  */
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|temp
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|cxx_mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|temp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|sfk_complete_destructor
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Returns the initialization guard variable for the variable DECL,    which has static storage duration.  */
end_comment

begin_function
name|tree
name|get_guard
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|sname
decl_stmt|;
name|tree
name|guard
decl_stmt|;
name|sname
operator|=
name|mangle_guard_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|guard
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|guard
condition|)
block|{
name|tree
name|guard_type
decl_stmt|;
comment|/* We use a type that is big enough to contain a mutex as well 	 as an integer counter.  */
name|guard_type
operator|=
name|targetm
operator|.
name|cxx
operator|.
name|guard_type
argument_list|()
expr_stmt|;
name|guard
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|sname
argument_list|,
name|guard_type
argument_list|)
expr_stmt|;
comment|/* The guard should have the same linkage as what it guards.  */
name|TREE_PUBLIC
argument_list|(
name|guard
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|guard
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|guard
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|guard
argument_list|)
operator|=
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_WEAK
argument_list|(
name|guard
argument_list|)
operator|=
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|guard
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|guard
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|guard
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level_and_finish
argument_list|(
name|guard
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|guard
return|;
block|}
end_function

begin_comment
comment|/* Return those bits of the GUARD variable that should be set when the    guarded entity is actually initialized.  */
end_comment

begin_function
specifier|static
name|tree
name|get_guard_bits
parameter_list|(
name|tree
name|guard
parameter_list|)
block|{
if|if
condition|(
operator|!
name|targetm
operator|.
name|cxx
operator|.
name|guard_mask_bit
argument_list|()
condition|)
block|{
comment|/* We only set the first byte of the guard, in order to leave room 	 for a mutex in the high-order bits.  */
name|guard
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|)
argument_list|,
name|guard
argument_list|)
expr_stmt|;
name|guard
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
name|guard
argument_list|)
expr_stmt|;
name|guard
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|char_type_node
argument_list|,
name|guard
argument_list|)
expr_stmt|;
block|}
return|return
name|guard
return|;
block|}
end_function

begin_comment
comment|/* Return an expression which determines whether or not the GUARD    variable has already been initialized.  */
end_comment

begin_function
name|tree
name|get_guard_cond
parameter_list|(
name|tree
name|guard
parameter_list|)
block|{
name|tree
name|guard_value
decl_stmt|;
comment|/* Check to see if the GUARD is zero.  */
name|guard
operator|=
name|get_guard_bits
argument_list|(
name|guard
argument_list|)
expr_stmt|;
comment|/* Mask off all but the low bit.  */
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|guard_mask_bit
argument_list|()
condition|)
block|{
name|guard_value
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard_value
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|)
condition|)
name|guard_value
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|,
name|guard_value
argument_list|)
expr_stmt|;
name|guard
operator|=
name|cp_build_binary_op
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|guard
argument_list|,
name|guard_value
argument_list|)
expr_stmt|;
block|}
name|guard_value
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard_value
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|)
condition|)
name|guard_value
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|,
name|guard_value
argument_list|)
expr_stmt|;
return|return
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|guard
argument_list|,
name|guard_value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an expression which sets the GUARD variable, indicating that    the variable being guarded has been initialized.  */
end_comment

begin_function
name|tree
name|set_guard
parameter_list|(
name|tree
name|guard
parameter_list|)
block|{
name|tree
name|guard_init
decl_stmt|;
comment|/* Set the GUARD to one.  */
name|guard
operator|=
name|get_guard_bits
argument_list|(
name|guard
argument_list|)
expr_stmt|;
name|guard_init
operator|=
name|integer_one_node
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard_init
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|)
condition|)
name|guard_init
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|guard
argument_list|)
argument_list|,
name|guard_init
argument_list|)
expr_stmt|;
return|return
name|build_modify_expr
argument_list|(
name|guard
argument_list|,
name|NOP_EXPR
argument_list|,
name|guard_init
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start the process of running a particular set of global constructors    or destructors.  Subroutine of do_[cd]tors.  */
end_comment

begin_function
specifier|static
name|tree
name|start_objects
parameter_list|(
name|int
name|method_type
parameter_list|,
name|int
name|initp
parameter_list|)
block|{
name|tree
name|body
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|char
name|type
index|[
literal|10
index|]
decl_stmt|;
comment|/* Make ctor or dtor function.  METHOD_TYPE may be 'I' or 'D'.  */
if|if
condition|(
name|initp
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|char
name|joiner
decl_stmt|;
ifdef|#
directive|ifdef
name|JOINER
name|joiner
operator|=
name|JOINER
expr_stmt|;
else|#
directive|else
name|joiner
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%c%c%.5u"
argument_list|,
name|method_type
argument_list|,
name|joiner
argument_list|,
name|initp
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%c"
argument_list|,
name|method_type
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_file_function_name_long
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|start_preparsed_function
argument_list|(
name|fndecl
argument_list|,
comment|/*attrs=*/
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* It can be a static function as long as collect2 does not have      to scan the object file to find its ctor/dtor routine.  */
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|=
operator|!
name|targetm
operator|.
name|have_ctors_dtors
expr_stmt|;
comment|/* Mark this declaration as used to avoid spurious warnings.  */
name|TREE_USED
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark this function as a global constructor or destructor.  */
if|if
condition|(
name|method_type
operator|==
literal|'I'
condition|)
name|DECL_GLOBAL_CTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|DECL_GLOBAL_DTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|current_function_decl
argument_list|)
operator|->
name|decl_flags
operator|.
name|u2sel
operator|=
literal|1
expr_stmt|;
name|body
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_FN_BODY
argument_list|)
expr_stmt|;
comment|/* We cannot allow these functions to be elided, even if they do not      have external linkage.  And, there's no point in deferring      compilation of these functions; they're all going to have to be      out anyhow.  */
name|DECL_INLINE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_comment
comment|/* Finish the process of running a particular set of global constructors    or destructors.  Subroutine of do_[cd]tors.  */
end_comment

begin_function
specifier|static
name|void
name|finish_objects
parameter_list|(
name|int
name|method_type
parameter_list|,
name|int
name|initp
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
comment|/* Finish up.  */
name|finish_compound_stmt
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|fn
operator|=
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_or_defer_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* When only doing semantic analysis, and no RTL generation, we      can't call functions that directly emit assembly code; there is      no assembly file in which to put the code.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
block|{
name|rtx
name|fnsym
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|method_type
operator|==
literal|'I'
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|constructor
call|)
argument_list|(
name|fnsym
argument_list|,
name|initp
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|destructor
call|)
argument_list|(
name|fnsym
argument_list|,
name|initp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The names of the parameters to the function created to handle    initializations and destructions for objects with static storage    duration.  */
end_comment

begin_define
define|#
directive|define
name|INITIALIZE_P_IDENTIFIER
value|"__initialize_p"
end_define

begin_define
define|#
directive|define
name|PRIORITY_IDENTIFIER
value|"__priority"
end_define

begin_comment
comment|/* The name of the function we create to handle initializations and    destructions for objects with static storage duration.  */
end_comment

begin_define
define|#
directive|define
name|SSDF_IDENTIFIER
value|"__static_initialization_and_destruction"
end_define

begin_comment
comment|/* The declaration for the __INITIALIZE_P argument.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|initialize_p_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The declaration for the __PRIORITY argument.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|priority_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The declaration for the static storage duration function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|ssdf_decl
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* All the static storage duration functions created in this    translation unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|ssdf_decls
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A map from priority levels to information about that priority    level.  There may be many such levels, so efficient lookup is    important.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|priority_info_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begins the generation of the function that will handle all    initialization and destruction of objects with static storage    duration.  The function generated takes two parameters of type    `int': __INITIALIZE_P and __PRIORITY.  If __INITIALIZE_P is    nonzero, it performs initializations.  Otherwise, it performs    destructions.  It only performs those initializations or    destructions with the indicated __PRIORITY.  The generated function    returns no value.     It is assumed that this function will only be called once per    translation unit.  */
end_comment

begin_function
specifier|static
name|tree
name|start_static_storage_duration_function
parameter_list|(
name|unsigned
name|count
parameter_list|)
block|{
name|tree
name|parm_types
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|body
decl_stmt|;
name|char
name|id
index|[
sizeof|sizeof
argument_list|(
name|SSDF_IDENTIFIER
argument_list|)
operator|+
literal|1
comment|/* '\0' */
operator|+
literal|32
index|]
decl_stmt|;
comment|/* Create the identifier for this function.  It will be of the form      SSDF_IDENTIFIER_<number>.  */
name|sprintf
argument_list|(
name|id
argument_list|,
literal|"%s_%u"
argument_list|,
name|SSDF_IDENTIFIER
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Create the parameters.  */
name|parm_types
operator|=
name|void_list_node
expr_stmt|;
name|parm_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
name|parm_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
comment|/* Create the FUNCTION_DECL itself.  */
name|ssdf_decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|id
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Put this function in the list of functions to be called from the      static constructors and destructors.  */
if|if
condition|(
operator|!
name|ssdf_decls
condition|)
block|{
name|ssdf_decls
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Take this opportunity to initialize the map from priority 	 numbers to information about that priority level.  */
name|priority_info_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
comment|/*delete_key_fn=*/
literal|0
argument_list|,
comment|/*delete_value_fn=*/
operator|(
name|splay_tree_delete_value_fn
operator|)
operator|&
name|free
argument_list|)
expr_stmt|;
comment|/* We always need to generate functions for the 	 DEFAULT_INIT_PRIORITY so enter it now.  That way when we walk 	 priorities later, we'll be sure to find the 	 DEFAULT_INIT_PRIORITY.  */
name|get_priority_info
argument_list|(
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|ssdf_decls
argument_list|,
name|ssdf_decl
argument_list|)
expr_stmt|;
comment|/* Create the argument list.  */
name|initialize_p_decl
operator|=
name|cp_build_parm_decl
argument_list|(
name|get_identifier
argument_list|(
name|INITIALIZE_P_IDENTIFIER
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
name|ssdf_decl
expr_stmt|;
name|TREE_USED
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|priority_decl
operator|=
name|cp_build_parm_decl
argument_list|(
name|get_identifier
argument_list|(
name|PRIORITY_IDENTIFIER
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|priority_decl
argument_list|)
operator|=
name|ssdf_decl
expr_stmt|;
name|TREE_USED
argument_list|(
name|priority_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
name|priority_decl
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
name|initialize_p_decl
expr_stmt|;
comment|/* Put the function in the global scope.  */
name|pushdecl
argument_list|(
name|ssdf_decl
argument_list|)
expr_stmt|;
comment|/* Start the function itself.  This is equivalent to declaring the      function as:         static void __ssdf (int __initialize_p, init __priority_p);       It is static because we only need to call this function from the      various constructor and destructor functions for this module.  */
name|start_preparsed_function
argument_list|(
name|ssdf_decl
argument_list|,
comment|/*attrs=*/
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* Set up the scope of the outermost block in the function.  */
name|body
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_FN_BODY
argument_list|)
expr_stmt|;
comment|/* This function must not be deferred because we are depending on      its compilation to tell us what is TREE_SYMBOL_REFERENCED.  */
name|DECL_INLINE
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|body
return|;
block|}
end_function

begin_comment
comment|/* Finish the generation of the function which performs initialization    and destruction of objects with static storage duration.  After    this point, no more such objects can be created.  */
end_comment

begin_function
specifier|static
name|void
name|finish_static_storage_duration_function
parameter_list|(
name|tree
name|body
parameter_list|)
block|{
comment|/* Close out the function.  */
name|finish_compound_stmt
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|expand_or_defer_fn
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the information about the indicated PRIORITY level.  If no    code to handle this level has yet been generated, generate the    appropriate prologue.  */
end_comment

begin_function
specifier|static
name|priority_info
name|get_priority_info
parameter_list|(
name|int
name|priority
parameter_list|)
block|{
name|priority_info
name|pi
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|priority_info_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* Create a new priority information structure, and insert it 	 into the map.  */
name|pi
operator|=
name|XNEW
argument_list|(
expr|struct
name|priority_info_s
argument_list|)
expr_stmt|;
name|pi
operator|->
name|initializations_p
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|destructions_p
operator|=
literal|0
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|priority_info_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|priority
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
name|pi
operator|=
operator|(
name|priority_info
operator|)
name|n
operator|->
name|value
expr_stmt|;
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/* The effective initialization priority of a DECL.  */
end_comment

begin_define
define|#
directive|define
name|DECL_EFFECTIVE_INIT_PRIORITY
parameter_list|(
name|decl
parameter_list|)
define|\
value|((!DECL_HAS_INIT_PRIORITY_P (decl) || DECL_INIT_PRIORITY (decl) == 0) \ 	 ? DEFAULT_INIT_PRIORITY : DECL_INIT_PRIORITY (decl))
end_define

begin_comment
comment|/* Whether a DECL needs a guard to protect it against multiple    initialization.  */
end_comment

begin_define
define|#
directive|define
name|NEEDS_GUARD_P
parameter_list|(
name|decl
parameter_list|)
value|(TREE_PUBLIC (decl)&& (DECL_COMMON (decl)      \ 						    || DECL_ONE_ONLY (decl) \ 						    || DECL_WEAK (decl)))
end_define

begin_comment
comment|/* Set up to handle the initialization or destruction of DECL.  If    INITP is nonzero, we are initializing the variable.  Otherwise, we    are destroying it.  */
end_comment

begin_function
specifier|static
name|void
name|one_static_initialization_or_destruction
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|bool
name|initp
parameter_list|)
block|{
name|tree
name|guard_if_stmt
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|guard
decl_stmt|;
comment|/* If we are supposed to destruct and there's a trivial destructor,      nothing has to be done.  */
if|if
condition|(
operator|!
name|initp
operator|&&
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Trick the compiler into thinking we are at the file and line      where DECL was declared so that error-messages make sense, and so      that the debugger will show somewhat sensible file and line      information.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Because of:         [class.access.spec]         Access control for implicit calls to the constructors,        the conversion functions, or the destructor called to        create and destroy a static data member is performed as        if these calls appeared in the scope of the member's        class.       we pretend we are in a static member function of the class of      which the DECL is a member.  */
if|if
condition|(
name|member_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Assume we don't need a guard.  */
name|guard
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* We need a guard if this is an object with external linkage that      might be initialized in more than one place.  (For example, a      static data member of a template, when the data member requires      construction.)  */
if|if
condition|(
name|NEEDS_GUARD_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|guard_cond
decl_stmt|;
name|guard
operator|=
name|get_guard
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* When using __cxa_atexit, we just check the GUARD as we would 	 for a local static.  */
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
block|{
comment|/* When using __cxa_atexit, we never try to destroy 	     anything from a static destructor.  */
name|gcc_assert
argument_list|(
name|initp
argument_list|)
expr_stmt|;
name|guard_cond
operator|=
name|get_guard_cond
argument_list|(
name|guard
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have __cxa_atexit, then we will be running 	 destructors from .fini sections, or their equivalents.  So, 	 we need to know how many times we've tried to initialize this 	 object.  We do initializations only if the GUARD is zero, 	 i.e., if we are the first to initialize the variable.  We do 	 destructions only if the GUARD is one, i.e., if we are the 	 last to destroy the variable.  */
elseif|else
if|if
condition|(
name|initp
condition|)
name|guard_cond
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|guard
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
else|else
name|guard_cond
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|guard
argument_list|,
comment|/*noconvert=*/
literal|1
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|guard_if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|guard_cond
argument_list|,
name|guard_if_stmt
argument_list|)
expr_stmt|;
block|}
comment|/* If we're using __cxa_atexit, we have not already set the GUARD,      so we must do so now.  */
if|if
condition|(
name|guard
operator|&&
name|initp
operator|&&
name|flag_use_cxa_atexit
condition|)
name|finish_expr_stmt
argument_list|(
name|set_guard
argument_list|(
name|guard
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform the initialization or destruction.  */
if|if
condition|(
name|initp
condition|)
block|{
if|if
condition|(
name|init
condition|)
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* If we're using __cxa_atexit, register a function that calls the 	 destructor for the object.  */
if|if
condition|(
name|flag_use_cxa_atexit
condition|)
name|finish_expr_stmt
argument_list|(
name|register_dtor_fn
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|finish_expr_stmt
argument_list|(
name|build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finish the guard if-stmt, if necessary.  */
if|if
condition|(
name|guard
condition|)
block|{
name|finish_then_clause
argument_list|(
name|guard_if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|guard_if_stmt
argument_list|)
expr_stmt|;
block|}
comment|/* Now that we're done with DECL we don't need to pretend to be a      member of its class any longer.  */
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to do the initialization or destruction of the decls in VARS,    a TREE_LIST of VAR_DECL with static storage duration.    Whether initialization or destruction is performed is specified by INITP.  */
end_comment

begin_function
specifier|static
name|void
name|do_static_initialization_or_destruction
parameter_list|(
name|tree
name|vars
parameter_list|,
name|bool
name|initp
parameter_list|)
block|{
name|tree
name|node
decl_stmt|,
name|init_if_stmt
decl_stmt|,
name|cond
decl_stmt|;
comment|/* Build the outer if-stmt to check for initialization or destruction.  */
name|init_if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|cond
operator|=
name|initp
condition|?
name|integer_one_node
else|:
name|integer_zero_node
expr_stmt|;
name|cond
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|initialize_p_decl
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|cond
argument_list|,
name|init_if_stmt
argument_list|)
expr_stmt|;
name|node
operator|=
name|vars
expr_stmt|;
do|do
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|tree
name|priority_if_stmt
decl_stmt|;
name|int
name|priority
decl_stmt|;
name|priority_info
name|pi
decl_stmt|;
comment|/* If we don't need a destructor, there's nothing to do.  Avoid        creating a possibly empty if-stmt.  */
if|if
condition|(
operator|!
name|initp
operator|&&
name|TYPE_HAS_TRIVIAL_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Remember that we had an initialization or finalization at this        priority.  */
name|priority
operator|=
name|DECL_EFFECTIVE_INIT_PRIORITY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pi
operator|=
name|get_priority_info
argument_list|(
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|initp
condition|)
name|pi
operator|->
name|initializations_p
operator|=
literal|1
expr_stmt|;
else|else
name|pi
operator|->
name|destructions_p
operator|=
literal|1
expr_stmt|;
comment|/* Conditionalize this initialization on being in the right priority        and being initializing/finalizing appropriately.  */
name|priority_if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|cond
operator|=
name|cp_build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|priority_decl
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|cond
argument_list|,
name|priority_if_stmt
argument_list|)
expr_stmt|;
comment|/* Process initializers with same priority.  */
for|for
control|(
init|;
name|node
operator|&&
name|DECL_EFFECTIVE_INIT_PRIORITY
argument_list|(
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|priority
condition|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
control|)
comment|/* Do one initialization or destruction.  */
name|one_static_initialization_or_destruction
argument_list|(
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|node
argument_list|)
argument_list|,
name|initp
argument_list|)
expr_stmt|;
comment|/* Finish up the priority if-stmt body.  */
name|finish_then_clause
argument_list|(
name|priority_if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|priority_if_stmt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|node
condition|)
do|;
comment|/* Finish up the init/destruct if-stmt body.  */
name|finish_then_clause
argument_list|(
name|init_if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|init_if_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARS is a list of variables with static storage duration which may    need initialization and/or finalization.  Remove those variables    that don't really need to be initialized or finalized, and return    the resulting list.  The order in which the variables appear in    VARS is in reverse order of the order in which they should actually    be initialized.  The list we return is in the unreversed order;    i.e., the first variable should be initialized first.  */
end_comment

begin_function
specifier|static
name|tree
name|prune_vars_needing_no_initialization
parameter_list|(
name|tree
modifier|*
name|vars
parameter_list|)
block|{
name|tree
modifier|*
name|var
init|=
name|vars
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
operator|*
name|var
condition|)
block|{
name|tree
name|t
init|=
operator|*
name|var
decl_stmt|;
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Deal gracefully with error.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
block|{
name|var
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The only things that can be initialized are variables.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
comment|/* If this object is not defined, we don't need to do anything 	 here.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|var
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Also, if the initializer already contains errors, we can bail 	 out now.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|value_member
argument_list|(
name|error_mark_node
argument_list|,
name|init
argument_list|)
condition|)
block|{
name|var
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* This variable is going to need initialization and/or 	 finalization, so we add it to the list.  */
operator|*
name|var
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|t
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Make sure we have told the back end about all the variables in    VARS.  */
end_comment

begin_function
specifier|static
name|void
name|write_out_vars
parameter_list|(
name|tree
name|vars
parameter_list|)
block|{
name|tree
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|vars
init|;
name|v
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var_finalized_p
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|import_export_decl
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|var
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a static constructor (if CONSTRUCTOR_P) or destructor    (otherwise) that will initialize all gobal objects with static    storage duration having the indicated PRIORITY.  */
end_comment

begin_function
specifier|static
name|void
name|generate_ctor_or_dtor_function
parameter_list|(
name|bool
name|constructor_p
parameter_list|,
name|int
name|priority
parameter_list|,
name|location_t
modifier|*
name|locus
parameter_list|)
block|{
name|char
name|function_key
decl_stmt|;
name|tree
name|arguments
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|body
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|input_location
operator|=
operator|*
name|locus
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
comment|/* ??? */
else|#
directive|else
name|locus
operator|->
name|line
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* We use `I' to indicate initialization and `D' to indicate      destruction.  */
name|function_key
operator|=
name|constructor_p
condition|?
literal|'I'
else|:
literal|'D'
expr_stmt|;
comment|/* We emit the function lazily, to avoid generating empty      global constructors and destructors.  */
name|body
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* For Objective-C++, we may need to initialize metadata found in this module.      This must be done _before_ any other static initializations.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
operator|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
operator|)
operator|&&
name|constructor_p
operator|&&
name|objc_static_init_needed_p
argument_list|()
condition|)
block|{
name|body
operator|=
name|start_objects
argument_list|(
name|function_key
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|static_ctors
operator|=
name|objc_generate_static_init_call
argument_list|(
name|static_ctors
argument_list|)
expr_stmt|;
block|}
comment|/* Call the static storage duration function with appropriate      arguments.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|ssdf_decls
argument_list|,
name|i
argument_list|,
name|fndecl
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* Calls to pure or const functions will expand to nothing.  */
if|if
condition|(
operator|!
operator|(
name|flags_from_decl_or_type
argument_list|(
name|fndecl
argument_list|)
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|start_objects
argument_list|(
name|function_key
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|arguments
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|priority
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arguments
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|constructor_p
argument_list|)
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|fndecl
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're generating code for the DEFAULT_INIT_PRIORITY, throw in      calls to any functions marked with attributes indicating that      they should be called at initialization- or destruction-time.  */
if|if
condition|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|tree
name|fns
decl_stmt|;
for|for
control|(
name|fns
operator|=
name|constructor_p
condition|?
name|static_ctors
else|:
name|static_dtors
init|;
name|fns
condition|;
name|fns
operator|=
name|TREE_CHAIN
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* Calls to pure/const functions will expand to nothing.  */
if|if
condition|(
operator|!
operator|(
name|flags_from_decl_or_type
argument_list|(
name|fndecl
argument_list|)
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|start_objects
argument_list|(
name|function_key
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Close out the function.  */
if|if
condition|(
name|body
condition|)
name|finish_objects
argument_list|(
name|function_key
argument_list|,
name|priority
argument_list|,
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate constructor and destructor functions for the priority    indicated by N.  */
end_comment

begin_function
specifier|static
name|int
name|generate_ctor_and_dtor_functions_for_priority
parameter_list|(
name|splay_tree_node
name|n
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|location_t
modifier|*
name|locus
init|=
operator|(
name|location_t
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|priority
init|=
operator|(
name|int
operator|)
name|n
operator|->
name|key
decl_stmt|;
name|priority_info
name|pi
init|=
operator|(
name|priority_info
operator|)
name|n
operator|->
name|value
decl_stmt|;
comment|/* Generate the functions themselves, but only if they are really      needed.  */
if|if
condition|(
name|pi
operator|->
name|initializations_p
operator|||
operator|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
operator|&&
name|static_ctors
operator|)
condition|)
name|generate_ctor_or_dtor_function
argument_list|(
comment|/*constructor_p=*/
name|true
argument_list|,
name|priority
argument_list|,
name|locus
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|destructions_p
operator|||
operator|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
operator|&&
name|static_dtors
operator|)
condition|)
name|generate_ctor_or_dtor_function
argument_list|(
comment|/*constructor_p=*/
name|false
argument_list|,
name|priority
argument_list|,
name|locus
argument_list|)
expr_stmt|;
comment|/* Keep iterating.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called via LANGHOOK_CALLGRAPH_ANALYZE_EXPR.  It is supposed to mark    decls referenced from frontend specific constructs; it will be called    only for language-specific tree nodes.     Here we must deal with member pointers.  */
end_comment

begin_function
name|tree
name|cxx_callgraph_analyze_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|from
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PTRMEM_CST
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASELINK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|cgraph_mark_needed_node
argument_list|(
name|cgraph_node
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_VTABLE_OR_VTT_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* The ABI requires that all virtual tables be emitted 	     whenever one of them is.  */
name|tree
name|vtbl
decl_stmt|;
for|for
control|(
name|vtbl
operator|=
name|CLASSTYPE_VTABLES
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
name|vtbl
condition|;
name|vtbl
operator|=
name|TREE_CHAIN
argument_list|(
name|vtbl
argument_list|)
control|)
name|mark_decl_referenced
argument_list|(
name|vtbl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* If we need a static variable in a function, then we 	   need the containing function.  */
name|mark_decl_referenced
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Java requires that we be able to reference a local address for a    method, and not be confused by PLT entries.  If hidden aliases are    supported, emit one for each java function that we've emitted.  */
end_comment

begin_function
specifier|static
name|void
name|build_java_method_aliases
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_GAS_HIDDEN
return|return;
endif|#
directive|endif
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|tree
name|fndecl
init|=
name|node
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|TYPE_FOR_JAVA
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|TARGET_USE_LOCAL_THUNK_ALIAS_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Mangle the name in a predictable way; we need to reference 	     this from a java compiled object file.  */
name|tree
name|oid
decl_stmt|,
name|nid
decl_stmt|,
name|alias
decl_stmt|;
specifier|const
name|char
modifier|*
name|oname
decl_stmt|;
name|char
modifier|*
name|nname
decl_stmt|;
name|oid
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|oname
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|oname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|oname
index|[
literal|1
index|]
operator|==
literal|'Z'
argument_list|)
expr_stmt|;
name|nname
operator|=
name|ACONCAT
argument_list|(
operator|(
literal|"_ZGA"
operator|,
name|oname
operator|+
literal|2
operator|,
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|nid
operator|=
name|get_identifier
argument_list|(
name|nname
argument_list|)
expr_stmt|;
name|alias
operator|=
name|make_alias_for
argument_list|(
name|fndecl
argument_list|,
name|nid
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|alias
argument_list|)
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
name|assemble_alias
argument_list|(
name|alias
argument_list|,
name|oid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This routine is called from the last rule in yyparse ().    Its job is to create all the code needed to initialize and    destroy the global aggregates.  We do the destruction    first, since that way we only need to reverse the decls once.  */
end_comment

begin_function
name|void
name|cp_finish_file
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|vars
decl_stmt|;
name|bool
name|reconsider
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|location_t
name|locus
decl_stmt|;
name|unsigned
name|ssdf_count
init|=
literal|0
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|locus
operator|=
name|input_location
expr_stmt|;
name|at_eof
operator|=
literal|1
expr_stmt|;
comment|/* Bad parse errors.  Just forget about it.  */
if|if
condition|(
operator|!
name|global_bindings_p
argument_list|()
operator|||
name|current_class_type
operator|||
name|decl_namespace_list
condition|)
return|return;
if|if
condition|(
name|pch_file
condition|)
name|c_common_write_pch
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
comment|/* FIXME - huh? */
else|#
directive|else
comment|/* Otherwise, GDB can get confused, because in only knows      about source for LINENO-1 lines.  */
name|input_line
operator|-=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* We now have to write out all the stuff we put off writing out.      These include:         o Template specializations that we have not yet instantiated, 	 but which are needed.        o Initialization and destruction for non-local objects with 	 static storage duration.  (Local objects with static storage 	 duration are initialized when their scope is first entered, 	 and are cleaned up via atexit.)        o Virtual function tables.       All of these may cause others to be needed.  For example,      instantiating one function may cause another to be needed, and      generating the initializer for an object may cause templates to be      instantiated, etc., etc.  */
name|timevar_push
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
name|emit_support_tinfos
argument_list|()
expr_stmt|;
do|do
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|reconsider
operator|=
name|false
expr_stmt|;
comment|/* If there are templates that we've put off instantiating, do 	 them now.  */
name|instantiate_pending_templates
argument_list|(
name|retries
argument_list|)
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
comment|/* Write out virtual tables as required.  Note that writing out 	 the virtual table for a template class may cause the 	 instantiation of members of that class.  If we write out 	 vtables then we remove the class from our list so we don't 	 have to look at it again.  */
while|while
condition|(
name|keyed_classes
operator|!=
name|NULL_TREE
operator|&&
name|maybe_emit_vtables
argument_list|(
name|TREE_VALUE
argument_list|(
name|keyed_classes
argument_list|)
argument_list|)
condition|)
block|{
name|reconsider
operator|=
name|true
expr_stmt|;
name|keyed_classes
operator|=
name|TREE_CHAIN
argument_list|(
name|keyed_classes
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|keyed_classes
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|maybe_emit_vtables
argument_list|(
name|TREE_VALUE
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
name|reconsider
operator|=
name|true
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out needed type info variables.  We have to be careful 	 looping through unemitted decls, because emit_tinfo_decl may 	 cause other variables to be needed. New elements will be 	 appended, and we remove from the vector those that actually 	 get emitted.  */
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|unemitted_tinfo_decls
argument_list|)
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|unemitted_tinfo_decls
argument_list|,
operator|--
name|i
argument_list|,
name|t
argument_list|)
condition|;
control|)
if|if
condition|(
name|emit_tinfo_decl
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|reconsider
operator|=
name|true
expr_stmt|;
name|VEC_unordered_remove
argument_list|(
name|tree
argument_list|,
name|unemitted_tinfo_decls
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* The list of objects with static storage duration is built up 	 in reverse order.  We clear STATIC_AGGREGATES so that any new 	 aggregates added during the initialization of these will be 	 initialized in the correct order when we next come around the 	 loop.  */
name|vars
operator|=
name|prune_vars_needing_no_initialization
argument_list|(
operator|&
name|static_aggregates
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
condition|)
block|{
comment|/* We need to start a new initialization function each time 	     through the loop.  That's because we need to know which 	     vtables have been referenced, and TREE_SYMBOL_REFERENCED 	     isn't computed until a function is finished, and written 	     out.  That's a deficiency in the back-end.  When this is 	     fixed, these initialization functions could all become 	     inline, with resulting performance improvements.  */
name|tree
name|ssdf_body
decl_stmt|;
comment|/* Set the line and file, so that it is obviously not from 	     the source file.  */
name|input_location
operator|=
name|locus
expr_stmt|;
name|ssdf_body
operator|=
name|start_static_storage_duration_function
argument_list|(
name|ssdf_count
argument_list|)
expr_stmt|;
comment|/* Make sure the back end knows about all the variables.  */
name|write_out_vars
argument_list|(
name|vars
argument_list|)
expr_stmt|;
comment|/* First generate code to do all the initializations.  */
if|if
condition|(
name|vars
condition|)
name|do_static_initialization_or_destruction
argument_list|(
name|vars
argument_list|,
comment|/*initp=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Then, generate code to do all the destructions.  Do these 	     in reverse order so that the most recently constructed 	     variable is the first destroyed.  If we're using 	     __cxa_atexit, then we don't need to do this; functions 	     were registered at initialization time to destroy the 	     local statics.  */
if|if
condition|(
operator|!
name|flag_use_cxa_atexit
operator|&&
name|vars
condition|)
block|{
name|vars
operator|=
name|nreverse
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|do_static_initialization_or_destruction
argument_list|(
name|vars
argument_list|,
comment|/*initp=*/
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|vars
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Finish up the static storage duration function for this 	     round.  */
name|input_location
operator|=
name|locus
expr_stmt|;
name|finish_static_storage_duration_function
argument_list|(
name|ssdf_body
argument_list|)
expr_stmt|;
comment|/* All those initializations and finalizations might cause 	     us to need more inline functions, more template 	     instantiations, etc.  */
name|reconsider
operator|=
name|true
expr_stmt|;
name|ssdf_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
comment|/* ??? */
else|#
directive|else
name|locus
operator|.
name|line
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Go through the set of inline functions whose bodies have not 	 been emitted yet.  If out-of-line copies of these functions 	 are required, emit them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|deferred_fns
argument_list|,
name|i
argument_list|,
name|decl
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* Does it need synthesizing?  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
comment|/* Even though we're already at the top-level, we push 		 there again.  That way, when we pop back a few lines 		 hence, all of our state is restored.  Otherwise, 		 finish_function doesn't clean things up, and we end 		 up with CURRENT_FUNCTION_DECL set.  */
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* The decl's location will mark where it was first 		 needed.  Save that so synthesize method can indicate 		 where it was needed from, in case of error  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|synthesize_method
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|reconsider
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
comment|/* We lie to the back-end, pretending that some functions 	     are not defined when they really are.  This keeps these 	     functions from being put out unnecessarily.  But, we must 	     stop lying when the functions are referenced, or if they 	     are not comdat since they need to be put out now.  If 	     DECL_INTERFACE_KNOWN, then we have already set 	     DECL_EXTERNAL appropriately, so there's no need to check 	     again, and we do not want to clear DECL_EXTERNAL if a 	     previous call to import_export_decl set it.  	     This is done in a separate for cycle, because if some 	     deferred function is contained in another deferred 	     function later in deferred_fns varray, 	     rest_of_compilation would skip this function and we 	     really cannot expand the same function twice.  */
name|import_export_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_needed_p
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If we're going to need to write this function out, and 	     there's already a body for it, create RTL for it now. 	     (There might be no body if this is a method we haven't 	     gotten around to synthesizing yet.)  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_needed_p
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|cgraph_node
argument_list|(
name|decl
argument_list|)
operator|->
name|local
operator|.
name|finalized
condition|)
block|{
comment|/* We will output the function; no longer consider it in this 		 loop.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Generate RTL for this function now that we know we 		 need it.  */
name|expand_or_defer_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If we're compiling -fsyntax-only pretend that this 		 function has been written out so that we don't try to 		 expand it again.  */
if|if
condition|(
name|flag_syntax_only
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|reconsider
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|walk_namespaces
argument_list|(
name|wrapup_globals_for_namespace
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
condition|)
name|reconsider
operator|=
name|true
expr_stmt|;
comment|/* Static data members are just like namespace-scope globals.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|,
name|i
argument_list|,
name|decl
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|var_finalized_p
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
name|import_export_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If this static data member is needed, provide it to the 	     back end.  */
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_needed_p
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
operator|!=
literal|0
operator|&&
name|wrapup_global_declarations
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
argument_list|)
condition|)
name|reconsider
operator|=
name|true
expr_stmt|;
name|retries
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
comment|/* All used inline functions must have a definition at this point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|deferred_fns
argument_list|,
name|i
argument_list|,
name|decl
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
comment|/* Check online inline functions that were actually used.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
comment|/* If the definition actually was available here, then the 	     fact that the function was not defined merely represents 	     that for some reason (use of a template repository, 	     #pragma interface, etc.) we decided not to emit the 	     definition here.  */
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
comment|/* An explicit instantiation can be used to specify 	     that the body is in another unit. It will have 	     already verified there was a definition.  */
operator|&&
operator|!
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"inline function %q+D used but never defined"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Avoid a duplicate warning from check_global_declaration_1.  */
name|TREE_NO_WARNING
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We give C linkage to static constructors and destructors.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* Generate initialization and destruction functions for all      priorities for which they are required.  */
if|if
condition|(
name|priority_info_map
condition|)
name|splay_tree_foreach
argument_list|(
name|priority_info_map
argument_list|,
name|generate_ctor_and_dtor_functions_for_priority
argument_list|,
comment|/*data=*/
operator|&
name|locus
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we have a ctor or this is obj-c++ and we need a static init, 	 call generate_ctor_or_dtor_function.  */
if|if
condition|(
name|static_ctors
operator|||
operator|(
name|c_dialect_objc
argument_list|()
operator|&&
name|objc_static_init_needed_p
argument_list|()
operator|)
condition|)
name|generate_ctor_or_dtor_function
argument_list|(
comment|/*constructor_p=*/
name|true
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_dtors
condition|)
name|generate_ctor_or_dtor_function
argument_list|(
comment|/*constructor_p=*/
name|false
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
block|}
comment|/* We're done with the splay-tree now.  */
if|if
condition|(
name|priority_info_map
condition|)
name|splay_tree_delete
argument_list|(
name|priority_info_map
argument_list|)
expr_stmt|;
comment|/* Generate any missing aliases.  */
name|maybe_apply_pending_pragma_weaks
argument_list|()
expr_stmt|;
comment|/* We're done with static constructors, so we can go back to "C++"      linkage now.  */
name|pop_lang_context
argument_list|()
expr_stmt|;
name|cgraph_finalize_compilation_unit
argument_list|()
expr_stmt|;
name|cgraph_optimize
argument_list|()
expr_stmt|;
comment|/* Now, issue warnings about static, but not defined, functions,      etc., and emit debugging information.  */
name|walk_namespaces
argument_list|(
name|wrapup_globals_for_namespace
argument_list|,
comment|/*data=*/
operator|&
name|reconsider
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|check_global_declarations
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
argument_list|)
expr_stmt|;
name|emit_debug_global_declarations
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|pending_statics
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate hidden aliases for Java.  */
name|build_java_method_aliases
argument_list|()
expr_stmt|;
name|finish_repo
argument_list|()
expr_stmt|;
comment|/* The entire file is now complete.  If requested, dump everything      to a file.  */
block|{
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_tu
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|dump_node
argument_list|(
name|global_namespace
argument_list|,
name|flags
operator|&
operator|~
name|TDF_SLIM
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_tu
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|timevar_pop
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|dump_tree_statistics
argument_list|()
expr_stmt|;
name|dump_time_statistics
argument_list|()
expr_stmt|;
block|}
name|input_location
operator|=
name|locus
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|validate_conversion_obstack
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
block|}
end_function

begin_comment
comment|/* FN is an OFFSET_REF, DOTSTAR_EXPR or MEMBER_REF indicating the    function to call in parse-tree form; it has not yet been    semantically analyzed.  ARGS are the arguments to the function.    They have already been semantically analyzed.  */
end_comment

begin_function
name|tree
name|build_offset_ref_call_from_tree
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|tree
name|orig_fn
decl_stmt|;
name|tree
name|orig_args
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|object
decl_stmt|;
name|orig_fn
operator|=
name|fn
expr_stmt|;
name|orig_args
operator|=
name|args
expr_stmt|;
name|object
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|DOTSTAR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|MEMBER_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
operator|||
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|build_min_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* Transform the arguments and add the implicit "this" 	 parameter.  That must be done before the FN is transformed 	 because we depend on the form of FN.  */
name|args
operator|=
name|build_non_dependent_args
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|DOTSTAR_EXPR
condition|)
name|object
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|object
operator|=
name|build_non_dependent_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|object
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Now that the arguments are done, transform FN.  */
name|fn
operator|=
name|build_non_dependent_expr
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* A qualified name corresponding to a bound pointer-to-member is      represented as an OFFSET_REF:  	struct B { void g(); }; 	void (B::*p)(); 	void B::g() { (this->*p)(); }  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
name|tree
name|object_addr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|object
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_member_function_from_ptrfunc
argument_list|(
operator|&
name|object_addr
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|object_addr
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|expr
operator|!=
name|error_mark_node
condition|)
return|return
name|build_min_non_dep
argument_list|(
name|CALL_EXPR
argument_list|,
name|expr
argument_list|,
name|orig_fn
argument_list|,
name|orig_args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|expr
return|;
block|}
end_function

begin_function
name|void
name|check_default_args
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|arg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|saw_def
init|=
name|false
decl_stmt|;
name|int
name|i
init|=
literal|0
operator|-
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
for|for
control|(
init|;
name|arg
operator|&&
name|arg
operator|!=
name|void_list_node
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
condition|)
name|saw_def
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|saw_def
condition|)
block|{
name|error
argument_list|(
literal|"default argument missing for parameter %P of %q+#D"
argument_list|,
name|i
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark DECL (either a _DECL or a BASELINK) as "used" in the program.    If DECL is a specialization or implicitly declared class member,    generate the actual definition.  */
end_comment

begin_function
name|void
name|mark_used
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|HOST_WIDE_INT
name|saved_processing_template_decl
init|=
literal|0
decl_stmt|;
comment|/* If DECL is a BASELINK for a single function, then treat it just      like the DECL for the function.  Otherwise, if the BASELINK is      for an overloaded function, we don't know which function was      actually used until after overload resolution.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BASELINK
condition|)
block|{
name|decl
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|decl
operator|=
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we don't need a value, then we don't need to synthesize DECL.  */
if|if
condition|(
name|skip_evaluation
condition|)
return|return;
comment|/* Normally, we can wait until instantiation-time to synthesize      DECL.  However, if DECL is a static data member initialized with      a constant, we need the value right now because a reference to      such a data member is not value-dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Don't try to instantiate members of dependent types.  We 	 cannot just use dependent_type_p here because this function 	 may be called from fold_non_dependent_expr, and then we may 	 see dependent types, even though processing_template_decl 	 will not be set.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|)
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Pretend that we are not in a template, even if we are, so 	 that the static data member initializer will be processed.  */
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Remember it, so we can check it was defined.  */
block|{
if|if
condition|(
name|DECL_DEFERRED_FN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Remember the current location for a function we will end up 	 synthesizing.  Then we can inform the user where it was 	 required in the case of error.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_THUNK_P
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|note_vague_linkage_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Is it a synthesized method that needs to be synthesized?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_THUNK_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
comment|/* Kludge: don't synthesize for default args.  Unfortunately this 	 rules out initializers of namespace-scoped objects too, but 	 it's sort-of ok if the implicit ctor or dtor decl keeps 	 pointing to the class location.  */
operator|&&
name|current_function_decl
condition|)
block|{
name|synthesize_method
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If we've already synthesized the method we don't need to 	 do the instantiation test below.  */
block|}
elseif|else
if|if
condition|(
operator|(
name|DECL_NON_THUNK_FUNCTION_P
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|template_for_substitution
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* We need to instantiate static data members so that there 		  initializers are available in integral constant 		  expressions.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
comment|/* If this is a function or variable that is an instance of some        template, we now know that we will need to actually do the        instantiation. We check that DECL is not an explicit        instantiation because that is not checked in instantiate_decl.         We put off instantiating functions in order to improve compile        times.  Maintaining a stack of active functions is expensive,        and the inliner knows to instantiate any functions it might        need.  Therefore, we always try to defer instantiation.  */
name|instantiate_decl
argument_list|(
name|decl
argument_list|,
comment|/*defer_ok=*/
name|true
argument_list|,
comment|/*expl_inst_class_mem_p=*/
name|false
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-decl2.h"
end_include

end_unit

