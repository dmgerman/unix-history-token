begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 92-98, 1999 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_include
include|#
directive|include
file|"dwarfout.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_if
if|#
directive|if
name|USE_CPPLIB
end_if

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
specifier|extern
name|cpp_reader
name|parse_in
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure contains information about the initializations    and/or destructions required for a particular priority level.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|priority_info_s
block|{
comment|/* A label indicating where we should generate the next      initialization with this priority.  */
name|rtx
name|initialization_sequence
decl_stmt|;
comment|/* A label indicating where we should generate the next destruction      with this priority.  */
name|rtx
name|destruction_sequence
decl_stmt|;
comment|/* Non-zero if there have been any initializations at this priority      throughout the translation unit.  */
name|int
name|initializations_p
decl_stmt|;
comment|/* Non-zero if there have been any destructions at this priority      throughout the translation unit.  */
name|int
name|destructions_p
decl_stmt|;
block|}
typedef|*
name|priority_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|tree
name|get_sentry
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_vtable_entries
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grok_function_init
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finish_vtable_vardecl
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prune_vtable_vardecl
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finish_sigtable_vardecl
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_namespace_ancestor
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_using_namespace
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ambiguous_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_anon_union_vars
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acceptable_java_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_vtable_inherit
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_objects
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_objects
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|merge_functions
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_namespace
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|validate_nonmember_using_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_nonmember_using_decl
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|tree
operator|*
operator|,
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_static_storage_duration_function
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|generate_inits_for_priority
name|PROTO
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_static_storage_duration_function
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|priority_info
name|get_priority_info
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_static_initialization
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_static_destruction
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_static_initialization_and_destruction
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_ctor_or_dtor_function
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|generate_ctor_and_dtor_functions_for_priority
name|PROTO
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_class_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of virtual function tables we must make sure to write out.  */
end_comment

begin_decl_stmt
name|tree
name|pending_vtables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of static class variables.  This is needed, because a    static class variable can be declared inside the class without    an initializer, and then initialized, staticly, outside the class.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|pending_statics
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|pending_statics_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of functions which were declared inline, but which we    may need to emit outline anyway.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|saved_inlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|saved_inlines_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to help generate temporary names which are unique within    a function.  Reset to 0 by start_function.  */
end_comment

begin_decl_stmt
name|int
name|temp_name_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same, but not reset.  Local temp variables and global temp variables    can have the same name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_temp_name_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag used when debugging spew.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|spew_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we're done parsing and into end-of-file activities.  */
end_comment

begin_decl_stmt
name|int
name|at_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions called along with real static constructors and destructors.  */
end_comment

begin_decl_stmt
name|tree
name|static_ctors
decl_stmt|,
name|static_dtors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current open namespace, and ::. */
end_comment

begin_decl_stmt
name|tree
name|current_namespace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|global_namespace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stack for namespaces of current declarations. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|decl_namespace_list
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* C (and C++) language-specific option variables.  */
end_comment

begin_comment
comment|/* Nonzero means allow type mismatches in conditional expressions;    just make their values `void'.   */
end_comment

begin_decl_stmt
name|int
name|flag_cond_mismatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the keyword `asm'.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize any extension keywords.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_gnu_keywords
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do some things the same way PCC does.  Only provided so    the compiler will link.  */
end_comment

begin_decl_stmt
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_bitfields
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enable obscure ANSI features and disable GNU extensions    that might cause ANSI-compliant code to be miscompiled.  */
end_comment

begin_decl_stmt
name|int
name|flag_ansi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do emit exported implementations of functions even if    they can be inlined.  */
end_comment

begin_decl_stmt
name|int
name|flag_implement_inlines
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do emit exported implementations of templates, instead of    multiple static copies in each file that needs a definition.  */
end_comment

begin_decl_stmt
name|int
name|flag_external_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that the decision to emit or not emit the implementation of a    template depends on where the template is instantiated, rather than where    it is defined.  */
end_comment

begin_decl_stmt
name|int
name|flag_alt_external_templates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that implicit instantiations will be emitted if needed.  */
end_comment

begin_decl_stmt
name|int
name|flag_implicit_templates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that implicit instantiations of inline templates will be    emitted if needed, even if instantiations of non-inline templates    aren't.  */
end_comment

begin_decl_stmt
name|int
name|flag_implicit_inline_templates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about implicit declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about usage of long long when `-pedantic'.  */
end_comment

begin_decl_stmt
name|int
name|warn_long_long
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when all ctors or dtors are private, and the class    has no friends.  */
end_comment

begin_decl_stmt
name|int
name|warn_ctor_dtor_privacy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we want to implement vtables using "thunks".    The default is off.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_VTABLE_THUNKS
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_VTABLE_THUNKS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|flag_vtable_thunks
init|=
name|DEFAULT_VTABLE_THUNKS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we want to deal with repository information.  */
end_comment

begin_decl_stmt
name|int
name|flag_use_repository
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to issue diagnostics that the standard says are not    required.  */
end_comment

begin_decl_stmt
name|int
name|flag_optional_diags
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give string constants the type `const char *', as mandated    by the standard.  */
end_comment

begin_decl_stmt
name|int
name|flag_const_strings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about deprecated conversion from string constant to    `char *'.  */
end_comment

begin_decl_stmt
name|int
name|warn_write_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that can drop a type qualifier    from the pointer target type.  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_qual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about sizeof(function) or addition/subtraction    of function pointers.  */
end_comment

begin_decl_stmt
name|int
name|warn_pointer_arith
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for any function def without prototype decl.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about multiple (redundant) decls for the same single    variable or function.  */
end_comment

begin_decl_stmt
name|int
name|warn_redundant_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if initializer is not completely bracketed.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_braces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about comparison of signed and unsigned values.  */
end_comment

begin_decl_stmt
name|int
name|warn_sign_compare
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about *printf or *scanf format/argument anomalies.  */
end_comment

begin_decl_stmt
name|int
name|warn_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about a subscript that has type char.  */
end_comment

begin_decl_stmt
name|int
name|warn_char_subscripts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a type conversion is done that might have confusing results.  */
end_comment

begin_decl_stmt
name|int
name|warn_conversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if adding () is suggested.  */
end_comment

begin_decl_stmt
name|int
name|warn_parentheses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn in function declared in derived class has the    same name as a virtual in the base class, but fails to match the    type signature of any virtual function in the base class.  */
end_comment

begin_decl_stmt
name|int
name|warn_overloaded_virtual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when declaring a class that has a non virtual    destructor, when it really ought to have a virtual one.  */
end_comment

begin_decl_stmt
name|int
name|warn_nonvdtor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when a function is declared extern and later inline.  */
end_comment

begin_decl_stmt
name|int
name|warn_extern_inline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when the compiler will reorder code.  */
end_comment

begin_decl_stmt
name|int
name|warn_reorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when synthesis behavior differs from Cfront's.  */
end_comment

begin_decl_stmt
name|int
name|warn_synth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when we convert a pointer to member function    into a pointer to (void or function).  */
end_comment

begin_decl_stmt
name|int
name|warn_pmf2ptr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about violation of some Effective C++ style rules.  */
end_comment

begin_decl_stmt
name|int
name|warn_ecpp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn where overload resolution chooses a promotion from    unsigned to signed over a conversion to an unsigned of the same size.  */
end_comment

begin_decl_stmt
name|int
name|warn_sign_promo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when an old-style cast is used.  */
end_comment

begin_decl_stmt
name|int
name|warn_old_style_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about #pragma directives that are not recognised.  */
end_comment

begin_decl_stmt
name|int
name|warn_unknown_pragmas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tri state variable.  */
end_comment

begin_comment
comment|/* Nonzero means warn about use of multicharacter literals.  */
end_comment

begin_decl_stmt
name|int
name|warn_multichar
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when non-templatized friend functions are    declared within a template */
end_comment

begin_decl_stmt
name|int
name|warn_nontemplate_friend
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means complain about deprecated features.  */
end_comment

begin_decl_stmt
name|int
name|warn_deprecated
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means `$' can be in an identifier.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dollars_in_ident
init|=
name|DOLLARS_IN_IDENTIFIERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -fno-strict-prototype switch: do not consider empty    argument prototype to mean function takes no arguments.  */
end_comment

begin_decl_stmt
name|int
name|flag_strict_prototype
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict_prototype
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict_prototypes_lang_c
decl_stmt|,
name|strict_prototypes_lang_cplusplus
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that labels can be used as first-class objects */
end_comment

begin_decl_stmt
name|int
name|flag_labels_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to collect statistics which might be expensive    and to print them when we are done.  */
end_comment

begin_decl_stmt
name|int
name|flag_detailed_statistics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ specific flags.  */
end_comment

begin_comment
comment|/* Zero means that `this' is a *const.  This gives nice behavior in the    2.0 world.  1 gives 1.2-compatible behavior.  2 gives Spring behavior.    -2 means we're constructing an object and it has fixed type.  */
end_comment

begin_decl_stmt
name|int
name|flag_this_is_variable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3 means write out only virtuals function tables `defined'    in this implementation file.    0 means write out virtual function tables and give them    (C) static access (default).  */
end_comment

begin_decl_stmt
name|int
name|write_virtuals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should attempt to elide constructors when possible.  */
end_comment

begin_decl_stmt
name|int
name|flag_elide_constructors
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means recognize and handle signature language constructs.  */
end_comment

begin_decl_stmt
name|int
name|flag_handle_signatures
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that member functions defined in class scope are    inline by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_default_inline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether compiler generates 'type descriptor' that give    run-time type information.  */
end_comment

begin_decl_stmt
name|int
name|flag_rtti
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we wish to output cross-referencing information    for the GNU class browser.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_gnu_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)    objects.  */
end_comment

begin_decl_stmt
name|int
name|flag_huge_objects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to conserve space in the .o files.  We do this    by putting uninitialized data and runtime initialized data into    .common instead of .data at the expense of not flagging multiple    definitions.  */
end_comment

begin_decl_stmt
name|int
name|flag_conserve_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to obey access control semantics.  */
end_comment

begin_decl_stmt
name|int
name|flag_access_control
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to understand the operator names, i.e. 'bitand'.  */
end_comment

begin_decl_stmt
name|int
name|flag_operator_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to check the return value of new and avoid calling    constructors if it is a null pointer.  */
end_comment

begin_decl_stmt
name|int
name|flag_check_new
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want the new ANSI rules for pushing a new scope for `for'    initialization variables.    0: Old rules, set by -fno-for-scope.    2: New ANSI rules, set by -ffor-scope.    1: Try to implement new ANSI rules, but with backup compatibility    (and warnings).  This is the default, for now.  */
end_comment

begin_decl_stmt
name|int
name|flag_new_for_scope
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to emit defined symbols with common-like linkage as    weak symbols where possible, in order to conform to C++ semantics.    Otherwise, emit them as local symbols.  */
end_comment

begin_decl_stmt
name|int
name|flag_weak
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to enable experimental ABI changes.  */
end_comment

begin_decl_stmt
name|int
name|flag_new_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to not ignore namespace std. */
end_comment

begin_decl_stmt
name|int
name|flag_honor_std
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum template instantiation depth. Must be at least 17 for ANSI    compliance. */
end_comment

begin_decl_stmt
name|int
name|max_tinst_depth
init|=
literal|17
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name-mangling scheme to use.  Must be 1 or greater to support    template functions with identical types, but different template    arguments.  */
end_comment

begin_decl_stmt
name|int
name|name_mangling_version
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that guiding declarations are allowed.  */
end_comment

begin_decl_stmt
name|int
name|flag_guiding_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if squashed mangling is to be performed.     This uses the B and K codes to reference previously seen class types     and class qualifiers.       */
end_comment

begin_decl_stmt
name|int
name|flag_do_squangling
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means output .vtable_{entry,inherit} for use in doing vtable gc.  */
end_comment

begin_decl_stmt
name|int
name|flag_vtable_gc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the default pedwarns warnings instead of errors.    The value of this flag is ignored if -pedantic is specified.  */
end_comment

begin_decl_stmt
name|int
name|flag_permissive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of language-dependent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
block|}
name|lang_f_options
index|[]
init|=
block|{
comment|/* C/C++ options.  */
block|{
literal|"signed-char"
block|,
operator|&
name|flag_signed_char
block|,
literal|1
block|}
block|,
block|{
literal|"unsigned-char"
block|,
operator|&
name|flag_signed_char
block|,
literal|0
block|}
block|,
block|{
literal|"signed-bitfields"
block|,
operator|&
name|flag_signed_bitfields
block|,
literal|1
block|}
block|,
block|{
literal|"unsigned-bitfields"
block|,
operator|&
name|flag_signed_bitfields
block|,
literal|0
block|}
block|,
block|{
literal|"short-enums"
block|,
operator|&
name|flag_short_enums
block|,
literal|1
block|}
block|,
block|{
literal|"short-double"
block|,
operator|&
name|flag_short_double
block|,
literal|1
block|}
block|,
block|{
literal|"cond-mismatch"
block|,
operator|&
name|flag_cond_mismatch
block|,
literal|1
block|}
block|,
block|{
literal|"asm"
block|,
operator|&
name|flag_no_asm
block|,
literal|0
block|}
block|,
block|{
literal|"builtin"
block|,
operator|&
name|flag_no_builtin
block|,
literal|0
block|}
block|,
comment|/* C++-only options.  */
block|{
literal|"access-control"
block|,
operator|&
name|flag_access_control
block|,
literal|1
block|}
block|,
block|{
literal|"check-new"
block|,
operator|&
name|flag_check_new
block|,
literal|1
block|}
block|,
block|{
literal|"conserve-space"
block|,
operator|&
name|flag_conserve_space
block|,
literal|1
block|}
block|,
block|{
literal|"const-strings"
block|,
operator|&
name|flag_const_strings
block|,
literal|1
block|}
block|,
block|{
literal|"default-inline"
block|,
operator|&
name|flag_default_inline
block|,
literal|1
block|}
block|,
block|{
literal|"dollars-in-identifiers"
block|,
operator|&
name|dollars_in_ident
block|,
literal|1
block|}
block|,
block|{
literal|"elide-constructors"
block|,
operator|&
name|flag_elide_constructors
block|,
literal|1
block|}
block|,
block|{
literal|"external-templates"
block|,
operator|&
name|flag_external_templates
block|,
literal|1
block|}
block|,
block|{
literal|"for-scope"
block|,
operator|&
name|flag_new_for_scope
block|,
literal|2
block|}
block|,
block|{
literal|"gnu-keywords"
block|,
operator|&
name|flag_no_gnu_keywords
block|,
literal|0
block|}
block|,
block|{
literal|"handle-exceptions"
block|,
operator|&
name|flag_exceptions
block|,
literal|1
block|}
block|,
block|{
literal|"handle-signatures"
block|,
operator|&
name|flag_handle_signatures
block|,
literal|1
block|}
block|,
block|{
literal|"honor-std"
block|,
operator|&
name|flag_honor_std
block|,
literal|1
block|}
block|,
block|{
literal|"huge-objects"
block|,
operator|&
name|flag_huge_objects
block|,
literal|1
block|}
block|,
block|{
literal|"implement-inlines"
block|,
operator|&
name|flag_implement_inlines
block|,
literal|1
block|}
block|,
block|{
literal|"implicit-inline-templates"
block|,
operator|&
name|flag_implicit_inline_templates
block|,
literal|1
block|}
block|,
block|{
literal|"implicit-templates"
block|,
operator|&
name|flag_implicit_templates
block|,
literal|1
block|}
block|,
block|{
literal|"labels-ok"
block|,
operator|&
name|flag_labels_ok
block|,
literal|1
block|}
block|,
block|{
literal|"nonansi-builtins"
block|,
operator|&
name|flag_no_nonansi_builtin
block|,
literal|0
block|}
block|,
block|{
literal|"operator-names"
block|,
operator|&
name|flag_operator_names
block|,
literal|1
block|}
block|,
block|{
literal|"optional-diags"
block|,
operator|&
name|flag_optional_diags
block|,
literal|1
block|}
block|,
block|{
literal|"permissive"
block|,
operator|&
name|flag_permissive
block|,
literal|1
block|}
block|,
block|{
literal|"repo"
block|,
operator|&
name|flag_use_repository
block|,
literal|1
block|}
block|,
block|{
literal|"rtti"
block|,
operator|&
name|flag_rtti
block|,
literal|1
block|}
block|,
block|{
literal|"squangle"
block|,
operator|&
name|flag_do_squangling
block|,
literal|1
block|}
block|,
block|{
literal|"stats"
block|,
operator|&
name|flag_detailed_statistics
block|,
literal|1
block|}
block|,
block|{
literal|"strict-prototype"
block|,
operator|&
name|flag_strict_prototype
block|,
literal|1
block|}
block|,
block|{
literal|"this-is-variable"
block|,
operator|&
name|flag_this_is_variable
block|,
literal|1
block|}
block|,
block|{
literal|"vtable-gc"
block|,
operator|&
name|flag_vtable_gc
block|,
literal|1
block|}
block|,
block|{
literal|"vtable-thunks"
block|,
operator|&
name|flag_vtable_thunks
block|,
literal|1
block|}
block|,
block|{
literal|"weak"
block|,
operator|&
name|flag_weak
block|,
literal|1
block|}
block|,
block|{
literal|"xref"
block|,
operator|&
name|flag_gnu_xref
block|,
literal|1
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Decode the string P as a language-specific option.    Return the number of strings consumed for a valid option.    Otherwise return 0.  */
end_comment

begin_function
name|int
name|lang_decode_option
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
if|#
directive|if
operator|!
name|USE_CPPLIB
name|ATTRIBUTE_UNUSED
endif|#
directive|endif
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|strings_processed
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
if|#
directive|if
name|USE_CPPLIB
name|strings_processed
operator|=
name|cpp_handle_option
argument_list|(
operator|&
name|parse_in
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|#
directive|else
name|strings_processed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ! USE_CPPLIB */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ftraditional"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
comment|/* ignore */
empty_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
comment|/* Some kind of -f option. 	 P's value is the option sans `-f'. 	 Search for it in the table of options.  */
name|int
name|found
init|=
literal|0
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Try special -f options.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"handle-exceptions"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-handle-exceptions"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"-fhandle-exceptions has been renamed to -fexceptions (and is now on by default)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"memoize-lookups"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-memoize-lookups"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"save-memoized"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-save-memoized"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-all-virtual"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-enum-int-equiv"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"nonnull-objects"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"ansi-overloading"
argument_list|)
condition|)
block|{
comment|/* ignore */
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"all-virtual"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"enum-int-equiv"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-nonnull-objects"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-ansi-overloading"
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"-f%s is no longer supported"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"alt-external-templates"
argument_list|)
condition|)
block|{
name|flag_external_templates
operator|=
literal|1
expr_stmt|;
name|flag_alt_external_templates
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|cp_deprecated
argument_list|(
literal|"-falt-external-templates"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-alt-external-templates"
argument_list|)
condition|)
block|{
name|flag_alt_external_templates
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"repo"
argument_list|)
condition|)
block|{
name|flag_use_repository
operator|=
literal|1
expr_stmt|;
name|flag_implicit_templates
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"guiding-decls"
argument_list|)
condition|)
block|{
name|flag_guiding_decls
operator|=
literal|1
expr_stmt|;
name|name_mangling_version
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-guiding-decls"
argument_list|)
condition|)
block|{
name|flag_guiding_decls
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"this-is-variable"
argument_list|)
condition|)
block|{
name|flag_this_is_variable
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|cp_deprecated
argument_list|(
literal|"-fthis-is-variable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"external-templates"
argument_list|)
condition|)
block|{
name|flag_external_templates
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|cp_deprecated
argument_list|(
literal|"-fexternal-templates"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"handle-signatures"
argument_list|)
condition|)
block|{
name|flag_handle_signatures
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|cp_deprecated
argument_list|(
literal|"-fhandle-signatures"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"new-abi"
argument_list|)
condition|)
block|{
name|flag_new_abi
operator|=
literal|1
expr_stmt|;
name|flag_do_squangling
operator|=
literal|1
expr_stmt|;
name|flag_honor_std
operator|=
literal|1
expr_stmt|;
name|flag_vtable_thunks
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-new-abi"
argument_list|)
condition|)
block|{
name|flag_new_abi
operator|=
literal|0
expr_stmt|;
name|flag_do_squangling
operator|=
literal|0
expr_stmt|;
name|flag_honor_std
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"template-depth-"
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|max_tinst_depth
operator|=
name|read_integral_parameter
argument_list|(
name|p
operator|+
literal|15
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|max_tinst_depth
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"name-mangling-version-"
argument_list|,
literal|22
argument_list|)
condition|)
block|{
name|name_mangling_version
operator|=
name|read_integral_parameter
argument_list|(
name|p
operator|+
literal|22
argument_list|,
name|p
operator|-
literal|2
argument_list|,
name|name_mangling_version
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|lang_f_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lang_f_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|lang_f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|lang_f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|lang_f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 		 but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|lang_f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|lang_f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|lang_f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'W'
condition|)
block|{
name|int
name|setting
init|=
literal|1
decl_stmt|;
comment|/* The -W options control the warning behavior of the compiler.  */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
name|setting
operator|=
literal|0
operator|,
name|p
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"implicit"
argument_list|)
condition|)
name|warn_implicit
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"long-long"
argument_list|)
condition|)
name|warn_long_long
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"return-type"
argument_list|)
condition|)
name|warn_return_type
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"ctor-dtor-privacy"
argument_list|)
condition|)
name|warn_ctor_dtor_privacy
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"write-strings"
argument_list|)
condition|)
name|warn_write_strings
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"cast-qual"
argument_list|)
condition|)
name|warn_cast_qual
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"char-subscripts"
argument_list|)
condition|)
name|warn_char_subscripts
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pointer-arith"
argument_list|)
condition|)
name|warn_pointer_arith
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"missing-prototypes"
argument_list|)
condition|)
name|warn_missing_prototypes
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"redundant-decls"
argument_list|)
condition|)
name|warn_redundant_decls
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"missing-braces"
argument_list|)
condition|)
name|warn_missing_braces
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"sign-compare"
argument_list|)
condition|)
name|warn_sign_compare
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"format"
argument_list|)
condition|)
name|warn_format
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"conversion"
argument_list|)
condition|)
name|warn_conversion
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"parentheses"
argument_list|)
condition|)
name|warn_parentheses
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"non-virtual-dtor"
argument_list|)
condition|)
name|warn_nonvdtor
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"extern-inline"
argument_list|)
condition|)
name|warn_extern_inline
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"reorder"
argument_list|)
condition|)
name|warn_reorder
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"synth"
argument_list|)
condition|)
name|warn_synth
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pmf-conversions"
argument_list|)
condition|)
name|warn_pmf2ptr
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"effc++"
argument_list|)
condition|)
name|warn_ecpp
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"sign-promo"
argument_list|)
condition|)
name|warn_sign_promo
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"old-style-cast"
argument_list|)
condition|)
name|warn_old_style_cast
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"overloaded-virtual"
argument_list|)
condition|)
name|warn_overloaded_virtual
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"multichar"
argument_list|)
condition|)
name|warn_multichar
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"unknown-pragmas"
argument_list|)
condition|)
comment|/* Set to greater than 1, so that even unknown pragmas in 	   system headers will be warned about.  */
name|warn_unknown_pragmas
operator|=
name|setting
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"non-template-friend"
argument_list|)
condition|)
name|warn_nontemplate_friend
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"deprecated"
argument_list|)
condition|)
name|warn_deprecated
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"comment"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"comments"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"trigraphs"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"import"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|warn_return_type
operator|=
name|setting
expr_stmt|;
name|warn_unused
operator|=
name|setting
expr_stmt|;
name|warn_implicit
operator|=
name|setting
expr_stmt|;
name|warn_switch
operator|=
name|setting
expr_stmt|;
name|warn_format
operator|=
name|setting
expr_stmt|;
name|warn_parentheses
operator|=
name|setting
expr_stmt|;
name|warn_missing_braces
operator|=
name|setting
expr_stmt|;
name|warn_sign_compare
operator|=
name|setting
expr_stmt|;
name|warn_multichar
operator|=
name|setting
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put 	     -Wuninitialized on the command line, we need to generate a 	     warning about not using it without also specifying -O.  */
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
operator|(
name|setting
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Only warn about unknown pragmas that are not in system 	     headers.  */
name|warn_unknown_pragmas
operator|=
literal|1
expr_stmt|;
comment|/* C++-specific warnings.  */
name|warn_ctor_dtor_privacy
operator|=
name|setting
expr_stmt|;
name|warn_nonvdtor
operator|=
name|setting
expr_stmt|;
name|warn_reorder
operator|=
name|setting
expr_stmt|;
name|warn_nontemplate_friend
operator|=
name|setting
expr_stmt|;
block|}
else|else
return|return
name|strings_processed
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ansi"
argument_list|)
condition|)
name|flag_no_nonansi_builtin
operator|=
literal|1
operator|,
name|flag_ansi
operator|=
literal|1
operator|,
name|flag_no_gnu_keywords
operator|=
literal|1
operator|,
name|flag_operator_names
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
comment|/* Undocumented, only ever used when you're invoking cc1plus by hand, since      it's probably safe to assume no sane person would ever want to use this      under normal circumstances.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-spew-debug"
argument_list|)
condition|)
name|spew_debug
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
return|return
name|strings_processed
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Incorporate `const' and `volatile' qualifiers for member functions.    FUNCTION is a TYPE_DECL or a FUNCTION_DECL.    QUALS is a list of qualifiers.  */
end_comment

begin_function
name|tree
name|grok_method_quals
parameter_list|(
name|ctype
parameter_list|,
name|function
parameter_list|,
name|quals
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|function
decl_stmt|,
name|quals
decl_stmt|;
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|int
name|type_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
name|int
name|dup_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
do|do
block|{
name|int
name|tq
init|=
name|cp_type_qual_from_rid
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_quals
operator|&
name|tq
condition|)
name|dup_quals
operator||=
name|tq
expr_stmt|;
else|else
name|type_quals
operator||=
name|tq
expr_stmt|;
name|quals
operator|=
name|TREE_CHAIN
argument_list|(
name|quals
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|quals
condition|)
do|;
if|if
condition|(
name|dup_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
name|cp_error
argument_list|(
literal|"duplicate type qualifiers in %s declaration"
argument_list|,
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|"member function"
else|:
literal|"type"
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|cp_build_qualified_type
argument_list|(
name|ctype
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|fntype
expr_stmt|;
return|return
name|ctype
return|;
block|}
end_function

begin_comment
comment|/* Warn when -fexternal-templates is used and #pragma    interface/implementation is not used all the times it should be,    inform the user.  */
end_comment

begin_function
name|void
name|warn_if_unknown_interface
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|static
name|int
name|already_warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|already_warned
operator|++
condition|)
return|return;
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
name|struct
name|tinst_level
modifier|*
name|til
init|=
name|tinst_for_decl
argument_list|()
decl_stmt|;
name|int
name|sl
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|sf
init|=
name|input_filename
decl_stmt|;
if|if
condition|(
name|til
condition|)
block|{
name|lineno
operator|=
name|til
operator|->
name|line
expr_stmt|;
name|input_filename
operator|=
name|til
operator|->
name|file
expr_stmt|;
block|}
name|cp_warning
argument_list|(
literal|"template `%#D' instantiated in file without #pragma interface"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|sl
expr_stmt|;
name|input_filename
operator|=
name|sf
expr_stmt|;
block|}
else|else
name|cp_warning_at
argument_list|(
literal|"template `%#D' defined in file without #pragma interface"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of the parser, to handle a component list.  */
end_comment

begin_function
name|void
name|grok_x_components
parameter_list|(
name|specs
parameter_list|)
name|tree
name|specs
decl_stmt|;
block|{
name|struct
name|pending_inline
modifier|*
modifier|*
name|p
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|specs
operator|=
name|strip_attrs
argument_list|(
name|specs
argument_list|)
expr_stmt|;
name|check_tag_decl
argument_list|(
name|specs
argument_list|)
expr_stmt|;
name|t
operator|=
name|groktypename
argument_list|(
name|build_decl_list
argument_list|(
name|specs
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The only case where we need to do anything additional here is an      anonymous union field, e.g.: `struct S { union { int i; }; };'.  */
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
operator|!
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return;
name|fixup_anonymous_union
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore any inline function definitions in the anonymous union      since an anonymous union may not have function members.  */
name|p
operator|=
operator|&
name|pending_inlines
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|fndecl
argument_list|)
operator|!=
name|t
condition|)
break|break;
block|}
end_function

begin_comment
comment|/* Constructors for types with virtual baseclasses need an "in-charge" flag    saying whether this constructor is responsible for initialization of    virtual baseclasses or not.  All destructors also need this "in-charge"    flag, which additionally determines whether or not the destructor should    free the memory for the object.     This function adds the "in-charge" flag to member function FN if    appropriate.  It is called from grokclassfn and tsubst.    FN must be either a constructor or destructor.  */
end_comment

begin_function
name|void
name|maybe_retrofit_in_chrg
parameter_list|(
name|fn
parameter_list|)
name|tree
name|fn
decl_stmt|;
block|{
name|tree
name|basetype
decl_stmt|,
name|arg_types
decl_stmt|,
name|parms
decl_stmt|,
name|parm
decl_stmt|,
name|fntype
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* OK */
empty_stmt|;
else|else
return|return;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
condition|)
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* First add it to DECL_ARGUMENTS...  */
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|in_charge_identifier
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
comment|/* Mark the artificial `__in_chrg' parameter as "artificial".  */
name|SET_DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|parm
expr_stmt|;
comment|/* ...and then to TYPE_ARG_TYPES.  */
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|=
name|fntype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Classes overload their constituent function names automatically.    When a function name is declared in a record structure,    its name is changed to it overloaded name.  Since names for    constructors and destructors can conflict, we place a leading    '$' for destructors.     CNAME is the name of the class we are grokking for.     FUNCTION is a FUNCTION_DECL.  It was created by `grokdeclarator'.     FLAGS contains bits saying what's special about today's    arguments.  1 == DESTRUCTOR.  2 == OPERATOR.     If FUNCTION is a destructor, then we must add the `auto-delete' field    as a second parameter.  There is some hair associated with the fact    that we must "declare" this variable in the manner consistent with the    way the rest of the arguments were declared.     QUALS are the qualifiers for the this pointer.  */
end_comment

begin_function
name|void
name|grokclassfn
parameter_list|(
name|ctype
parameter_list|,
name|function
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|function
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|;
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|qualtype
decl_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"name missing for member function"
argument_list|)
expr_stmt|;
name|fn_name
operator|=
name|get_identifier
argument_list|(
literal|"<anonymous>"
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|=
name|fn_name
expr_stmt|;
block|}
if|if
condition|(
name|quals
condition|)
name|qualtype
operator|=
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|function
argument_list|,
name|quals
argument_list|)
expr_stmt|;
else|else
name|qualtype
operator|=
name|ctype
expr_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Must add the class instance variable up front.  */
comment|/* Right now we just make this a pointer.  But later 	 we may wish to make it special.  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|>
literal|0
operator|)
operator|&&
operator|(
name|flags
operator|==
name|DTOR_FLAG
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
operator|)
condition|)
name|constp
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|this_identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Mark the artificial `this' parameter as "artificial".  */
name|SET_DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* We can make this a register, so long as we don't 	 accidentally complain if someone tries to take its address.  */
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|constp
condition|)
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|last_function_parms
operator|=
name|parm
expr_stmt|;
block|}
name|DECL_ARGUMENTS
argument_list|(
name|function
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
comment|/* First approximations.  */
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
operator|=
name|ctype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
operator|=
name|ctype
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
operator|||
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|maybe_retrofit_in_chrg
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|=
name|build_destructor_name
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|set_mangled_name_for_decl
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Work on the expr used by alignof (this is only called by the parser).  */
end_comment

begin_function
name|tree
name|grok_alignof
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|best
decl_stmt|,
name|t
decl_stmt|;
name|int
name|bestalign
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|ALIGNOF_EXPR
argument_list|,
name|sizetype
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"`__alignof__' applied to a bit-field"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|best
operator|=
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bestalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|thisalign
decl_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisalign
operator|>
name|bestalign
condition|)
name|best
operator|=
name|t
operator|,
name|bestalign
operator|=
name|thisalign
expr_stmt|;
block|}
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* ANSI says arrays and fns are converted inside comma. 	 But we can't convert them in build_compound_expr 	 because that would break commas in lvalues. 	 So do the conversion here if operand was a comma.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create an ARRAY_REF, checking for the user doing things backwards    along the way.  */
end_comment

begin_function
name|tree
name|grok_array_decl
parameter_list|(
name|array_expr
parameter_list|,
name|index_exp
parameter_list|)
name|tree
name|array_expr
decl_stmt|,
name|index_exp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|array_expr
argument_list|)
decl_stmt|;
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|index_exp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_min
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
condition|?
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
else|:
name|NULL_TREE
argument_list|,
name|array_expr
argument_list|,
name|index_exp
argument_list|)
return|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Something has gone very wrong.  Assume we are mistakenly reducing 	 an expression instead of a declaration.  */
name|error
argument_list|(
literal|"parser may be lost: is there a '{' missing somewhere?"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If they have an `operator[]', use that.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_exp
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|ARRAY_REF
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|array_expr
argument_list|,
name|index_exp
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* Otherwise, create an ARRAY_REF for a pointer or array type.  It      is a little-known fact that, if `a' is an array and `i' is an      int, you can write `i[a]', which means the same thing as `a[i]'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|p1
operator|=
name|array_expr
expr_stmt|;
else|else
name|p1
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_POINTER
argument_list|,
name|array_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index_exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|p2
operator|=
name|index_exp
expr_stmt|;
else|else
name|p2
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_POINTER
argument_list|,
name|index_exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i1
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|array_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i2
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|index_exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p1
operator|&&
name|i2
operator|)
operator|&&
operator|(
name|i1
operator|&&
name|p2
operator|)
condition|)
name|error
argument_list|(
literal|"ambiguous conversion for array subscript"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|&&
name|i2
condition|)
name|array_expr
operator|=
name|p1
operator|,
name|index_exp
operator|=
name|i2
expr_stmt|;
elseif|else
if|if
condition|(
name|i1
operator|&&
name|p2
condition|)
name|array_expr
operator|=
name|p2
operator|,
name|index_exp
operator|=
name|i1
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"invalid types `%T[%T]' for array subscript"
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|index_exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|array_expr
operator|==
name|error_mark_node
operator|||
name|index_exp
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous conversion for array subscript"
argument_list|)
expr_stmt|;
return|return
name|build_array_ref
argument_list|(
name|array_expr
argument_list|,
name|index_exp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the cast expression EXP, checking out its validity.   Either return    an error_mark_node if there was an unavoidable error, return a cast to    void for trying to delete a pointer w/ the value 0, or return the    call to delete.  If DOING_VEC is 1, we handle things differently    for doing an array delete.  If DOING_VEC is 2, they gave us the    array size as an argument to delete.    Implements ARM $5.3.4.  This is called from the parser.  */
end_comment

begin_function
name|tree
name|delete_sanity
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|,
name|doing_vec
parameter_list|,
name|use_global_delete
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|size
decl_stmt|;
name|int
name|doing_vec
decl_stmt|,
name|use_global_delete
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
comment|/* For a regular vector delete (aka, no size argument) we will pass      this down as a NULL_TREE into build_vec_delete.  */
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|t
operator|=
name|build_min
argument_list|(
name|DELETE_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
operator|=
name|use_global_delete
expr_stmt|;
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|doing_vec
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|exp
operator|=
name|resolve_offset_ref
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|convert_from_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|t
operator|=
name|stabilize_reference
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_POINTER
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"type `%#T' argument given to `delete', expected pointer"
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|doing_vec
operator|==
literal|2
condition|)
block|{
name|maxindex
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"anachronistic use of array size in vector delete"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* As of Valley Forge, you can delete a pointer to const.  */
comment|/* You can't delete functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot delete a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Deleting ptr to void is undefined behaviour [expr.delete/3].  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|cp_warning
argument_list|(
literal|"`%T' is not a pointer-to-object type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* An array can't have been allocated by new, so complain.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|cp_warning
argument_list|(
literal|"deleting array `%#D'"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deleting a pointer with the value zero is valid and has no effect.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|)
return|;
if|if
condition|(
name|doing_vec
condition|)
return|return
name|build_vec_delete
argument_list|(
name|t
argument_list|,
name|maxindex
argument_list|,
name|integer_one_node
argument_list|,
name|integer_zero_node
argument_list|,
name|use_global_delete
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_GETS_REG_DELETE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Only do access checking here; we'll be calling op delete 	     from the destructor.  */
name|tree
name|tmp
init|=
name|build_op_delete_call
argument_list|(
name|DELETE_EXPR
argument_list|,
name|t
argument_list|,
name|size_zero_node
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_delete
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|integer_three_node
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|use_global_delete
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Report an error if the indicated template declaration is not the    sort of thing that should be a member template.  */
end_comment

begin_function
name|void
name|check_member_template
parameter_list|(
name|tmpl
parameter_list|)
name|tree
name|tmpl
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|current_function_decl
condition|)
comment|/* 14.5.2.2 [temp.mem] 	    	   A local class shall not have member templates. */
name|cp_error
argument_list|(
literal|"declaration of member template `%#D' in local class"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* 14.5.2.3 [temp.mem]  	     A member function template shall not be virtual.  */
name|cp_error
argument_list|(
literal|"invalid use of `virtual' in template declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The debug-information generating code doesn't know what to do 	 with member templates.  */
name|DECL_IGNORED_P
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cp_error
argument_list|(
literal|"template declaration of `%#D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true iff TYPE is a valid Java parameter or return type. */
end_comment

begin_function
specifier|static
name|int
name|acceptable_java_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|type
operator|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For a METHOD in a Java class CTYPE, return 1 if    the parameter and return types are valid Java types.    Otherwise, print appropriate error messages, and return 0.  */
end_comment

begin_function
name|int
name|check_java_method
parameter_list|(
name|method
parameter_list|)
name|tree
name|method
decl_stmt|;
block|{
name|int
name|jerr
init|=
literal|0
decl_stmt|;
name|tree
name|arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|acceptable_java_type
argument_list|(
name|ret_type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"Java method '%D' has non-Java return type `%T'"
argument_list|,
name|method
argument_list|,
name|ret_type
argument_list|)
expr_stmt|;
name|jerr
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|arg_types
operator|!=
name|NULL_TREE
condition|;
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|acceptable_java_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"Java method '%D' has non-Java parameter type `%T'"
argument_list|,
name|method
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|jerr
operator|++
expr_stmt|;
block|}
block|}
return|return
name|jerr
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Sanity check: report error if this function FUNCTION is not    really a member of the class (CTYPE) it is supposed to belong to.    CNAME is the same here as it is for grokclassfn above.  */
end_comment

begin_function
name|tree
name|check_classfn
parameter_list|(
name|ctype
parameter_list|,
name|function
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|function
decl_stmt|;
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|fndecls
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|complete_type
argument_list|(
name|ctype
argument_list|)
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|methods
init|=
literal|0
decl_stmt|;
name|tree
modifier|*
name|end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_USE_TEMPLATE
argument_list|(
name|function
argument_list|)
operator|&&
name|is_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
comment|/* Since this is a specialization of a member template,        we're not going to find the declaration in the class.        For example, in:                  struct S { template<typename T> void f(T); };          template<> void S::f(int);                we're not going to find `S::f(int)', but there's no        reason we should, either.  We let our callers know we didn't        find the method, but we don't complain.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* First suss out ctors and dtors.  */
if|if
condition|(
operator|*
name|methods
operator|&&
name|fn_name
operator|==
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
if|if
condition|(
operator|*
operator|++
name|methods
operator|&&
name|fn_name
operator|==
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
operator|&&
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
operator|&&
operator|*
name|methods
condition|)
block|{
name|fndecl
operator|=
operator|*
name|methods
expr_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
operator|*
name|methods
argument_list|)
argument_list|)
condition|)
block|{
name|got_it
label|:
for|for
control|(
name|fndecls
operator|=
operator|*
name|methods
init|;
name|fndecls
operator|!=
name|NULL_TREE
condition|;
name|fndecls
operator|=
name|OVL_NEXT
argument_list|(
name|fndecls
argument_list|)
control|)
block|{
name|fndecl
operator|=
name|OVL_CURRENT
argument_list|(
name|fndecls
argument_list|)
expr_stmt|;
comment|/* The DECL_ASSEMBLER_NAME for a TEMPLATE_DECL, or 		     for a for member function of a template class, is 		     not mangled, so the check below does not work 		     correctly in that case.  Since mangled destructor 		     names do not include the type of the arguments, 		     we can't use this short-cut for them, either. 		     (It's not legal to declare arguments for a 		     destructor, but some people try.)  */
if|if
condition|(
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
operator|&&
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|&&
operator|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|)
condition|)
return|return
name|fndecl
return|;
comment|/* We cannot simply call decls_match because this 		     doesn't work for static member functions that are                       pretending to be methods, and because the name 		     may have been changed by asm("new_name").  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Get rid of the this parameter on functions that become 			 static.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|compparms
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|&&
operator|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|function
argument_list|)
operator|||
operator|(
name|DECL_TI_TEMPLATE
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_TI_TEMPLATE
argument_list|(
name|fndecl
argument_list|)
operator|)
operator|)
condition|)
return|return
name|fndecl
return|;
block|}
block|}
break|break;
comment|/* loser */
block|}
block|}
block|}
if|if
condition|(
name|methods
operator|!=
name|end
operator|&&
operator|*
name|methods
condition|)
block|{
name|tree
name|fndecl
init|=
operator|*
name|methods
decl_stmt|;
name|cp_error
argument_list|(
literal|"prototype for `%#D' does not match any in class `%T'"
argument_list|,
name|function
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"candidate%s: %+#D"
argument_list|,
name|OVL_NEXT
argument_list|(
name|fndecl
argument_list|)
condition|?
literal|"s are"
else|:
literal|" is"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecl
operator|=
name|OVL_NEXT
argument_list|(
name|fndecl
argument_list|)
operator|,
name|fndecl
condition|)
name|cp_error_at
argument_list|(
literal|"                %#D"
argument_list|,
name|OVL_CURRENT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|methods
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
operator|==
literal|0
condition|)
name|incomplete_type_error
argument_list|(
name|function
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"no `%#D' member function declared in class `%T'"
argument_list|,
name|function
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not find the method in the class, add it to avoid      spurious errors (unless the CTYPE is not yet defined, in which      case we'll only confuse ourselves when the function is declared      properly within the class.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ctype
argument_list|)
condition|)
name|add_method
argument_list|(
name|ctype
argument_list|,
name|methods
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* We have just processed the DECL, which is a static data member.    Its initializer, if present, is INIT.  The ASMSPEC_TREE, if    present, is the assembly-language name for the data member.    NEED_POP and FLAGS are as for cp_finish_decl.  */
end_comment

begin_function
name|void
name|finish_static_data_member_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|,
name|need_pop
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
name|int
name|need_pop
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We cannot call pushdecl here, because that would fill in the      decl of our TREE_CHAIN.  Instead, we modify cp_finish_decl to do      the right thing, namely, to put this decl out straight away.  */
comment|/* current_class_type can be NULL_TREE in case of error.  */
if|if
condition|(
operator|!
name|asmspec
operator|&&
name|current_class_type
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_static_name
argument_list|(
name|current_class_type
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
operator|!
name|pending_statics
condition|)
name|VARRAY_TREE_INIT
argument_list|(
name|pending_statics
argument_list|,
literal|32
argument_list|,
literal|"pending_statics"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_statics_used
operator|==
name|pending_statics
operator|->
name|num_elements
condition|)
name|VARRAY_GROW
argument_list|(
name|pending_statics
argument_list|,
literal|2
operator|*
name|pending_statics
operator|->
name|num_elements
argument_list|)
expr_stmt|;
name|VARRAY_TREE
argument_list|(
name|pending_statics
argument_list|,
name|pending_statics_used
argument_list|)
operator|=
name|decl
expr_stmt|;
operator|++
name|pending_statics_used
expr_stmt|;
block|}
comment|/* Static consts need not be initialized in the class definition.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|int
name|explanation
init|=
literal|0
decl_stmt|;
name|error
argument_list|(
literal|"initializer invalid for static member with constructor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|explanation
operator|++
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"(you really want to initialize it separately)"
argument_list|)
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Force the compiler to know when an uninitialized static const      member is being used.  */
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|init
operator|==
literal|0
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
name|need_pop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    QUALS is a list of type qualifiers for this decl (such as for declaring    const member functions).     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.     C++:     If class A defines that certain functions in class B are friends, then    the way I have set things up, it is B who is interested in permission    granted by A.  However, it is in A's context that these declarations    are parsed.  By returning a void_type_node, class A does not attempt    to incorporate the declarations of the friends within its structure.     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `start_method'.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|,
name|attrlist
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|init
decl_stmt|,
name|asmspec_tree
decl_stmt|,
name|attrlist
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|LOOKUP_ONLYCONVERTING
decl_stmt|;
comment|/* Convert () initializers to = initializers.  */
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|&&
name|declarator
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
operator|)
operator|&&
name|parmlist_is_exprlist
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|declspecs
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Access declaration */
if|if
condition|(
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_COMPLEXITY
argument_list|(
name|declarator
argument_list|)
operator|==
name|current_class_depth
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
return|return
name|do_class_using_decl
argument_list|(
name|declarator
argument_list|)
return|;
block|}
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
operator|==
name|error_mark_node
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
name|init
operator|!=
literal|0
argument_list|,
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|||
name|value
operator|==
name|error_mark_node
condition|)
comment|/* friend or constructor went bad.  */
return|return
name|value
return|;
comment|/* Pass friendly classes back.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"member `%D' conflicts with virtual function table field name"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Stash away type declarations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* Now that we've updated the context, we need to remangle the 	 name for this TYPE_DECL.  */
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|value
argument_list|)
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"field declaration not allowed in signature"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' is already defined in `%T'"
argument_list|,
name|value
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"function declarations cannot have initializers in signature"
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|grok_function_init
argument_list|(
name|value
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|VAR_DECL
condition|)
comment|/* Already complained in grokdeclarator.  */
name|init
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
comment|/* We allow initializers to become parameters to base              initializers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|init
argument_list|)
condition|)
name|init
operator|=
name|decl_constant_value
argument_list|(
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|init
argument_list|)
argument_list|,
literal|192
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
comment|/* We must make this look different than `error_mark_node' 	       because `decl_const_value' would mis-interpret it 	       as only meaning that this VAR_DECL is defined.  */
name|init
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|processing_template_decl
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* We can allow references to things that are effectively 		 static, since references are initialized with the address.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|!=
literal|'d'
operator|||
name|DECL_EXTERNAL
argument_list|(
name|init
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"field initializer is not constant"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* The corresponding pop_obstacks is in cp_finish_decl.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|current_function_decl
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
name|value
operator|=
name|push_template_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrlist
condition|)
name|cplus_decl_attributes
argument_list|(
name|value
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|attrlist
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|attrlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|finish_static_data_member_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
comment|/*need_pop=*/
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed 	     by grokclassfn.  Lay this out fresh.  */
name|DECL_RTL
argument_list|(
name|value
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|==
name|error_mark_node
condition|)
name|init
operator|=
name|error_mark_node
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* This must override the asm specifier which was placed 	     by grokclassfn.  Lay this out fresh.  */
name|DECL_RTL
argument_list|(
name|value
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
block|}
name|cp_finish_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Pass friends back this way.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|void_type_node
return|;
if|#
directive|if
literal|0
comment|/* Just because a fn is declared doesn't mean we'll try to define it.  */
block|if (current_function_decl&& ! IS_SIGNATURE (current_class_type)) 	cp_error ("method `%#D' of local class must be defined in class body", 		  value);
endif|#
directive|endif
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|21
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like `grokfield', but for bitfields.    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */
end_comment

begin_function
name|tree
name|grokbitfield
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|width
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|BITFIELD
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|NULL_TREE
return|;
comment|/* friends went bad.  */
comment|/* Pass friendly classes back.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot declare `%D' to be a bitfield type"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Usually, finish_struct_1 catches bitifields with invalid types.      But, in the case of bitfields with function type, we confuse      ourselves into thinking they are member functions, so we must      check here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"cannot declare bitfield `%D' with funcion type"
argument_list|,
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field declaration not allowed in signature"
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' is already defined in the class %T"
argument_list|,
name|value
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"static member `%D' cannot be a bitfield"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|cp_finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|error_mark_node
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
name|SET_DECL_C_BIT_FIELD
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|tree
name|grokoptypename
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
block|{
name|tree
name|t
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
return|return
name|build_typename_overload
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* When a function is declared with an initializer,    do the right thing.  Currently, there are two possibilities:     class B    {     public:      // initialization possibility #1.      virtual void f () = 0;      int g ();    };        class D1 : B    {     public:      int d1;      // error, no f ();    };        class D2 : B    {     public:      int d2;      void f ();    };        class D3 : B    {     public:      int d3;      // initialization possibility #2      void f () = B::f;    };  */
end_comment

begin_function
name|int
name|copy_assignment_arg_p
parameter_list|(
name|parmtype
parameter_list|,
name|virtualp
parameter_list|)
name|tree
name|parmtype
decl_stmt|;
name|int
name|virtualp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|current_class_type
operator|)
if|#
directive|if
literal|0
comment|/* Non-standard hack to support old Booch components.  */
condition||| (! virtualp&& DERIVED_FROM_P (parmtype, current_class_type))
endif|#
directive|endif
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|grok_function_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
comment|/* An initializer for a function tells how this function should      be inherited.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|cp_error
argument_list|(
literal|"initializer specified for non-member function `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We'll check for this in finish_struct_1.  */
if|else if (DECL_VINDEX (decl) == NULL_TREE)     cp_error ("initializer specified for non-virtual method `%D'", decl);
endif|#
directive|endif
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|init
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Mark this function as being "defined".  */
block|DECL_INITIAL (decl) = error_mark_node;
comment|/* pure virtual destructors must be defined.  */
comment|/* pure virtual needs to be defined (as abort) only when put in  	 vtbl. For wellformed call, it should be itself. pr4737 */
block|if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl))) 	{ 	  extern tree abort_fndecl;
comment|/* Give this node rtl from `abort'.  */
block|DECL_RTL (decl) = DECL_RTL (abort_fndecl); 	}
endif|#
directive|endif
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
condition|)
block|{
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy_assignment_arg_p
argument_list|(
name|parmtype
argument_list|,
literal|1
argument_list|)
condition|)
name|TYPE_HAS_ABSTRACT_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|cp_error
argument_list|(
literal|"invalid initializer for virtual method `%D'"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cplus_decl_attributes
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|attributes
decl_stmt|,
name|prefix_attributes
decl_stmt|;
block|{
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|decl
operator|==
name|void_type_node
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
name|decl
argument_list|,
name|attributes
argument_list|,
name|prefix_attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* CONSTRUCTOR_NAME:    Return the name for the constructor (or destructor) for the    specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or    IDENTIFIER_NODE.  When given a template, this routine doesn't    lose the specialization.  */
end_comment

begin_function
name|tree
name|constructor_name_full
parameter_list|(
name|thing
parameter_list|)
name|tree
name|thing
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|thing
operator|=
name|TYPE_NAME
argument_list|(
name|thing
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_WAS_ANONYMOUS
argument_list|(
name|thing
argument_list|)
operator|&&
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|thing
argument_list|)
condition|)
name|thing
operator|=
name|DECL_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|thing
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|thing
operator|=
name|TYPE_NAME
argument_list|(
name|thing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|thing
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
condition|)
name|thing
operator|=
name|DECL_NAME
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|197
argument_list|)
expr_stmt|;
return|return
name|thing
return|;
block|}
end_function

begin_comment
comment|/* CONSTRUCTOR_NAME:    Return the name for the constructor (or destructor) for the    specified class.  Argument can be RECORD_TYPE, TYPE_DECL, or    IDENTIFIER_NODE.  When given a template, return the plain    unspecialized name.  */
end_comment

begin_function
name|tree
name|constructor_name
parameter_list|(
name|thing
parameter_list|)
name|tree
name|thing
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|thing
operator|=
name|constructor_name_full
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|t
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|thing
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|thing
return|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cache the value of this class's main virtual function table pointer    in a register variable.  This will save one indirection if a    more than one virtual function call is made this function.  */
end_comment

begin_function
name|void
name|setup_vtbl_ptr
parameter_list|()
block|{
specifier|extern
name|tree
name|base_init_expr
decl_stmt|;
if|if
condition|(
name|base_init_expr
operator|==
literal|0
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|add_tree
argument_list|(
name|build_min_nt
argument_list|(
name|CTOR_INITIALIZER
argument_list|,
name|current_member_init_list
argument_list|,
name|current_base_init_list
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_base_init
argument_list|(
name|current_class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the existence of an addressable inline function.  */
end_comment

begin_function
name|void
name|mark_inline_for_output
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|decl
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|363
argument_list|)
expr_stmt|;
name|DECL_SAVED_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|saved_inlines
condition|)
name|VARRAY_TREE_INIT
argument_list|(
name|saved_inlines
argument_list|,
literal|32
argument_list|,
literal|"saved_inlines"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_inlines_used
operator|==
name|saved_inlines
operator|->
name|num_elements
condition|)
name|VARRAY_GROW
argument_list|(
name|saved_inlines
argument_list|,
literal|2
operator|*
name|saved_inlines
operator|->
name|num_elements
argument_list|)
expr_stmt|;
name|VARRAY_TREE
argument_list|(
name|saved_inlines
argument_list|,
name|saved_inlines_used
argument_list|)
operator|=
name|decl
expr_stmt|;
operator|++
name|saved_inlines_used
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_temp_name
parameter_list|()
block|{
name|temp_name_counter
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hand off a unique name which can be used for variable we don't really    want to know about anyway, for example, the anonymous variables which    are needed to make references work.  Declare this thing so we can use it.    The variable created will be of type TYPE.     STATICP is nonzero if this variable should be static.  */
end_comment

begin_function
name|tree
name|get_temp_name
parameter_list|(
name|type
parameter_list|,
name|staticp
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|staticp
decl_stmt|;
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|AUTO_TEMP_FORMAT
argument_list|)
operator|+
literal|20
index|]
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|toplev
init|=
name|toplevel_bindings_p
argument_list|()
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplev
operator|||
name|staticp
condition|)
block|{
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|AUTO_TEMP_FORMAT
argument_list|,
name|global_temp_name_counter
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
name|AUTO_TEMP_FORMAT
argument_list|,
name|temp_name_counter
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
name|staticp
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is a local variable, then lay out its rtl now.      Otherwise, callers of this function are responsible for dealing      with this variable's rtl.  */
if|if
condition|(
operator|!
name|toplev
condition|)
block|{
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Get a variable which we can use for multiple assignments.    It is not entered into current_binding_level, because    that breaks things when it comes time to do final cleanups    (which take place "outside" the binding contour of the function).  */
end_comment

begin_function
name|tree
name|get_temp_regvar
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can expand these without fear, since they cannot need      constructors or destructors.  */
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|INIT_EXPR
argument_list|,
name|init
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Hunts through the global anonymous union ANON_DECL, building    appropriate VAR_DECLs.  Stores cleanups on the list of ELEMS, and    returns a VAR_DECL whose size is the same as the size of the    ANON_DECL, if one is available.  */
end_comment

begin_function
specifier|static
name|tree
name|build_anon_union_vars
parameter_list|(
name|anon_decl
parameter_list|,
name|elems
parameter_list|,
name|static_p
parameter_list|,
name|external_p
parameter_list|)
name|tree
name|anon_decl
decl_stmt|;
name|tree
modifier|*
name|elems
decl_stmt|;
name|int
name|static_p
decl_stmt|;
name|int
name|external_p
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|anon_decl
argument_list|)
decl_stmt|;
name|tree
name|main_decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|!=
name|NULL_TREE
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|cp_pedwarn_at
argument_list|(
literal|"`%#D' invalid; an anonymous union can only have non-static data members"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|field
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"private member `%#D' in anonymous union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|field
argument_list|)
condition|)
name|cp_pedwarn_at
argument_list|(
literal|"protected member `%#D' in anonymous union"
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|decl
operator|=
name|build_anon_union_vars
argument_list|(
name|field
argument_list|,
name|elems
argument_list|,
name|static_p
argument_list|,
name|external_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* tell `pushdecl' that this is not tentative.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
name|static_p
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|external_p
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Only write out one anon union element--choose the one that 	 can hold them all.  */
if|if
condition|(
name|main_decl
operator|==
name|NULL_TREE
operator|&&
name|simple_cst_equal
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SIZE
argument_list|(
name|anon_decl
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|main_decl
operator|=
name|decl
expr_stmt|;
else|else
comment|/* ??? This causes there to be no debug info written out 	   about this decl.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* The remainder of the processing was already done in the 	   recursive call.  */
continue|continue;
comment|/* If there's a cleanup to do, it belongs in the 	 TREE_PURPOSE of the following TREE_LIST.  */
operator|*
name|elems
operator|=
name|scratch_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
operator|*
name|elems
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|elems
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
return|return
name|main_decl
return|;
block|}
end_function

begin_comment
comment|/* Finish off the processing of a UNION_TYPE structure.    If there are static members, then all members are    static, and must be laid out together.  If the    union is an anonymous union, we arrange for that    as well.  PUBLIC_P is nonzero if this union is    not declared static.  */
end_comment

begin_function
name|void
name|finish_anon_union
parameter_list|(
name|anon_union_decl
parameter_list|)
name|tree
name|anon_union_decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
name|tree
name|elems
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|main_decl
decl_stmt|;
name|int
name|public_p
init|=
name|TREE_PUBLIC
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
name|int
name|static_p
init|=
name|TREE_STATIC
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
name|int
name|external_p
init|=
name|DECL_EXTERNAL
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|public_p
condition|)
block|{
name|error
argument_list|(
literal|"global anonymous unions must be declared static"
argument_list|)
expr_stmt|;
return|return;
block|}
name|main_decl
operator|=
name|build_anon_union_vars
argument_list|(
name|anon_union_decl
argument_list|,
operator|&
name|elems
argument_list|,
name|static_p
argument_list|,
name|external_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"anonymous union with no members"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|static_p
condition|)
block|{
name|make_decl_rtl
argument_list|(
name|main_decl
argument_list|,
literal|0
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|anon_union_decl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|main_decl
argument_list|)
expr_stmt|;
block|}
comment|/* The following call assumes that there are never any cleanups      for anonymous unions--a reasonable assumption.  */
name|expand_anon_union_decl
argument_list|(
name|anon_union_decl
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing a builtin type TYPE.  It's name is NAME,    its fields are in the array FIELDS.  LEN is the number of elements    in FIELDS minus one, or put another way, it is the maximum subscript    used in FIELDS.     It is given the same alignment as ALIGN_TYPE.  */
end_comment

begin_function
name|void
name|finish_builtin_type
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|fields
parameter_list|,
name|len
parameter_list|,
name|align_type
parameter_list|)
name|tree
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|fields
index|[]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|align_type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|fields
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|align_type
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|TYPE_NAME (type) = make_type_decl (get_identifier (name), type);
else|#
directive|else
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Auxiliary functions to make type signatures for    `operator new' and `operator delete' correspond to    what compiler will be expecting.  */
end_comment

begin_function
name|tree
name|coerce_new_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|e1
init|=
literal|0
decl_stmt|,
name|e2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
name|e1
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator new' must return type `void *'"
argument_list|)
expr_stmt|;
comment|/* Technically the type must be `size_t', but we may not know      what that is.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|e1
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator new' takes type `size_t' parameter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|sizetype
argument_list|)
condition|)
name|e2
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator new' takes type `size_t' as first parameter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e1
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|coerce_delete_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|e1
init|=
literal|0
decl_stmt|,
name|e2
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|e3 = 0;
endif|#
directive|endif
name|tree
name|arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
condition|)
name|e1
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator delete' must return type `void'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
condition|)
name|e2
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator delete' takes type `void *' as first parameter"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (arg_types&& TREE_CHAIN (arg_types)&& TREE_CHAIN (arg_types) != void_list_node)     {
comment|/* Again, technically this argument must be `size_t', but again 	 we may not know what that is.  */
block|tree t2 = TREE_VALUE (TREE_CHAIN (arg_types));       if (! same_type_p (t2, sizetype)) 	e3 = 1, error ("second argument to `operator delete' must be of type `size_t'");       else if (TREE_CHAIN (TREE_CHAIN (arg_types)) != void_list_node) 	{ 	  e3 = 1; 	  if (TREE_CHAIN (TREE_CHAIN (arg_types))) 	    error ("too many arguments in declaration of `operator delete'"); 	  else 	    error ("`...' invalid in specification of `operator delete'"); 	}     }    if (e3)     arg_types = tree_cons (NULL_TREE, ptr_type_node, 			   build_tree_list (NULL_TREE, sizetype));   else if (e3 |= e2)     {       if (arg_types == NULL_TREE) 	arg_types = tree_cons (NULL_TREE, ptr_type_node, void_list_node);       else 	arg_types = tree_cons (NULL_TREE, ptr_type_node, TREE_CHAIN (arg_types));     }   else e3 |= e1;
endif|#
directive|endif
if|if
condition|(
name|e2
condition|)
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|arg_types
condition|?
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
else|:
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|||
name|e1
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|tree
name|abort_fndecl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mark_vtable_entries
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|entries
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|entries
condition|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
control|)
block|{
name|tree
name|fnaddr
decl_stmt|;
name|tree
name|fn
decl_stmt|;
name|fnaddr
operator|=
operator|(
name|flag_vtable_thunks
condition|?
name|TREE_VALUE
argument_list|(
name|entries
argument_list|)
else|:
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|entries
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fnaddr
argument_list|)
operator|==
name|NOP_EXPR
condition|)
comment|/* RTTI offset.  */
continue|continue;
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
operator|=
name|fn
operator|=
name|copy_node
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|fn
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|abort_fndecl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|abort_fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|THUNK_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|emit_thunk
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set DECL up to have the closest approximation of "initialized common"    linkage available.  */
end_comment

begin_function
name|void
name|comdat_linkage
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|flag_weak
condition|)
name|make_decl_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* We can just emit functions and vtables statically; it doesn't really        matter if we have multiple copies.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Static data member template instantiations, however, cannot 	 have multiple copies.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EMPTY_CONSTRUCTOR_P
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't do anything useful; leave vars for explicit 	     instantiation.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For win32 we also want to put explicit instantiations in    linkonce sections, so that they will be merged with implicit    instantiations; otherwise we get duplicate symbol errors.  */
end_comment

begin_function
name|void
name|maybe_make_one_only
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* This is not necessary on targets that support weak symbols, because      the implicit instantiations will defer to the explicit one.  */
if|if
condition|(
operator|!
name|supports_one_only
argument_list|()
operator|||
name|SUPPORTS_WEAK
condition|)
return|return;
comment|/* We can't set DECL_COMDAT on functions, or finish_file will think      we can get away with not emitting them if they aren't used.  We need      to for variables so that cp_finish_decl will update their linkage,      because their DECL_INITIAL may not have been set properly yet.  */
name|make_decl_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,    based on TYPE and other static flags.     Note that anything public is tagged TREE_PUBLIC, whether    it's public in this file or in another one.  */
end_comment

begin_function
name|void
name|import_export_vtable
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|final
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
name|int
name|final
decl_stmt|;
block|{
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We can only wait to decide if we have real non-inline virtual 	 functions in our class, or if we come from a template.  */
name|int
name|found
init|=
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
operator|!
name|final
condition|)
block|{
name|tree
name|method
decl_stmt|;
for|for
control|(
name|method
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|method
operator|!=
name|NULL_TREE
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|method
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_THIS_INLINE
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|final
operator|||
operator|!
name|found
condition|)
block|{
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine whether or not we want to specifically import or export CTYPE,    using various heuristics.  */
end_comment

begin_function
name|void
name|import_export_class
parameter_list|(
name|ctype
parameter_list|)
name|tree
name|ctype
decl_stmt|;
block|{
comment|/* -1 for imported, 1 for exported.  */
name|int
name|import_export
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
condition|)
return|return;
comment|/* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma interface,      we will have CLASSTYPE_INTERFACE_ONLY set but not      CLASSTYPE_INTERFACE_KNOWN.  In that case, we don't want to use this      heuristic because someone will supply a #pragma implementation      elsewhere, and deducing it here would produce a conflict.  */
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|VALID_MACHINE_TYPE_ATTRIBUTE
comment|/* FIXME this should really use some sort of target-independent macro.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|import_export
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|import_export
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If we got -fno-implicit-templates, we import template classes that      weren't explicitly instantiated.  */
if|if
condition|(
name|import_export
operator|==
literal|0
operator|&&
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|flag_implicit_templates
condition|)
name|import_export
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Base our import/export status on that of the first non-inline,      non-abstract virtual function, if any.  */
if|if
condition|(
name|import_export
operator|==
literal|0
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|tree
name|method
decl_stmt|;
for|for
control|(
name|method
operator|=
name|TYPE_METHODS
argument_list|(
name|ctype
argument_list|)
init|;
name|method
operator|!=
name|NULL_TREE
condition|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|method
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|DECL_THIS_INLINE
argument_list|(
name|method
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|import_export
operator|=
operator|(
name|DECL_REALLY_EXTERN
argument_list|(
name|method
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|MULTIPLE_SYMBOL_SPACES
if|if
condition|(
name|import_export
operator|==
operator|-
literal|1
condition|)
name|import_export
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|import_export
condition|)
block|{
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|ctype
argument_list|)
operator|=
operator|(
name|import_export
operator|>
literal|0
operator|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
operator|=
operator|(
name|import_export
operator|<
literal|0
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We need to describe to the assembler the relationship between    a vtable and the vtable of the parent class.  */
end_comment

begin_function
specifier|static
name|void
name|output_vtable_inherit
parameter_list|(
name|vars
parameter_list|)
name|tree
name|vars
decl_stmt|;
block|{
name|tree
name|parent
decl_stmt|;
name|rtx
name|op
index|[
literal|2
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|vars
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* strip the mem ref  */
name|parent
operator|=
name|binfo_for_vtable
argument_list|(
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|TYPE_BINFO
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|vars
argument_list|)
argument_list|)
condition|)
name|op
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|parent
condition|)
block|{
name|parent
operator|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parent
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* strip the mem ref  */
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|980826
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|".vtable_inherit %c0, %c1"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|finish_vtable_vardecl
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|vars
init|=
operator|*
name|t
decl_stmt|;
name|tree
name|ctype
init|=
name|DECL_CONTEXT
argument_list|(
name|vars
argument_list|)
decl_stmt|;
name|import_export_class
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|import_export_vtable
argument_list|(
name|vars
argument_list|,
name|ctype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|vars
argument_list|)
operator|&&
operator|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|vars
argument_list|)
operator|||
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|vars
argument_list|)
argument_list|)
operator|||
operator|(
name|hack_decl_function_context
argument_list|(
name|vars
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|vars
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|vars
argument_list|)
condition|)
block|{
comment|/* Write it out.  */
name|mark_vtable_entries
argument_list|(
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|vars
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|store_init_value
argument_list|(
name|vars
argument_list|,
name|DECL_INITIAL
argument_list|(
name|vars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
block|{
comment|/* Mark the VAR_DECL node representing the vtable itself as a 	     "gratuitous" one, thereby forcing dwarfout.c to ignore it. 	     It is rather important that such things be ignored because 	     any effort to actually generate DWARF for them will run 	     into trouble when/if we encounter code like:  		#pragma interface 		struct S { virtual void member (); };  	      because the artificial declaration of the vtable itself (as 	      manufactured by the g++ front end) will say that the vtable 	      is a static member of `S' but only *after* the debug output 	      for the definition of `S' has already been output.  This causes 	      grief because the DWARF entry for the definition of the vtable 	      will try to refer back to an earlier *declaration* of the 	      vtable as a static member of `S' and there won't be one. 	      We might be able to arrange to have the "vtable static member" 	      attached to the member list for `S' before the debug info for 	      `S' get written (which would solve the problem) but that would 	      require more intrusive changes to the g++ front end.  */
name|DECL_IGNORED_P
argument_list|(
name|vars
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Always make vtables weak.  */
if|if
condition|(
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|vars
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_vtable_gc
condition|)
name|output_vtable_inherit
argument_list|(
name|vars
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|vars
argument_list|)
argument_list|)
condition|)
comment|/* We don't know what to do with this one yet.  */
return|return
literal|0
return|;
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|prune_vtable_vardecl
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|finish_sigtable_vardecl
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We don't need to mark sigtable entries as addressable here as is done      for vtables.  Since sigtables, unlike vtables, are always written out,      that was already done in build_signature_table_constructor.  */
name|rest_of_decl_compilation
argument_list|(
operator|*
name|t
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an    inline function or template instantiation at end-of-file.  */
end_comment

begin_function
name|void
name|import_export_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|(
name|flag_implicit_templates
operator|||
operator|(
name|flag_implicit_inline_templates
operator|&&
name|DECL_THIS_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Templates are allowed to have internal linkage.  See  	       [basic.link].  */
empty_stmt|;
else|else
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|ctype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|import_export_class
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|DECL_THIS_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Always make artificials weak.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|maybe_make_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_TINFO_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ctype
argument_list|)
condition|)
name|import_export_class
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ctype
argument_list|)
operator|&&
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|ctype
argument_list|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|ctype
argument_list|)
comment|/* If the type is a cv-qualified variant of a type, then we 	     must emit the tinfo function in this translation unit 	     since it will not be emitted when the vtable for the type 	     is output (which is when the unqualified version is 	     generated).  */
operator|&&
name|same_type_p
argument_list|(
name|ctype
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|ctype
argument_list|)
operator|||
operator|(
name|DECL_THIS_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_implement_inlines
operator|&&
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Always make artificials weak.  */
if|if
condition|(
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_BUILT_IN
argument_list|(
name|ctype
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|ctype
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|comdat_linkage
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|temp
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|temp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|parse_time
decl_stmt|,
name|varconst_time
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_sentry
parameter_list|(
name|base
parameter_list|)
name|tree
name|base
decl_stmt|;
block|{
name|tree
name|sname
init|=
name|get_id_2
argument_list|(
literal|"__sn"
argument_list|,
name|base
argument_list|)
decl_stmt|;
comment|/* For struct X foo __attribute__((weak)), there is a counter      __snfoo. Since base is already an assembler name, sname should      be globally unique */
name|tree
name|sentry
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|sname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sentry
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|sentry
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|sname
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|sentry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|sentry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|sentry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|sentry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|sentry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|sentry
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|sentry
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|sentry
return|;
block|}
end_function

begin_comment
comment|/* Start the process of running a particular set of global constructors    or destructors.  Subroutine of do_[cd]tors.  */
end_comment

begin_function
specifier|static
name|void
name|start_objects
parameter_list|(
name|method_type
parameter_list|,
name|initp
parameter_list|)
name|int
name|method_type
decl_stmt|,
name|initp
decl_stmt|;
block|{
name|tree
name|fnname
decl_stmt|;
name|char
name|type
index|[
literal|10
index|]
decl_stmt|;
comment|/* Make ctor or dtor function.  METHOD_TYPE may be 'I' or 'D'.  */
if|if
condition|(
name|initp
operator|!=
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|char
name|joiner
decl_stmt|;
ifdef|#
directive|ifdef
name|JOINER
name|joiner
operator|=
name|JOINER
expr_stmt|;
else|#
directive|else
name|joiner
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%c%c%.5u"
argument_list|,
name|method_type
argument_list|,
name|joiner
argument_list|,
name|initp
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%c"
argument_list|,
name|method_type
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|get_file_function_name_long
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|void_list_node
argument_list|,
name|make_call_declarator
argument_list|(
name|fnname
argument_list|,
name|void_list_node
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_CONSTRUCTOR
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_DESTRUCTOR
argument_list|)
comment|/* It can be a static function as long as collect2 does not have      to scan the object file to find its ctor/dtor routine.  */
name|TREE_PUBLIC
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* We cannot allow these functions to be elided, even if they do not      have external linkage.  And, there's no point in deferring      copmilation of thes functions; they're all going to have to be      out anyhow.  */
name|current_function_cannot_inline
operator|=
literal|"static constructors and destructors cannot be inlined"
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the process of running a particular set of global constructors    or destructors.  Subroutine of do_[cd]tors.  */
end_comment

begin_function
specifier|static
name|void
name|finish_objects
parameter_list|(
name|method_type
parameter_list|,
name|initp
parameter_list|)
name|int
name|method_type
decl_stmt|,
name|initp
decl_stmt|;
block|{
name|char
modifier|*
name|fnname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Finish up. */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|initp
operator|==
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
if|if
condition|(
name|method_type
operator|==
literal|'I'
condition|)
name|assemble_constructor
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
else|else
name|assemble_destructor
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_SECTION_NAME
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_CONSTRUCTOR
argument_list|)
comment|/* If we're using init priority we can't use assemble_*tor, but on ELF      targets we can stick the references into named sections for GNU ld      to collect.  */
else|else
block|{
name|char
name|buf
index|[
literal|15
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%ctors.%.5u"
argument_list|,
name|method_type
operator|==
literal|'I'
condition|?
literal|'c'
else|:
literal|'d'
argument_list|,
comment|/* invert the numbering so the linker puts us in the proper 		  order; constructors are run from right to left, and the 		  linker sorts in increasing order.  */
name|MAX_INIT_PRIORITY
operator|-
name|initp
argument_list|)
expr_stmt|;
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|fnname
argument_list|)
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The names of the parameters to the function created to handle    initializations and destructions for objects with static storage    duration.  */
end_comment

begin_define
define|#
directive|define
name|INITIALIZE_P_IDENTIFIER
value|"__initialize_p"
end_define

begin_define
define|#
directive|define
name|PRIORITY_IDENTIFIER
value|"__priority"
end_define

begin_comment
comment|/* The name of the function we create to handle initializations and    destructions for objects with static storage duration.  */
end_comment

begin_define
define|#
directive|define
name|SSDF_IDENTIFIER
value|"__static_initialization_and_destruction"
end_define

begin_comment
comment|/* The declaration for the __INITIALIZE_P argument.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|initialize_p_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The declaration for the __PRIORITY argument.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|priority_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The declaration for the static storage duration function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|ssdf_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the static storage duration functions created in this    translation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|ssdf_decls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ssdf_decls_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A map from priority levels to information about that priority    level.  There may be many such levels, so efficient lookup is    important.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|priority_info_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begins the generation of the function that will handle all    initialization and destruction of objects with static storage    duration.  The function generated takes two parameters of type    `int': __INITIALIZE_P and __PRIORITY.  If __INITIALIZE_P is    non-zero, it performs initializations.  Otherwise, it performs    destructions.  It only performs those initializations or    destructions with the indicated __PRIORITY.  The generated function    returns no value.       It is assumed that this function will only be called once per    translation unit.  */
end_comment

begin_function
specifier|static
name|void
name|start_static_storage_duration_function
parameter_list|()
block|{
specifier|static
name|unsigned
name|ssdf_number
decl_stmt|;
name|tree
name|parm_types
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
name|id
index|[
sizeof|sizeof
argument_list|(
name|SSDF_IDENTIFIER
argument_list|)
operator|+
literal|1
comment|/* '\0' */
operator|+
literal|32
index|]
decl_stmt|;
comment|/* Create the identifier for this function.  It will be of the form      SSDF_IDENTIFIER_<number>.  */
name|sprintf
argument_list|(
name|id
argument_list|,
literal|"%s_%u"
argument_list|,
name|SSDF_IDENTIFIER
argument_list|,
name|ssdf_number
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssdf_number
operator|==
literal|0
condition|)
block|{
comment|/* Overflow occurred.  That means there are at least 4 billion 	 initialization functions.  */
name|sorry
argument_list|(
literal|"too many initialization functions required"
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|19990430
argument_list|)
expr_stmt|;
block|}
comment|/* Create the parameters.  */
name|parm_types
operator|=
name|void_list_node
expr_stmt|;
name|parm_types
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
name|parm_types
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
comment|/* Create the FUNCTION_DECL itself.  */
name|ssdf_decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|id
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Put this function in the list of functions to be called from the      static constructors and destructors.  */
if|if
condition|(
operator|!
name|ssdf_decls
condition|)
block|{
name|VARRAY_TREE_INIT
argument_list|(
name|ssdf_decls
argument_list|,
literal|32
argument_list|,
literal|"ssdf_decls"
argument_list|)
expr_stmt|;
comment|/* Take this opportunity to initialize the map from priority 	 numbers to information about that priority level. */
name|priority_info_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
comment|/*delete_key_fn=*/
literal|0
argument_list|,
comment|/*delete_value_fn=*/
operator|(
name|splay_tree_delete_value_fn
operator|)
operator|&
name|free
argument_list|)
expr_stmt|;
comment|/* We always need to generate functions for the 	 DEFAULT_INIT_PRIORITY so enter it now.  That way when we walk 	 priorities later, we'll be sure to find the 	 DEFAULT_INIT_PRIORITY.  */
name|get_priority_info
argument_list|(
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssdf_decls_used
operator|==
name|ssdf_decls
operator|->
name|num_elements
condition|)
name|VARRAY_GROW
argument_list|(
name|ssdf_decls
argument_list|,
literal|2
operator|*
name|ssdf_decls_used
argument_list|)
expr_stmt|;
name|VARRAY_TREE
argument_list|(
name|ssdf_decls
argument_list|,
name|ssdf_decls_used
argument_list|)
operator|=
name|ssdf_decl
expr_stmt|;
operator|++
name|ssdf_decls_used
expr_stmt|;
comment|/* Create the argument list.  */
name|initialize_p_decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|get_identifier
argument_list|(
name|INITIALIZE_P_IDENTIFIER
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
name|ssdf_decl
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TREE_USED
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|priority_decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|get_identifier
argument_list|(
name|PRIORITY_IDENTIFIER
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|priority_decl
argument_list|)
operator|=
name|ssdf_decl
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|priority_decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TREE_USED
argument_list|(
name|priority_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|initialize_p_decl
argument_list|)
operator|=
name|priority_decl
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|ssdf_decl
argument_list|)
operator|=
name|initialize_p_decl
expr_stmt|;
comment|/* Start the function itself.  This is equivalent to declarating the      function as:         static void __ssdf (int __initialize_p, init __priority_p);              It is static because we only need to call this function from the      various constructor and destructor functions for this module.  */
name|start_function
argument_list|(
comment|/*specs=*/
name|NULL_TREE
argument_list|,
name|ssdf_decl
argument_list|,
comment|/*attrs=*/
name|NULL_TREE
argument_list|,
comment|/*pre_parsed_p=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Set up the scope of the outermost block in the function.  */
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This function must not be deferred because we are depending on      its compilation to tell us what is TREE_SYMBOL_REFERENCED.  */
name|current_function_cannot_inline
operator|=
literal|"static storage duration functions cannot be inlined"
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the initialization code for the priority indicated in N.  */
end_comment

begin_function
specifier|static
name|int
name|generate_inits_for_priority
parameter_list|(
name|n
parameter_list|,
name|data
parameter_list|)
name|splay_tree_node
name|n
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|priority
init|=
operator|(
name|int
operator|)
name|n
operator|->
name|key
decl_stmt|;
name|priority_info
name|pi
init|=
operator|(
name|priority_info
operator|)
name|n
operator|->
name|value
decl_stmt|;
comment|/* For each priority N which has been used generate code which looks      like:         if (__priority == N) {          if (__initialize_p) 	   ... 	 else 	   ...        }       We use the sequences we've accumulated to fill in the `...'s.  */
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|priority_decl
argument_list|,
name|build_int_2
argument_list|(
name|priority
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
comment|/*exit_flag=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Do the initializations.  */
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|initialize_p_decl
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
comment|/*exit_flag=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|initialization_sequence
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|push_to_sequence
argument_list|(
name|pi
operator|->
name|initialization_sequence
argument_list|)
expr_stmt|;
name|insns
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|pi
operator|->
name|initialization_sequence
operator|=
name|NULL_RTX
expr_stmt|;
name|pi
operator|->
name|initializations_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Do the destructions.  */
name|expand_start_else
argument_list|()
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|destruction_sequence
condition|)
block|{
name|rtx
name|insns
decl_stmt|;
name|push_to_sequence
argument_list|(
name|pi
operator|->
name|destruction_sequence
argument_list|)
expr_stmt|;
name|insns
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|insns
argument_list|)
expr_stmt|;
name|pi
operator|->
name|destruction_sequence
operator|=
name|NULL_RTX
expr_stmt|;
name|pi
operator|->
name|destructions_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Close out the conditionals.  */
name|expand_end_cond
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
comment|/* Don't stop iterating.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Finish the generation of the function which performs initialization    and destruction of objects with static storage duration.  After    this point, no more such objects can be created.  */
end_comment

begin_function
specifier|static
name|void
name|finish_static_storage_duration_function
parameter_list|()
block|{
name|splay_tree_foreach
argument_list|(
name|priority_info_map
argument_list|,
name|generate_inits_for_priority
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Close out the function.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the information about the indicated PRIORITY level.  If no    code to handle this level has yet been generated, generate the    appropriate prologue.  */
end_comment

begin_function
specifier|static
name|priority_info
name|get_priority_info
parameter_list|(
name|priority
parameter_list|)
name|int
name|priority
decl_stmt|;
block|{
name|priority_info
name|pi
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|priority_info_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* Create a new priority information structure, and insert it 	 into the map.  */
name|pi
operator|=
operator|(
name|priority_info
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|priority_info_s
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|initialization_sequence
operator|=
name|NULL_RTX
expr_stmt|;
name|pi
operator|->
name|destruction_sequence
operator|=
name|NULL_RTX
expr_stmt|;
name|pi
operator|->
name|initializations_p
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|destructions_p
operator|=
literal|0
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|priority_info_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|priority
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
name|pi
operator|=
operator|(
name|priority_info
operator|)
name|n
operator|->
name|value
expr_stmt|;
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/* Generate code to do the static initialization of DECL.  The    initialization is INIT.  If DECL may be initialized more than once    in different object files, SENTRY is the guard variable to     check.  PRIORITY is the priority for the initialization.  */
end_comment

begin_function
specifier|static
name|void
name|do_static_initialization
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|sentry
parameter_list|,
name|priority
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|tree
name|sentry
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
name|priority_info
name|pi
decl_stmt|;
comment|/* Get the priority information for this PRIORITY,  */
name|pi
operator|=
name|get_priority_info
argument_list|(
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|initialization_sequence
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|pi
operator|->
name|initialization_sequence
argument_list|)
expr_stmt|;
comment|/* Tell the debugger that we are at the location of the static      variable in question.  */
name|emit_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* If there's a SENTRY, we only do the initialization if it is      zero, i.e., if we are the first to initialize it.  */
if|if
condition|(
name|sentry
condition|)
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|sentry
argument_list|,
comment|/*noconvert=*/
literal|0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
comment|/*exit_flag=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Prepare a binding level for temporaries created during the      initialization.  */
name|expand_start_target_temps
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|expand_expr
argument_list|(
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
else|else
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The expression might have involved increments and decrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
comment|/* Cleanup any temporaries needed for the initial value.  */
name|expand_end_target_temps
argument_list|()
expr_stmt|;
comment|/* Cleanup any deferred pops from function calls.  This would be done      by expand_end_cond, but we also need it when !SENTRY, since we are      constructing these sequences by parts.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Close the conditional opened above.  */
if|if
condition|(
name|sentry
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
comment|/* Save the sequence for later use.  */
name|pi
operator|->
name|initialization_sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate code to do the static destruction of DECL.  If DECL may be    initialized more than once in different object files, SENTRY is the    guard variable to check.  PRIORITY is the priority for the    destruction.  */
end_comment

begin_function
specifier|static
name|void
name|do_static_destruction
parameter_list|(
name|decl
parameter_list|,
name|sentry
parameter_list|,
name|priority
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|sentry
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
name|rtx
name|new_insns
decl_stmt|;
name|priority_info
name|pi
decl_stmt|;
comment|/* If we don't need a destructor, there's nothing to do.  */
if|if
condition|(
operator|!
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Get the priority information for this PRIORITY,  */
name|pi
operator|=
name|get_priority_info
argument_list|(
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|destruction_sequence
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|pi
operator|->
name|destruction_sequence
argument_list|)
expr_stmt|;
comment|/* Start a new sequence to handle just this destruction.  */
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Tell the debugger that we are at the location of the static      variable in question.  */
name|emit_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* If there's a SENTRY, we only do the destruction if it is one,      i.e., if we are the last to destroy it.  */
if|if
condition|(
name|sentry
condition|)
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|sentry
argument_list|,
comment|/*nonconvert=*/
literal|1
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
comment|/*exit_flag=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Actually to the destruction.  */
name|expand_expr_stmt
argument_list|(
name|build_cleanup
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup any deferred pops from function calls.  This would be done      by expand_end_cond, but we also need it when !SENTRY, since we are      constructing these sequences by parts.  */
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* Close the conditional opened above.  */
if|if
condition|(
name|sentry
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
comment|/* Insert the NEW_INSNS before the current insns.  (Destructions are      run in reverse order of initializations.)  */
name|new_insns
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|destruction_sequence
condition|)
name|emit_insn_before
argument_list|(
name|new_insns
argument_list|,
name|pi
operator|->
name|destruction_sequence
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|new_insns
argument_list|)
expr_stmt|;
comment|/* Save the sequence for later use.  */
name|pi
operator|->
name|destruction_sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add code to the static storage duration function that will handle    DECL (a static variable that needs initializing and/or destruction)    with the indicated PRIORITY.  If DECL needs initializing, INIT is    the initializer.  */
end_comment

begin_function
specifier|static
name|void
name|do_static_initialization_and_destruction
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
name|tree
name|sentry
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|priority
decl_stmt|;
comment|/* Deal gracefully with error.  */
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* The only things that can be initialized are variables.  */
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|19990420
argument_list|)
expr_stmt|;
comment|/* If this object is not defined, we don't need to do anything       here.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Also, if the initializer already contains errors, we can bail out      now.  */
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|value_member
argument_list|(
name|error_mark_node
argument_list|,
name|init
argument_list|)
condition|)
return|return;
comment|/* Trick the compiler into thinking we are at the file and line      where DECL was declared so that error-messages make sense, and so      that the debugger will show somewhat sensible file and line      information.  */
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Because of:         [class.access.spec]         Access control for implicit calls to the constructors,        the conversion functions, or the destructor called to        create and destroy a static data member is performed as        if these calls appeared in the scope of the member's        class.         we pretend we are in a static member function of the class of      which the DECL is a member.  */
if|if
condition|(
name|member_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We need a sentry if this is an object with external linkage that      might be initialized in more than one place.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|sentry
operator|=
name|get_sentry
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the code to actually do the intialization and      destruction.  */
name|priority
operator|=
name|DECL_INIT_PRIORITY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priority
condition|)
name|priority
operator|=
name|DEFAULT_INIT_PRIORITY
expr_stmt|;
name|do_static_initialization
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|sentry
argument_list|,
name|priority
argument_list|)
expr_stmt|;
name|do_static_destruction
argument_list|(
name|decl
argument_list|,
name|sentry
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|/* Now that we're done with DECL we don't need to pretend to be a      member of its class any longer.  */
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a static constructor (if CONSTRUCTOR_P) or destructor    (otherwise) that will initialize all gobal objects with static    storage duration having the indicated PRIORITY.  */
end_comment

begin_function
specifier|static
name|void
name|generate_ctor_or_dtor_function
parameter_list|(
name|constructor_p
parameter_list|,
name|priority
parameter_list|)
name|int
name|constructor_p
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
name|char
name|function_key
decl_stmt|;
name|tree
name|arguments
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* We use `I' to indicate initialization and `D' to indicate      destruction.  */
if|if
condition|(
name|constructor_p
condition|)
name|function_key
operator|=
literal|'I'
expr_stmt|;
else|else
name|function_key
operator|=
literal|'D'
expr_stmt|;
comment|/* Begin the function.  */
name|start_objects
argument_list|(
name|function_key
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|/* Call the static storage duration function with appropriate      arguments.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ssdf_decls_used
condition|;
operator|++
name|i
control|)
block|{
name|arguments
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|priority
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|arguments
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|constructor_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|VARRAY_TREE
argument_list|(
name|ssdf_decls
argument_list|,
name|i
argument_list|)
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we're generating code for the DEFAULT_INIT_PRIORITY, throw in      calls to any functions marked with attributes indicating that      they should be called at initialization- or destruction-time.  */
if|if
condition|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
condition|)
block|{
name|tree
name|fns
decl_stmt|;
for|for
control|(
name|fns
operator|=
name|constructor_p
condition|?
name|static_ctors
else|:
name|static_dtors
init|;
name|fns
condition|;
name|fns
operator|=
name|TREE_CHAIN
argument_list|(
name|fns
argument_list|)
control|)
name|expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Close out the function.  */
name|finish_objects
argument_list|(
name|function_key
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate constructor and destructor functions for the priority    indicated by N.  */
end_comment

begin_function
specifier|static
name|int
name|generate_ctor_and_dtor_functions_for_priority
parameter_list|(
name|n
parameter_list|,
name|data
parameter_list|)
name|splay_tree_node
name|n
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|priority
init|=
operator|(
name|int
operator|)
name|n
operator|->
name|key
decl_stmt|;
name|priority_info
name|pi
init|=
operator|(
name|priority_info
operator|)
name|n
operator|->
name|value
decl_stmt|;
comment|/* Generate the functions themselves, but only if they are really      needed.  */
if|if
condition|(
name|pi
operator|->
name|initializations_p
operator|||
operator|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
operator|&&
name|static_ctors
operator|)
condition|)
name|generate_ctor_or_dtor_function
argument_list|(
comment|/*constructor_p=*/
literal|1
argument_list|,
name|priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|destructions_p
operator|||
operator|(
name|priority
operator|==
name|DEFAULT_INIT_PRIORITY
operator|&&
name|static_dtors
operator|)
condition|)
name|generate_ctor_or_dtor_function
argument_list|(
comment|/*constructor_p=*/
literal|0
argument_list|,
name|priority
argument_list|)
expr_stmt|;
comment|/* Keep iterating.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This routine is called from the last rule in yyparse ().    Its job is to create all the code needed to initialize and    destroy the global aggregates.  We do the destruction    first, since that way we only need to reverse the decls once.  */
end_comment

begin_function
name|void
name|finish_file
parameter_list|()
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|int
name|start_time
decl_stmt|,
name|this_time
decl_stmt|;
name|tree
name|vars
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|at_eof
operator|=
literal|1
expr_stmt|;
comment|/* Bad parse errors.  Just forget about it.  */
if|if
condition|(
operator|!
name|global_bindings_p
argument_list|()
operator|||
name|current_class_type
operator|||
name|decl_namespace_list
condition|)
return|return;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
comment|/* Otherwise, GDB can get confused, because in only knows      about source for LINENO-1 lines.  */
name|lineno
operator|-=
literal|1
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|interface_only
operator|=
literal|0
expr_stmt|;
comment|/* We now have to write out all the stuff we put off writing out.      These include:         o Template specializations that we have not yet instantiated,          but which are needed.        o Initialization and destruction for non-local objects with          static storage duration.  (Local objects with static storage 	 duration are initialized when their scope is first entered, 	 and are cleaned up via atexit.)        o Virtual function tables.         All of these may cause others to be needed.  For example,      instantiating one function may cause another to be needed, and      generating the intiailzer for an object may cause templates to be      instantiated, etc., etc.  */
name|this_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|parse_time
operator|-=
name|this_time
operator|-
name|start_time
expr_stmt|;
name|varconst_time
operator|+=
name|this_time
operator|-
name|start_time
expr_stmt|;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Non-zero if we need a static storage duration function on 	 this iteration through the loop.  */
name|int
name|need_ssdf_p
init|=
literal|0
decl_stmt|;
name|reconsider
operator|=
literal|0
expr_stmt|;
comment|/* If there are templates that we've put off instantiating, do 	 them now.  */
name|instantiate_pending_templates
argument_list|()
expr_stmt|;
comment|/* Write out signature-tables and virtual tables as required. 	 Note that writing out the virtual table for a template class 	 may cause the instantiation of members of that class.  */
if|if
condition|(
name|flag_handle_signatures
operator|&&
name|walk_globals
argument_list|(
name|sigtable_decl_p
argument_list|,
name|finish_sigtable_vardecl
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|walk_globals
argument_list|(
name|vtable_decl_p
argument_list|,
name|finish_vtable_vardecl
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
comment|/* The list of objects with static storage duration is built up 	 in reverse order, so we reverse it here.  We also clear 	 STATIC_AGGREGATES so that any new aggregates added during the 	 initialization of these will be initialized in the correct 	 order when we next come around the loop.  */
name|vars
operator|=
name|nreverse
argument_list|(
name|static_aggregates
argument_list|)
expr_stmt|;
name|static_aggregates
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|vars
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
argument_list|)
condition|)
name|rest_of_decl_compilation
argument_list|(
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_ssdf_p
condition|)
block|{
comment|/* We need to start a new initialization function each 		 time through the loop.  That's because we need to 		 know which vtables have been referenced, and 		 TREE_SYMBOL_REFERENCED isn't computed until a 		 function is finished, and written out.  That's a 		 deficiency in the back-end.  When this is fixed, 		 these initialization functions could all become 		 inline, with resulting performance improvements.  */
name|start_static_storage_duration_function
argument_list|()
expr_stmt|;
name|need_ssdf_p
operator|=
literal|1
expr_stmt|;
block|}
name|do_static_initialization_and_destruction
argument_list|(
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|vars
argument_list|)
argument_list|)
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
comment|/* Finish up the static storage duration function for this          round.  */
if|if
condition|(
name|need_ssdf_p
condition|)
name|finish_static_storage_duration_function
argument_list|()
expr_stmt|;
comment|/* Go through the various inline functions, and see if any need 	 synthesizing.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|saved_inlines_used
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|decl
init|=
name|VARRAY_TREE
argument_list|(
name|saved_inlines
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|import_export_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
comment|/* Even though we're already at the top-level, we push 		 there again.  That way, when we pop back a few lines 		 hence, all of our state is restored.  Otherwise, 		 finish_function doesn't clean things up, and we end 		 up with CURRENT_FUNCTION_DECL set.  */
name|push_to_top_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_TINFO_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
name|synthesize_tinfo_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|synthesize_method
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Mark all functions that might deal with exception-handling as 	 referenced.  */
name|mark_all_runtime_matches
argument_list|()
expr_stmt|;
comment|/* We lie to the back-end, pretending that some functions are 	 not defined when they really are.  This keeps these functions 	 from being put out unncessarily.  But, we must stop lying 	 when the functions are referenced, or if they are not comdat 	 since they need to be put out now.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|saved_inlines_used
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|decl
init|=
name|VARRAY_TREE
argument_list|(
name|saved_inlines
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
operator|!
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|saved_inlines_used
operator|&&
name|wrapup_global_declarations
argument_list|(
operator|&
name|VARRAY_TREE
argument_list|(
name|saved_inlines
argument_list|,
literal|0
argument_list|)
argument_list|,
name|saved_inlines_used
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|walk_namespaces
argument_list|(
name|wrapup_globals_for_namespace
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
comment|/* Static data members are just like namespace-scope globals.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pending_statics_used
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|decl
init|=
name|VARRAY_TREE
argument_list|(
name|pending_statics
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
continue|continue;
name|import_export_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pending_statics
operator|&&
name|wrapup_global_declarations
argument_list|(
operator|&
name|VARRAY_TREE
argument_list|(
name|pending_statics
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pending_statics_used
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
comment|/* We give C linkage to static constructors and destructors.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* Generate initialization and destruction functions for all      priorities for which they are required.  */
if|if
condition|(
name|priority_info_map
condition|)
name|splay_tree_foreach
argument_list|(
name|priority_info_map
argument_list|,
name|generate_ctor_and_dtor_functions_for_priority
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* We're done with the splay-tree now.  */
if|if
condition|(
name|priority_info_map
condition|)
name|splay_tree_delete
argument_list|(
name|priority_info_map
argument_list|)
expr_stmt|;
comment|/* We're done with static constructors, so we can go back to "C++"      linkage now.  */
name|pop_lang_context
argument_list|()
expr_stmt|;
comment|/* Now delete from the chain of variables all virtual function tables.      We output them all ourselves, because each will be treated      specially.  */
name|walk_globals
argument_list|(
name|vtable_decl_p
argument_list|,
name|prune_vtable_vardecl
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Now, issue warnings about static, but not defined, functions,      etc.  */
name|walk_namespaces
argument_list|(
name|wrapup_globals_for_namespace
argument_list|,
comment|/*data=*/
operator|&
name|reconsider
argument_list|)
expr_stmt|;
name|finish_repo
argument_list|()
expr_stmt|;
name|this_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|parse_time
operator|-=
name|this_time
operator|-
name|start_time
expr_stmt|;
name|varconst_time
operator|+=
name|this_time
operator|-
name|start_time
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|dump_tree_statistics
argument_list|()
expr_stmt|;
name|dump_time_statistics
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is something of the form 'A()()()()()+1' that has turned out to be an    expr.  Since it was parsed like a type, we need to wade through and fix    that.  Unfortunately, since operator() is left-associative, we can't use    tail recursion.  In the above example, TYPE is `A', and DECL is    `()()()()()'.     Maybe this shouldn't be recursive, but how often will it actually be    used?  (jason) */
end_comment

begin_function
name|tree
name|reparse_absdcl_as_expr
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
comment|/* do build_functional_cast (type, NULL_TREE) at bottom */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
return|;
comment|/* recurse */
name|decl
operator|=
name|reparse_absdcl_as_expr
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_x_function_call
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|current_class_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
operator|!
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|decl
operator|=
name|require_complete_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* This is something of the form `int ((int)(int)(int)1)' that has turned    out to be an expr.  Since it was parsed like a type, we need to wade    through and fix that.  Since casts are right-associative, we are    reversing the order, so we don't have to recurse.     In the above example, DECL is the `(int)(int)(int)', and EXPR is the    `1'.  */
end_comment

begin_function
name|tree
name|reparse_absdcl_as_casts
parameter_list|(
name|decl
parameter_list|,
name|expr
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|groktypename
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies signature type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|expr
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
operator|(
name|tree
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
condition|)
name|my_friendly_abort
argument_list|(
literal|78
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|decl
condition|)
block|{
name|type
operator|=
name|groktypename
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_c_cast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_old_style_cast
operator|&&
operator|!
name|in_system_header
operator|&&
name|current_lang_name
operator|!=
name|lang_name_c
condition|)
name|warning
argument_list|(
literal|"use of old-style cast"
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Given plain tree nodes for an expression, build up the full semantics.  */
end_comment

begin_function
name|tree
name|build_expr_from_tree
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
return|return
name|do_identifier
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|LOOKUP_EXPR
case|:
if|if
condition|(
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|do_scoped_id
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|do_identifier
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|TEMPLATE_ID_EXPR
case|:
return|return
operator|(
name|lookup_template_function
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|build_x_indirect_ref
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|"unary *"
argument_list|)
return|;
case|case
name|CAST_EXPR
case|:
return|return
name|build_functional_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|REINTERPRET_CAST_EXPR
case|:
return|return
name|build_reinterpret_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONST_CAST_EXPR
case|:
return|return
name|build_const_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|DYNAMIC_CAST_EXPR
case|:
return|return
name|build_dynamic_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|STATIC_CAST_EXPR
case|:
return|return
name|build_static_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
comment|/* Unary + */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|build_x_unary_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|MEMBER_REF
case|:
return|return
name|build_x_binary_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|DOTSTAR_EXPR
case|:
return|return
name|build_m_component_ref
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|build_offset_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
comment|/* new-type-id */
return|return
name|build_parse_node
argument_list|(
name|ARRAY_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|grok_array_decl
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
block|{
name|tree
name|r
init|=
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|r
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SIZEOF_EXPR
condition|?
name|c_sizeof
argument_list|(
name|r
argument_list|)
else|:
name|c_alignof
argument_list|(
name|r
argument_list|)
return|;
block|}
case|case
name|MODOP_EXPR
case|:
return|return
name|build_x_modify_expr
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ARROW_EXPR
case|:
return|return
name|build_x_arrow
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEW_EXPR
case|:
return|return
name|build_new
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|DELETE_EXPR
case|:
return|return
name|delete_sanity
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|build_x_compound_expr
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|my_friendly_abort
argument_list|(
literal|42
argument_list|)
expr_stmt|;
case|case
name|METHOD_CALL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|ref
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build_scoped_method_call
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We can get a TEMPLATE_ID_EXPR here on code like:  	       x->f<2>(); 	       	     so we must resolve that.  However, we can also get things 	     like a BIT_NOT_EXPR here, when referring to a destructor, 	     and things like that are not correctly resolved by 	     build_expr_from_tree.  So, just use build_expr_from_tree 	     when we really need it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fn
operator|=
name|lookup_template_function
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|ref
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|build_member_call
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|tree
name|args
init|=
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|LOOKUP_EXPR
operator|&&
operator|!
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
operator|(
name|id
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
operator|(
operator|!
name|current_class_type
operator|||
operator|!
name|lookup_member
argument_list|(
name|current_class_type
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* Do Koenig lookup if there are no class members. */
name|name
operator|=
name|do_identifier
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
operator|!
name|really_overloaded_fn
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|build_expr_from_tree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|build_x_function_call
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|current_class_ref
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_x_conditional_expr
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|build_expr_from_tree
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|build_expr_from_tree
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|build_expr_from_tree
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
name|expr_tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|object
init|=
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We use a COMPONENT_REF to indicate things of the form `x.b' 	   and `x.A::b'.  We must distinguish between those cases 	   here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|SCOPE_REF
condition|)
return|return
name|build_object_ref
argument_list|(
name|object
argument_list|,
name|TREE_OPERAND
argument_list|(
name|field
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|build_x_component_ref
argument_list|(
name|object
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
return|;
block|}
case|case
name|THROW_EXPR
case|:
return|return
name|build_throw
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|tree
name|r
decl_stmt|;
comment|/* digest_init will do the wrong thing if we let it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
name|r
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|build_expr_from_tree
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|r
return|;
block|}
case|case
name|TYPEID_EXPR
case|:
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|get_typeid
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|build_x_typeid
argument_list|(
name|build_expr_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
return|return
name|convert_from_reference
argument_list|(
name|t
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is something of the form `int (*a)++' that has turned out to be an    expr.  It was only converted into parse nodes, so we need to go through    and build up the semantics.  Most of the work is done by    build_expr_from_tree, above.     In the above example, TYPE is `int' and DECL is `*a'.  */
end_comment

begin_function
name|tree
name|reparse_decl_as_expr
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|decl
operator|=
name|build_expr_from_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
return|return
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|)
argument_list|)
return|;
else|else
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* This is something of the form `int (*a)' that has turned out to be a    decl.  It was only converted into parse nodes, so we need to do the    checking that make_{pointer,reference}_declarator do.  */
end_comment

begin_function
name|tree
name|finish_decl_parsing
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|extern
name|int
name|current_class_depth
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
return|return
name|decl
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|make_pointer_declarator
argument_list|(
name|NULL_TREE
argument_list|,
name|finish_decl_parsing
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|make_reference_declarator
argument_list|(
name|NULL_TREE
argument_list|,
name|finish_decl_parsing
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BIT_NOT_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|finish_decl_parsing
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
case|case
name|SCOPE_REF
case|:
name|push_nested_class
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
return|return
name|decl
return|;
case|case
name|ARRAY_REF
case|:
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|finish_decl_parsing
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
case|case
name|TREE_LIST
case|:
comment|/* For attribute handling.  */
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|finish_decl_parsing
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
default|default:
name|my_friendly_abort
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_function
name|tree
name|check_cp_case_value
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|fold
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"case label `%E' does not reduce to an integer constant"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* Promote char or short to int.  */
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if root encloses child. */
end_comment

begin_function
specifier|static
name|int
name|is_namespace_ancestor
parameter_list|(
name|root
parameter_list|,
name|child
parameter_list|)
name|tree
name|root
decl_stmt|,
name|child
decl_stmt|;
block|{
if|if
condition|(
name|root
operator|==
name|child
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|root
operator|==
name|global_namespace
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|child
operator|==
name|global_namespace
condition|)
return|return
literal|0
return|;
return|return
name|is_namespace_ancestor
argument_list|(
name|root
argument_list|,
name|CP_DECL_CONTEXT
argument_list|(
name|child
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the namespace that is the common ancestor     of two given namespaces. */
end_comment

begin_function
name|tree
name|namespace_ancestor
parameter_list|(
name|ns1
parameter_list|,
name|ns2
parameter_list|)
name|tree
name|ns1
decl_stmt|,
name|ns2
decl_stmt|;
block|{
if|if
condition|(
name|is_namespace_ancestor
argument_list|(
name|ns1
argument_list|,
name|ns2
argument_list|)
condition|)
return|return
name|ns1
return|;
return|return
name|namespace_ancestor
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|ns1
argument_list|)
argument_list|,
name|ns2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Insert used into the using list of user. Set indirect_flag if this    directive is not directly from the source. Also find the common    ancestor and let our users know about the new namespace */
end_comment

begin_function
specifier|static
name|void
name|add_using_namespace
parameter_list|(
name|user
parameter_list|,
name|used
parameter_list|,
name|indirect
parameter_list|)
name|tree
name|user
decl_stmt|;
name|tree
name|used
decl_stmt|;
name|int
name|indirect
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* Using oneself is a no-op. */
if|if
condition|(
name|user
operator|==
name|used
condition|)
return|return;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|user
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|380
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|used
argument_list|)
operator|==
name|NAMESPACE_DECL
argument_list|,
literal|380
argument_list|)
expr_stmt|;
comment|/* Check if we already have this. */
name|t
operator|=
name|purpose_member
argument_list|(
name|used
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|indirect
condition|)
comment|/* Promote to direct usage. */
name|TREE_INDIRECT_USING
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Add used to the user's using list. */
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|used
argument_list|,
name|namespace_ancestor
argument_list|(
name|user
argument_list|,
name|used
argument_list|)
argument_list|,
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_INDIRECT_USING
argument_list|(
name|DECL_NAMESPACE_USING
argument_list|(
name|user
argument_list|)
argument_list|)
operator|=
name|indirect
expr_stmt|;
comment|/* Add user to the used's users list. */
name|DECL_NAMESPACE_USERS
argument_list|(
name|used
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|user
argument_list|,
literal|0
argument_list|,
name|DECL_NAMESPACE_USERS
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recursively add all namespaces used. */
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|used
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
comment|/* indirect usage */
name|add_using_namespace
argument_list|(
name|user
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell everyone using us about the new used namespaces. */
for|for
control|(
name|t
operator|=
name|DECL_NAMESPACE_USERS
argument_list|(
name|user
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|add_using_namespace
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|used
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Combines two sets of overloaded functions into an OVERLOAD chain, removing    duplicates.  The first list becomes the tail of the result.     The algorithm is O(n^2).  We could get this down to O(n log n) by    doing a sort on the addresses of the functions, if that becomes    necessary.  */
end_comment

begin_function
specifier|static
name|tree
name|merge_functions
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|tree
name|s1
decl_stmt|;
name|tree
name|s2
decl_stmt|;
block|{
for|for
control|(
init|;
name|s2
condition|;
name|s2
operator|=
name|OVL_NEXT
argument_list|(
name|s2
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ovl_member
argument_list|(
name|fn
argument_list|,
name|s1
argument_list|)
condition|)
name|s1
operator|=
name|build_overload
argument_list|(
name|fn
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/* This should return an error not all definitions define functions.    It is not an error if we find two functions with exactly the    same signature, only if these are selected in overload resolution.    old is the current set of bindings, new the freshly-found binding.    XXX Do we want to give *all* candidates in case of ambiguity?    XXX In what way should I treat extern declarations?    XXX I don't want to repeat the entire duplicate_decls here */
end_comment

begin_function
specifier|static
name|tree
name|ambiguous_decl
parameter_list|(
name|name
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|,
name|flags
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|old
decl_stmt|;
name|tree
name|new
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|,
name|type
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|old
operator|!=
name|NULL_TREE
argument_list|,
literal|393
argument_list|)
expr_stmt|;
comment|/* Copy the value. */
name|val
operator|=
name|BINDING_VALUE
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
comment|/* If we expect types or namespaces, and not templates,            or this is not a template class. */
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
operator|&&
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|LOOKUP_TYPES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|LOOKUP_QUALIFIERS_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|val
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
condition|)
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|&&
name|val
operator|!=
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
operator|=
name|merge_functions
argument_list|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Some declarations are functions, some are not. */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
comment|/* If we've already given this error for this lookup, 		 BINDING_VALUE (old) is error_mark_node, so let's not 		 repeat ourselves.  */
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|cp_error
argument_list|(
literal|"use of `%D' is ambiguous"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  first declared as `%#D' here"
argument_list|,
name|BINDING_VALUE
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cp_error_at
argument_list|(
literal|"  also declared as `%#D' here"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* ... and copy the type. */
name|type
operator|=
name|BINDING_TYPE
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOOKUP_NAMESPACES_ONLY
argument_list|(
name|flags
argument_list|)
condition|)
name|type
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|BINDING_TYPE
argument_list|(
name|old
argument_list|)
condition|)
name|BINDING_TYPE
argument_list|(
name|old
argument_list|)
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&&
name|BINDING_TYPE
argument_list|(
name|old
argument_list|)
operator|!=
name|type
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' denotes an ambiguous type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  first type here"
argument_list|,
name|BINDING_TYPE
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  other type here"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* Add the bindings of name in used namespaces to val.    The using list is defined by usings, and the lookup goes to scope.    Returns zero on errors. */
end_comment

begin_function
name|int
name|lookup_using_namespace
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|,
name|usings
parameter_list|,
name|scope
parameter_list|,
name|flags
parameter_list|)
name|tree
name|name
decl_stmt|,
name|val
decl_stmt|,
name|usings
decl_stmt|,
name|scope
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|iter
decl_stmt|;
name|tree
name|val1
decl_stmt|;
comment|/* Iterate over all used namespaces in current, searching for using      directives of scope. */
for|for
control|(
name|iter
operator|=
name|usings
init|;
name|iter
condition|;
name|iter
operator|=
name|TREE_CHAIN
argument_list|(
name|iter
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|iter
argument_list|)
operator|==
name|scope
condition|)
block|{
name|val1
operator|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|iter
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve ambiguities. */
name|val
operator|=
name|ambiguous_decl
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|val1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|val
operator|!=
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* [namespace.qual]    Excepts the name to lookup and its qualifying scope.    Returns the name/type pair found into the CPLUS_BINDING result,    or 0 on error. */
end_comment

begin_function
name|int
name|qualified_lookup_using_namespace
parameter_list|(
name|name
parameter_list|,
name|scope
parameter_list|,
name|result
parameter_list|,
name|flags
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* Maintain a list of namespaces visited... */
name|tree
name|seen
init|=
name|NULL_TREE
decl_stmt|;
comment|/* ... and a list of namespace yet to see. */
name|tree
name|todo
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|usings
decl_stmt|;
while|while
condition|(
name|scope
operator|&&
operator|(
name|result
operator|!=
name|error_mark_node
operator|)
condition|)
block|{
name|seen
operator|=
name|temp_tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|seen
argument_list|)
expr_stmt|;
name|result
operator|=
name|ambiguous_decl
argument_list|(
name|name
argument_list|,
name|result
argument_list|,
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|scope
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|BINDING_TYPE
argument_list|(
name|result
argument_list|)
condition|)
comment|/* Consider using directives. */
for|for
control|(
name|usings
operator|=
name|DECL_NAMESPACE_USING
argument_list|(
name|scope
argument_list|)
init|;
name|usings
condition|;
name|usings
operator|=
name|TREE_CHAIN
argument_list|(
name|usings
argument_list|)
control|)
comment|/* If this was a real directive, and we have not seen it. */
if|if
condition|(
operator|!
name|TREE_INDIRECT_USING
argument_list|(
name|usings
argument_list|)
operator|&&
operator|!
name|purpose_member
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|seen
argument_list|)
condition|)
name|todo
operator|=
name|temp_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|usings
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|todo
argument_list|)
expr_stmt|;
if|if
condition|(
name|todo
condition|)
block|{
name|scope
operator|=
name|TREE_PURPOSE
argument_list|(
name|todo
argument_list|)
expr_stmt|;
name|todo
operator|=
name|TREE_CHAIN
argument_list|(
name|todo
argument_list|)
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there never was a todo list. */
block|}
return|return
name|result
operator|!=
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* [namespace.memdef]/2 */
end_comment

begin_comment
comment|/* Set the context of a declaration to scope. Complain if we are not    outside scope. */
end_comment

begin_function
name|void
name|set_decl_namespace
parameter_list|(
name|decl
parameter_list|,
name|scope
parameter_list|,
name|friendp
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|int
name|friendp
decl_stmt|;
block|{
name|tree
name|old
decl_stmt|;
if|if
condition|(
name|scope
operator|==
name|std_node
condition|)
name|scope
operator|=
name|global_namespace
expr_stmt|;
comment|/* Get rid of namespace aliases. */
name|scope
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* It is ok for friends to be qualified in parallel space.  */
if|if
condition|(
operator|!
name|friendp
operator|&&
operator|!
name|is_namespace_ancestor
argument_list|(
name|current_namespace
argument_list|,
name|scope
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"declaration of `%D' not in a namespace surrounding `%D'"
argument_list|,
name|decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|!=
name|current_namespace
condition|)
block|{
comment|/* See whether this has been declared in the namespace. */
name|old
operator|=
name|namespace_binding
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
comment|/* No old declaration at all. */
goto|goto
name|complain
goto|;
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Don't compare non-function decls with decls_match here, 	   since it can't check for the correct constness at this 	   point. pushdecl will find those errors later.  */
return|return;
comment|/* Since decl is a function, old should contain a function decl. */
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|old
argument_list|)
condition|)
goto|goto
name|complain
goto|;
if|if
condition|(
name|processing_template_decl
operator|||
name|processing_specialization
condition|)
comment|/* We have not yet called push_template_decl to turn the 	   FUNCTION_DECL into a TEMPLATE_DECL, so the declarations 	   won't match.  But, we'll check later, when we construct the 	   template.  */
return|return;
for|for
control|(
init|;
name|old
condition|;
name|old
operator|=
name|OVL_NEXT
argument_list|(
name|old
argument_list|)
control|)
if|if
condition|(
name|decls_match
argument_list|(
name|decl
argument_list|,
name|OVL_CURRENT
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
return|return;
block|}
else|else
return|return;
name|complain
label|:
name|cp_error
argument_list|(
literal|"`%D' should have been declared inside `%D'"
argument_list|,
name|decl
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the namespace where a declaration is defined. */
end_comment

begin_function
specifier|static
name|tree
name|decl_namespace
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
while|while
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|decl
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|decl
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|390
argument_list|)
expr_stmt|;
block|}
return|return
name|global_namespace
return|;
block|}
end_function

begin_comment
comment|/* Return the namespace where the current declaration is declared. */
end_comment

begin_function
name|tree
name|current_decl_namespace
parameter_list|()
block|{
name|tree
name|result
decl_stmt|;
comment|/* If we have been pushed into a different namespace, use it. */
if|if
condition|(
name|decl_namespace_list
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|decl_namespace_list
argument_list|)
return|;
if|if
condition|(
name|current_class_type
condition|)
name|result
operator|=
name|decl_namespace
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
condition|)
name|result
operator|=
name|decl_namespace
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|current_namespace
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Temporarily set the namespace for the current declaration. */
end_comment

begin_function
name|void
name|push_decl_namespace
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
name|decl
operator|=
name|decl_namespace
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl_namespace_list
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|decl_namespace_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_decl_namespace
parameter_list|()
block|{
name|decl_namespace_list
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_namespace_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a class or namespace scope. */
end_comment

begin_function
name|void
name|push_scope
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|push_decl_namespace
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|pushclass
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Leave scope pushed by push_scope. */
end_comment

begin_function
name|void
name|pop_scope
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
else|else
name|popclass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [basic.lookup.koenig] */
end_comment

begin_comment
comment|/* A non-zero return value in the functions below indicates an error.    All nodes allocated in the procedure are on the scratch obstack. */
end_comment

begin_struct
struct|struct
name|arg_lookup
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|namespaces
decl_stmt|;
name|tree
name|classes
decl_stmt|;
name|tree
name|functions
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|arg_assoc
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_lookup
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arg_assoc_args
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_lookup
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arg_assoc_type
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_lookup
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_function
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_lookup
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arg_assoc_namespace
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_lookup
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arg_assoc_class
name|PROTO
argument_list|(
operator|(
expr|struct
name|arg_lookup
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a function to the lookup structure.    Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|add_function
parameter_list|(
name|k
parameter_list|,
name|fn
parameter_list|)
name|struct
name|arg_lookup
modifier|*
name|k
decl_stmt|;
name|tree
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|ovl_member
argument_list|(
name|fn
argument_list|,
name|k
operator|->
name|functions
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We must find only functions, or exactly one non-function. */
if|if
condition|(
name|k
operator|->
name|functions
operator|&&
name|is_overloaded_fn
argument_list|(
name|k
operator|->
name|functions
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|k
operator|->
name|functions
operator|=
name|build_overload
argument_list|(
name|fn
argument_list|,
name|k
operator|->
name|functions
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|functions
condition|)
block|{
name|tree
name|f1
init|=
name|OVL_CURRENT
argument_list|(
name|k
operator|->
name|functions
argument_list|)
decl_stmt|;
name|tree
name|f2
init|=
name|fn
decl_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|f1
argument_list|)
condition|)
block|{
name|fn
operator|=
name|f1
expr_stmt|;
name|f1
operator|=
name|f2
expr_stmt|;
name|f2
operator|=
name|fn
expr_stmt|;
block|}
name|cp_error_at
argument_list|(
literal|"`%D' is not a function,"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  conflict with `%D'"
argument_list|,
name|f2
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"  in call to `%D'"
argument_list|,
name|k
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|k
operator|->
name|functions
operator|=
name|fn
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add functions of a namespace to the lookup structure.    Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|arg_assoc_namespace
parameter_list|(
name|k
parameter_list|,
name|scope
parameter_list|)
name|struct
name|arg_lookup
modifier|*
name|k
decl_stmt|;
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|purpose_member
argument_list|(
name|scope
argument_list|,
name|k
operator|->
name|namespaces
argument_list|)
condition|)
return|return
literal|0
return|;
name|k
operator|->
name|namespaces
operator|=
name|tree_cons
argument_list|(
name|scope
argument_list|,
name|NULL_TREE
argument_list|,
name|k
operator|->
name|namespaces
argument_list|)
expr_stmt|;
name|value
operator|=
name|namespace_binding
argument_list|(
name|k
operator|->
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|value
condition|;
name|value
operator|=
name|OVL_NEXT
argument_list|(
name|value
argument_list|)
control|)
if|if
condition|(
name|add_function
argument_list|(
name|k
argument_list|,
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with class to the lookup structure.    Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|arg_assoc_class
parameter_list|(
name|k
parameter_list|,
name|type
parameter_list|)
name|struct
name|arg_lookup
modifier|*
name|k
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|list
decl_stmt|,
name|friends
decl_stmt|,
name|context
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|purpose_member
argument_list|(
name|type
argument_list|,
name|k
operator|->
name|classes
argument_list|)
condition|)
return|return
literal|0
return|;
name|k
operator|->
name|classes
operator|=
name|tree_cons
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|k
operator|->
name|classes
argument_list|)
expr_stmt|;
name|context
operator|=
name|decl_namespace
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|context
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Process baseclasses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Process friends. */
for|for
control|(
name|list
operator|=
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
if|if
condition|(
name|k
operator|->
name|name
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
for|for
control|(
name|friends
operator|=
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
init|;
name|friends
condition|;
name|friends
operator|=
name|TREE_CHAIN
argument_list|(
name|friends
argument_list|)
control|)
comment|/* Only interested in global functions with potentially hidden            (i.e. unqualified) declarations. */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
operator|==
name|error_mark_node
operator|&&
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
operator|&&
name|decl_namespace
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
name|context
condition|)
if|if
condition|(
name|add_function
argument_list|(
name|k
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Process template arguments.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|list
operator|=
name|innermost_args
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|list
argument_list|)
condition|;
operator|++
name|i
control|)
name|arg_assoc
argument_list|(
name|k
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a given type.    Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|arg_assoc_type
parameter_list|(
name|k
parameter_list|,
name|type
parameter_list|)
name|struct
name|arg_lookup
modifier|*
name|k
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
literal|0
return|;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|type
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|decl_namespace
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
comment|/* Pointer to member: associate class type and value type. */
if|if
condition|(
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|METHOD_TYPE
case|:
comment|/* The basetype is referenced in the first arg type, so just 	 fall through.  */
case|case
name|FUNCTION_TYPE
case|:
comment|/* Associate the parameter types. */
if|if
condition|(
name|arg_assoc_args
argument_list|(
name|k
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Associate the return type. */
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
return|return
literal|0
return|;
case|case
name|LANG_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|unknown_type_node
condition|)
return|return
literal|0
return|;
comment|/* else fall through */
default|default:
name|my_friendly_abort
argument_list|(
literal|390
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with arguments.  Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|arg_assoc_args
parameter_list|(
name|k
parameter_list|,
name|args
parameter_list|)
name|struct
name|arg_lookup
modifier|*
name|k
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
if|if
condition|(
name|arg_assoc
argument_list|(
name|k
argument_list|,
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Adds everything associated with a given tree_node.  Returns 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|arg_assoc
parameter_list|(
name|k
parameter_list|,
name|n
parameter_list|)
name|struct
name|arg_lookup
modifier|*
name|k
decl_stmt|;
name|tree
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
operator|!
name|type_unknown_p
argument_list|(
name|n
argument_list|)
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|n
operator|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|n
operator|=
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* [basic.lookup.koenig]  	 If T is a template-id, its associated namespaces and classes 	 are the namespace in which the template is defined; for 	 member templates, the member template's class; the namespaces 	 and classes associated with the types of the template 	 arguments provided for template type parameters (excluding 	 template template parameters); the namespaces in which any 	 template template arguments are defined; and the classes in 	 which any member templates used as template template 	 arguments are defined.  [Note: non-type template arguments do 	 not contribute to the set of associated namespaces.  ]   */
name|tree
name|template
init|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|tree
name|arg
decl_stmt|;
comment|/* First, the template.  There may actually be more than one if 	 this is an overloaded function template.  But, in that case, 	 we only need the first; all the functions will be in the same 	 namespace.  */
name|template
operator|=
name|OVL_CURRENT
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
block|}
comment|/* It must be a member template.  */
elseif|else
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* Now the arguments.  */
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL_TREE
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|ctx
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|arg_assoc_namespace
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|arg_assoc_class
argument_list|(
name|k
argument_list|,
name|ctx
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|&&
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|t
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|n
argument_list|)
operator|==
name|OVERLOAD
argument_list|,
literal|980715
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|OVL_CHAIN
argument_list|(
name|n
argument_list|)
control|)
if|if
condition|(
name|arg_assoc_type
argument_list|(
name|k
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Performs Koenig lookup depending on arguments, where fns    are the functions found in normal lookup. */
end_comment

begin_function
name|tree
name|lookup_arg_dependent
parameter_list|(
name|name
parameter_list|,
name|fns
parameter_list|,
name|args
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|struct
name|arg_lookup
name|k
decl_stmt|;
name|k
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|k
operator|.
name|functions
operator|=
name|fns
expr_stmt|;
name|k
operator|.
name|classes
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Note that we've already looked at the current namespace during normal      unqualified lookup, unless we found a decl in function scope.  */
if|if
condition|(
name|fns
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
condition|)
name|k
operator|.
name|namespaces
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|k
operator|.
name|namespaces
operator|=
name|scratch_tree_cons
argument_list|(
name|current_decl_namespace
argument_list|()
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|push_scratch_obstack
argument_list|()
expr_stmt|;
name|arg_assoc_args
argument_list|(
operator|&
name|k
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|k
operator|.
name|functions
return|;
block|}
end_function

begin_comment
comment|/* Process a namespace-alias declaration. */
end_comment

begin_function
name|void
name|do_namespace_alias
parameter_list|(
name|alias
parameter_list|,
name|namespace
parameter_list|)
name|tree
name|alias
decl_stmt|,
name|namespace
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
comment|/* The parser did not find it, so it's not there. */
name|cp_error
argument_list|(
literal|"unknown namespace `%D'"
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return;
block|}
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
comment|/* Build the alias. */
name|alias
operator|=
name|build_lang_decl
argument_list|(
name|NAMESPACE_DECL
argument_list|,
name|alias
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_NAMESPACE_ALIAS
argument_list|(
name|alias
argument_list|)
operator|=
name|namespace
expr_stmt|;
name|pushdecl
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a non-member using-declaration. Return the name and scope    being used, and the USING_DECL, or NULL_TREE on failure. */
end_comment

begin_function
specifier|static
name|tree
name|validate_nonmember_using_decl
parameter_list|(
name|decl
parameter_list|,
name|scope
parameter_list|,
name|name
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
modifier|*
name|scope
decl_stmt|;
name|tree
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|==
name|std_node
condition|)
block|{
if|if
condition|(
name|namespace_bindings_p
argument_list|()
operator|&&
name|current_namespace
operator|==
name|global_namespace
condition|)
comment|/* There's no need for a using declaration at all, here, 	   since `std' is the same as `::'.  We can't just pass this 	   on because we'll complain later about declaring something 	   in the same scope as a using declaration with the same 	   name.  We return NULL_TREE which indicates to the caller 	   that there's no need to do any further processing.  */
return|return
name|NULL_TREE
return|;
operator|*
name|scope
operator|=
name|global_namespace
expr_stmt|;
operator|*
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
operator|*
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* [namespace.udecl]  	 A using-declaration for a class member shall be a 	 member-declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|scope
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"`%T' is not a namespace"
argument_list|,
operator|*
name|scope
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"`%D' is not a namespace"
argument_list|,
operator|*
name|scope
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
operator|*
name|scope
operator|=
name|global_namespace
expr_stmt|;
operator|*
name|name
operator|=
name|decl
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|382
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|name
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
operator|*
name|name
operator|=
name|DECL_NAME
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
comment|/* Make a USING_DECL. */
return|return
name|push_using_decl
argument_list|(
operator|*
name|scope
argument_list|,
operator|*
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process local and global using-declarations. */
end_comment

begin_function
specifier|static
name|void
name|do_nonmember_using_decl
parameter_list|(
name|scope
parameter_list|,
name|name
parameter_list|,
name|oldval
parameter_list|,
name|oldtype
parameter_list|,
name|newval
parameter_list|,
name|newtype
parameter_list|)
name|tree
name|scope
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|;
name|tree
modifier|*
name|newval
decl_stmt|,
decl|*
name|newtype
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|decls
decl_stmt|;
name|struct
name|tree_binding
name|_decls
decl_stmt|;
operator|*
name|newval
operator|=
operator|*
name|newtype
operator|=
name|NULL_TREE
expr_stmt|;
name|decls
operator|=
name|binding_init
argument_list|(
operator|&
name|_decls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
name|decls
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* Lookup error */
return|return;
if|if
condition|(
operator|!
name|BINDING_VALUE
argument_list|(
name|decls
argument_list|)
operator|&&
operator|!
name|BINDING_TYPE
argument_list|(
name|decls
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' not declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for using functions. */
if|if
condition|(
name|BINDING_VALUE
argument_list|(
name|decls
argument_list|)
operator|&&
name|is_overloaded_fn
argument_list|(
name|BINDING_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|;
if|if
condition|(
name|oldval
operator|&&
operator|!
name|is_overloaded_fn
argument_list|(
name|oldval
argument_list|)
condition|)
block|{
name|duplicate_decls
argument_list|(
name|OVL_CURRENT
argument_list|(
name|BINDING_VALUE
argument_list|(
name|decls
argument_list|)
argument_list|)
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|*
name|newval
operator|=
name|oldval
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|BINDING_VALUE
argument_list|(
name|decls
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|OVL_NEXT
argument_list|(
name|tmp
argument_list|)
control|)
block|{
name|tree
name|new_fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
comment|/* [namespace.udecl]  	     If a function declaration in namespace scope or block 	     scope has the same name and the same parameter types as a 	     function introduced by a using declaration the program is 	     ill-formed.  */
for|for
control|(
name|tmp1
operator|=
name|oldval
init|;
name|tmp1
condition|;
name|tmp1
operator|=
name|OVL_NEXT
argument_list|(
name|tmp1
argument_list|)
control|)
block|{
name|tree
name|old_fn
init|=
name|OVL_CURRENT
argument_list|(
name|tmp1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|OVL_USED
argument_list|(
name|tmp1
argument_list|)
operator|&&
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_fn
argument_list|)
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_fn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* There was already a non-using declaration in 		     this scope with the same parameter types.  */
name|cp_error
argument_list|(
literal|"`%D' is already declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|duplicate_decls
argument_list|(
name|new_fn
argument_list|,
name|old_fn
argument_list|)
condition|)
comment|/* We're re-using something we already used  		   before.  We don't need to add it again.  */
break|break;
block|}
comment|/* If we broke out of the loop, there's no reason to add 	     this function to the using declarations for this 	     scope.  */
if|if
condition|(
name|tmp1
condition|)
continue|continue;
operator|*
name|newval
operator|=
name|build_overload
argument_list|(
name|OVL_CURRENT
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|*
name|newval
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|newval
argument_list|)
operator|!=
name|OVERLOAD
condition|)
operator|*
name|newval
operator|=
name|ovl_cons
argument_list|(
operator|*
name|newval
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|OVL_USED
argument_list|(
operator|*
name|newval
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|newval
operator|=
name|BINDING_VALUE
argument_list|(
name|decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldval
condition|)
name|duplicate_decls
argument_list|(
operator|*
name|newval
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
block|}
operator|*
name|newtype
operator|=
name|BINDING_TYPE
argument_list|(
name|decls
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtype
operator|&&
operator|*
name|newtype
operator|&&
name|oldtype
operator|!=
operator|*
name|newtype
condition|)
block|{
name|cp_error
argument_list|(
literal|"using directive `%D' introduced ambiguous type `%T'"
argument_list|,
name|name
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/* Process a using-declaration not appearing in class or local scope. */
end_comment

begin_function
name|void
name|do_toplevel_using_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|scope
decl_stmt|,
name|name
decl_stmt|,
name|binding
decl_stmt|;
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|,
name|newval
decl_stmt|,
name|newtype
decl_stmt|;
name|decl
operator|=
name|validate_nonmember_using_decl
argument_list|(
name|decl
argument_list|,
operator|&
name|scope
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
name|binding
operator|=
name|binding_for_name
argument_list|(
name|name
argument_list|,
name|current_namespace
argument_list|)
expr_stmt|;
name|oldval
operator|=
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|oldtype
operator|=
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|do_nonmember_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|oldval
argument_list|,
name|oldtype
argument_list|,
operator|&
name|newval
argument_list|,
operator|&
name|newtype
argument_list|)
expr_stmt|;
comment|/* Copy declarations found. */
if|if
condition|(
name|newval
condition|)
name|BINDING_VALUE
argument_list|(
name|binding
argument_list|)
operator|=
name|newval
expr_stmt|;
if|if
condition|(
name|newtype
condition|)
name|BINDING_TYPE
argument_list|(
name|binding
argument_list|)
operator|=
name|newtype
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Process a using-declaration at function scope.  */
end_comment

begin_function
name|void
name|do_local_using_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|scope
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|oldval
decl_stmt|,
name|oldtype
decl_stmt|,
name|newval
decl_stmt|,
name|newtype
decl_stmt|;
name|decl
operator|=
name|validate_nonmember_using_decl
argument_list|(
name|decl
argument_list|,
operator|&
name|scope
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
name|oldval
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|oldtype
operator|=
name|lookup_type_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|do_nonmember_using_decl
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|oldval
argument_list|,
name|oldtype
argument_list|,
operator|&
name|newval
argument_list|,
operator|&
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|newval
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|,
name|term
decl_stmt|;
comment|/* We only need to push declarations for those functions 	     that were not already bound in the current level. 	     The old value might be NULL_TREE, it might be a single 	     function, or an OVERLOAD.  */
if|if
condition|(
name|oldval
operator|&&
name|TREE_CODE
argument_list|(
name|oldval
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|term
operator|=
name|OVL_FUNCTION
argument_list|(
name|oldval
argument_list|)
expr_stmt|;
else|else
name|term
operator|=
name|oldval
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|newval
init|;
name|fn
operator|&&
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
operator|!=
name|term
condition|;
name|fn
operator|=
name|OVL_NEXT
argument_list|(
name|fn
argument_list|)
control|)
name|push_overloaded_decl
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|PUSH_LOCAL
operator||
name|PUSH_USING
argument_list|)
expr_stmt|;
block|}
else|else
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|newval
argument_list|,
name|PUSH_USING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newtype
condition|)
name|set_identifier_type_value
argument_list|(
name|name
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|do_class_using_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|SCOPE_REF
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
block|{
name|cp_error
argument_list|(
literal|"using-declaration for non-member at class scope"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|cp_error
argument_list|(
literal|"using-declaration for destructor"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|980716
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_lang_field_decl
argument_list|(
name|USING_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Process a using-directive. */
end_comment

begin_function
name|void
name|do_using_directive
parameter_list|(
name|namespace
parameter_list|)
name|tree
name|namespace
decl_stmt|;
block|{
if|if
condition|(
name|namespace
operator|==
name|std_node
condition|)
return|return;
comment|/* using namespace A::B::C; */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|namespace
operator|=
name|TREE_OPERAND
argument_list|(
name|namespace
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Lookup in lexer did not find a namespace. */
name|cp_error
argument_list|(
literal|"namespace `%T' undeclared"
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|namespace
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%T' is not a namespace"
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
return|return;
block|}
name|namespace
operator|=
name|ORIGINAL_NAMESPACE
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel_bindings_p
argument_list|()
condition|)
name|push_using_directive
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
else|else
comment|/* direct usage */
name|add_using_namespace
argument_list|(
name|current_namespace
argument_list|,
name|namespace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|check_default_args
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|arg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|saw_def
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
operator|-
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
decl_stmt|;
for|for
control|(
init|;
name|arg
operator|&&
name|arg
operator|!=
name|void_list_node
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
condition|)
name|saw_def
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|saw_def
condition|)
block|{
name|cp_error_at
argument_list|(
literal|"default argument missing for parameter %P of `%+#D'"
argument_list|,
name|i
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|mark_used
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
return|return;
name|assemble_external
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Is it a synthesized method that needs to be synthesized?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
comment|/* Kludge: don't synthesize for default args.  */
operator|&&
name|current_function_decl
condition|)
name|synthesize_method
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If this is a function or variable that is an instance of some      template, we now know that we will need to actually do the      instantiation.  A TEMPLATE_DECL may also have DECL_TEMPLATE_INFO,      if it's a partial instantiation, but there's no need to      instantiate such a thing.  We check that DECL is not an explicit      instantiation because that is not checked in instantiate_decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for named_class_head_sans_basetype nonterminal.  We    have just seen something of the form `AGGR SCOPE::ID'.  Return a    TYPE_DECL for the type declared by ID in SCOPE.  */
end_comment

begin_function
name|tree
name|handle_class_head
parameter_list|(
name|aggr
parameter_list|,
name|scope
parameter_list|,
name|id
parameter_list|)
name|tree
name|aggr
decl_stmt|,
name|scope
decl_stmt|,
name|id
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|decl
operator|=
name|id
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|id
argument_list|)
condition|)
name|decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|id
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|scope
condition|)
name|cp_error
argument_list|(
literal|"`%T' does not have a nested type named `%D'"
argument_list|,
name|scope
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"no file-scope type named `%D'"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|xref_tag
argument_list|(
name|aggr
argument_list|,
name|make_anon_name
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This syntax is only allowed when we're defining a type, so we      enter the SCOPE.  */
name|push_scope
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we see something like:         template<typename T> struct S::I ....              we must create a TEMPLATE_DECL for the nested type.  */
if|if
condition|(
name|PROCESSING_REAL_TEMPLATE_DECL_P
argument_list|()
condition|)
name|decl
operator|=
name|push_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

end_unit

