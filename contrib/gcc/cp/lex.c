begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Separate lexical analyzer for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is the lexical analyzer for GNU C++.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_function_decl
specifier|static
name|int
name|interface_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_cp_pragma
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|parse_strconst_pragma
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_vtable
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_unit
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_interface
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_implementation
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_java_exceptions
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_operators
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_lang_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A constraint that can be tested at compile time.  */
end_comment

begin_define
define|#
directive|define
name|CONSTRAINT
parameter_list|(
name|name
parameter_list|,
name|expr
parameter_list|)
value|extern int constraint_##name [(expr) ? 1 : -1]
end_define

begin_comment
comment|/* Functions and data structures for #pragma interface.     `#pragma implementation' means that the main file being compiled    is considered to implement (provide) the classes that appear in    its main body.  I.e., if this is file "foo.cc", and class `bar'    is defined in "foo.cc", then we say that "foo.cc implements bar".     All main input files "implement" themselves automagically.     `#pragma interface' means that unless this file (of the form "foo.h"    is not presently being included by file "foo.cc", the    CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none    of the vtables nor any of the inline functions defined in foo.h    will ever be output.     There are cases when we want to link files such as "defs.h" and    "main.cc".  In this case, we give "defs.h" a `#pragma interface',    and "main.cc" has `#pragma implementation "defs.h"'.  */
end_comment

begin_struct
struct|struct
name|impl_files
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|impl_files
modifier|*
name|impl_file_chain
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|cxx_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|c_common_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A mapping from tree codes to operator name information.  */
end_comment

begin_decl_stmt
name|operator_name_info_t
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but for assignment operators.  */
end_comment

begin_decl_stmt
name|operator_name_info_t
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data structures that keep track of operator names.  */
end_comment

begin_define
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|C
parameter_list|,
name|M
parameter_list|,
name|AR
parameter_list|,
name|AP
parameter_list|)
define|\
value|CONSTRAINT (C, sizeof "operator " + sizeof NAME<= 256);
end_define

begin_include
include|#
directive|include
file|"operators.def"
end_include

begin_undef
undef|#
directive|undef
name|DEF_OPERATOR
end_undef

begin_function
specifier|static
name|void
name|init_operators
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|operator_name_info_t
modifier|*
name|oni
decl_stmt|;
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|MANGLING
parameter_list|,
name|ARITY
parameter_list|,
name|ASSN_P
parameter_list|)
define|\
value|sprintf (buffer, ISALPHA (NAME[0]) ? "operator %s" : "operator%s", NAME); \   identifier = get_identifier (buffer);					    \   IDENTIFIER_OPNAME_P (identifier) = 1;					    \ 									    \   oni = (ASSN_P								    \ 	 ?&assignment_operator_name_info[(int) CODE]			    \ 	 :&operator_name_info[(int) CODE]);				    \   oni->identifier = identifier;						    \   oni->name = NAME;							    \   oni->mangled_name = MANGLING;						    \   oni->arity = ARITY;
include|#
directive|include
file|"operators.def"
undef|#
directive|undef
name|DEF_OPERATOR
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ERROR_MARK
index|]
operator|.
name|identifier
operator|=
name|get_identifier
argument_list|(
literal|"<invalid operator>"
argument_list|)
expr_stmt|;
comment|/* Handle some special cases.  These operators are not defined in      the language, but can be produced internally.  We may need them      for error-reporting.  (Eventually, we should ensure that this      does not happen.  Error messages involving these operators will      be confusing to users.)  */
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|INIT_EXPR
index|]
operator|.
name|name
operator|=
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|.
name|name
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ABS_EXPR
index|]
operator|.
name|name
operator|=
literal|"abs"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TRUTH_AND_EXPR
index|]
operator|.
name|name
operator|=
literal|"strict&&"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TRUTH_OR_EXPR
index|]
operator|.
name|name
operator|=
literal|"strict ||"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|RANGE_EXPR
index|]
operator|.
name|name
operator|=
literal|"..."
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|UNARY_PLUS_EXPR
index|]
operator|.
name|name
operator|=
literal|"+"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(exact /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling %=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor %=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round %=)"
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The reserved keyword table.  */
end_comment

begin_struct
struct|struct
name|resword
block|{
specifier|const
name|char
modifier|*
specifier|const
name|word
decl_stmt|;
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
specifier|const
name|rid
operator|:
literal|16
expr_stmt|;
specifier|const
name|unsigned
name|int
name|disable
range|:
literal|16
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Disable mask.  Keywords are disabled if (reswords[i].disable& mask) is    _true_.  */
end_comment

begin_define
define|#
directive|define
name|D_EXT
value|0x01
end_define

begin_comment
comment|/* GCC extension */
end_comment

begin_define
define|#
directive|define
name|D_ASM
value|0x02
end_define

begin_comment
comment|/* in C99, but has a switch to turn it off */
end_comment

begin_define
define|#
directive|define
name|D_OBJC
value|0x04
end_define

begin_comment
comment|/* Objective C++ only */
end_comment

begin_expr_stmt
name|CONSTRAINT
argument_list|(
name|ridbits_fit
argument_list|,
name|RID_LAST_MODIFIER
operator|<
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
name|CHAR_BIT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|resword
name|reswords
index|[]
init|=
block|{
block|{
literal|"_Complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__FUNCTION__"
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__PRETTY_FUNCTION__"
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof__"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__asm"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__asm__"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute__"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_offsetof"
block|,
name|RID_OFFSETOF
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_va_arg"
block|,
name|RID_VA_ARG
block|,
literal|0
block|}
block|,
block|{
literal|"__complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__complex__"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__const__"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__extension__"
block|,
name|RID_EXTENSION
block|,
literal|0
block|}
block|,
block|{
literal|"__func__"
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__imag"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__imag__"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__inline__"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__label__"
block|,
name|RID_LABEL
block|,
literal|0
block|}
block|,
block|{
literal|"__null"
block|,
name|RID_NULL
block|,
literal|0
block|}
block|,
block|{
literal|"__real"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__real__"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict__"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__signed__"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__thread"
block|,
name|RID_THREAD
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof__"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile__"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"asm"
block|,
name|RID_ASM
block|,
name|D_ASM
block|}
block|,
block|{
literal|"auto"
block|,
name|RID_AUTO
block|,
literal|0
block|}
block|,
block|{
literal|"bool"
block|,
name|RID_BOOL
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|RID_BREAK
block|,
literal|0
block|}
block|,
block|{
literal|"case"
block|,
name|RID_CASE
block|,
literal|0
block|}
block|,
block|{
literal|"catch"
block|,
name|RID_CATCH
block|,
literal|0
block|}
block|,
block|{
literal|"char"
block|,
name|RID_CHAR
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
name|RID_CLASS
block|,
literal|0
block|}
block|,
block|{
literal|"const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"const_cast"
block|,
name|RID_CONSTCAST
block|,
literal|0
block|}
block|,
block|{
literal|"continue"
block|,
name|RID_CONTINUE
block|,
literal|0
block|}
block|,
block|{
literal|"default"
block|,
name|RID_DEFAULT
block|,
literal|0
block|}
block|,
block|{
literal|"delete"
block|,
name|RID_DELETE
block|,
literal|0
block|}
block|,
block|{
literal|"do"
block|,
name|RID_DO
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
name|RID_DOUBLE
block|,
literal|0
block|}
block|,
block|{
literal|"dynamic_cast"
block|,
name|RID_DYNCAST
block|,
literal|0
block|}
block|,
block|{
literal|"else"
block|,
name|RID_ELSE
block|,
literal|0
block|}
block|,
block|{
literal|"enum"
block|,
name|RID_ENUM
block|,
literal|0
block|}
block|,
block|{
literal|"explicit"
block|,
name|RID_EXPLICIT
block|,
literal|0
block|}
block|,
block|{
literal|"export"
block|,
name|RID_EXPORT
block|,
literal|0
block|}
block|,
block|{
literal|"extern"
block|,
name|RID_EXTERN
block|,
literal|0
block|}
block|,
block|{
literal|"false"
block|,
name|RID_FALSE
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|RID_FLOAT
block|,
literal|0
block|}
block|,
block|{
literal|"for"
block|,
name|RID_FOR
block|,
literal|0
block|}
block|,
block|{
literal|"friend"
block|,
name|RID_FRIEND
block|,
literal|0
block|}
block|,
block|{
literal|"goto"
block|,
name|RID_GOTO
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
name|RID_IF
block|,
literal|0
block|}
block|,
block|{
literal|"inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|RID_INT
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|RID_LONG
block|,
literal|0
block|}
block|,
block|{
literal|"mutable"
block|,
name|RID_MUTABLE
block|,
literal|0
block|}
block|,
block|{
literal|"namespace"
block|,
name|RID_NAMESPACE
block|,
literal|0
block|}
block|,
block|{
literal|"new"
block|,
name|RID_NEW
block|,
literal|0
block|}
block|,
block|{
literal|"operator"
block|,
name|RID_OPERATOR
block|,
literal|0
block|}
block|,
block|{
literal|"private"
block|,
name|RID_PRIVATE
block|,
literal|0
block|}
block|,
block|{
literal|"protected"
block|,
name|RID_PROTECTED
block|,
literal|0
block|}
block|,
block|{
literal|"public"
block|,
name|RID_PUBLIC
block|,
literal|0
block|}
block|,
block|{
literal|"register"
block|,
name|RID_REGISTER
block|,
literal|0
block|}
block|,
block|{
literal|"reinterpret_cast"
block|,
name|RID_REINTCAST
block|,
literal|0
block|}
block|,
block|{
literal|"return"
block|,
name|RID_RETURN
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|RID_SHORT
block|,
literal|0
block|}
block|,
block|{
literal|"signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof"
block|,
name|RID_SIZEOF
block|,
literal|0
block|}
block|,
block|{
literal|"static"
block|,
name|RID_STATIC
block|,
literal|0
block|}
block|,
block|{
literal|"static_cast"
block|,
name|RID_STATCAST
block|,
literal|0
block|}
block|,
block|{
literal|"struct"
block|,
name|RID_STRUCT
block|,
literal|0
block|}
block|,
block|{
literal|"switch"
block|,
name|RID_SWITCH
block|,
literal|0
block|}
block|,
block|{
literal|"template"
block|,
name|RID_TEMPLATE
block|,
literal|0
block|}
block|,
block|{
literal|"this"
block|,
name|RID_THIS
block|,
literal|0
block|}
block|,
block|{
literal|"throw"
block|,
name|RID_THROW
block|,
literal|0
block|}
block|,
block|{
literal|"true"
block|,
name|RID_TRUE
block|,
literal|0
block|}
block|,
block|{
literal|"try"
block|,
name|RID_TRY
block|,
literal|0
block|}
block|,
block|{
literal|"typedef"
block|,
name|RID_TYPEDEF
block|,
literal|0
block|}
block|,
block|{
literal|"typename"
block|,
name|RID_TYPENAME
block|,
literal|0
block|}
block|,
block|{
literal|"typeid"
block|,
name|RID_TYPEID
block|,
literal|0
block|}
block|,
block|{
literal|"typeof"
block|,
name|RID_TYPEOF
block|,
name|D_ASM
operator||
name|D_EXT
block|}
block|,
block|{
literal|"union"
block|,
name|RID_UNION
block|,
literal|0
block|}
block|,
block|{
literal|"unsigned"
block|,
name|RID_UNSIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"using"
block|,
name|RID_USING
block|,
literal|0
block|}
block|,
block|{
literal|"virtual"
block|,
name|RID_VIRTUAL
block|,
literal|0
block|}
block|,
block|{
literal|"void"
block|,
name|RID_VOID
block|,
literal|0
block|}
block|,
block|{
literal|"volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"wchar_t"
block|,
name|RID_WCHAR
block|,
literal|0
block|}
block|,
block|{
literal|"while"
block|,
name|RID_WHILE
block|,
literal|0
block|}
block|,
comment|/* The remaining keywords are specific to Objective-C++.  NB:      All of them will remain _disabled_, since they are context-      sensitive.  */
comment|/* These ObjC keywords are recognized only immediately after      an '@'.  NB: The following C++ keywords double as      ObjC keywords in this context: RID_CLASS, RID_PRIVATE,      RID_PROTECTED, RID_PUBLIC, RID_THROW, RID_TRY and RID_CATCH.  */
block|{
literal|"compatibility_alias"
block|,
name|RID_AT_ALIAS
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"defs"
block|,
name|RID_AT_DEFS
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"encode"
block|,
name|RID_AT_ENCODE
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"end"
block|,
name|RID_AT_END
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"implementation"
block|,
name|RID_AT_IMPLEMENTATION
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"interface"
block|,
name|RID_AT_INTERFACE
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"protocol"
block|,
name|RID_AT_PROTOCOL
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"selector"
block|,
name|RID_AT_SELECTOR
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"finally"
block|,
name|RID_AT_FINALLY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"synchronized"
block|,
name|RID_AT_SYNCHRONIZED
block|,
name|D_OBJC
block|}
block|,
comment|/* These are recognized only in protocol-qualifier context.  */
block|{
literal|"bycopy"
block|,
name|RID_BYCOPY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"byref"
block|,
name|RID_BYREF
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"in"
block|,
name|RID_IN
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"inout"
block|,
name|RID_INOUT
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"oneway"
block|,
name|RID_ONEWAY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"out"
block|,
name|RID_OUT
block|,
name|D_OBJC
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_reswords
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|int
name|mask
init|=
operator|(
operator|(
name|flag_no_asm
condition|?
name|D_ASM
else|:
literal|0
operator|)
operator||
name|D_OBJC
operator||
operator|(
name|flag_no_gnu_keywords
condition|?
name|D_EXT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|ridpointers
operator|=
name|GGC_CNEWVEC
argument_list|(
name|tree
argument_list|,
operator|(
name|int
operator|)
name|RID_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reswords
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|get_identifier
argument_list|(
name|reswords
index|[
name|i
index|]
operator|.
name|word
argument_list|)
expr_stmt|;
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
operator|=
name|reswords
index|[
name|i
index|]
operator|.
name|rid
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|reswords
index|[
name|i
index|]
operator|.
name|rid
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reswords
index|[
name|i
index|]
operator|.
name|disable
operator|&
name|mask
operator|)
condition|)
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_cp_pragma
parameter_list|(
name|void
parameter_list|)
block|{
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"vtable"
argument_list|,
name|handle_pragma_vtable
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"unit"
argument_list|,
name|handle_pragma_unit
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"interface"
argument_list|,
name|handle_pragma_interface
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"implementation"
argument_list|,
name|handle_pragma_implementation
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"interface"
argument_list|,
name|handle_pragma_interface
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"implementation"
argument_list|,
name|handle_pragma_implementation
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"java_exceptions"
argument_list|,
name|handle_pragma_java_exceptions
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* TRUE if a code represents a statement.  */
end_comment

begin_decl_stmt
name|bool
name|statement_code_p
index|[
name|MAX_TREE_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the C++ front end.  This function is very sensitive to    the exact order that things are done here.  It would be nice if the    initialization done by this routine were moved to its subroutines,    and the ordering dependencies clarified and reduced.  */
end_comment

begin_function
name|bool
name|cxx_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|enum
name|tree_code
name|stmt_codes
index|[]
init|=
block|{
name|CTOR_INITIALIZER
block|,
name|TRY_BLOCK
block|,
name|HANDLER
block|,
name|EH_SPEC_BLOCK
block|,
name|USING_STMT
block|,
name|TAG_DEFN
block|,
name|IF_STMT
block|,
name|CLEANUP_STMT
block|,
name|FOR_STMT
block|,
name|WHILE_STMT
block|,
name|DO_STMT
block|,
name|BREAK_STMT
block|,
name|CONTINUE_STMT
block|,
name|SWITCH_STMT
block|,
name|EXPR_STMT
block|}
decl_stmt|;
name|memset
argument_list|(
operator|&
name|statement_code_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|statement_code_p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|stmt_codes
argument_list|)
condition|;
name|i
operator|++
control|)
name|statement_code_p
index|[
name|stmt_codes
index|[
name|i
index|]
index|]
operator|=
name|true
expr_stmt|;
comment|/* We cannot just assign to input_filename because it has already      been initialized and will be used later as an N_BINCL for stabs+      debugging.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|push_srcloc
argument_list|(
name|BUILTINS_LOCATION
argument_list|)
expr_stmt|;
else|#
directive|else
name|push_srcloc
argument_list|(
literal|"<built-in>"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_reswords
argument_list|()
expr_stmt|;
name|init_tree
argument_list|()
expr_stmt|;
name|init_cp_semantics
argument_list|()
expr_stmt|;
name|init_operators
argument_list|()
expr_stmt|;
name|init_method
argument_list|()
expr_stmt|;
name|init_error
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|class_type_node
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CLASS
index|]
expr_stmt|;
name|cxx_init_decl_processing
argument_list|()
expr_stmt|;
comment|/* The fact that G++ uses COMDAT for many entities (inline      functions, template instantiations, virtual tables, etc.) mean      that it is fundamentally unreliable to try to make decisions      about whether or not to output a particular entity until the end      of the compilation.  However, the inliner requires that functions      be provided to the back end if they are to be inlined.      Therefore, we always use unit-at-a-time mode; in that mode, we      can provide entities to the back end and it will decide what to      emit based on what is actually needed.  */
name|flag_unit_at_a_time
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c_common_init
argument_list|()
operator|==
name|false
condition|)
block|{
name|pop_srcloc
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|init_cp_pragma
argument_list|()
expr_stmt|;
name|init_repo
argument_list|()
expr_stmt|;
name|pop_srcloc
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if S is not considered part of an    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|interface_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* Set the interface/implementation bits for this scope.  */
name|struct
name|impl_files
modifier|*
name|ifiles
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
for|for
control|(
name|ifiles
operator|=
name|impl_file_chain
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|t1
init|=
name|ifiles
operator|->
name|filename
decl_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|t1
operator|||
operator|*
name|s1
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|)
name|s1
operator|++
operator|,
name|t1
operator|++
expr_stmt|;
comment|/* A match.  */
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
condition|)
return|return
literal|0
return|;
comment|/* Don't get faked out by xxx.yyy.cc vs xxx.zzz.cc.  */
if|if
condition|(
name|strchr
argument_list|(
name|s1
argument_list|,
literal|'.'
argument_list|)
operator|||
name|strchr
argument_list|(
name|t1
argument_list|,
literal|'.'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|||
name|s1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|t1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* A match.  */
return|return
literal|0
return|;
block|}
comment|/* No matches.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a #pragma whose sole argument is a string constant.    If OPT is true, the argument is optional.  */
end_comment

begin_function
specifier|static
name|tree
name|parse_strconst_pragma
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|tree
name|result
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
name|t
operator|=
name|pragma_lex
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CPP_STRING
condition|)
block|{
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"junk at end of #pragma %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|t
operator|==
name|CPP_EOF
operator|&&
name|opt
condition|)
return|return
name|NULL_TREE
return|;
name|error
argument_list|(
literal|"invalid #pragma %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_vtable
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|parse_strconst_pragma
argument_list|(
literal|"vtable"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sorry
argument_list|(
literal|"#pragma vtable no longer supported"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_unit
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Validate syntax, but don't do anything.  */
name|parse_strconst_pragma
argument_list|(
literal|"unit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_interface
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fname
init|=
name|parse_strconst_pragma
argument_list|(
literal|"interface"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|error_mark_node
condition|)
return|return;
elseif|else
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
name|filename
operator|=
name|lbasename
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
else|else
name|filename
operator|=
name|ggc_strdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
comment|/* If this is zero at this point, then we are 	 auto-implementing.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
block|}
name|finfo
operator|->
name|interface_only
operator|=
name|interface_strcmp
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* If MULTIPLE_SYMBOL_SPACES is set, we cannot assume that we can see      a definition in another file.  */
if|if
condition|(
operator|!
name|MULTIPLE_SYMBOL_SPACES
operator|||
operator|!
name|finfo
operator|->
name|interface_only
condition|)
name|finfo
operator|->
name|interface_unknown
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that we have seen a #pragma implementation for the key MAIN_FILENAME.    We used to only allow this at toplevel, but that restriction was buggy    in older compilers and it seems reasonable to allow it in the headers    themselves, too.  It only needs to precede the matching #p interface.     We don't touch finfo->interface_only or finfo->interface_unknown;    the user must specify a matching #p interface for this to have    any effect.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_implementation
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fname
init|=
name|parse_strconst_pragma
argument_list|(
literal|"implementation"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|main_input_filename
condition|)
name|filename
operator|=
name|main_input_filename
expr_stmt|;
else|else
name|filename
operator|=
name|input_filename
expr_stmt|;
name|filename
operator|=
name|lbasename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|ggc_strdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We currently cannot give this diagnostic, as we reach this point 	 only after cpplib has scanned the entire translation unit, so 	 cpp_included always returns true.  A plausible fix is to compare 	 the current source-location cookie with the first source-location 	 cookie (if any) of the filename, but this requires completing the 	 --enable-mapped-location project first.  See PR 17577.  */
block|if (cpp_included (parse_in, filename)) 	warning (0, "#pragma implementation for %qs appears after " 		 "file is included", filename);
endif|#
directive|endif
block|}
for|for
control|(
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifiles
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ifiles
operator|==
literal|0
condition|)
block|{
name|ifiles
operator|=
name|XNEW
argument_list|(
expr|struct
name|impl_files
argument_list|)
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|ifiles
operator|->
name|next
operator|=
name|impl_file_chain
expr_stmt|;
name|impl_file_chain
operator|=
name|ifiles
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Indicate that this file uses Java-personality exception handling.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_java_exceptions
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|pragma_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"junk at end of #pragma GCC java_exceptions"
argument_list|)
expr_stmt|;
name|choose_personality_routine
argument_list|(
name|lang_java
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message indicating that the lookup of NAME (an    IDENTIFIER_NODE) failed.  Returns the ERROR_MARK_NODE.  */
end_comment

begin_function
name|tree
name|unqualified_name_lookup_error
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|!=
name|ansi_opname
argument_list|(
name|ERROR_MARK
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD not defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%qD was not declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Prevent repeated error messages by creating a VAR_DECL with 	 this NAME in the innermost block scope.  */
if|if
condition|(
name|current_function_decl
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|push_local_binding
argument_list|(
name|name
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark the variable as used so that we do not get warnings 	     about it being unused later.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like unqualified_name_lookup_error, but NAME is an unqualified-id    used as a function.  Returns an appropriate expression for    NAME.  */
end_comment

begin_function
name|tree
name|unqualified_fn_lookup_error
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* In a template, it is invalid to write "f()" or "f(3)" if no 	 declaration of "f" is available.  Historically, G++ and most 	 other compilers accepted that usage since they deferred all name 	 lookup until instantiation time rather than doing unqualified 	 name lookup at template definition time; explain to the user what 	 is going wrong.  	 Note that we have the exact wording of the following message in 	 the manual (trouble.texi, node "Name lookup"), so they need to 	 be kept in synch.  */
name|pedwarn
argument_list|(
literal|"there are no arguments to %qD that depend on a template "
literal|"parameter, so a declaration of %qD must be available"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_permissive
condition|)
block|{
specifier|static
name|bool
name|hint
decl_stmt|;
if|if
condition|(
operator|!
name|hint
condition|)
block|{
name|error
argument_list|(
literal|"(if you use %<-fpermissive%>, G++ will accept your "
literal|"code, but allowing the use of an undeclared name is "
literal|"deprecated)"
argument_list|)
expr_stmt|;
name|hint
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|name
return|;
block|}
return|return
name|unqualified_name_lookup_error
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_lang_decl
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retrofit_lang_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* All nesting of C++ functions is lexical; there is never a "static      chain" in the sense of GNU C nested functions.  */
if|if
condition|(
name|code
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Add DECL_LANG_SPECIFIC info to T.  Called from build_lang_decl    and pushdecl (for functions generated by the backend).  */
end_comment

begin_function
name|void
name|retrofit_lang_decl
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
name|ld
operator|=
name|GGC_CNEWVAR
argument_list|(
expr|struct
name|lang_decl
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|can_be_full
operator|=
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|u1sel
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|u2sel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|decl_flags
operator|.
name|can_be_full
condition|)
name|ld
operator|->
name|u
operator|.
name|f
operator|.
name|u3sel
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|ld
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|||
name|decl_linkage
argument_list|(
name|t
argument_list|)
operator|==
name|lk_none
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_java
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cxx_dup_lang_specific_decl
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|ld
operator|=
name|GGC_NEWVAR
argument_list|(
expr|struct
name|lang_decl
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ld
argument_list|,
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
name|ld
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy DECL, including any language-specific parts.  */
end_comment

begin_function
name|tree
name|copy_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Replace the shared language-specific parts of NODE with a new copy.  */
end_comment

begin_function
specifier|static
name|void
name|copy_lang_type
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|lt
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|->
name|u
operator|.
name|h
operator|.
name|is_lang_type_class
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type_ptrmem
argument_list|)
expr_stmt|;
name|lt
operator|=
name|GGC_NEWVAR
argument_list|(
expr|struct
name|lang_type
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lt
argument_list|,
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
name|lt
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy TYPE, including any language-specific parts.  */
end_comment

begin_function
name|tree
name|copy_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|copy_lang_type
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
name|tree
name|cxx_make_type
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* Create lang_type structure.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|struct
name|lang_type
modifier|*
name|pi
init|=
name|GGC_CNEW
argument_list|(
expr|struct
name|lang_type
argument_list|)
decl_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|pi
expr_stmt|;
name|pi
operator|->
name|u
operator|.
name|c
operator|.
name|h
operator|.
name|is_lang_type_class
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set up some flags that give proper default behavior.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|struct
name|c_fileinfo
modifier|*
name|finfo
init|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|finfo
operator|->
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|finfo
operator|->
name|interface_only
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|make_aggr_type
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|t
init|=
name|cxx_make_type
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we are currently in the main source file, or in a    template instantiation started from the main source file.  */
end_comment

begin_function
name|bool
name|in_main_input_context
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|tl
init|=
name|outermost_tinst_level
argument_list|()
decl_stmt|;
if|if
condition|(
name|tl
condition|)
return|return
name|strcmp
argument_list|(
name|main_input_filename
argument_list|,
name|LOCATION_FILE
argument_list|(
name|TINST_LOCATION
argument_list|(
name|tl
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
return|;
else|else
return|return
name|strcmp
argument_list|(
name|main_input_filename
argument_list|,
name|input_filename
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

end_unit

