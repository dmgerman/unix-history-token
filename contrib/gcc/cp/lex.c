begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Separate lexical analyzer for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is the lexical analyzer for GNU C++.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_function_decl
specifier|static
name|int
name|interface_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_cp_pragma
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|parse_strconst_pragma
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_vtable
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_unit
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_interface
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_implementation
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pragma_java_exceptions
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_operators
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_lang_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A constraint that can be tested at compile time.  */
end_comment

begin_define
define|#
directive|define
name|CONSTRAINT
parameter_list|(
name|name
parameter_list|,
name|expr
parameter_list|)
value|extern int constraint_##name [(expr) ? 1 : -1]
end_define

begin_comment
comment|/* Functions and data structures for #pragma interface.     `#pragma implementation' means that the main file being compiled    is considered to implement (provide) the classes that appear in    its main body.  I.e., if this is file "foo.cc", and class `bar'    is defined in "foo.cc", then we say that "foo.cc implements bar".     All main input files "implement" themselves automagically.     `#pragma interface' means that unless this file (of the form "foo.h"    is not presently being included by file "foo.cc", the    CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none    of the vtables nor any of the inline functions defined in foo.h    will ever be output.     There are cases when we want to link files such as "defs.h" and    "main.cc".  In this case, we give "defs.h" a `#pragma interface',    and "main.cc" has `#pragma implementation "defs.h"'.  */
end_comment

begin_struct
struct|struct
name|impl_files
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|impl_files
modifier|*
name|impl_file_chain
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    CV_QUALIFIERS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|tree
name|cv_qualifiers
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `*'"
argument_list|)
expr_stmt|;
name|target
operator|=
name|build_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a&.    TARGET is the absolute declarator that the& contains.    CV_QUALIFIERS is a list of modifiers such as const or volatile    to apply to the reference type, represented as identifiers.     We return an ADDR_EXPR whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_reference_declarator
parameter_list|(
name|tree
name|cv_qualifiers
parameter_list|,
name|tree
name|target
parameter_list|)
block|{
name|target
operator|=
name|build_nt
argument_list|(
name|ADDR_EXPR
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|tree
name|make_call_declarator
parameter_list|(
name|tree
name|target
parameter_list|,
name|tree
name|parms
parameter_list|,
name|tree
name|cv_qualifiers
parameter_list|,
name|tree
name|exception_specification
parameter_list|)
block|{
name|target
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|target
argument_list|,
name|tree_cons
argument_list|(
name|parms
argument_list|,
name|cv_qualifiers
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
comment|/* The third operand is really RTL.  We 			shouldn't put anything there.  */
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CALL_DECLARATOR_EXCEPTION_SPEC
argument_list|(
name|target
argument_list|)
operator|=
name|exception_specification
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|void
name|set_quals_and_spec
parameter_list|(
name|tree
name|call_declarator
parameter_list|,
name|tree
name|cv_qualifiers
parameter_list|,
name|tree
name|exception_specification
parameter_list|)
block|{
name|CALL_DECLARATOR_QUALS
argument_list|(
name|call_declarator
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
name|CALL_DECLARATOR_EXCEPTION_SPEC
argument_list|(
name|call_declarator
argument_list|)
operator|=
name|exception_specification
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|interface_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not current file is only for 				   interface definitions.  */
end_comment

begin_decl_stmt
name|int
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not we know this class 				   to behave according to #pragma interface.  */
end_comment

begin_escape
end_escape

begin_function
name|void
name|cxx_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|c_common_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A mapping from tree codes to operator name information.  */
end_comment

begin_decl_stmt
name|operator_name_info_t
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but for assignment operators.  */
end_comment

begin_decl_stmt
name|operator_name_info_t
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data structures that keep track of operator names.  */
end_comment

begin_define
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|C
parameter_list|,
name|M
parameter_list|,
name|AR
parameter_list|,
name|AP
parameter_list|)
define|\
value|CONSTRAINT (C, sizeof "operator " + sizeof NAME<= 256);
end_define

begin_include
include|#
directive|include
file|"operators.def"
end_include

begin_undef
undef|#
directive|undef
name|DEF_OPERATOR
end_undef

begin_function
specifier|static
name|void
name|init_operators
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|identifier
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|operator_name_info_t
modifier|*
name|oni
decl_stmt|;
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|MANGLING
parameter_list|,
name|ARITY
parameter_list|,
name|ASSN_P
parameter_list|)
define|\
value|sprintf (buffer, ISALPHA (NAME[0]) ? "operator %s" : "operator%s", NAME); \   identifier = get_identifier (buffer);					    \   IDENTIFIER_OPNAME_P (identifier) = 1;					    \ 									    \   oni = (ASSN_P								    \ 	 ?&assignment_operator_name_info[(int) CODE]			    \ 	 :&operator_name_info[(int) CODE]);				    \   oni->identifier = identifier;						    \   oni->name = NAME;							    \   oni->mangled_name = MANGLING;                                             \   oni->arity = ARITY;
include|#
directive|include
file|"operators.def"
undef|#
directive|undef
name|DEF_OPERATOR
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ERROR_MARK
index|]
operator|.
name|identifier
operator|=
name|get_identifier
argument_list|(
literal|"<invalid operator>"
argument_list|)
expr_stmt|;
comment|/* Handle some special cases.  These operators are not defined in      the language, but can be produced internally.  We may need them      for error-reporting.  (Eventually, we should ensure that this      does not happen.  Error messages involving these operators will      be confusing to users.)  */
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|INIT_EXPR
index|]
operator|.
name|name
operator|=
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|.
name|name
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ABS_EXPR
index|]
operator|.
name|name
operator|=
literal|"abs"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TRUTH_AND_EXPR
index|]
operator|.
name|name
operator|=
literal|"strict&&"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TRUTH_OR_EXPR
index|]
operator|.
name|name
operator|=
literal|"strict ||"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|IN_EXPR
index|]
operator|.
name|name
operator|=
literal|"in"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|RANGE_EXPR
index|]
operator|.
name|name
operator|=
literal|"..."
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|.
name|name
operator|=
literal|"+"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(exact /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling %=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor %=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round %=)"
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The reserved keyword table.  */
end_comment

begin_struct
struct|struct
name|resword
block|{
specifier|const
name|char
modifier|*
specifier|const
name|word
decl_stmt|;
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
specifier|const
name|rid
operator|:
literal|16
expr_stmt|;
specifier|const
name|unsigned
name|int
name|disable
range|:
literal|16
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Disable mask.  Keywords are disabled if (reswords[i].disable& mask) is    _true_.  */
end_comment

begin_define
define|#
directive|define
name|D_EXT
value|0x01
end_define

begin_comment
comment|/* GCC extension */
end_comment

begin_define
define|#
directive|define
name|D_ASM
value|0x02
end_define

begin_comment
comment|/* in C99, but has a switch to turn it off */
end_comment

begin_expr_stmt
name|CONSTRAINT
argument_list|(
name|ridbits_fit
argument_list|,
name|RID_LAST_MODIFIER
operator|<
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
name|CHAR_BIT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|resword
name|reswords
index|[]
init|=
block|{
block|{
literal|"_Complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__FUNCTION__"
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__PRETTY_FUNCTION__"
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof__"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__asm"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__asm__"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute__"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_va_arg"
block|,
name|RID_VA_ARG
block|,
literal|0
block|}
block|,
block|{
literal|"__complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__complex__"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__const__"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__extension__"
block|,
name|RID_EXTENSION
block|,
literal|0
block|}
block|,
block|{
literal|"__func__"
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__imag"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__imag__"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__inline__"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__label__"
block|,
name|RID_LABEL
block|,
literal|0
block|}
block|,
block|{
literal|"__null"
block|,
name|RID_NULL
block|,
literal|0
block|}
block|,
block|{
literal|"__offsetof"
block|,
name|RID_OFFSETOF
block|,
literal|0
block|}
block|,
block|{
literal|"__offsetof__"
block|,
name|RID_OFFSETOF
block|,
literal|0
block|}
block|,
block|{
literal|"__real"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__real__"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict__"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__signed__"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__thread"
block|,
name|RID_THREAD
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof__"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile__"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"asm"
block|,
name|RID_ASM
block|,
name|D_ASM
block|}
block|,
block|{
literal|"auto"
block|,
name|RID_AUTO
block|,
literal|0
block|}
block|,
block|{
literal|"bool"
block|,
name|RID_BOOL
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|RID_BREAK
block|,
literal|0
block|}
block|,
block|{
literal|"case"
block|,
name|RID_CASE
block|,
literal|0
block|}
block|,
block|{
literal|"catch"
block|,
name|RID_CATCH
block|,
literal|0
block|}
block|,
block|{
literal|"char"
block|,
name|RID_CHAR
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
name|RID_CLASS
block|,
literal|0
block|}
block|,
block|{
literal|"const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"const_cast"
block|,
name|RID_CONSTCAST
block|,
literal|0
block|}
block|,
block|{
literal|"continue"
block|,
name|RID_CONTINUE
block|,
literal|0
block|}
block|,
block|{
literal|"default"
block|,
name|RID_DEFAULT
block|,
literal|0
block|}
block|,
block|{
literal|"delete"
block|,
name|RID_DELETE
block|,
literal|0
block|}
block|,
block|{
literal|"do"
block|,
name|RID_DO
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
name|RID_DOUBLE
block|,
literal|0
block|}
block|,
block|{
literal|"dynamic_cast"
block|,
name|RID_DYNCAST
block|,
literal|0
block|}
block|,
block|{
literal|"else"
block|,
name|RID_ELSE
block|,
literal|0
block|}
block|,
block|{
literal|"enum"
block|,
name|RID_ENUM
block|,
literal|0
block|}
block|,
block|{
literal|"explicit"
block|,
name|RID_EXPLICIT
block|,
literal|0
block|}
block|,
block|{
literal|"export"
block|,
name|RID_EXPORT
block|,
literal|0
block|}
block|,
block|{
literal|"extern"
block|,
name|RID_EXTERN
block|,
literal|0
block|}
block|,
block|{
literal|"false"
block|,
name|RID_FALSE
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|RID_FLOAT
block|,
literal|0
block|}
block|,
block|{
literal|"for"
block|,
name|RID_FOR
block|,
literal|0
block|}
block|,
block|{
literal|"friend"
block|,
name|RID_FRIEND
block|,
literal|0
block|}
block|,
block|{
literal|"goto"
block|,
name|RID_GOTO
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
name|RID_IF
block|,
literal|0
block|}
block|,
block|{
literal|"inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|RID_INT
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|RID_LONG
block|,
literal|0
block|}
block|,
block|{
literal|"mutable"
block|,
name|RID_MUTABLE
block|,
literal|0
block|}
block|,
block|{
literal|"namespace"
block|,
name|RID_NAMESPACE
block|,
literal|0
block|}
block|,
block|{
literal|"new"
block|,
name|RID_NEW
block|,
literal|0
block|}
block|,
block|{
literal|"operator"
block|,
name|RID_OPERATOR
block|,
literal|0
block|}
block|,
block|{
literal|"private"
block|,
name|RID_PRIVATE
block|,
literal|0
block|}
block|,
block|{
literal|"protected"
block|,
name|RID_PROTECTED
block|,
literal|0
block|}
block|,
block|{
literal|"public"
block|,
name|RID_PUBLIC
block|,
literal|0
block|}
block|,
block|{
literal|"register"
block|,
name|RID_REGISTER
block|,
literal|0
block|}
block|,
block|{
literal|"reinterpret_cast"
block|,
name|RID_REINTCAST
block|,
literal|0
block|}
block|,
block|{
literal|"return"
block|,
name|RID_RETURN
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|RID_SHORT
block|,
literal|0
block|}
block|,
block|{
literal|"signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof"
block|,
name|RID_SIZEOF
block|,
literal|0
block|}
block|,
block|{
literal|"static"
block|,
name|RID_STATIC
block|,
literal|0
block|}
block|,
block|{
literal|"static_cast"
block|,
name|RID_STATCAST
block|,
literal|0
block|}
block|,
block|{
literal|"struct"
block|,
name|RID_STRUCT
block|,
literal|0
block|}
block|,
block|{
literal|"switch"
block|,
name|RID_SWITCH
block|,
literal|0
block|}
block|,
block|{
literal|"template"
block|,
name|RID_TEMPLATE
block|,
literal|0
block|}
block|,
block|{
literal|"this"
block|,
name|RID_THIS
block|,
literal|0
block|}
block|,
block|{
literal|"throw"
block|,
name|RID_THROW
block|,
literal|0
block|}
block|,
block|{
literal|"true"
block|,
name|RID_TRUE
block|,
literal|0
block|}
block|,
block|{
literal|"try"
block|,
name|RID_TRY
block|,
literal|0
block|}
block|,
block|{
literal|"typedef"
block|,
name|RID_TYPEDEF
block|,
literal|0
block|}
block|,
block|{
literal|"typename"
block|,
name|RID_TYPENAME
block|,
literal|0
block|}
block|,
block|{
literal|"typeid"
block|,
name|RID_TYPEID
block|,
literal|0
block|}
block|,
block|{
literal|"typeof"
block|,
name|RID_TYPEOF
block|,
name|D_ASM
operator||
name|D_EXT
block|}
block|,
block|{
literal|"union"
block|,
name|RID_UNION
block|,
literal|0
block|}
block|,
block|{
literal|"unsigned"
block|,
name|RID_UNSIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"using"
block|,
name|RID_USING
block|,
literal|0
block|}
block|,
block|{
literal|"virtual"
block|,
name|RID_VIRTUAL
block|,
literal|0
block|}
block|,
block|{
literal|"void"
block|,
name|RID_VOID
block|,
literal|0
block|}
block|,
block|{
literal|"volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"wchar_t"
block|,
name|RID_WCHAR
block|,
literal|0
block|}
block|,
block|{
literal|"while"
block|,
name|RID_WHILE
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_reswords
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|int
name|mask
init|=
operator|(
operator|(
name|flag_no_asm
condition|?
name|D_ASM
else|:
literal|0
operator|)
operator||
operator|(
name|flag_no_gnu_keywords
condition|?
name|D_EXT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|ridpointers
operator|=
name|ggc_calloc
argument_list|(
operator|(
name|int
operator|)
name|RID_MAX
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reswords
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|get_identifier
argument_list|(
name|reswords
index|[
name|i
index|]
operator|.
name|word
argument_list|)
expr_stmt|;
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
operator|=
name|reswords
index|[
name|i
index|]
operator|.
name|rid
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|reswords
index|[
name|i
index|]
operator|.
name|rid
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reswords
index|[
name|i
index|]
operator|.
name|disable
operator|&
name|mask
operator|)
condition|)
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_cp_pragma
parameter_list|(
name|void
parameter_list|)
block|{
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"vtable"
argument_list|,
name|handle_pragma_vtable
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"unit"
argument_list|,
name|handle_pragma_unit
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"interface"
argument_list|,
name|handle_pragma_interface
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|0
argument_list|,
literal|"implementation"
argument_list|,
name|handle_pragma_implementation
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"interface"
argument_list|,
name|handle_pragma_interface
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"implementation"
argument_list|,
name|handle_pragma_implementation
argument_list|)
expr_stmt|;
name|c_register_pragma
argument_list|(
literal|"GCC"
argument_list|,
literal|"java_exceptions"
argument_list|,
name|handle_pragma_java_exceptions
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the C++ front end.  This function is very sensitive to    the exact order that things are done here.  It would be nice if the    initialization done by this routine were moved to its subroutines,    and the ordering dependencies clarified and reduced.  */
end_comment

begin_function
name|bool
name|cxx_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|enum
name|tree_code
name|stmt_codes
index|[]
init|=
block|{
name|c_common_stmt_codes
block|,
name|cp_stmt_codes
block|}
decl_stmt|;
name|INIT_STATEMENT_CODES
argument_list|(
name|stmt_codes
argument_list|)
expr_stmt|;
comment|/* We cannot just assign to input_filename because it has already      been initialized and will be used later as an N_BINCL for stabs+      debugging.  */
name|push_srcloc
argument_list|(
literal|"<internal>"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_reswords
argument_list|()
expr_stmt|;
name|init_tree
argument_list|()
expr_stmt|;
name|init_cp_semantics
argument_list|()
expr_stmt|;
name|init_operators
argument_list|()
expr_stmt|;
name|init_method
argument_list|()
expr_stmt|;
name|init_error
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|class_type_node
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CLASS
index|]
expr_stmt|;
name|cxx_init_decl_processing
argument_list|()
expr_stmt|;
comment|/* Create the built-in __null node.  */
name|null_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_node
argument_list|)
operator|=
name|c_common_type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ridpointers
index|[
name|RID_NULL
index|]
operator|=
name|null_node
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c_common_init
argument_list|()
operator|==
name|false
condition|)
block|{
name|pop_srcloc
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
name|init_cp_pragma
argument_list|()
expr_stmt|;
name|init_repo
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|pop_srcloc
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function to load global variables with interface    information.  */
end_comment

begin_function
name|void
name|extract_interface_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_fileinfo
modifier|*
name|finfo
decl_stmt|;
name|finfo
operator|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|finfo
operator|->
name|interface_only
expr_stmt|;
name|interface_unknown
operator|=
name|finfo
operator|->
name|interface_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if S is not considered part of an    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|interface_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* Set the interface/implementation bits for this scope.  */
name|struct
name|impl_files
modifier|*
name|ifiles
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
for|for
control|(
name|ifiles
operator|=
name|impl_file_chain
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|t1
init|=
name|ifiles
operator|->
name|filename
decl_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|t1
operator|||
operator|*
name|s1
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|)
name|s1
operator|++
operator|,
name|t1
operator|++
expr_stmt|;
comment|/* A match.  */
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
condition|)
return|return
literal|0
return|;
comment|/* Don't get faked out by xxx.yyy.cc vs xxx.zzz.cc.  */
if|if
condition|(
name|strchr
argument_list|(
name|s1
argument_list|,
literal|'.'
argument_list|)
operator|||
name|strchr
argument_list|(
name|t1
argument_list|,
literal|'.'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|||
name|s1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|t1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* A match.  */
return|return
literal|0
return|;
block|}
comment|/* No matches.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a #pragma whose sole argument is a string constant.    If OPT is true, the argument is optional.  */
end_comment

begin_function
specifier|static
name|tree
name|parse_strconst_pragma
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|tree
name|result
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CPP_STRING
condition|)
block|{
name|result
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|t
operator|==
name|CPP_EOF
operator|&&
name|opt
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|"invalid #pragma %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_vtable
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|parse_strconst_pragma
argument_list|(
literal|"vtable"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sorry
argument_list|(
literal|"#pragma vtable no longer supported"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_unit
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Validate syntax, but don't do anything.  */
name|parse_strconst_pragma
argument_list|(
literal|"unit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_interface
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fname
init|=
name|parse_strconst_pragma
argument_list|(
literal|"interface"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|main_filename
decl_stmt|;
if|if
condition|(
name|fname
operator|==
operator|(
name|tree
operator|)
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
name|main_filename
operator|=
name|lbasename
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
else|else
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|finfo
operator|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
comment|/* If this is zero at this point, then we are 	 auto-implementing.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
block|}
name|interface_only
operator|=
name|interface_strcmp
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIPLE_SYMBOL_SPACES
if|if
condition|(
operator|!
name|interface_only
condition|)
endif|#
directive|endif
name|interface_unknown
operator|=
literal|0
expr_stmt|;
name|finfo
operator|->
name|interface_only
operator|=
name|interface_only
expr_stmt|;
name|finfo
operator|->
name|interface_unknown
operator|=
name|interface_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that we have seen a #pragma implementation for the key MAIN_FILENAME.    We used to only allow this at toplevel, but that restriction was buggy    in older compilers and it seems reasonable to allow it in the headers    themselves, too.  It only needs to precede the matching #p interface.     We don't touch interface_only or interface_unknown; the user must specify    a matching #p interface for this to have any effect.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_implementation
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fname
init|=
name|parse_strconst_pragma
argument_list|(
literal|"implementation"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|main_filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
if|if
condition|(
name|fname
operator|==
operator|(
name|tree
operator|)
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|main_input_filename
condition|)
name|main_filename
operator|=
name|main_input_filename
expr_stmt|;
else|else
name|main_filename
operator|=
name|input_filename
expr_stmt|;
name|main_filename
operator|=
name|lbasename
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_included
argument_list|(
name|parse_in
argument_list|,
name|main_filename
argument_list|)
condition|)
name|warning
argument_list|(
literal|"#pragma implementation for %s appears after file is included"
argument_list|,
name|main_filename
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifiles
operator|->
name|filename
argument_list|,
name|main_filename
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ifiles
operator|==
literal|0
condition|)
block|{
name|ifiles
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|ifiles
operator|->
name|next
operator|=
name|impl_file_chain
expr_stmt|;
name|impl_file_chain
operator|=
name|ifiles
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Indicate that this file uses Java-personality exception handling.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_java_exceptions
parameter_list|(
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma GCC java_exceptions"
argument_list|)
expr_stmt|;
name|choose_personality_routine
argument_list|(
name|lang_java
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Issue an error message indicating that the lookup of NAME (an    IDENTIFIER_NODE) failed.  Returns the ERROR_MARK_NODE.  */
end_comment

begin_function
name|tree
name|unqualified_name_lookup_error
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|!=
name|ansi_opname
argument_list|(
name|ERROR_MARK
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%D' not defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"`%D' was not declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|error_mark_node
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
specifier|static
name|int
name|undeclared_variable_notice
decl_stmt|;
name|error
argument_list|(
literal|"`%D' undeclared (first use this function)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|undeclared_variable_notice
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once for each function it appears in.)"
argument_list|)
expr_stmt|;
name|undeclared_variable_notice
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Prevent repeated error messages.  */
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like unqualified_name_lookup_error, but NAME is an unqualified-id    used as a function.  Returns an appropriate expression for    NAME.  */
end_comment

begin_function
name|tree
name|unqualified_fn_lookup_error
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* In a template, it is invalid to write "f()" or "f(3)" if no 	 declaration of "f" is available.  Historically, G++ and most 	 other compilers accepted that usage since they deferred all name 	 lookup until instantiation time rather than doing unqualified 	 name lookup at template definition time; explain to the user what  	 is going wrong.  	 Note that we have the exact wording of the following message in 	 the manual (trouble.texi, node "Name lookup"), so they need to 	 be kept in synch.  */
name|pedwarn
argument_list|(
literal|"there are no arguments to `%D' that depend on a template "
literal|"parameter, so a declaration of `%D' must be available"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_permissive
condition|)
block|{
specifier|static
name|bool
name|hint
decl_stmt|;
if|if
condition|(
operator|!
name|hint
condition|)
block|{
name|error
argument_list|(
literal|"(if you use `-fpermissive', G++ will accept your code, "
literal|"but allowing the use of an undeclared name is "
literal|"deprecated)"
argument_list|)
expr_stmt|;
name|hint
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|name
return|;
block|}
return|return
name|unqualified_name_lookup_error
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_lang_decl
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retrofit_lang_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Add DECL_LANG_SPECIFIC info to T.  Called from build_lang_decl    and pushdecl (for functions generated by the backend).  */
end_comment

begin_function
name|void
name|retrofit_lang_decl
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ggc_alloc_cleared
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|can_be_full
operator|=
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|u1sel
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|u2sel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|decl_flags
operator|.
name|can_be_full
condition|)
name|ld
operator|->
name|u
operator|.
name|f
operator|.
name|u3sel
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|ld
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
operator|||
name|decl_linkage
argument_list|(
name|t
argument_list|)
operator|==
name|lk_none
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_java
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cxx_dup_lang_specific_decl
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ld
argument_list|,
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
name|ld
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy DECL, including any language-specific parts.  */
end_comment

begin_function
name|tree
name|copy_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Replace the shared language-specific parts of NODE with a new copy.  */
end_comment

begin_function
specifier|static
name|void
name|copy_lang_type
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|lt
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|->
name|u
operator|.
name|h
operator|.
name|is_lang_type_class
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type_ptrmem
argument_list|)
expr_stmt|;
name|lt
operator|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lt
argument_list|,
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
name|lt
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy TYPE, including any language-specific parts.  */
end_comment

begin_function
name|tree
name|copy_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|copy_lang_type
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
name|tree
name|cxx_make_type
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* Create lang_type structure.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|struct
name|lang_type
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|pi
expr_stmt|;
name|pi
operator|->
name|u
operator|.
name|c
operator|.
name|h
operator|.
name|is_lang_type_class
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set up some flags that give proper default behavior.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
comment|/* Make sure this is laid out, for ease of use later.  In the 	 presence of parse errors, the normal was of assuring this 	 might not ever get executed, so we lay it out *immediately*.  */
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,        TYPE_ALIAS_SET is initialized to -1 by default, so we must        clear it here.  */
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We need to allocate a TYPE_BINFO even for TEMPLATE_TYPE_PARMs      since they can be virtual base types, and we then need a      canonical binfo for them.  Ideally, this would be done lazily for      all types.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|TYPENAME_TYPE
condition|)
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|size_zero_node
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|make_aggr_type
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
name|tree
name|t
init|=
name|cxx_make_type
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the type-qualifier corresponding to the identifier given by    RID.  */
end_comment

begin_function
name|int
name|cp_type_qual_from_rid
parameter_list|(
name|tree
name|rid
parameter_list|)
block|{
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
return|return
name|TYPE_QUAL_CONST
return|;
elseif|else
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
return|return
name|TYPE_QUAL_VOLATILE
return|;
elseif|else
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
condition|)
return|return
name|TYPE_QUAL_RESTRICT
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|TYPE_UNQUALIFIED
return|;
block|}
end_function

end_unit

