begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Separate lexical analyzer for GNU C++.    Copyright (C) 1987, 89, 92-98, 1999 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is the lexical analyzer for GNU C++.  */
end_comment

begin_comment
comment|/* Cause the `yydebug' variable to be defined.  */
end_comment

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DIR_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|DIR_SEPARATOR
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|yyprint
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|YYSTYPE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|get_time_identifier
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_newline
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_white_space
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_defarg
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|my_get_run_time
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_last_nonwhite_on_line
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interface_strcmp
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readescape
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|extend_token_buffer
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|consume_string
name|PROTO
argument_list|(
operator|(
expr|struct
name|obstack
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_typedecl_interface_info
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|feed_defarg
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_vardecl_interface_info
name|PROTO
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_pending_inline
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|pending_inline
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reinit_parse_for_expr
name|PROTO
argument_list|(
operator|(
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|init_cpp_parse
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_cp_pragma
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|handle_generic_pragma
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|reduce_cmp
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|token_cmp
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|begin_definition_of_inclass_inline
name|PROTO
argument_list|(
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_float
name|PROTO
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_global
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_filename_times
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a file name X, return the nondirectory portion.    Keep in mind that X can be computed more than once.  */
end_comment

begin_function
name|char
modifier|*
name|file_name_nondirectory
parameter_list|(
name|x
parameter_list|)
specifier|const
name|char
modifier|*
name|x
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|x
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|DIR_SEPARATOR
operator|!=
literal|'/'
operator|&&
operator|!
name|tmp
condition|)
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|x
argument_list|,
name|DIR_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|tmp
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|char
operator|*
operator|)
name|x
return|;
block|}
end_function

begin_comment
comment|/* This obstack is needed to hold text.  It is not safe to use    TOKEN_BUFFER because `check_newline' calls `yylex'.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|inline_text_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inline_text_firstobj
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|USE_CPPLIB
end_if

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
specifier|extern
name|cpp_reader
name|parse_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|cpp_options
name|parse_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
modifier|*
name|yy_cur
decl_stmt|,
modifier|*
name|yy_lim
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|FILE
modifier|*
name|finput
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pending language change.    Positive is push count, negative is pop count.  */
end_comment

begin_decl_stmt
name|int
name|pending_lang_change
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wrap the current header file in extern "C".  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|c_header_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|first_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|token_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? Don't really know where this goes yet.  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_include
include|#
directive|include
file|"input.c"
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|put_back
parameter_list|(
comment|/* int */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|input_redirected
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|feed_input
parameter_list|(
comment|/* char *, int */
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Holds translations from TREE_CODEs to operator name strings,    i.e., opname_tab[PLUS_EXPR] == "+".  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|opname_tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|assignop_tab
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|YYLTYPE yylloc;
comment|/*  location data for the lookahead	*/
end_comment

begin_comment
comment|/*  symbol				*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes    for the reserved type names and storage classes.    It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may keep statistics about how long which files took to compile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_time
decl_stmt|,
name|body_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|filename_times
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|this_filename_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array for holding counts of the numbers of tokens seen.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    CV_QUALIFIERS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|cv_qualifiers
parameter_list|,
name|target
parameter_list|)
name|tree
name|cv_qualifiers
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `*'"
argument_list|)
expr_stmt|;
name|target
operator|=
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a&.    TARGET is the absolute declarator that the& contains.    CV_QUALIFIERS is a list of modifiers such as const or volatile    to apply to the reference type, represented as identifiers.     We return an ADDR_EXPR whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_reference_declarator
parameter_list|(
name|cv_qualifiers
parameter_list|,
name|target
parameter_list|)
name|tree
name|cv_qualifiers
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare pointers to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `&'"
argument_list|)
expr_stmt|;
block|}
name|target
operator|=
name|build_parse_node
argument_list|(
name|ADDR_EXPR
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|tree
name|make_call_declarator
parameter_list|(
name|target
parameter_list|,
name|parms
parameter_list|,
name|cv_qualifiers
parameter_list|,
name|exception_specification
parameter_list|)
name|tree
name|target
decl_stmt|,
name|parms
decl_stmt|,
name|cv_qualifiers
decl_stmt|,
name|exception_specification
decl_stmt|;
block|{
name|target
operator|=
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|target
argument_list|,
name|parms
argument_list|,
name|cv_qualifiers
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|exception_specification
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|void
name|set_quals_and_spec
parameter_list|(
name|call_declarator
parameter_list|,
name|cv_qualifiers
parameter_list|,
name|exception_specification
parameter_list|)
name|tree
name|call_declarator
decl_stmt|,
name|cv_qualifiers
decl_stmt|,
name|exception_specification
decl_stmt|;
block|{
name|TREE_OPERAND
argument_list|(
name|call_declarator
argument_list|,
literal|2
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|call_declarator
argument_list|)
operator|=
name|exception_specification
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build names and nodes for overloaded operators.  */
end_comment

begin_decl_stmt
name|tree
name|ansi_opname
index|[
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ansi_assopname
index|[
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|operator_name_string
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|opname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|+
literal|2
decl_stmt|;
name|tree
modifier|*
name|opname_table
decl_stmt|;
name|int
name|i
decl_stmt|,
name|assign
decl_stmt|;
comment|/* Works for builtin and user defined types.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
name|opname
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
name|opname
index|[
literal|2
index|]
operator|!=
literal|'_'
condition|)
block|{
name|opname
operator|+=
literal|1
expr_stmt|;
name|assign
operator|=
literal|1
expr_stmt|;
name|opname_table
operator|=
name|ansi_assopname
expr_stmt|;
block|}
else|else
block|{
name|assign
operator|=
literal|0
expr_stmt|;
name|opname_table
operator|=
name|ansi_opname
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
name|IDENTIFIER_POINTER
argument_list|(
name|opname_table
index|[
name|i
index|]
argument_list|)
index|[
literal|2
operator|+
name|assign
index|]
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
name|IDENTIFIER_POINTER
argument_list|(
name|opname_table
index|[
name|i
index|]
argument_list|)
index|[
literal|3
operator|+
name|assign
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|LAST_CPLUS_TREE_CODE
condition|)
return|return
literal|"<invalid operator>"
return|;
if|if
condition|(
name|assign
condition|)
return|return
name|assignop_tab
index|[
name|i
index|]
return|;
else|else
return|return
name|opname_tab
index|[
name|i
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|interface_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not current file is only for 				   interface definitions.  */
end_comment

begin_decl_stmt
name|int
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not we know this class 				   to behave according to #pragma interface.  */
end_comment

begin_comment
comment|/* lexical analyzer */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_TYPE_SIZE
end_ifdef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
specifier|static
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nominal length of token buffer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to token buffer. 				   Actual allocated length is maxtoken + 2.  */
end_comment

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Nonzero tells yylex to ignore \ in string constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_escape_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|get_time_identifier
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|time_identifier
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"file "
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|buf
operator|+
literal|5
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|time_identifier
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIME_IDENTIFIER_TIME
argument_list|(
name|time_identifier
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|TIME_IDENTIFIER_TIME
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TIME_IDENTIFIER_FILEINFO
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|time_identifier
argument_list|,
name|filename_times
argument_list|)
expr_stmt|;
name|filename_times
operator|=
name|time_identifier
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|time_identifier
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
specifier|static
name|int
name|my_get_run_time
parameter_list|()
block|{
name|int
name|old_quiet_flag
init|=
name|quiet_flag
decl_stmt|;
name|int
name|this_time
decl_stmt|;
name|quiet_flag
operator|=
literal|0
expr_stmt|;
name|this_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|quiet_flag
operator|=
name|old_quiet_flag
expr_stmt|;
return|return
name|this_time
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r,<, 1 and 2.  See cp/cp-tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
name|cplus_tree_code_type
index|[]
init|=
block|{
literal|'x'
block|,
include|#
directive|include
file|"cp-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|cplus_tree_code_length
index|[]
init|=
block|{
literal|0
block|,
include|#
directive|include
file|"cp-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|cplus_tree_code_name
index|[]
init|=
block|{
literal|"@@dummy"
block|,
include|#
directive|include
file|"cp-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_escape
end_escape

begin_comment
comment|/* toplev.c needs to call these.  */
end_comment

begin_function
name|void
name|lang_init_options
parameter_list|()
block|{
if|#
directive|if
name|USE_CPPLIB
name|cpp_reader_init
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
name|parse_in
operator|.
name|opts
operator|=
operator|&
name|parse_options
expr_stmt|;
name|cpp_options_init
argument_list|(
operator|&
name|parse_options
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Default exceptions on.  */
name|flag_exceptions
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_init
parameter_list|()
block|{
comment|/* the beginning of the file is a new line; check for # */
comment|/* With luck, we discover the real source file's name from that      and put it in input_filename.  */
if|#
directive|if
operator|!
name|USE_CPPLIB
name|put_back
argument_list|(
name|check_newline
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|check_newline
argument_list|()
expr_stmt|;
name|yy_cur
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_gnu_xref
condition|)
name|GNU_xref_begin
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|init_repo
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_finish
parameter_list|()
block|{
specifier|extern
name|int
name|errorcount
decl_stmt|,
name|sorrycount
decl_stmt|;
if|if
condition|(
name|flag_gnu_xref
condition|)
name|GNU_xref_end
argument_list|(
name|errorcount
operator|+
name|sorrycount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|lang_identify
parameter_list|()
block|{
return|return
literal|"cplusplus"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_filename_times
parameter_list|()
block|{
name|this_filename_time
operator|=
name|get_time_identifier
argument_list|(
literal|"<top level>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|header_time
operator|=
literal|0
expr_stmt|;
name|body_time
operator|=
name|my_get_run_time
argument_list|()
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|TIME_IDENTIFIER_TIME
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|=
name|body_time
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Change by Bryan Boreham, Kewill, Thu Jul 27 09:46:05 1989.    Stuck this hack in to get the files open correctly; this is called    in place of init_parse if we are an unexec'd binary.    */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void reinit_lang_specific () {   init_filename_times ();   reinit_search_statistics (); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
modifier|*
name|init_cpp_parse
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
name|reduce_count
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|REDUCE_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reduce_count
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|REDUCE_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|reduce_count
operator|+=
literal|1
expr_stmt|;
name|token_count
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|TOKEN_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|token_count
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|TOKEN_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|token_count
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|token_count
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|init_parse
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|extern
name|int
name|flag_no_gnu_keywords
decl_stmt|;
specifier|extern
name|int
name|flag_operator_names
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Change to the native locale for multibyte conversions.  */
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|literal_codeset
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_CPPLIB
name|parse_in
operator|.
name|show_column
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cpp_start_read
argument_list|(
operator|&
name|parse_in
argument_list|,
name|filename
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* cpp_start_read always puts at least one line directive into the      token buffer.  We must arrange to read it out here. */
name|yy_cur
operator|=
name|parse_in
operator|.
name|token_buffer
expr_stmt|;
name|yy_lim
operator|=
name|CPP_PWRITTEN
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Open input file.  */
if|if
condition|(
name|filename
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|finput
operator|=
name|stdin
expr_stmt|;
name|filename
operator|=
literal|"stdin"
expr_stmt|;
block|}
else|else
name|finput
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IO_BUFFER_SIZE
name|setvbuf
argument_list|(
name|finput
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|IO_BUFFER_SIZE
argument_list|)
argument_list|,
name|_IOFBF
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !USE_CPPLIB */
comment|/* Initialize the lookahead machinery.  */
name|init_spew
argument_list|()
expr_stmt|;
comment|/* Make identifier nodes long enough for the language-specific slots.  */
name|set_identifier_size
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|decl_printable_name
operator|=
name|lang_printable_name
expr_stmt|;
name|init_cplus_expand
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|cplus_tree_code_type
argument_list|,
name|tree_code_type
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cplus_tree_code_length
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_length
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cplus_tree_code_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_name
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|opname_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opname_tab
argument_list|,
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assignop_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assignop_tab
argument_list|,
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ansi_opname
index|[
literal|0
index|]
operator|=
name|get_identifier
argument_list|(
literal|"<invalid operator>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
block|{
name|ansi_opname
index|[
name|i
index|]
operator|=
name|ansi_opname
index|[
literal|0
index|]
expr_stmt|;
name|ansi_assopname
index|[
name|i
index|]
operator|=
name|ansi_opname
index|[
literal|0
index|]
expr_stmt|;
block|}
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ml"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aml"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__md"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__amd"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mi"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ami"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__rs"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ars"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ne"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__gt"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ge"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__or"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aor"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aa"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__nt"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__pp"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__as"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|NOP_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__cm"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__dv"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__adv"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__pl"
argument_list|)
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__apl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ls"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__als"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__eq"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__lt"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__le"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ad"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aad"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__er"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aer"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__oo"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__co"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mm"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__rf"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__rm"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__cl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__vc"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__nw"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__dl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__vn"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__vd"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This is not true: these operators are not defined in ANSI,      but we need them anyway.  */
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mn"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mx"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__cn"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|SIZEOF_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__sz"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|SIZEOF_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init_method
argument_list|()
expr_stmt|;
name|init_error
argument_list|()
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|inline_text_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start it at 0, because check_newline is called at the very beginning      and will increment it to 1.  */
name|lineno
operator|=
literal|0
expr_stmt|;
name|input_filename
operator|=
literal|"<internal>"
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|maxtoken
operator|=
literal|40
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BOOL
index|]
operator|=
name|get_identifier
argument_list|(
literal|"bool"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"float"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"short"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
operator|=
name|get_identifier
argument_list|(
literal|"long"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"unsigned"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|=
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__restrict"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|=
name|get_identifier
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"typedef"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|=
name|get_identifier
argument_list|(
literal|"register"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_COMPLEX
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__complex"
argument_list|)
expr_stmt|;
comment|/* C++ extensions. These are probably not correctly named.  */
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__wchar_t"
argument_list|)
expr_stmt|;
name|class_type_node
operator|=
name|build_int_2
argument_list|(
name|class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|class_type_node
argument_list|)
operator|=
name|class_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CLASS
index|]
operator|=
name|class_type_node
expr_stmt|;
name|record_type_node
operator|=
name|build_int_2
argument_list|(
name|record_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|record_type_node
argument_list|)
operator|=
name|record_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RECORD
index|]
operator|=
name|record_type_node
expr_stmt|;
name|union_type_node
operator|=
name|build_int_2
argument_list|(
name|union_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|union_type_node
argument_list|)
operator|=
name|union_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNION
index|]
operator|=
name|union_type_node
expr_stmt|;
name|enum_type_node
operator|=
name|build_int_2
argument_list|(
name|enum_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|enum_type_node
argument_list|)
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ENUM
index|]
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
operator|=
name|get_identifier
argument_list|(
literal|"virtual"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXPLICIT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"explicit"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXPORT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"export"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
operator|=
name|get_identifier
argument_list|(
literal|"friend"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PUBLIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"public"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PRIVATE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"private"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PROTECTED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"protected"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TEMPLATE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"template"
argument_list|)
expr_stmt|;
comment|/* This is for ANSI C++.  */
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_MUTABLE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"mutable"
argument_list|)
expr_stmt|;
comment|/* Signature handling extensions.  */
name|signature_type_node
operator|=
name|build_int_2
argument_list|(
name|signature_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|signature_type_node
argument_list|)
operator|=
name|signature_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNATURE
index|]
operator|=
name|signature_type_node
expr_stmt|;
comment|/* Create the built-in __null node.  Note that we can't yet call for      type_for_size here because integer_type_node and so forth are not      set up.  Therefore, we don't set the type of these nodes until      init_decl_processing.  */
name|null_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ridpointers
index|[
name|RID_NULL
index|]
operator|=
name|null_node
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|=
literal|"->"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
operator|=
literal|"->*"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
literal|"*"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
operator|=
literal|"[]"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|=
literal|"="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|=
literal|"new"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|=
literal|"delete"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
operator|=
literal|"new []"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
operator|=
literal|"delete []"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
operator|=
literal|"?:"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|=
literal|"()"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
literal|"+"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
literal|"-"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
literal|"*"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
literal|"/"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
literal|"(floor /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
literal|"(round /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
literal|"%"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
literal|"(ceiling %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
literal|"(floor %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
literal|"(round %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
literal|"-"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
literal|"<?"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
literal|">?"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ABS_EXPR
index|]
operator|=
literal|"abs"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FFS_EXPR
index|]
operator|=
literal|"ffs"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
literal|"<<"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
literal|">>"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
literal|"|"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
literal|"^"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
literal|"&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_ANDTC_EXPR
index|]
operator|=
literal|"&~"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|=
literal|"~"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
operator|=
literal|"&&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
operator|=
literal|"||"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_AND_EXPR
index|]
operator|=
literal|"strict&&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_OR_EXPR
index|]
operator|=
literal|"strict ||"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|=
literal|"!"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
operator|=
literal|"<"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
operator|=
literal|"<="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
operator|=
literal|">"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
operator|=
literal|">="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
operator|=
literal|"=="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
operator|=
literal|"!="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|IN_EXPR
index|]
operator|=
literal|"in"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|RANGE_EXPR
index|]
operator|=
literal|"..."
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
literal|"+"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
literal|"&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
operator|=
literal|"--"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
operator|=
literal|"++"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|=
literal|"--"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|=
literal|"++"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
operator|=
literal|","
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|NOP_EXPR
index|]
operator|=
literal|"="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
literal|"+="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
literal|"+="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
literal|"-="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
literal|"-="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
literal|"*="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
literal|"*="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
literal|"/="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|=
literal|"(exact /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
literal|"(ceiling /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
literal|"(floor /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
literal|"(round /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
literal|"%="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
literal|"(ceiling %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
literal|"(floor %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
literal|"(round %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
literal|"<?="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
literal|">?="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
literal|"<<="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
literal|">>="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
literal|"|="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
literal|"^="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
literal|"&="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
literal|"&="
expr_stmt|;
name|init_filename_times
argument_list|()
expr_stmt|;
comment|/* Some options inhibit certain reserved words.      Clear those words out of the hash table so they won't be recognized.  */
define|#
directive|define
name|UNSET_RESERVED_WORD
parameter_list|(
name|STRING
parameter_list|)
define|\
value|do { struct resword *s = is_reserved_word (STRING, sizeof (STRING) - 1); \        if (s) s->name = ""; } while (0)
if|#
directive|if
literal|0
comment|/* let's parse things, and if they use it, then give them an error.  */
block|if (!flag_exceptions)     {       UNSET_RESERVED_WORD ("throw");       UNSET_RESERVED_WORD ("try");       UNSET_RESERVED_WORD ("catch");     }
endif|#
directive|endif
if|if
condition|(
operator|!
name|flag_rtti
operator|||
name|flag_no_gnu_keywords
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"classof"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"headof"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_handle_signatures
operator|||
name|flag_no_gnu_keywords
condition|)
block|{
comment|/* Easiest way to not recognize signature 	 handling extensions...  */
name|UNSET_RESERVED_WORD
argument_list|(
literal|"signature"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"sigof"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_no_asm
operator|||
name|flag_no_gnu_keywords
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_operator_names
condition|)
block|{
comment|/* These are new ANSI keywords that may break code.  */
name|UNSET_RESERVED_WORD
argument_list|(
literal|"and"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"and_eq"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"bitand"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"bitor"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"compl"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"not"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"not_eq"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"or"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"or_eq"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"xor"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"xor_eq"
argument_list|)
expr_stmt|;
block|}
name|token_count
operator|=
name|init_cpp_parse
argument_list|()
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_function
name|void
name|finish_parse
parameter_list|()
block|{
if|#
directive|if
name|USE_CPPLIB
name|cpp_finish
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
else|#
directive|else
name|fclose
argument_list|(
name|finput
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|reinit_parse_for_function
parameter_list|()
block|{
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
name|void
name|yyprint
parameter_list|(
name|file
parameter_list|,
name|yychar
parameter_list|,
name|yylval
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|yychar
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|TYPESPEC
case|:
case|case
name|PTYPENAME
case|:
case|case
name|IDENTIFIER_DEFN
case|:
case|case
name|TYPENAME_DEFN
case|:
case|case
name|PTYPENAME_DEFN
case|:
case|case
name|SCSPEC
case|:
case|case
name|PRE_PARSED_CLASS_DECL
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|224
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGGR
case|:
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|class_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `class'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|record_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `struct'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|union_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `union'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|enum_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `enum'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|signature_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `signature'"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|80
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GATHER_STATISTICS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REDUCE_LENGTH
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reduce_count
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|REDUCE_LENGTH
value|(sizeof (yyr2) / sizeof (yyr2[0]))
end_define

begin_define
define|#
directive|define
name|TOKEN_LENGTH
value|(256 + sizeof (yytname) / sizeof (yytname[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
end_ifdef

begin_function
name|void
name|yyhook
parameter_list|(
name|yyn
parameter_list|)
name|int
name|yyn
decl_stmt|;
block|{
name|reduce_count
index|[
name|yyn
index|]
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|reduce_cmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
name|reduce_count
index|[
operator|*
name|q
index|]
operator|-
name|reduce_count
index|[
operator|*
name|p
index|]
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|token_cmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
name|token_count
index|[
operator|*
name|q
index|]
operator|-
name|token_count
index|[
operator|*
name|p
index|]
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_parse_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|int
name|i
decl_stmt|;
name|int
name|maxlen
init|=
name|REDUCE_LENGTH
decl_stmt|;
name|unsigned
modifier|*
name|sorted
decl_stmt|;
if|if
condition|(
name|reduce_count
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TOKEN_LENGTH
operator|>
name|REDUCE_LENGTH
condition|)
name|maxlen
operator|=
name|TOKEN_LENGTH
expr_stmt|;
name|sorted
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|maxlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKEN_LENGTH
condition|;
name|i
operator|++
control|)
name|sorted
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|TOKEN_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|token_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKEN_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token_count
index|[
name|idx
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|token_count
index|[
name|idx
index|]
operator|<
name|token_count
index|[
operator|-
literal|1
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"token %d, `%s', count = %d\n"
argument_list|,
name|idx
argument_list|,
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|idx
argument_list|)
index|]
argument_list|,
name|token_count
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDUCE_LENGTH
condition|;
name|i
operator|++
control|)
name|sorted
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|REDUCE_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|reduce_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDUCE_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reduce_count
index|[
name|idx
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|reduce_count
index|[
name|idx
index|]
operator|<
name|reduce_count
index|[
operator|-
literal|1
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rule %d, line %d, count = %d\n"
argument_list|,
name|idx
argument_list|,
name|yyrline
index|[
name|idx
index|]
argument_list|,
name|reduce_count
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Sets the value of the 'yydebug' variable to VALUE.    This is a function so we don't have to have YYDEBUG defined    in order to build the compiler.  */
end_comment

begin_function
name|void
name|set_yydebug
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
specifier|extern
name|int
name|yydebug
decl_stmt|;
name|yydebug
operator|=
name|value
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"YYDEBUG not defined."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for #pragma interface.     `#pragma implementation' means that the main file being compiled    is considered to implement (provide) the classes that appear in    its main body.  I.e., if this is file "foo.cc", and class `bar'    is defined in "foo.cc", then we say that "foo.cc implements bar".     All main input files "implement" themselves automagically.     `#pragma interface' means that unless this file (of the form "foo.h"    is not presently being included by file "foo.cc", the    CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none    of the vtables nor any of the inline functions defined in foo.h    will ever be output.     There are cases when we want to link files such as "defs.h" and    "main.cc".  In this case, we give "defs.h" a `#pragma interface',    and "main.cc" has `#pragma implementation "defs.h"'.  */
end_comment

begin_struct
struct|struct
name|impl_files
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|impl_files
modifier|*
name|impl_file_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function to load global variables with interface    information.  */
end_comment

begin_function
name|void
name|extract_interface_info
parameter_list|()
block|{
name|tree
name|fileinfo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
name|struct
name|tinst_level
modifier|*
name|til
init|=
name|tinst_for_decl
argument_list|()
decl_stmt|;
if|if
condition|(
name|til
condition|)
name|fileinfo
operator|=
name|get_time_identifier
argument_list|(
name|til
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fileinfo
condition|)
name|fileinfo
operator|=
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|fileinfo
operator|=
name|TIME_IDENTIFIER_FILEINFO
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if S is not considered part of an    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|interface_strcmp
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Set the interface/implementation bits for this scope.  */
name|struct
name|impl_files
modifier|*
name|ifiles
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
for|for
control|(
name|ifiles
operator|=
name|impl_file_chain
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|t1
init|=
name|ifiles
operator|->
name|filename
decl_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|t1
operator|||
operator|*
name|s1
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|)
name|s1
operator|++
operator|,
name|t1
operator|++
expr_stmt|;
comment|/* A match.  */
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
condition|)
return|return
literal|0
return|;
comment|/* Don't get faked out by xxx.yyy.cc vs xxx.zzz.cc.  */
if|if
condition|(
name|index
argument_list|(
name|s1
argument_list|,
literal|'.'
argument_list|)
operator|||
name|index
argument_list|(
name|t1
argument_list|,
literal|'.'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|||
name|s1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|t1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* A match.  */
return|return
literal|0
return|;
block|}
comment|/* No matches.  */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_typedecl_interface_info
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|id
init|=
name|get_time_identifier
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fileinfo
init|=
name|TIME_IDENTIFIER_FILEINFO
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_strcmp
argument_list|(
name|file_name_nondirectory
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_vardecl_interface_info
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|DECL_CONTEXT
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
condition|)
name|set_typedecl_interface_info
argument_list|(
operator|&
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
operator|*
name|t
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
operator|*
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the state required to correctly handle the definition of the    inline function whose preparsed state has been saved in PI.  */
end_comment

begin_function
specifier|static
name|void
name|begin_definition_of_inclass_inline
parameter_list|(
name|pi
parameter_list|)
name|struct
name|pending_inline
modifier|*
name|pi
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|fndecl
condition|)
return|return;
comment|/* If this is an inline function in a local class, we must make sure      that we save all pertinent information about the function      surrounding the local class.  */
name|context
operator|=
name|hack_decl_function_context
argument_list|(
name|pi
operator|->
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|push_cp_function_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|feed_input
argument_list|(
name|pi
operator|->
name|buf
argument_list|,
name|pi
operator|->
name|len
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|pi
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|pi
operator|->
name|filename
expr_stmt|;
name|yychar
operator|=
name|PRE_PARSED_FUNCTION_DECL
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_tree_list
argument_list|(
operator|(
name|tree
operator|)
name|pi
argument_list|,
name|pi
operator|->
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Pass back a handle to the rest of the inline functions, so that they      can be processed later.  */
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|pi
operator|->
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|interface_unknown
operator|=
name|pi
operator|->
name|interface
operator|==
literal|1
expr_stmt|;
name|interface_only
operator|=
name|pi
operator|->
name|interface
operator|==
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from the top level: if there are any pending inlines to    do, set up to process them now.  This function sets up the first function    to be parsed; after it has been, the rule for fndef in parse.y will    call process_next_inline to start working on the next one.  */
end_comment

begin_function
name|void
name|do_pending_inlines
parameter_list|()
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
comment|/* Oops, we're still dealing with the last batch.  */
if|if
condition|(
name|yychar
operator|==
name|PRE_PARSED_FUNCTION_DECL
condition|)
return|return;
comment|/* Reverse the pending inline functions, since      they were cons'd instead of appended.  */
block|{
name|struct
name|pending_inline
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|t
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|tail
control|)
block|{
name|tail
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|t
operator|->
name|deja_vu
operator|=
literal|1
expr_stmt|;
name|prev
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return;
comment|/* Now start processing the first inline function.  */
name|begin_definition_of_inclass_inline
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|nextchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called from the fndecl rule in the parser when the function just parsed    was declared using a PRE_PARSED_FUNCTION_DECL (i.e. came from    do_pending_inlines).  */
end_comment

begin_function
name|void
name|process_next_inline
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|i
init|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|context
operator|=
name|hack_decl_function_context
argument_list|(
name|i
operator|->
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|pop_cp_function_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
block|{
name|error
argument_list|(
literal|"parse error at end of saved function text"
argument_list|)
expr_stmt|;
comment|/* restore_pending_input will abort unless yychar is either          END_OF_SAVED_INPUT or YYEMPTY; since we already know we're          hosed, feed back YYEMPTY.  We also need to discard nextchar,          since that may have gotten set as well.  */
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|end_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|begin_definition_of_inclass_inline
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Since inline methods can refer to text which has not yet been seen,    we store the text of the method in a structure which is placed in the    DECL_PENDING_INLINE_INFO field of the FUNCTION_DECL.    After parsing the body of the class definition, the FUNCTION_DECL's are    scanned to see which ones have this field set.  Those are then digested    one at a time.     This function's FUNCTION_DECL will have a bit set in its common so    that we know to watch out for it.  */
end_comment

begin_function
specifier|static
name|void
name|consume_string
parameter_list|(
name|this_obstack
parameter_list|,
name|matching_char
parameter_list|)
specifier|register
name|struct
name|obstack
modifier|*
name|this_obstack
decl_stmt|;
name|int
name|matching_char
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|int
name|save_lineno
init|=
name|lineno
decl_stmt|;
name|lineno
operator|=
name|starting_lineno
expr_stmt|;
if|if
condition|(
name|matching_char
operator|==
literal|'"'
condition|)
name|error
argument_list|(
literal|"end of file encountered inside string constant"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"end of file encountered inside character constant"
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|save_lineno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Make sure we continue the loop */
name|c
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|matching_char
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|nextyychar
init|=
name|YYEMPTY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|YYSTYPE
name|nextyylval
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pending_input
block|{
name|int
name|nextchar
decl_stmt|,
name|yychar
decl_stmt|,
name|nextyychar
decl_stmt|,
name|eof
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|,
name|nextyylval
decl_stmt|;
name|struct
name|obstack
name|token_obstack
decl_stmt|;
name|int
name|first_token
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|pending_input
modifier|*
name|save_pending_input
parameter_list|()
block|{
name|struct
name|pending_input
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending_input
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_input
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|nextchar
operator|=
name|nextchar
expr_stmt|;
name|p
operator|->
name|yychar
operator|=
name|yychar
expr_stmt|;
name|p
operator|->
name|nextyychar
operator|=
name|nextyychar
expr_stmt|;
name|p
operator|->
name|yylval
operator|=
name|yylval
expr_stmt|;
name|p
operator|->
name|nextyylval
operator|=
name|nextyylval
expr_stmt|;
name|p
operator|->
name|eof
operator|=
name|end_of_file
expr_stmt|;
name|yychar
operator|=
name|nextyychar
operator|=
name|YYEMPTY
expr_stmt|;
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|first_token
operator|=
name|first_token
expr_stmt|;
name|p
operator|->
name|token_obstack
operator|=
name|token_obstack
expr_stmt|;
name|first_token
operator|=
literal|0
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|token_obstack
argument_list|)
expr_stmt|;
name|end_of_file
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|restore_pending_input
parameter_list|(
name|p
parameter_list|)
name|struct
name|pending_input
modifier|*
name|p
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|nextchar
operator|==
operator|-
literal|1
argument_list|,
literal|229
argument_list|)
expr_stmt|;
name|nextchar
operator|=
name|p
operator|->
name|nextchar
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|yychar
operator|==
name|YYEMPTY
operator|||
name|yychar
operator|==
name|END_OF_SAVED_INPUT
argument_list|,
literal|230
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|p
operator|->
name|yychar
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nextyychar
operator|==
name|YYEMPTY
argument_list|,
literal|231
argument_list|)
expr_stmt|;
name|nextyychar
operator|=
name|p
operator|->
name|nextyychar
expr_stmt|;
name|yylval
operator|=
name|p
operator|->
name|yylval
expr_stmt|;
name|nextyylval
operator|=
name|p
operator|->
name|nextyylval
expr_stmt|;
name|first_token
operator|=
name|p
operator|->
name|first_token
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|token_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|token_obstack
operator|=
name|p
operator|->
name|token_obstack
expr_stmt|;
name|end_of_file
operator|=
name|p
operator|->
name|eof
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unget character CH from the input stream.    If RESCAN is non-zero, then we want to `see' this    character as the next input token.  */
end_comment

begin_function
name|void
name|yyungetc
parameter_list|(
name|ch
parameter_list|,
name|rescan
parameter_list|)
name|int
name|ch
decl_stmt|;
name|int
name|rescan
decl_stmt|;
block|{
comment|/* Unget a character from the input stream.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
operator|||
name|rescan
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|put_back
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|nextchar
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|nextyychar
operator|==
name|YYEMPTY
argument_list|,
literal|232
argument_list|)
expr_stmt|;
name|nextyychar
operator|=
name|yychar
expr_stmt|;
name|nextyylval
operator|=
name|yylval
expr_stmt|;
name|yychar
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|clear_inline_text_obstack
parameter_list|()
block|{
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|inline_text_firstobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function stores away the text for an inline function that should    be processed later.  It decides how much later, and may need to move    the info between obstacks; therefore, the caller should not refer to    the T parameter after calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|store_pending_inline
parameter_list|(
name|decl
parameter_list|,
name|t
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
block|{
name|t
operator|->
name|fndecl
operator|=
name|decl
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Because we use obstacks, we must process these in precise order.  */
name|t
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_parse_for_method
parameter_list|(
name|yychar
parameter_list|,
name|decl
parameter_list|)
name|int
name|yychar
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|reinit_parse_for_block
argument_list|(
name|yychar
argument_list|,
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|void_type_node
operator|||
operator|(
name|current_class_type
operator|&&
name|TYPE_REDEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Happens when we get two declarations of the same 	 function in the same scope.  */
name|char
modifier|*
name|buf
init|=
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|starting_lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|starting_filename
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|YYEMPTY
expr_stmt|;
name|t
operator|->
name|token_value
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|deja_vu
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (interface_unknown&& processing_template_defn&& flag_external_templates&& ! DECL_IN_SYSTEM_HEADER (decl)) 	warn_if_unknown_interface (decl);
endif|#
directive|endif
name|t
operator|->
name|interface
operator|=
operator|(
name|interface_unknown
condition|?
literal|1
else|:
operator|(
name|interface_only
condition|?
literal|0
else|:
literal|2
operator|)
operator|)
expr_stmt|;
name|store_pending_inline
argument_list|(
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Consume a block -- actually, a method beginning    with `:' or `{' -- and save it away on the specified obstack.  */
end_comment

begin_function
name|void
name|reinit_parse_for_block
parameter_list|(
name|pyychar
parameter_list|,
name|obstackp
parameter_list|)
name|int
name|pyychar
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|blev
init|=
literal|1
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|look_for_semicolon
init|=
literal|0
decl_stmt|;
name|int
name|look_for_lbrac
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pyychar
operator|==
literal|'{'
condition|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pyychar
operator|==
literal|'='
condition|)
name|look_for_semicolon
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pyychar
operator|==
literal|':'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|pyychar
argument_list|)
expr_stmt|;
comment|/* Add a space so we don't get confused by ': ::A(20)'.  */
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|look_for_lbrac
operator|=
literal|1
expr_stmt|;
name|blev
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pyychar
operator|==
name|RETURN_KEYWORD
condition|)
block|{
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
literal|"return"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|look_for_lbrac
operator|=
literal|1
expr_stmt|;
name|blev
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pyychar
operator|==
name|TRY
condition|)
block|{
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
literal|"try"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|look_for_lbrac
operator|=
literal|1
expr_stmt|;
name|blev
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|yyerror
argument_list|(
literal|"parse error in method specification"
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextchar
operator|!=
name|EOF
condition|)
block|{
name|c
operator|=
name|nextchar
expr_stmt|;
name|nextchar
operator|=
name|EOF
expr_stmt|;
block|}
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|int
name|this_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Don't lose our cool if there are lots of comments.  */
if|if
condition|(
name|lineno
operator|==
name|this_lineno
operator|+
literal|1
condition|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|==
name|this_lineno
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|-
name|this_lineno
operator|<
literal|10
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|lineno
operator|-
name|this_lineno
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n# %d \""
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|input_filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|' '
condition|)
comment|/* ASCII dependent...  */
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|look_for_lbrac
operator|=
literal|0
expr_stmt|;
name|blev
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|blev
operator|--
expr_stmt|;
if|if
condition|(
name|blev
operator|==
literal|0
operator|&&
operator|!
name|look_for_semicolon
condition|)
block|{
if|if
condition|(
name|pyychar
operator|==
name|TRY
condition|)
block|{
if|if
condition|(
name|peekyylex
argument_list|()
operator|==
name|CATCH
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
literal|" catch "
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|look_for_lbrac
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|yychar
operator|=
literal|'{'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Don't act on the next character...e.g, doing an escaped 		 double-quote.  */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"end of file read inside definition"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|consume_string
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|consume_string
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|look_for_lbrac
condition|)
block|{
name|error
argument_list|(
literal|"function body for constructor missing"
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|look_for_semicolon
operator|&&
name|blev
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"end of file read inside definition"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
name|done
label|:
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consume a no-commas expression -- actually, a default argument -- and    save it away on the specified obstack.  */
end_comment

begin_function
specifier|static
name|void
name|reinit_parse_for_expr
parameter_list|(
name|obstackp
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|plev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nextchar
operator|!=
name|EOF
condition|)
block|{
name|c
operator|=
name|nextchar
expr_stmt|;
name|nextchar
operator|=
name|EOF
expr_stmt|;
block|}
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|int
name|this_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Don't lose our cool if there are lots of comments.  */
if|if
condition|(
name|lineno
operator|==
name|this_lineno
operator|+
literal|1
condition|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|==
name|this_lineno
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|-
name|this_lineno
operator|<
literal|10
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|lineno
operator|-
name|this_lineno
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n# %d \""
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|input_filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|' '
condition|)
comment|/* ASCII dependent...  */
block|{
if|if
condition|(
name|plev
operator|<=
literal|0
operator|&&
operator|(
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|','
operator|)
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'['
condition|)
operator|++
name|plev
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|')'
condition|)
operator|--
name|plev
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Don't act on the next character...e.g, doing an escaped 		 double-quote.  */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"end of file read inside definition"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|consume_string
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|consume_string
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"end of file read inside definition"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
name|done
label|:
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|do_snarf_defarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decide whether the default argument we are about to see should be    gobbled up as text for later parsing.  */
end_comment

begin_function
name|void
name|maybe_snarf_defarg
parameter_list|()
block|{
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|do_snarf_defarg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When we see a default argument in a method declaration, we snarf it as    text using snarf_defarg.  When we get up to namespace scope, we then go    through and parse all of them using do_pending_defargs.  Since yacc    parsers are not reentrant, we retain defargs state in these two    variables so that subsequent calls to do_pending_defargs can resume    where the previous call left off.  */
end_comment

begin_decl_stmt
name|tree
name|defarg_fns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|defarg_parm
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|snarf_defarg
parameter_list|()
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|reinit_parse_for_expr
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|buf
operator|=
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|push_obstacks
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|arg
operator|=
name|make_node
argument_list|(
name|DEFAULT_ARG
argument_list|)
expr_stmt|;
name|DEFARG_LENGTH
argument_list|(
name|arg
argument_list|)
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|DEFARG_POINTER
argument_list|(
name|arg
argument_list|)
operator|=
name|buf
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Called from grokfndecl to note a function decl with unparsed default    arguments for later processing.  Also called from grokdeclarator    for function types with unparsed defargs; the call from grokfndecl    will always come second, so we can overwrite the entry from the type.  */
end_comment

begin_function
name|void
name|add_defarg_fn
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_VALUE
argument_list|(
name|defarg_fns
argument_list|)
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|push_obstacks
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|defarg_fns
operator|=
name|tree_cons
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
name|defarg_fns
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper for do_pending_defargs.  Starts the parsing of a default arg.  */
end_comment

begin_function
specifier|static
name|void
name|feed_defarg
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|)
name|tree
name|f
decl_stmt|,
name|p
decl_stmt|;
block|{
name|tree
name|d
init|=
name|TREE_PURPOSE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|feed_input
argument_list|(
name|DEFARG_POINTER
argument_list|(
name|d
argument_list|)
argument_list|,
name|DEFARG_LENGTH
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|yychar
operator|=
name|DEFARG_MARKER
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for do_pending_defargs.  Ends the parsing of a default arg.  */
end_comment

begin_function
specifier|static
name|void
name|finish_defarg
parameter_list|()
block|{
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
block|{
name|error
argument_list|(
literal|"parse error at end of saved function text"
argument_list|)
expr_stmt|;
comment|/* restore_pending_input will abort unless yychar is either          END_OF_SAVED_INPUT or YYEMPTY; since we already know we're          hosed, feed back YYEMPTY.  We also need to discard nextchar,          since that may have gotten set as well.  */
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|end_input
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main function for deferred parsing of default arguments.  Called from    the parser.  */
end_comment

begin_function
name|void
name|do_pending_defargs
parameter_list|()
block|{
if|if
condition|(
name|defarg_parm
condition|)
name|finish_defarg
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|defarg_fns
condition|;
name|defarg_fns
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_fns
argument_list|)
control|)
block|{
name|tree
name|defarg_fn
init|=
name|TREE_VALUE
argument_list|(
name|defarg_fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|defarg_parm
operator|==
name|NULL_TREE
condition|)
block|{
name|push_nested_class
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|defarg_fns
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|defarg_fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|maybe_begin_member_template_processing
argument_list|(
name|defarg_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|defarg_fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|#
directive|if
literal|0
block|tree p; 	      for (p = DECL_ARGUMENTS (defarg_fn); p; p = TREE_CHAIN (p)) 		pushdecl (copy_node (p));
endif|#
directive|endif
name|defarg_parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|defarg_fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|defarg_parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|defarg_fn
argument_list|)
expr_stmt|;
block|}
else|else
name|defarg_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_parm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|defarg_parm
condition|;
name|defarg_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|defarg_parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|defarg_parm
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|defarg_parm
argument_list|)
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
name|feed_defarg
argument_list|(
name|defarg_fn
argument_list|,
name|defarg_parm
argument_list|)
expr_stmt|;
comment|/* Return to the parser, which will process this defarg 	       and call us again.  */
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|defarg_fn
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|maybe_end_member_template_processing
argument_list|()
expr_stmt|;
name|check_default_args
argument_list|(
name|defarg_fn
argument_list|)
expr_stmt|;
block|}
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a default function named NAME for type TYPE.    KIND says what to build.     When KIND == 0, build default destructor.    When KIND == 1, build virtual destructor.    When KIND == 2, build default constructor.    When KIND == 3, build default X(const X&) constructor.    When KIND == 4, build default X(X&) constructor.    When KIND == 5, build default operator = (const X&).    When KIND == 6, build default operator = (X&).  */
end_comment

begin_function
name|tree
name|cons_up_default_function
parameter_list|(
name|type
parameter_list|,
name|full_name
parameter_list|,
name|kind
parameter_list|)
name|tree
name|type
decl_stmt|,
name|full_name
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|{
specifier|extern
name|tree
name|void_list_node
decl_stmt|;
name|tree
name|declspecs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|argtype
decl_stmt|;
name|int
name|retref
init|=
literal|0
decl_stmt|;
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|full_name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
comment|/* Destructors.  */
case|case
literal|1
case|:
name|declspecs
operator|=
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|0
case|:
name|name
operator|=
name|build_parse_node
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|args
operator|=
name|void_list_node
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Default constructor.  */
name|args
operator|=
name|void_list_node
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|type
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|4
case|:
comment|/* According to ARM $12.8, the default copy ctor will be declared, but 	 not defined, unless it's needed.  */
name|argtype
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|hash_tree_chain
argument_list|(
name|argtype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"_ctor_arg"
argument_list|)
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
name|retref
operator|=
literal|1
expr_stmt|;
name|declspecs
operator|=
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
literal|5
condition|)
name|type
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|name
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
expr_stmt|;
name|argtype
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|hash_tree_chain
argument_list|(
name|argtype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"_ctor_arg"
argument_list|)
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|59
argument_list|)
expr_stmt|;
block|}
name|declspecs
operator|=
name|decl_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
argument_list|,
name|declspecs
argument_list|)
expr_stmt|;
name|TREE_PARMLIST
argument_list|(
name|args
argument_list|)
operator|=
literal|1
expr_stmt|;
block|{
name|tree
name|declarator
init|=
name|make_call_declarator
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|retref
condition|)
name|declarator
operator|=
name|build_parse_node
argument_list|(
name|ADDR_EXPR
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|fn
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|==
name|void_type_node
condition|)
return|return
name|fn
return|;
if|if
condition|(
name|kind
operator|>
literal|2
condition|)
name|SET_DECL_ARTIFICIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (processing_template_defn)     {       SET_DECL_IMPLICIT_INSTANTIATION (fn);       repo_template_used (fn);     }
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (CLASSTYPE_INTERFACE_KNOWN (type))     {       DECL_INTERFACE_KNOWN (fn) = 1;       DECL_NOT_REALLY_EXTERN (fn) = (!CLASSTYPE_INTERFACE_ONLY (type)&& flag_implement_inlines);     }   else
endif|#
directive|endif
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_inline_for_output
argument_list|(
name|fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DEFAULT_FUNCTIONS
block|{
name|char
modifier|*
name|fn_type
init|=
name|NULL
decl_stmt|;
name|tree
name|t
init|=
name|name
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|0
case|:
name|fn_type
operator|=
literal|"default destructor"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fn_type
operator|=
literal|"virtual destructor"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fn_type
operator|=
literal|"default constructor"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fn_type
operator|=
literal|"default X(const X&)"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fn_type
operator|=
literal|"default X(X&)"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fn_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[[[[ %s for %s:\n%s]]]]\n"
argument_list|,
name|fn_type
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|func_buf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* DEBUG_DEFAULT_FUNCTIONS */
comment|/* Show that this function was generated by the compiler.  */
name|SET_DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to tell whether the user is missing a semicolon    after a struct or enum declaration.  Emit an error message    if we know the user has blown it.  */
end_comment

begin_function
name|void
name|check_for_missing_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|yychar
operator|>
literal|255
operator|&&
name|yychar
operator|!=
name|SCSPEC
operator|&&
name|yychar
operator|!=
name|IDENTIFIER
operator|&&
name|yychar
operator|!=
name|TYPENAME
operator|&&
name|yychar
operator|!=
name|CV_QUALIFIER
operator|&&
name|yychar
operator|!=
name|SELFNAME
operator|)
operator|||
name|end_of_file
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"semicolon missing after %s declaration"
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|?
literal|"enum"
else|:
literal|"struct"
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"semicolon missing after declaration of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Could probably also hack cases where class { ... } f (); appears.  */
name|clear_anon_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_got_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|my_friendly_abort
argument_list|(
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_list_got_semicolon
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|note_got_semicolon
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|clear_anon_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If C is not whitespace, return C.    Otherwise skip whitespace and return first nonwhite char read.  */
end_comment

begin_function
specifier|static
name|int
name|skip_white_space
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|c
operator|=
name|check_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\' in program"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make the token buffer longer, preserving the data in it.    P should point to just beyond the last valid character in the old buffer.    The value we return is a pointer to the new buffer    at a place corresponding to P.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extend_token_buffer
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|p
operator|-
name|token_buffer
decl_stmt|;
name|maxtoken
operator|=
name|maxtoken
operator|*
literal|2
operator|+
literal|10
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|token_buffer
argument_list|,
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|token_buffer
operator|+
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|get_last_nonwhite_on_line
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|HANDLE_PRAGMA
end_if

begin_comment
comment|/* Local versions of these macros, that can be passed as function pointers.  */
end_comment

begin_function
specifier|static
name|int
name|pragma_getc
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nextchar
operator|!=
name|EOF
condition|)
block|{
name|c
operator|=
name|nextchar
expr_stmt|;
name|nextchar
operator|=
name|EOF
expr_stmt|;
block|}
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pragma_ungetc
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|yyungetc
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_PRAGMA */
end_comment

begin_comment
comment|/* At the beginning of a line, increment the line number    and process any #-directive on this line.    If the line is a #-directive, read the entire line and return a newline.    Otherwise, return the line's first non-whitespace character.  */
end_comment

begin_decl_stmt
name|int
name|linemode
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_newline
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|token
decl_stmt|;
name|int
name|saw_line
init|=
literal|0
decl_stmt|;
comment|/* Read first nonwhite char on the line.  Do this before incrementing the      line number, in case we're at the end of saved text.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'#'
condition|)
block|{
comment|/* If not #, return it so caller will use it.  */
return|return
name|c
return|;
block|}
comment|/* Don't read beyond this line.  */
name|linemode
operator|=
literal|1
expr_stmt|;
comment|/* Read first nonwhite char after the `#'.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
comment|/* If a letter follows, then if the word here is `line', skip      it and ignore it; otherwise, ignore the line, with an error      if the word isn't `pragma'.  */
if|if
condition|(
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'g'
operator|&&
name|getch
argument_list|()
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
condition|)
block|{
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|IDENTIFIER
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* If this is 1, we handled it; if it's -1, it was one we 		     wanted but had something wrong with it.  Only if it's 		     0 was it not handled.  */
if|if
condition|(
name|handle_cp_pragma
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
condition|)
goto|goto
name|skipline
goto|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|END_OF_LINE
condition|)
goto|goto
name|skipline
goto|;
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA
comment|/* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS 		 (if both are defined), in order to give the back 		 end a chance to override the interpretation of 		 SYSV style pragmas.  */
if|if
condition|(
name|HANDLE_PRAGMA
argument_list|(
name|pragma_getc
argument_list|,
name|pragma_ungetc
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
condition|)
goto|goto
name|skipline
goto|;
endif|#
directive|endif
comment|/* HANDLE_PRAGMA */
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
if|if
condition|(
name|handle_generic_pragma
argument_list|(
name|token
argument_list|)
condition|)
goto|goto
name|skipline
goto|;
endif|#
directive|endif
comment|/* HANDLE_GENERIC_PRAGMAS */
comment|/* Issue a warning message if we have been asked to do so. 		 Ignoring unknown pragmas in system header file unless 		 an explcit -Wunknown-pragmas has been given. */
if|if
condition|(
name|warn_unknown_pragmas
operator|>
literal|1
operator|||
operator|(
name|warn_unknown_pragmas
operator|&&
operator|!
name|in_system_header
operator|)
condition|)
name|warning
argument_list|(
literal|"ignoring pragma: %s"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
goto|goto
name|skipline
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'f'
operator|&&
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|debug_define
argument_list|(
name|lineno
argument_list|,
name|GET_DIRECTIVE_LINE
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'f'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|debug_undef
argument_list|(
name|lineno
argument_list|,
name|GET_DIRECTIVE_LINE
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|saw_line
operator|=
literal|1
expr_stmt|;
goto|goto
name|linenum
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* #ident.  The pedantic warning is now in cccp.c.  */
comment|/* Here we have just seen `#ident '. 		 A string constant should follow.  */
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|END_OF_LINE
condition|)
goto|goto
name|skipline
goto|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #ident"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Skip the rest of this line.  */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'w'
operator|&&
name|getch
argument_list|()
operator|==
literal|'w'
operator|&&
name|getch
argument_list|()
operator|==
literal|'o'
operator|&&
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* Used to test incremental compilation.  */
name|sorry
argument_list|(
literal|"#pragma newworld"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
name|error
argument_list|(
literal|"undefined or invalid # directive"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|linenum
label|:
comment|/* Here we have either `#line' or `#<nonletter>'.      In either case, it should be a line number; a digit should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* If the # is the only nonwhite char on the line,      just ignore it.  Check the new newline.  */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|skipline
goto|;
comment|/* Something follows the #; read a token.  */
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
enum|enum
block|{
name|act_none
block|,
name|act_push
block|,
name|act_pop
block|}
name|action
init|=
name|act_none
enum|;
name|int
name|entering_system_header
init|=
literal|0
decl_stmt|;
name|int
name|entering_c_header
init|=
literal|0
decl_stmt|;
comment|/* subtract one, because it is the following line that 	 gets the specified number */
name|int
name|l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|-
literal|1
decl_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* No more: store the line number and check following line.  */
name|lineno
operator|=
name|l
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* More follows: it must be a string constant (filename).  */
if|if
condition|(
name|saw_line
condition|)
block|{
comment|/* Don't treat \ as special if we are processing #line 1 "...". 	     If you want it to be treated specially, use # 1 "...".  */
name|ignore_escape_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Read the string constant.  */
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|ignore_escape_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #line"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
comment|/* Changing files again.  This means currently collected time 	 is charged against header time, and body time starts back 	 at 0.  */
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|int
name|this_time
init|=
name|my_get_run_time
argument_list|()
decl_stmt|;
name|tree
name|time_identifier
init|=
name|get_time_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
decl_stmt|;
name|header_time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|TIME_IDENTIFIER_TIME
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|this_filename_time
operator|=
name|time_identifier
expr_stmt|;
name|body_time
operator|=
name|this_time
expr_stmt|;
block|}
name|input_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|input_filename
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|l
expr_stmt|;
name|GNU_xref_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
block|{
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
if|if
condition|(
name|ifiles
condition|)
block|{
while|while
condition|(
name|ifiles
operator|->
name|next
condition|)
name|ifiles
operator|=
name|ifiles
operator|->
name|next
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|file_name_nondirectory
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
block|{
name|walk_globals
argument_list|(
name|vtable_decl_p
argument_list|,
name|set_vardecl_interface_info
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
expr_stmt|;
name|walk_globals
argument_list|(
name|vtype_decl_p
argument_list|,
name|set_typedecl_interface_info
argument_list|,
comment|/*data=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|extract_interface_info
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* Update the name in the top element of input_file_stack.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
block|}
else|else
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
comment|/* `1' after file name means entering new file. 	     `2' after file name means just left a file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|1
condition|)
name|action
operator|=
name|act_push
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|2
condition|)
name|action
operator|=
name|act_pop
expr_stmt|;
if|if
condition|(
name|action
condition|)
block|{
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* `3' after file name means this is a system header file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|3
condition|)
block|{
name|entering_system_header
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* `4' after file name means this is a C header file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|4
condition|)
block|{
name|entering_c_header
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Do the actions implied by the preceding numbers.  */
if|if
condition|(
name|action
operator|==
name|act_push
condition|)
block|{
comment|/* Pushing to a new file.  */
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
expr_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|old_lineno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|input_file_stack
operator|=
name|p
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|debug_start_source_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|in_system_header
operator|=
name|entering_system_header
expr_stmt|;
if|if
condition|(
name|c_header_level
condition|)
operator|++
name|c_header_level
expr_stmt|;
elseif|else
if|if
condition|(
name|entering_c_header
condition|)
block|{
name|c_header_level
operator|=
literal|1
expr_stmt|;
operator|++
name|pending_lang_change
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|act_pop
condition|)
block|{
comment|/* Popping out of a file.  */
if|if
condition|(
name|input_file_stack
operator|->
name|next
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|c_header_level
operator|&&
operator|--
name|c_header_level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|entering_c_header
condition|)
name|warning
argument_list|(
literal|"badly nested C headers from preprocessor"
argument_list|)
expr_stmt|;
operator|--
name|pending_lang_change
expr_stmt|;
block|}
name|in_system_header
operator|=
name|entering_system_header
expr_stmt|;
name|p
operator|=
name|input_file_stack
expr_stmt|;
name|input_file_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|debug_end_source_file
argument_list|(
name|input_file_stack
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"#-lines for entering and leaving files don't match"
argument_list|)
expr_stmt|;
block|}
else|else
name|in_system_header
operator|=
name|entering_system_header
expr_stmt|;
block|}
comment|/* If NEXTCHAR is not end of line, we don't care what it is.  */
if|if
condition|(
name|nextchar
operator|==
name|EOF
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid #-line"
argument_list|)
expr_stmt|;
comment|/* skip the rest of this line.  */
name|skipline
label|:
name|linemode
operator|=
literal|0
expr_stmt|;
name|end_of_file
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|void
name|do_pending_lang_change
parameter_list|()
block|{
for|for
control|(
init|;
name|pending_lang_change
operator|>
literal|0
condition|;
operator|--
name|pending_lang_change
control|)
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pending_lang_change
operator|<
literal|0
condition|;
operator|++
name|pending_lang_change
control|)
name|pop_lang_context
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ENDFILE
value|-1
end_define

begin_comment
comment|/* token that represents end-of-file */
end_comment

begin_comment
comment|/* Read an escape sequence, returning its equivalent as a character,    or store 1 in *ignore_ptr if it is backslash-newline.  */
end_comment

begin_function
specifier|static
name|int
name|readescape
parameter_list|(
name|ignore_ptr
parameter_list|)
name|int
modifier|*
name|ignore_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|getch
argument_list|()
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|firstdig
init|=
literal|0
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nonnull
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonnull
condition|)
name|error
argument_list|(
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Digits are all 0's.  Ok.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
operator|(
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
name|firstdig
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"hex escape out of range"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
operator|*
name|ignore_ptr
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
return|return
name|TARGET_VT
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'?'
case|:
return|return
name|c
return|;
comment|/* `\(', etc, are used at beginning of line to avoid confusing Emacs.  */
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
comment|/* `\%' is used to prevent SCCS from getting confused.  */
case|case
literal|'%'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|ISGRAPH
argument_list|(
name|c
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"unknown escape sequence: `\\' followed by char code 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Value is 1 (or 2) if we should try to make the next identifier look like    a typename (when it may be a local variable or a class variable).    Value is 0 if we treat this name in a default fashion.  */
end_comment

begin_decl_stmt
name|int
name|looking_for_typename
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
name|int
name|identifier_type
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|PTYPENAME
return|;
elseif|else
if|if
condition|(
name|looking_for_template
condition|)
return|return
name|PFUNCNAME
return|;
block|}
if|if
condition|(
name|looking_for_template
operator|&&
name|really_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* See through a baselink.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|decl
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|OVL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|PFUNCNAME
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|NSNAME
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
name|IDENTIFIER
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|current_class_type
condition|)
return|return
name|SELFNAME
return|;
comment|/* A constructor declarator for a template type will get here as an      implicit typename, a TYPENAME_TYPE with a type.  */
name|t
operator|=
name|got_scope
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|decl
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|==
name|decl
condition|)
return|return
name|SELFNAME
return|;
return|return
name|TYPENAME
return|;
block|}
end_function

begin_function
name|void
name|see_typename
parameter_list|()
block|{
comment|/* Only types expected, not even namespaces. */
name|looking_for_typename
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|IDENTIFIER
condition|)
block|{
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag_labels_ok
condition|)
name|lastiddecl
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
block|}
else|else
name|yychar
operator|=
name|identifier_type
argument_list|(
name|lastiddecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if d is in a global scope. */
end_comment

begin_function
specifier|static
name|int
name|is_global
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
literal|1
return|;
case|case
name|OVERLOAD
case|:
name|d
operator|=
name|OVL_FUNCTION
argument_list|(
name|d
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TREE_LIST
case|:
name|d
operator|=
name|TREE_VALUE
argument_list|(
name|d
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
argument_list|)
operator|==
literal|'d'
argument_list|,
literal|980629
argument_list|)
expr_stmt|;
name|d
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|NAMESPACE_DECL
return|;
block|}
block|}
end_function

begin_function
name|tree
name|do_identifier
parameter_list|(
name|token
parameter_list|,
name|parsing
parameter_list|,
name|args
parameter_list|)
specifier|register
name|tree
name|token
decl_stmt|;
name|int
name|parsing
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
specifier|register
name|tree
name|id
decl_stmt|;
name|int
name|lexing
init|=
operator|(
name|parsing
operator|==
literal|1
operator|)
decl_stmt|;
name|int
name|in_call
init|=
operator|(
name|parsing
operator|==
literal|2
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|lexing
operator|||
name|IDENTIFIER_OPNAME_P
argument_list|(
name|token
argument_list|)
condition|)
name|id
operator|=
name|lookup_name
argument_list|(
name|token
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|lastiddecl
expr_stmt|;
comment|/* Scope class declarations before global      declarations.  */
if|if
condition|(
operator|(
operator|!
name|id
operator|||
name|is_global
argument_list|(
name|id
argument_list|)
operator|)
operator|&&
name|current_class_type
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Could be from one of the base classes.  */
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
comment|/* We have already generated the error message. 	   But we still want to return this value.  */
name|id
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|token
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|id
operator|=
name|field
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
operator|&&
name|IMPLICIT_TYPENAME_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
comment|/* When we did name-lookup before, we will have eschewed            implicit typenames in favor of global bindings.  Therefore,            if lookup_field returns an implicit typename, but ID is not            an implicit typename, then we should skip this one, too.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|my_friendly_abort
argument_list|(
literal|61
argument_list|)
expr_stmt|;
else|else
block|{
name|cp_error
argument_list|(
literal|"invalid use of member `%D'"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
comment|/* Do Koenig lookup if appropriate (inside templates we build lookup      expressions instead).  */
if|if
condition|(
name|args
operator|&&
operator|!
name|current_template_parms
operator|&&
operator|(
operator|!
name|id
operator|||
name|is_global
argument_list|(
name|id
argument_list|)
operator|)
condition|)
comment|/* If we have arguments and we only found global names, do Koenig        lookup. */
name|id
operator|=
name|lookup_arg_dependent
argument_list|(
name|token
argument_list|,
name|id
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Remember that this name has been used in the class definition, as per      [class.scope0] */
if|if
condition|(
name|id
operator|&&
name|parsing
comment|/* Avoid breaking if we get called for a default argument that 	 refers to an overloaded method.  Eventually this will not be 	 necessary, since default arguments shouldn't be parsed until 	 after the class is complete.  (jason 3/12/97) */
operator|&&
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|token
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
block|{
comment|/* lookup_name quietly returns error_mark_node if we're parsing, 	 as we don't want to complain about an identifier that ends up 	 being used as a declarator.  So we call it again to get the error 	 message.  */
name|id
operator|=
name|lookup_name
argument_list|(
name|token
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|id
condition|)
block|{
if|if
condition|(
name|current_template_parms
condition|)
return|return
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
return|;
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|ansi_opname
index|[
name|ERROR_MARK
index|]
condition|)
name|cp_error
argument_list|(
literal|"`%D' not defined"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_call
operator|&&
operator|!
name|flag_strict_prototype
condition|)
block|{
name|id
operator|=
name|implicitly_declare
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|cp_error
argument_list|(
literal|"`%D' was not declared in this scope"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|token
argument_list|)
operator|!=
name|error_mark_node
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|token
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
specifier|static
name|int
name|undeclared_variable_notice
decl_stmt|;
name|cp_error
argument_list|(
literal|"`%D' undeclared (first use this function)"
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|undeclared_variable_notice
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"for each function it appears in.)"
argument_list|)
expr_stmt|;
name|undeclared_variable_notice
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|id
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Prevent repeated error messages.  */
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|token
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|token
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|tree
name|shadowed
init|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|id
argument_list|)
decl_stmt|;
while|while
condition|(
name|shadowed
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|shadowed
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|shadowed
argument_list|)
condition|)
name|shadowed
operator|=
name|DECL_SHADOWED_FOR_VAR
argument_list|(
name|shadowed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shadowed
condition|)
name|shadowed
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadowed
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_ERROR_REPORTED
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"name lookup of `%s' changed"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  matches this `%D' under current ANSI rules"
argument_list|,
name|shadowed
argument_list|)
expr_stmt|;
name|cp_warning_at
argument_list|(
literal|"  matches this `%D' under old rules"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|DECL_ERROR_REPORTED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|id
operator|=
name|shadowed
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_ERROR_REPORTED
argument_list|(
name|id
argument_list|)
condition|)
block|{
specifier|static
name|char
name|msg
index|[]
init|=
literal|"name lookup of `%s' changed for new ANSI `for' scoping"
decl_stmt|;
name|DECL_ERROR_REPORTED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  cannot use obsolete binding at `%D' because it has a destructor"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
name|msg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|cp_pedwarn_at
argument_list|(
literal|"  using obsolete binding at `%D'"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* TREE_USED is set in `hack_identifier'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
comment|/* Check access.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|token
argument_list|)
operator|==
name|id
condition|)
name|enforce_access
argument_list|(
name|DECL_REAL_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
operator|||
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|id
argument_list|)
condition|)
name|id
operator|=
name|DECL_INITIAL
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|id
operator|=
name|hack_identifier
argument_list|(
name|id
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* We must look up dependent names when the template is      instantiated, not while parsing it.  For now, we don't      distinguish between dependent and independent names.  So, for      example, we look up all overloaded functions at      instantiation-time, even though in some cases we should just use      the DECL we have here.  We also use LOOKUP_EXPRs to find things      like local variables, rather than creating TEMPLATE_DECLs for the      local variables and then finding matching instantiations.  */
if|if
condition|(
name|current_template_parms
operator|&&
operator|(
name|is_overloaded_fn
argument_list|(
name|id
argument_list|)
comment|/* If it's not going to be around at instantiation time, we 	     look it up then.  This is a hack, and should go when we 	     really get dependent/independent name lookup right.  */
operator|||
operator|!
name|TREE_PERMANENT
argument_list|(
name|id
argument_list|)
comment|/* Some local VAR_DECLs (such as those for local variables 	     in member functions of local classes) are built on the 	     permanent obstack.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|CP_DECL_CONTEXT
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|USING_DECL
operator|)
condition|)
name|id
operator|=
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
name|tree
name|do_scoped_id
parameter_list|(
name|token
parameter_list|,
name|parsing
parameter_list|)
name|tree
name|token
decl_stmt|;
name|int
name|parsing
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
comment|/* during parsing, this is ::name. Otherwise, it is black magic. */
if|if
condition|(
name|parsing
condition|)
block|{
name|struct
name|tree_binding
name|_b
decl_stmt|;
name|id
operator|=
name|binding_init
argument_list|(
operator|&
name|_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qualified_lookup_using_namespace
argument_list|(
name|token
argument_list|,
name|global_namespace
argument_list|,
name|id
argument_list|,
literal|0
argument_list|)
condition|)
name|id
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|id
operator|=
name|BINDING_VALUE
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|id
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsing
operator|&&
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|id
operator|=
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|id
return|;
block|}
if|if
condition|(
name|parsing
operator|&&
operator|(
name|yychar
operator|==
literal|'('
operator|||
name|yychar
operator|==
name|LEFT_RIGHT
operator|)
operator|&&
operator|!
name|flag_strict_prototype
condition|)
name|id
operator|=
name|implicitly_declare
argument_list|(
name|token
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|token
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|cp_error
argument_list|(
literal|"`::%D' undeclared (first use here)"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Prevent repeated error messages.  */
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|token
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|mark_used
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|CONST_DECL
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* XXX CHS - should we set TREE_USED of the constant? */
name|id
operator|=
name|DECL_INITIAL
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* This is to prevent an enum whose value is 0 	 from being considered a null pointer constant.  */
name|id
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|id
operator|=
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|id
return|;
block|}
comment|/* else just use the decl */
block|}
return|return
name|convert_from_reference
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|identifier_typedecl_value
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
return|return
name|t
return|;
block|}
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
return|return
name|t
return|;
block|}
comment|/* Will this one ever happen?  */
if|if
condition|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
return|;
comment|/* We used to do an internal error of 62 here, but instead we will      handle the return of a null appropriately in the callers.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_struct
struct|struct
name|pf_args
block|{
comment|/* Input */
comment|/* I/O */
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|imag
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Output */
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|parse_float
parameter_list|(
name|data
parameter_list|)
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|pf_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|pf_args
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|fflag
init|=
literal|0
decl_stmt|,
name|lflag
init|=
literal|0
decl_stmt|;
comment|/* Copy token_buffer now, while it has just the number      and not the suffixes; once we add `f' or `i',      REAL_VALUE_ATOF may not work any more.  */
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|args
operator|->
name|p
operator|-
name|token_buffer
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|token_buffer
argument_list|,
name|copy
argument_list|,
name|args
operator|->
name|p
operator|-
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|lose
init|=
literal|0
decl_stmt|;
comment|/* Read the suffixes to choose a data type.  */
switch|switch
condition|(
name|args
operator|->
name|c
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|fflag
condition|)
name|error
argument_list|(
literal|"more than one `f' in numeric constant"
argument_list|)
expr_stmt|;
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|lflag
condition|)
name|error
argument_list|(
literal|"more than one `l' in numeric constant"
argument_list|)
expr_stmt|;
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
name|args
operator|->
name|imag
condition|)
name|error
argument_list|(
literal|"more than one `i' or `j' in numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|args
operator|->
name|imag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|lose
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lose
condition|)
break|break;
if|if
condition|(
name|args
operator|->
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|args
operator|->
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|args
operator|->
name|p
argument_list|)
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|p
operator|++
operator|)
operator|=
name|args
operator|->
name|c
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|p
operator|)
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
comment|/* The second argument, machine_mode, of REAL_VALUE_ATOF      tells the desired precision of the binary result      of decimal-to-binary conversion.  */
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
name|lflag
condition|)
name|error
argument_list|(
literal|"both `f' and `l' in floating constant"
argument_list|)
expr_stmt|;
name|args
operator|->
name|type
operator|=
name|float_type_node
expr_stmt|;
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A diagnostic is required here by some ANSI C testsuites. 	 This is not pedwarn, become some people don't want 	 an error for this.  */
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `float'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lflag
condition|)
block|{
name|args
operator|->
name|type
operator|=
name|long_double_type_node
expr_stmt|;
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `long double'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|args
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|args
operator|->
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|real_yylex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|dollar_seen
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Effectively do c = skip_white_space (c)      but do it faster in the usual cases.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* Call skip_white_space so we can warn if appropriate.  */
case|case
literal|'\n'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\\'
case|:
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|found_nonwhite
goto|;
block|}
name|found_nonwhite
label|:
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  yylloc.first_line = lineno; */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|end_of_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|input_redirected
argument_list|()
condition|)
name|value
operator|=
name|END_OF_SAVED_INPUT
expr_stmt|;
elseif|else
if|if
condition|(
name|linemode
condition|)
name|value
operator|=
name|END_OF_LINE
expr_stmt|;
else|else
name|value
operator|=
name|ENDFILE
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|dollars_in_ident
condition|)
name|error
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
name|dollar_seen
operator|=
literal|1
expr_stmt|;
goto|goto
name|letter
goto|;
case|case
literal|'L'
case|:
comment|/* Capital L may start a wide-string or wide-character constant.  */
block|{
specifier|register
name|int
name|c
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|char_constant
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'_'
case|:
name|letter
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
comment|/* We know that `token_buffer' can hold at least on char, 	       so we install C immediately. 	       We may have to read the value in `putback_char', so call 	       `getch' once.  */
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Make this run fast.  We know that we are reading straight 	       from FINPUT in this case (since identifiers cannot straddle 	       input sources.  */
while|while
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|dollars_in_ident
condition|)
name|error
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|linemode
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|EOF
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We know that `token_buffer' can hold at least on char, 	       so we install C immediately.  */
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|!
name|dollars_in_ident
condition|)
name|error
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|0
expr_stmt|;
comment|/* Try to recognize a keyword.  Uses minimum-perfect hash function */
block|{
specifier|register
name|struct
name|resword
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|is_reserved_word
argument_list|(
name|token_buffer
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rid
condition|)
block|{
name|tree
name|old_ttype
init|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|ptr
operator|->
name|rid
index|]
decl_stmt|;
comment|/* If this provides a type for us, then revert lexical 		     state to standard state.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_ttype
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|old_ttype
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|old_ttype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
name|AGGR
operator|||
name|ptr
operator|->
name|token
operator|==
name|ENUM
condition|)
name|looking_for_typename
operator|=
literal|2
expr_stmt|;
comment|/* Check if this is a language-type declaration. 		     Just glimpse the next non-white character.  */
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'"'
condition|)
block|{
comment|/* We are looking at a string.  Complain 			 if the token before the string is no `extern'. 			  			 Could cheat some memory by placing this string 			 on the temporary_, instead of the saveable_ 			 obstack.  */
if|if
condition|(
name|ptr
operator|->
name|rid
operator|!=
name|RID_EXTERN
condition|)
name|error
argument_list|(
literal|"invalid modifier `%s' for language string"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|real_yylex
argument_list|()
expr_stmt|;
name|value
operator|=
name|EXTERN_LANG_STRING
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
name|VISSPEC
condition|)
block|{
switch|switch
condition|(
name|ptr
operator|->
name|rid
condition|)
block|{
case|case
name|RID_PUBLIC
case|:
name|yylval
operator|.
name|ttype
operator|=
name|access_public_node
expr_stmt|;
break|break;
case|case
name|RID_PRIVATE
case|:
name|yylval
operator|.
name|ttype
operator|=
name|access_private_node
expr_stmt|;
break|break;
case|case
name|RID_PROTECTED
case|:
name|yylval
operator|.
name|ttype
operator|=
name|access_protected_node
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|63
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|yylval
operator|.
name|ttype
operator|=
name|old_ttype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
name|EQCOMPARE
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|NE_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
name|ASSIGN
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"and_eq"
argument_list|,
name|token_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'&'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"or_eq"
argument_list|,
name|token_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'|'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"xor_eq"
argument_list|,
name|token_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
block|}
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
literal|'&'
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'&'
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
literal|'|'
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'|'
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
literal|'^'
condition|)
block|{
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|int
operator|)
name|ptr
operator|->
name|token
expr_stmt|;
block|}
block|}
comment|/* If we did not find a keyword, look for an identifier 	   (or a typename).  */
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
operator|||
name|value
operator|==
name|TYPESPEC
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
condition|)
block|{
specifier|register
name|tree
name|tmp
init|=
name|get_identifier
argument_list|(
name|token_buffer
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|JOINER
argument_list|)
comment|/* Make sure that user does not collide with our internal 	       naming scheme.  */
if|if
condition|(
name|JOINER
operator|==
literal|'$'
operator|&&
name|dollar_seen
operator|&&
operator|(
name|THIS_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|VPTR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|VTABLE_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|TEMP_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|ANON_PARMNAME_P
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"identifier name `%s' conflicts with GNU C++ internal naming strategy"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yylval
operator|.
name|ttype
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|NEW
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
block|{
name|value
operator|=
name|NEW
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
break|break;
case|case
literal|'.'
case|:
block|{
specifier|register
name|int
name|c1
init|=
name|getch
argument_list|()
decl_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'*'
condition|)
block|{
name|value
operator|=
name|DOT_STAR
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|c1
operator|==
literal|'.'
condition|)
block|{
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'.'
condition|)
block|{
name|token_buffer
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
name|token_buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ELLIPSIS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
argument_list|(
literal|"parse error at `..'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|put_back
argument_list|(
name|c1
argument_list|)
expr_stmt|;
goto|goto
name|resume_numerical_scan
goto|;
block|}
name|nextchar
operator|=
name|c1
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
comment|/* Optimize for most frequent case.  */
block|{
specifier|register
name|int
name|c1
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|c1
argument_list|)
operator|&&
name|c1
operator|!=
literal|'.'
condition|)
block|{
comment|/* Terminate string.  */
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|integer_one_node
expr_stmt|;
name|nextchar
operator|=
name|c1
expr_stmt|;
name|value
operator|=
name|CONSTANT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|put_back
argument_list|(
name|c1
argument_list|)
expr_stmt|;
block|}
comment|/* fall through...  */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|resume_numerical_scan
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|numdigits
init|=
literal|0
decl_stmt|;
comment|/* for multi-precision arithmetic, 	   we actually store only HOST_BITS_PER_CHAR bits in each part. 	   The number of parts is chosen so as to be sufficient to hold 	   the enough bits to fit into the two HOST_WIDE_INTs that contain 	   the integer value (this is always at least as many bits as are 	   in a target `long long' value, but may be wider).  */
define|#
directive|define
name|TOTAL_PARTS
value|((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)
name|int
name|parts
index|[
name|TOTAL_PARTS
index|]
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
enum|enum
name|anon1
block|{
name|NOT_FLOAT
block|,
name|AFTER_POINT
block|,
name|TOO_MANY_POINTS
block|}
name|floatflag
init|=
name|NOT_FLOAT
enum|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
name|parts
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
block|}
comment|/* Leading 0 forces octal unless the 0 is the only digit.  */
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
block|}
else|else
name|numdigits
operator|++
expr_stmt|;
block|}
comment|/* Read all the digits-and-decimal-points.  */
while|while
condition|(
name|c
operator|==
literal|'.'
operator|||
operator|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'l'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'u'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'U'
operator|)
operator|&&
name|c
operator|!=
literal|'i'
operator|&&
name|c
operator|!=
literal|'I'
operator|&&
name|c
operator|!=
literal|'j'
operator|&&
name|c
operator|!=
literal|'J'
operator|&&
operator|(
name|floatflag
operator|==
name|NOT_FLOAT
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'f'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
name|error
argument_list|(
literal|"floating constant may not be in radix 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatflag
operator|==
name|TOO_MANY_POINTS
condition|)
comment|/* We have already emitted an error.  Don't need another.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|floatflag
operator|==
name|AFTER_POINT
condition|)
block|{
name|error
argument_list|(
literal|"malformed floating constant"
argument_list|)
expr_stmt|;
name|floatflag
operator|=
name|TOO_MANY_POINTS
expr_stmt|;
comment|/* Avoid another error from atof by forcing all characters 		       from here on to be ignored.  */
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Accept '.' as the start of a floating-point number 		   only when it is followed by a digit. 		   Otherwise, unread the following non-digit 		   and use the '.' as a structural token.  */
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
literal|2
operator|&&
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|ELLIPSIS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
argument_list|(
literal|"parse error at `..'"
argument_list|)
expr_stmt|;
block|}
name|nextchar
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* It is not a decimal point. 		   It should be a digit (perhaps a hex digit).  */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
name|error
argument_list|(
literal|"nondigits in number and not hexadecimal"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|largest_digit
condition|)
name|largest_digit
operator|=
name|c
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
block|{
name|parts
index|[
name|count
index|]
operator|*=
name|base
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|parts
index|[
name|count
index|]
operator|+=
operator|(
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|>>
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|parts
index|[
literal|0
index|]
operator|+=
name|c
expr_stmt|;
block|}
comment|/* If the extra highest-order part ever gets anything in it, 		   the number is certainly too big.  */
if|if
condition|(
name|parts
index|[
name|TOTAL_PARTS
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numdigits
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"numeric constant with no digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest_digit
operator|>=
name|base
condition|)
name|error
argument_list|(
literal|"numeric constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
comment|/* Remove terminating char from the token buffer and delimit the string */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|floatflag
operator|!=
name|NOT_FLOAT
condition|)
block|{
name|tree
name|type
init|=
name|double_type_node
decl_stmt|;
name|int
name|exceeds_double
init|=
literal|0
decl_stmt|;
name|int
name|imag
init|=
literal|0
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|struct
name|pf_args
name|args
decl_stmt|;
comment|/* Read explicit exponent if any, and put it in tokenbuf.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"floating constant exponent has no digits"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Setup input for parse_float() */
name|args
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|args
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|args
operator|.
name|imag
operator|=
name|imag
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* Convert string to a double, checking for overflow.  */
if|if
condition|(
name|do_float_handler
argument_list|(
name|parse_float
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|args
argument_list|)
condition|)
block|{
comment|/* Receive output from parse_float() */
name|value
operator|=
name|args
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* We got an exception from parse_float() */
name|error
argument_list|(
literal|"floating constant out of range"
argument_list|)
expr_stmt|;
name|value
operator|=
name|dconst0
expr_stmt|;
block|}
comment|/* Receive output from parse_float() */
name|p
operator|=
name|args
operator|.
name|p
expr_stmt|;
name|c
operator|=
name|args
operator|.
name|c
expr_stmt|;
name|imag
operator|=
name|args
operator|.
name|imag
expr_stmt|;
name|type
operator|=
name|args
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|&&
name|pedantic
condition|)
block|{
comment|/* ERANGE is also reported for underflow,   		   so test the value to distinguish overflow from that.  */
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|dconst1
argument_list|,
name|value
argument_list|)
operator|||
name|REAL_VALUES_LESS
argument_list|(
name|value
argument_list|,
name|dconstm1
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"floating point number exceeds range of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exceeds_double
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* If the result is not a number, assume it must have been 	       due to some error message above, so silently convert 	       it to a zero.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|dconst0
expr_stmt|;
comment|/* Create a node with determined type and value.  */
if|if
condition|(
name|imag
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|cp_convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|int
name|spec_unsigned
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_long_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_imag
init|=
literal|0
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|warn
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|spec_unsigned
condition|)
name|error
argument_list|(
literal|"two `u's in integer constant"
argument_list|)
expr_stmt|;
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|spec_long
condition|)
block|{
if|if
condition|(
name|spec_long_long
condition|)
name|error
argument_list|(
literal|"three `l's in integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids long long integer constants"
argument_list|)
expr_stmt|;
name|spec_long_long
operator|=
literal|1
expr_stmt|;
block|}
name|spec_long
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|||
name|c
operator|==
literal|'j'
operator|||
name|c
operator|==
literal|'I'
operator|||
name|c
operator|==
literal|'J'
condition|)
block|{
if|if
condition|(
name|spec_imag
condition|)
name|error
argument_list|(
literal|"more than one `i' or `j' in numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|spec_imag
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
comment|/* If the constant is not long long and it won't fit in an 	       unsigned long, or if the constant is long long and won't fit 	       in an unsigned long long, then warn that the constant is out 	       of range.  */
comment|/* ??? This assumes that long long and long integer types are 	       a multiple of 8 bits.  This better than the original code 	       though which assumed that long was exactly 32 bits and long 	       long was exactly 64 bits.  */
if|if
condition|(
name|spec_long_long
condition|)
name|bytes
operator|=
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|/
literal|8
expr_stmt|;
else|else
name|bytes
operator|=
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|/
literal|8
expr_stmt|;
name|warn
operator|=
name|overflow
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bytes
init|;
name|i
operator|<
name|TOTAL_PARTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|parts
index|[
name|i
index|]
condition|)
name|warn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* This is simplified by the fact that our constant 	       is always positive.  */
name|high
operator|=
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
control|)
block|{
name|high
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
operator|+
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
operator|)
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
operator|)
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
block|}
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
comment|/* Calculate the ANSI type.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|(
name|base
operator|!=
literal|10
operator|||
name|spec_unsigned
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
comment|/* Nondecimal constants try unsigned even in traditional C.  */
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
comment|/* Verify value does not overflow into sign bit.  */
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|>=
literal|0
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|type
argument_list|)
operator|&&
operator|!
name|warn
condition|)
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|10
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"decimal integer constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_imag
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_complex
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|cp_convert
argument_list|(
name|integer_type_node
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"complex integer constant is too wide for `__complex int'"
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
name|char_constant
label|:
block|{
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|num_chars
init|=
literal|0
decl_stmt|;
name|int
name|chars_seen
init|=
literal|0
decl_stmt|;
name|unsigned
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|longest_char
init|=
name|local_mb_cur_max
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|max_chars
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|width
operator|=
name|WCHAR_TYPE_SIZE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tryagain
label|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
operator|++
name|chars_seen
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|tryagain
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
name|width
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_CHARACTER
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids newline in character constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|char_len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|longest_char
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
name|maxtoken
operator|-
literal|4
condition|)
name|extend_token_buffer
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|token_buffer
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|!=
operator|-
literal|1
condition|)
break|break;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|char_len
operator|>
literal|1
condition|)
block|{
comment|/* mbtowc sometimes needs an extra char before accepting */
if|if
condition|(
name|char_len
operator|<
name|i
condition|)
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
comment|/* Merge character into result; ignore excess chars.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|char_len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
name|max_chars
condition|)
break|break;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|token_buffer
index|[
name|i
index|]
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|token_buffer
index|[
name|i
index|]
expr_stmt|;
block|}
name|num_chars
operator|+=
name|char_len
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|c
operator|=
name|wc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|c
operator|=
name|wc
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_CHARACTER
else|else
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* ! MULTIBYTE_CHARS */
ifdef|#
directive|ifdef
name|MAP_CHARACTER
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ! MULTIBYTE_CHARS */
block|}
if|if
condition|(
name|wide_flag
condition|)
block|{
if|if
condition|(
name|chars_seen
operator|==
literal|1
condition|)
comment|/* only keep the first one */
name|result
operator|=
name|c
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* Merge character into result; ignore excess chars.  */
name|num_chars
operator|++
expr_stmt|;
if|if
condition|(
name|num_chars
operator|<
name|max_chars
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chars_seen
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|num_chars
operator|=
name|max_chars
expr_stmt|;
name|error
argument_list|(
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_seen
operator|!=
literal|1
operator|&&
name|warn_multichar
condition|)
name|warning
argument_list|(
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|int
name|num_bits
init|=
name|num_chars
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|num_bits
operator|==
literal|0
condition|)
comment|/* We already got an error; avoid invalid shift.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|char_type_node
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator|&
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator||
operator|~
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_seen
operator|<=
literal|1
condition|)
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_type_node
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'"'
case|:
name|string_constant
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|width
init|=
name|wide_flag
condition|?
name|WCHAR_TYPE_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|int
name|longest_char
init|=
name|local_mb_cur_max
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|local_mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|p
operator|=
name|token_buffer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
comment|/* ignore_escape_flag is set for reading the filename in #line.  */
if|if
condition|(
operator|!
name|ignore_escape_flag
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|skipnewline
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
name|width
operator|)
condition|)
name|warning
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|wchar_t
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|char_len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|longest_char
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|p
operator|+
name|i
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|char_len
operator|=
name|local_mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_len
operator|!=
operator|-
literal|1
condition|)
break|break;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|char_len
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* mbtowc sometimes needs an extra char before accepting */
if|if
condition|(
name|char_len
operator|<=
name|i
condition|)
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|p
operator|+=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|wc
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE_CHARS */
block|}
comment|/* Add this single character into the buffer either as a wchar_t 	       or as a single byte.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
name|unsigned
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|unsigned
name|bytemask
init|=
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|byte
decl_stmt|;
if|if
condition|(
name|p
operator|+
name|WCHAR_BYTES
operator|>
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|WCHAR_BYTES
condition|;
operator|++
name|byte
control|)
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|byte
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|c
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|c
operator|>>
operator|(
name|byte
operator|*
name|width
operator|)
operator|)
operator|&
name|bytemask
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|p
index|[
name|WCHAR_BYTES
operator|-
name|byte
operator|-
literal|1
index|]
operator|=
name|value
expr_stmt|;
else|else
name|p
index|[
name|byte
index|]
operator|=
name|value
expr_stmt|;
block|}
name|p
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|skipnewline
label|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Terminate the string value, either with a single byte zero 	   or with a wide zero.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
if|if
condition|(
name|p
operator|+
name|WCHAR_BYTES
operator|>
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
name|p
operator|+=
name|WCHAR_BYTES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We have read the entire constant. 	   Construct a STRING_CST for the result.  */
if|if
condition|(
name|processing_template_decl
condition|)
name|push_obstacks
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|p
operator|-
operator|(
name|token_buffer
operator|+
literal|1
operator|)
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|pop_obstacks
argument_list|()
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
break|break;
block|}
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
block|{
specifier|register
name|int
name|c1
decl_stmt|;
name|combine
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|yylval
operator|.
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|yylval
operator|.
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|yylval
operator|.
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|RSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|yylval
operator|.
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|yylval
operator|.
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
block|}
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'>'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'!'
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|NE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'='
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|value
operator|=
name|ASSIGN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|c1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|value
operator|=
name|PLUSPLUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
name|MINUSMINUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'&'
case|:
name|value
operator|=
name|ANDAND
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'|'
case|:
name|value
operator|=
name|OROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'<'
case|:
name|c
operator|=
name|LSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
case|case
literal|'>'
case|:
name|c
operator|=
name|RSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|c1
operator|==
literal|'>'
operator|)
condition|)
block|{
name|nextchar
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'*'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|value
operator|=
name|POINTSAT_STAR
expr_stmt|;
block|}
else|else
name|value
operator|=
name|POINTSAT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'?'
operator|&&
operator|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'>'
operator|)
condition|)
block|{
name|token_buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
operator|(
name|c
operator|==
literal|'<'
condition|?
name|MIN_EXPR
else|:
name|MAX_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
comment|/*<?= or>?= expression.  */
name|token_buffer
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
name|value
operator|=
name|ASSIGN
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|MIN_MAX
expr_stmt|;
name|nextchar
operator|=
name|c1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"use of `operator %s' is not standard C++"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* digraphs */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
operator|&&
name|c1
operator|==
literal|'%'
condition|)
block|{
name|value
operator|=
literal|'{'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
operator|&&
name|c1
operator|==
literal|':'
condition|)
block|{
name|value
operator|=
literal|'['
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|c1
operator|==
literal|'>'
condition|)
block|{
name|value
operator|=
literal|'}'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|c1
operator|==
literal|':'
condition|)
block|{
name|value
operator|=
literal|'#'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c1
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|':'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|SCOPE
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|value
operator|=
literal|']'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
literal|':'
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* Don't make yyparse think this is eof.  */
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* try, weakly, to handle casts to pointers to functions.  */
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'*'
condition|)
block|{
name|int
name|next_c
init|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_c
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|PAREN_STAR_PAREN
expr_stmt|;
block|}
else|else
block|{
name|put_back
argument_list|(
name|next_c
argument_list|)
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nextchar
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|NULL_TREE
expr_stmt|;
name|value
operator|=
name|LEFT_RIGHT
expr_stmt|;
block|}
else|else
name|value
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
block|}
name|done
label|:
comment|/*  yylloc.last_line = lineno; */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
name|token_count
index|[
name|value
index|]
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_function
name|int
name|is_rid
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
operator|!
operator|!
name|is_reserved_word
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* The original for tree_node_kind is in the toplevel tree.c; changes there    need to be brought into here, unless this were actually put into a header    instead.  */
end_comment

begin_comment
comment|/* Statistics-gathering stuff.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|d_kind
block|,
name|t_kind
block|,
name|b_kind
block|,
name|s_kind
block|,
name|r_kind
block|,
name|e_kind
block|,
name|c_kind
block|,
name|id_kind
block|,
name|op_id_kind
block|,
name|perm_list_kind
block|,
name|temp_list_kind
block|,
name|vec_kind
block|,
name|x_kind
block|,
name|lang_decl
block|,
name|lang_type
block|,
name|all_kinds
block|}
name|tree_node_kind
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|tree_node_counts
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tree_node_sizes
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Place to save freed lang_decls which were allocated on the    permanent_obstack.  @@ Not currently used.  */
end_comment

begin_decl_stmt
name|tree
name|free_lang_decl_chain
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_lang_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|retrofit_lang_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Add DECL_LANG_SPECIFIC info to T.  Called from build_lang_decl    and pushdecl (for functions generated by the backend).  */
end_comment

begin_function
name|void
name|retrofit_lang_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
comment|/* Could be that saveable is permanent and current is not.  */
name|obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
if|if
condition|(
name|free_lang_decl_chain
operator|&&
name|obstack
operator|==
operator|&
name|permanent_obstack
condition|)
block|{
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|free_lang_decl_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
name|LANG_DECL_PERMANENT
argument_list|(
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
argument_list|)
operator|=
name|obstack
operator|==
operator|&
name|permanent_obstack
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|LANG_DECL_PERMANENT
argument_list|(
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
argument_list|)
operator|==
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|234
argument_list|)
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_c
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_java
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|64
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|if (code == TYPE_DECL)     {       tree id;       id = get_identifier (build_overload_name (type, 1, 1));       DECL_ASSEMBLER_NAME (t) = id;     }
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|tree
name|build_lang_field_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|if (code == TYPE_DECL)     {       tree id;       id = get_identifier (build_overload_name (type, 1, 1));       DECL_ASSEMBLER_NAME (t) = id;     }
endif|#
directive|endif
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
name|my_friendly_assert
argument_list|(
name|obstack
operator|==
operator|&
name|permanent_obstack
argument_list|,
literal|235
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|copy_lang_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pi
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|make_lang_type
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* Set up some flags that give proper default behavior.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|pi
decl_stmt|;
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
name|my_friendly_assert
argument_list|(
name|obstack
operator|==
operator|&
name|permanent_obstack
argument_list|,
literal|236
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pi
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|pi
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
comment|/* Make sure this is laid out, for ease of use later.  In the 	 presence of parse errors, the normal was of assuring this 	 might not ever get executed, so we lay it out *immediately*.  */
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,        TYPE_ALIAS_SET is initialized to -1 by default, so we must        clear it here.  */
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We need to allocate a TYPE_BINFO even for TEMPALTE_TYPE_PARMs      since they can be virtual base types, and we then need a      canonical binfo for them.  Ideally, this would be done lazily for      all types.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|dump_time_statistics
parameter_list|()
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
name|int
name|this_time
init|=
name|my_get_run_time
argument_list|()
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|TIME_IDENTIFIER_TIME
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"header files (total)"
argument_list|,
name|header_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"main file (total)"
argument_list|,
name|this_time
operator|-
name|body_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratio = %g : 1\n"
argument_list|,
operator|(
name|double
operator|)
name|header_time
operator|/
call|(
name|double
call|)
argument_list|(
name|this_time
operator|-
name|body_time
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|filename_times
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
for|for
control|(
name|decl
operator|=
name|prev
init|;
name|decl
condition|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
control|)
name|print_time
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TIME_IDENTIFIER_TIME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|compiler_error
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|"%s (compiler error)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|yyerror
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|extern
name|int
name|end_of_file
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* We can't print string and character constants well      because the token_buffer contains the result of processing escapes.  */
if|if
condition|(
name|end_of_file
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|input_redirected
argument_list|()
condition|?
literal|" at end of saved text"
else|:
literal|" at end of input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" at null character"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before string constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISGRAPH
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|" before character 0%o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|handle_cp_pragma
parameter_list|(
name|pname
parameter_list|)
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
block|{
specifier|register
name|int
name|token
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
literal|"vtable"
argument_list|)
condition|)
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
comment|/* More follows: it must be a string constant (class name).  */
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma vtable"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|write_virtuals
operator|!=
literal|2
condition|)
block|{
name|warning
argument_list|(
literal|"use `+e2' option to enable #pragma vtable"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pending_vtables
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|END_OF_LINE
condition|)
name|warning
argument_list|(
literal|"trailing characters ignored"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
literal|"unit"
argument_list|)
condition|)
block|{
comment|/* More follows: it must be a string constant (unit name).  */
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma unit"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|END_OF_LINE
condition|)
name|warning
argument_list|(
literal|"trailing characters ignored"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
literal|"interface"
argument_list|)
condition|)
block|{
name|tree
name|fileinfo
init|=
name|TIME_IDENTIFIER_FILEINFO
argument_list|(
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|main_filename
init|=
name|input_filename
decl_stmt|;
name|main_filename
operator|=
name|file_name_nondirectory
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|END_OF_LINE
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid `#pragma interface'"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|END_OF_LINE
condition|)
name|warning
argument_list|(
literal|"garbage after `#pragma interface' ignored"
argument_list|)
expr_stmt|;
name|write_virtuals
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
comment|/* If this is zero at this point, then we are 	     auto-implementing.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_IMPLEMENT
name|filename
operator|=
name|file_name_nondirectory
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_time_identifier
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fi
operator|=
name|TIME_IDENTIFIER_FILEINFO
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fi
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fi
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Get default.  */
name|impl_file_chain
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|impl_file_chain
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|impl_file_chain
operator|->
name|next
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|interface_only
operator|=
name|interface_strcmp
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIPLE_SYMBOL_SPACES
if|if
condition|(
operator|!
name|interface_only
condition|)
name|interface_unknown
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* MULTIPLE_SYMBOL_SPACES */
name|interface_unknown
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIPLE_SYMBOL_SPACES */
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pname
argument_list|,
literal|"implementation"
argument_list|)
condition|)
block|{
name|tree
name|fileinfo
init|=
name|TIME_IDENTIFIER_FILEINFO
argument_list|(
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|main_filename
init|=
name|main_input_filename
condition|?
name|main_input_filename
else|:
name|input_filename
decl_stmt|;
name|main_filename
operator|=
name|file_name_nondirectory
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|END_OF_LINE
condition|)
block|{
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid `#pragma implementation'"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|END_OF_LINE
condition|)
name|warning
argument_list|(
literal|"garbage after `#pragma implementation' ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
block|{
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
while|while
condition|(
name|ifiles
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifiles
operator|->
name|filename
argument_list|,
name|main_filename
argument_list|)
condition|)
break|break;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ifiles
operator|==
literal|0
condition|)
block|{
name|ifiles
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|ifiles
operator|->
name|next
operator|=
name|impl_file_chain
expr_stmt|;
name|impl_file_chain
operator|=
name|ifiles
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|main_input_filename
operator|!=
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|main_input_filename
argument_list|,
name|input_filename
argument_list|)
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|input_filename
argument_list|,
name|main_filename
argument_list|)
condition|)
block|{
name|write_virtuals
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
name|impl_file_chain
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|impl_file_chain
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|impl_file_chain
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"`#pragma implementation' can only appear at top-level"
argument_list|)
expr_stmt|;
name|interface_only
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|1
comment|/* We make this non-zero so that we infer decl linkage 	 in the impl file only for variables first declared 	 in the interface file.  */
name|interface_unknown
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* We make this zero so that templates in the impl 	 file will be emitted properly.  */
name|interface_unknown
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the type-qualifier corresponding to the identifier given by    RID.  */
end_comment

begin_function
name|int
name|cp_type_qual_from_rid
parameter_list|(
name|rid
parameter_list|)
name|tree
name|rid
decl_stmt|;
block|{
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
return|return
name|TYPE_QUAL_CONST
return|;
elseif|else
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
return|return
name|TYPE_QUAL_VOLATILE
return|;
elseif|else
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
condition|)
return|return
name|TYPE_QUAL_RESTRICT
return|;
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|TYPE_UNQUALIFIED
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_GENERIC_PRAGMAS
end_ifdef

begin_comment
comment|/* Handle a #pragma directive.  TOKEN is the type of the word following    the #pragma directive on the line.  Process the entire input line and    return non-zero iff the directive successfully parsed.  */
end_comment

begin_comment
comment|/* This function has to be in this file, in order to get at    the token types.  */
end_comment

begin_function
specifier|static
name|int
name|handle_generic_pragma
parameter_list|(
name|token
parameter_list|)
specifier|register
name|int
name|token
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|STRING
case|:
case|case
name|CONSTANT
case|:
name|handle_pragma_token
argument_list|(
name|token_buffer
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_RIGHT
case|:
name|handle_pragma_token
argument_list|(
literal|"("
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|handle_pragma_token
argument_list|(
literal|")"
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|END_OF_LINE
case|:
return|return
name|handle_pragma_token
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_TREE
argument_list|)
return|;
default|default:
name|handle_pragma_token
argument_list|(
name|token_buffer
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_GENERIC_PRAGMAS */
end_comment

end_unit

