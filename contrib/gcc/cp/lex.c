begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Separate lexical analyzer for GNU C++.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is the lexical analyzer for GNU C++.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"lex.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|"mbchar.h"
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|yyprint
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|YYSTYPE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interface_strcmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|init_cpp_parse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_cp_pragma
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|parse_strconst_pragma
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_vtable
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_unit
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_interface
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_implementation
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_pragma_java_exceptions
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|reduce_cmp
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|token_cmp
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|is_global
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_operators
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_lang_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A constraint that can be tested at compile time.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|CONSTRAINT
parameter_list|(
name|name
parameter_list|,
name|expr
parameter_list|)
value|extern int constraint_##name [(expr) ? 1 : -1]
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONSTRAINT
parameter_list|(
name|name
parameter_list|,
name|expr
parameter_list|)
value|extern int constraint_
comment|/**/
value|name [(expr) ? 1 : -1]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.  yylex    must look this up to detect typedefs, which get token type    tTYPENAME, so it is left around in case the identifier is not a    typedef but is used in a context which makes it a reference to a    variable.  */
end_comment

begin_decl_stmt
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array for holding counts of the numbers of tokens seen.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions and data structures for #pragma interface.     `#pragma implementation' means that the main file being compiled    is considered to implement (provide) the classes that appear in    its main body.  I.e., if this is file "foo.cc", and class `bar'    is defined in "foo.cc", then we say that "foo.cc implements bar".     All main input files "implement" themselves automagically.     `#pragma interface' means that unless this file (of the form "foo.h"    is not presently being included by file "foo.cc", the    CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none    of the vtables nor any of the inline functions defined in foo.h    will ever be output.     There are cases when we want to link files such as "defs.h" and    "main.cc".  In this case, we give "defs.h" a `#pragma interface',    and "main.cc" has `#pragma implementation "defs.h"'.  */
end_comment

begin_struct
struct|struct
name|impl_files
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|impl_files
modifier|*
name|impl_file_chain
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    CV_QUALIFIERS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|cv_qualifiers
parameter_list|,
name|target
parameter_list|)
name|tree
name|cv_qualifiers
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `*'"
argument_list|)
expr_stmt|;
name|target
operator|=
name|build_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a&.    TARGET is the absolute declarator that the& contains.    CV_QUALIFIERS is a list of modifiers such as const or volatile    to apply to the reference type, represented as identifiers.     We return an ADDR_EXPR whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_reference_declarator
parameter_list|(
name|cv_qualifiers
parameter_list|,
name|target
parameter_list|)
name|tree
name|cv_qualifiers
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare pointers to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `&'"
argument_list|)
expr_stmt|;
block|}
name|target
operator|=
name|build_nt
argument_list|(
name|ADDR_EXPR
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|tree
name|make_call_declarator
parameter_list|(
name|target
parameter_list|,
name|parms
parameter_list|,
name|cv_qualifiers
parameter_list|,
name|exception_specification
parameter_list|)
name|tree
name|target
decl_stmt|,
name|parms
decl_stmt|,
name|cv_qualifiers
decl_stmt|,
name|exception_specification
decl_stmt|;
block|{
name|target
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|target
argument_list|,
name|tree_cons
argument_list|(
name|parms
argument_list|,
name|cv_qualifiers
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
comment|/* The third operand is really RTL.  We 			shouldn't put anything there.  */
name|NULL_TREE
argument_list|)
expr_stmt|;
name|CALL_DECLARATOR_EXCEPTION_SPEC
argument_list|(
name|target
argument_list|)
operator|=
name|exception_specification
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|void
name|set_quals_and_spec
parameter_list|(
name|call_declarator
parameter_list|,
name|cv_qualifiers
parameter_list|,
name|exception_specification
parameter_list|)
name|tree
name|call_declarator
decl_stmt|,
name|cv_qualifiers
decl_stmt|,
name|exception_specification
decl_stmt|;
block|{
name|CALL_DECLARATOR_QUALS
argument_list|(
name|call_declarator
argument_list|)
operator|=
name|cv_qualifiers
expr_stmt|;
name|CALL_DECLARATOR_EXCEPTION_SPEC
argument_list|(
name|call_declarator
argument_list|)
operator|=
name|exception_specification
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|interface_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not current file is only for 				   interface definitions.  */
end_comment

begin_decl_stmt
name|int
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not we know this class 				   to behave according to #pragma interface.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Initialization before switch parsing.  */
end_comment

begin_function
name|void
name|cxx_init_options
parameter_list|()
block|{
name|c_common_init_options
argument_list|(
name|clk_cplusplus
argument_list|)
expr_stmt|;
comment|/* Default exceptions on.  */
name|flag_exceptions
operator|=
literal|1
expr_stmt|;
comment|/* By default wrap lines at 80 characters.  Is getenv ("COLUMNS")      preferable?  */
name|diagnostic_line_cutoff
argument_list|(
name|global_dc
argument_list|)
operator|=
literal|80
expr_stmt|;
comment|/* By default, emit location information once for every      diagnostic message.  */
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxx_finish
parameter_list|()
block|{
name|c_common_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
name|init_cpp_parse
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
name|reduce_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|REDUCE_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|reduce_count
operator|+=
literal|1
expr_stmt|;
name|token_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|TOKEN_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|token_count
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|token_count
return|;
block|}
end_function

begin_comment
comment|/* A mapping from tree codes to operator name information.  */
end_comment

begin_decl_stmt
name|operator_name_info_t
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but for assignment operators.  */
end_comment

begin_decl_stmt
name|operator_name_info_t
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize data structures that keep track of operator names.  */
end_comment

begin_define
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|C
parameter_list|,
name|M
parameter_list|,
name|AR
parameter_list|,
name|AP
parameter_list|)
define|\
value|CONSTRAINT (C, sizeof "operator " + sizeof NAME<= 256);
end_define

begin_include
include|#
directive|include
file|"operators.def"
end_include

begin_undef
undef|#
directive|undef
name|DEF_OPERATOR
end_undef

begin_function
specifier|static
name|void
name|init_operators
parameter_list|()
block|{
name|tree
name|identifier
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|operator_name_info_t
modifier|*
name|oni
decl_stmt|;
define|#
directive|define
name|DEF_OPERATOR
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|MANGLING
parameter_list|,
name|ARITY
parameter_list|,
name|ASSN_P
parameter_list|)
define|\
value|sprintf (buffer, ISALPHA (NAME[0]) ? "operator %s" : "operator%s", NAME); \   identifier = get_identifier (buffer);					    \   IDENTIFIER_OPNAME_P (identifier) = 1;					    \ 									    \   oni = (ASSN_P								    \ 	 ?&assignment_operator_name_info[(int) CODE]			    \ 	 :&operator_name_info[(int) CODE]);				    \   oni->identifier = identifier;						    \   oni->name = NAME;							    \   oni->mangled_name = MANGLING;                                             \   oni->arity = ARITY;
include|#
directive|include
file|"operators.def"
undef|#
directive|undef
name|DEF_OPERATOR
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ERROR_MARK
index|]
operator|.
name|identifier
operator|=
name|get_identifier
argument_list|(
literal|"<invalid operator>"
argument_list|)
expr_stmt|;
comment|/* Handle some special cases.  These operators are not defined in      the language, but can be produced internally.  We may need them      for error-reporting.  (Eventually, we should ensure that this      does not happen.  Error messages involving these operators will      be confusing to users.)  */
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|INIT_EXPR
index|]
operator|.
name|name
operator|=
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|.
name|name
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round /)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round %)"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|ABS_EXPR
index|]
operator|.
name|name
operator|=
literal|"abs"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|FFS_EXPR
index|]
operator|.
name|name
operator|=
literal|"ffs"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|BIT_ANDTC_EXPR
index|]
operator|.
name|name
operator|=
literal|"&~"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TRUTH_AND_EXPR
index|]
operator|.
name|name
operator|=
literal|"strict&&"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|TRUTH_OR_EXPR
index|]
operator|.
name|name
operator|=
literal|"strict ||"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|IN_EXPR
index|]
operator|.
name|name
operator|=
literal|"in"
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|RANGE_EXPR
index|]
operator|.
name|name
operator|=
literal|"..."
expr_stmt|;
name|operator_name_info
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|.
name|name
operator|=
literal|"+"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(exact /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round /=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(ceiling %=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(floor %=)"
expr_stmt|;
name|assignment_operator_name_info
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|.
name|name
operator|=
literal|"(round %=)"
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The reserved keyword table.  */
end_comment

begin_struct
struct|struct
name|resword
block|{
specifier|const
name|char
modifier|*
specifier|const
name|word
decl_stmt|;
specifier|const
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
name|rid
operator|:
literal|16
expr_stmt|;
specifier|const
name|unsigned
name|int
name|disable
range|:
literal|16
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Disable mask.  Keywords are disabled if (reswords[i].disable& mask) is    _true_.  */
end_comment

begin_define
define|#
directive|define
name|D_EXT
value|0x01
end_define

begin_comment
comment|/* GCC extension */
end_comment

begin_define
define|#
directive|define
name|D_ASM
value|0x02
end_define

begin_comment
comment|/* in C99, but has a switch to turn it off */
end_comment

begin_expr_stmt
name|CONSTRAINT
argument_list|(
name|ridbits_fit
argument_list|,
name|RID_LAST_MODIFIER
operator|<
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
name|CHAR_BIT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|resword
name|reswords
index|[]
init|=
block|{
block|{
literal|"_Complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__FUNCTION__"
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__PRETTY_FUNCTION__"
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof__"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__asm"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__asm__"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute__"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_va_arg"
block|,
name|RID_VA_ARG
block|,
literal|0
block|}
block|,
block|{
literal|"__complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__complex__"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__const__"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__extension__"
block|,
name|RID_EXTENSION
block|,
literal|0
block|}
block|,
block|{
literal|"__func__"
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__imag"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__imag__"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__inline__"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__label__"
block|,
name|RID_LABEL
block|,
literal|0
block|}
block|,
block|{
literal|"__null"
block|,
name|RID_NULL
block|,
literal|0
block|}
block|,
block|{
literal|"__real"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__real__"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict__"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__signed__"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__thread"
block|,
name|RID_THREAD
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof__"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile__"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"asm"
block|,
name|RID_ASM
block|,
name|D_ASM
block|}
block|,
block|{
literal|"auto"
block|,
name|RID_AUTO
block|,
literal|0
block|}
block|,
block|{
literal|"bool"
block|,
name|RID_BOOL
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|RID_BREAK
block|,
literal|0
block|}
block|,
block|{
literal|"case"
block|,
name|RID_CASE
block|,
literal|0
block|}
block|,
block|{
literal|"catch"
block|,
name|RID_CATCH
block|,
literal|0
block|}
block|,
block|{
literal|"char"
block|,
name|RID_CHAR
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
name|RID_CLASS
block|,
literal|0
block|}
block|,
block|{
literal|"const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"const_cast"
block|,
name|RID_CONSTCAST
block|,
literal|0
block|}
block|,
block|{
literal|"continue"
block|,
name|RID_CONTINUE
block|,
literal|0
block|}
block|,
block|{
literal|"default"
block|,
name|RID_DEFAULT
block|,
literal|0
block|}
block|,
block|{
literal|"delete"
block|,
name|RID_DELETE
block|,
literal|0
block|}
block|,
block|{
literal|"do"
block|,
name|RID_DO
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
name|RID_DOUBLE
block|,
literal|0
block|}
block|,
block|{
literal|"dynamic_cast"
block|,
name|RID_DYNCAST
block|,
literal|0
block|}
block|,
block|{
literal|"else"
block|,
name|RID_ELSE
block|,
literal|0
block|}
block|,
block|{
literal|"enum"
block|,
name|RID_ENUM
block|,
literal|0
block|}
block|,
block|{
literal|"explicit"
block|,
name|RID_EXPLICIT
block|,
literal|0
block|}
block|,
block|{
literal|"export"
block|,
name|RID_EXPORT
block|,
literal|0
block|}
block|,
block|{
literal|"extern"
block|,
name|RID_EXTERN
block|,
literal|0
block|}
block|,
block|{
literal|"false"
block|,
name|RID_FALSE
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|RID_FLOAT
block|,
literal|0
block|}
block|,
block|{
literal|"for"
block|,
name|RID_FOR
block|,
literal|0
block|}
block|,
block|{
literal|"friend"
block|,
name|RID_FRIEND
block|,
literal|0
block|}
block|,
block|{
literal|"goto"
block|,
name|RID_GOTO
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
name|RID_IF
block|,
literal|0
block|}
block|,
block|{
literal|"inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|RID_INT
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|RID_LONG
block|,
literal|0
block|}
block|,
block|{
literal|"mutable"
block|,
name|RID_MUTABLE
block|,
literal|0
block|}
block|,
block|{
literal|"namespace"
block|,
name|RID_NAMESPACE
block|,
literal|0
block|}
block|,
block|{
literal|"new"
block|,
name|RID_NEW
block|,
literal|0
block|}
block|,
block|{
literal|"operator"
block|,
name|RID_OPERATOR
block|,
literal|0
block|}
block|,
block|{
literal|"private"
block|,
name|RID_PRIVATE
block|,
literal|0
block|}
block|,
block|{
literal|"protected"
block|,
name|RID_PROTECTED
block|,
literal|0
block|}
block|,
block|{
literal|"public"
block|,
name|RID_PUBLIC
block|,
literal|0
block|}
block|,
block|{
literal|"register"
block|,
name|RID_REGISTER
block|,
literal|0
block|}
block|,
block|{
literal|"reinterpret_cast"
block|,
name|RID_REINTCAST
block|,
literal|0
block|}
block|,
block|{
literal|"return"
block|,
name|RID_RETURN
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|RID_SHORT
block|,
literal|0
block|}
block|,
block|{
literal|"signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof"
block|,
name|RID_SIZEOF
block|,
literal|0
block|}
block|,
block|{
literal|"static"
block|,
name|RID_STATIC
block|,
literal|0
block|}
block|,
block|{
literal|"static_cast"
block|,
name|RID_STATCAST
block|,
literal|0
block|}
block|,
block|{
literal|"struct"
block|,
name|RID_STRUCT
block|,
literal|0
block|}
block|,
block|{
literal|"switch"
block|,
name|RID_SWITCH
block|,
literal|0
block|}
block|,
block|{
literal|"template"
block|,
name|RID_TEMPLATE
block|,
literal|0
block|}
block|,
block|{
literal|"this"
block|,
name|RID_THIS
block|,
literal|0
block|}
block|,
block|{
literal|"throw"
block|,
name|RID_THROW
block|,
literal|0
block|}
block|,
block|{
literal|"true"
block|,
name|RID_TRUE
block|,
literal|0
block|}
block|,
block|{
literal|"try"
block|,
name|RID_TRY
block|,
literal|0
block|}
block|,
block|{
literal|"typedef"
block|,
name|RID_TYPEDEF
block|,
literal|0
block|}
block|,
block|{
literal|"typename"
block|,
name|RID_TYPENAME
block|,
literal|0
block|}
block|,
block|{
literal|"typeid"
block|,
name|RID_TYPEID
block|,
literal|0
block|}
block|,
block|{
literal|"typeof"
block|,
name|RID_TYPEOF
block|,
name|D_ASM
operator||
name|D_EXT
block|}
block|,
block|{
literal|"union"
block|,
name|RID_UNION
block|,
literal|0
block|}
block|,
block|{
literal|"unsigned"
block|,
name|RID_UNSIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"using"
block|,
name|RID_USING
block|,
literal|0
block|}
block|,
block|{
literal|"virtual"
block|,
name|RID_VIRTUAL
block|,
literal|0
block|}
block|,
block|{
literal|"void"
block|,
name|RID_VOID
block|,
literal|0
block|}
block|,
block|{
literal|"volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"wchar_t"
block|,
name|RID_WCHAR
block|,
literal|0
block|}
block|,
block|{
literal|"while"
block|,
name|RID_WHILE
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table mapping from RID_* constants to yacc token numbers.    Unfortunately we have to have entries for all the keywords in all    three languages.  */
end_comment

begin_decl_stmt
specifier|const
name|short
name|rid_to_yy
index|[
name|RID_MAX
index|]
init|=
block|{
comment|/* RID_STATIC */
name|SCSPEC
block|,
comment|/* RID_UNSIGNED */
name|TYPESPEC
block|,
comment|/* RID_LONG */
name|TYPESPEC
block|,
comment|/* RID_CONST */
name|CV_QUALIFIER
block|,
comment|/* RID_EXTERN */
name|SCSPEC
block|,
comment|/* RID_REGISTER */
name|SCSPEC
block|,
comment|/* RID_TYPEDEF */
name|SCSPEC
block|,
comment|/* RID_SHORT */
name|TYPESPEC
block|,
comment|/* RID_INLINE */
name|SCSPEC
block|,
comment|/* RID_VOLATILE */
name|CV_QUALIFIER
block|,
comment|/* RID_SIGNED */
name|TYPESPEC
block|,
comment|/* RID_AUTO */
name|SCSPEC
block|,
comment|/* RID_RESTRICT */
name|CV_QUALIFIER
block|,
comment|/* C extensions.  Bounded pointers are not yet in C++ */
comment|/* RID_BOUNDED */
literal|0
block|,
comment|/* RID_UNBOUNDED */
literal|0
block|,
comment|/* RID_COMPLEX */
name|TYPESPEC
block|,
comment|/* RID_THREAD */
name|SCSPEC
block|,
comment|/* C++ */
comment|/* RID_FRIEND */
name|SCSPEC
block|,
comment|/* RID_VIRTUAL */
name|SCSPEC
block|,
comment|/* RID_EXPLICIT */
name|SCSPEC
block|,
comment|/* RID_EXPORT */
name|EXPORT
block|,
comment|/* RID_MUTABLE */
name|SCSPEC
block|,
comment|/* ObjC */
comment|/* RID_IN */
literal|0
block|,
comment|/* RID_OUT */
literal|0
block|,
comment|/* RID_INOUT */
literal|0
block|,
comment|/* RID_BYCOPY */
literal|0
block|,
comment|/* RID_BYREF */
literal|0
block|,
comment|/* RID_ONEWAY */
literal|0
block|,
comment|/* C */
comment|/* RID_INT */
name|TYPESPEC
block|,
comment|/* RID_CHAR */
name|TYPESPEC
block|,
comment|/* RID_FLOAT */
name|TYPESPEC
block|,
comment|/* RID_DOUBLE */
name|TYPESPEC
block|,
comment|/* RID_VOID */
name|TYPESPEC
block|,
comment|/* RID_ENUM */
name|ENUM
block|,
comment|/* RID_STRUCT */
name|AGGR
block|,
comment|/* RID_UNION */
name|AGGR
block|,
comment|/* RID_IF */
name|IF
block|,
comment|/* RID_ELSE */
name|ELSE
block|,
comment|/* RID_WHILE */
name|WHILE
block|,
comment|/* RID_DO */
name|DO
block|,
comment|/* RID_FOR */
name|FOR
block|,
comment|/* RID_SWITCH */
name|SWITCH
block|,
comment|/* RID_CASE */
name|CASE
block|,
comment|/* RID_DEFAULT */
name|DEFAULT
block|,
comment|/* RID_BREAK */
name|BREAK
block|,
comment|/* RID_CONTINUE */
name|CONTINUE
block|,
comment|/* RID_RETURN */
name|RETURN_KEYWORD
block|,
comment|/* RID_GOTO */
name|GOTO
block|,
comment|/* RID_SIZEOF */
name|SIZEOF
block|,
comment|/* C extensions */
comment|/* RID_ASM */
name|ASM_KEYWORD
block|,
comment|/* RID_TYPEOF */
name|TYPEOF
block|,
comment|/* RID_ALIGNOF */
name|ALIGNOF
block|,
comment|/* RID_ATTRIBUTE */
name|ATTRIBUTE
block|,
comment|/* RID_VA_ARG */
name|VA_ARG
block|,
comment|/* RID_EXTENSION */
name|EXTENSION
block|,
comment|/* RID_IMAGPART */
name|IMAGPART
block|,
comment|/* RID_REALPART */
name|REALPART
block|,
comment|/* RID_LABEL */
name|LABEL
block|,
comment|/* RID_PTRBASE */
literal|0
block|,
comment|/* RID_PTREXTENT */
literal|0
block|,
comment|/* RID_PTRVALUE */
literal|0
block|,
comment|/* RID_CHOOSE_EXPR */
literal|0
block|,
comment|/* RID_TYPES_COMPATIBLE_P */
literal|0
block|,
comment|/* RID_FUNCTION_NAME */
name|VAR_FUNC_NAME
block|,
comment|/* RID_PRETTY_FUNCTION_NAME */
name|VAR_FUNC_NAME
block|,
comment|/* RID_c99_FUNCTION_NAME */
name|VAR_FUNC_NAME
block|,
comment|/* C++ */
comment|/* RID_BOOL */
name|TYPESPEC
block|,
comment|/* RID_WCHAR */
name|TYPESPEC
block|,
comment|/* RID_CLASS */
name|AGGR
block|,
comment|/* RID_PUBLIC */
name|VISSPEC
block|,
comment|/* RID_PRIVATE */
name|VISSPEC
block|,
comment|/* RID_PROTECTED */
name|VISSPEC
block|,
comment|/* RID_TEMPLATE */
name|TEMPLATE
block|,
comment|/* RID_NULL */
name|CONSTANT
block|,
comment|/* RID_CATCH */
name|CATCH
block|,
comment|/* RID_DELETE */
name|DELETE
block|,
comment|/* RID_FALSE */
name|CXX_FALSE
block|,
comment|/* RID_NAMESPACE */
name|NAMESPACE
block|,
comment|/* RID_NEW */
name|NEW
block|,
comment|/* RID_OPERATOR */
name|OPERATOR
block|,
comment|/* RID_THIS */
name|THIS
block|,
comment|/* RID_THROW */
name|THROW
block|,
comment|/* RID_TRUE */
name|CXX_TRUE
block|,
comment|/* RID_TRY */
name|TRY
block|,
comment|/* RID_TYPENAME */
name|TYPENAME_KEYWORD
block|,
comment|/* RID_TYPEID */
name|TYPEID
block|,
comment|/* RID_USING */
name|USING
block|,
comment|/* casts */
comment|/* RID_CONSTCAST */
name|CONST_CAST
block|,
comment|/* RID_DYNCAST */
name|DYNAMIC_CAST
block|,
comment|/* RID_REINTCAST */
name|REINTERPRET_CAST
block|,
comment|/* RID_STATCAST */
name|STATIC_CAST
block|,
comment|/* Objective-C */
comment|/* RID_ID */
literal|0
block|,
comment|/* RID_AT_ENCODE */
literal|0
block|,
comment|/* RID_AT_END */
literal|0
block|,
comment|/* RID_AT_CLASS */
literal|0
block|,
comment|/* RID_AT_ALIAS */
literal|0
block|,
comment|/* RID_AT_DEFS */
literal|0
block|,
comment|/* RID_AT_PRIVATE */
literal|0
block|,
comment|/* RID_AT_PROTECTED */
literal|0
block|,
comment|/* RID_AT_PUBLIC */
literal|0
block|,
comment|/* RID_AT_PROTOCOL */
literal|0
block|,
comment|/* RID_AT_SELECTOR */
literal|0
block|,
comment|/* RID_AT_INTERFACE */
literal|0
block|,
comment|/* RID_AT_IMPLEMENTATION */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_reswords
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|int
name|mask
init|=
operator|(
operator|(
name|flag_no_asm
condition|?
name|D_ASM
else|:
literal|0
operator|)
operator||
operator|(
name|flag_no_gnu_keywords
condition|?
name|D_EXT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
comment|/* It is not necessary to register ridpointers as a GC root, because      all the trees it points to are permanently interned in the      get_identifier hash anyway.  */
name|ridpointers
operator|=
operator|(
name|tree
operator|*
operator|)
name|xcalloc
argument_list|(
operator|(
name|int
operator|)
name|RID_MAX
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reswords
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|get_identifier
argument_list|(
name|reswords
index|[
name|i
index|]
operator|.
name|word
argument_list|)
expr_stmt|;
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
operator|=
name|reswords
index|[
name|i
index|]
operator|.
name|rid
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|reswords
index|[
name|i
index|]
operator|.
name|rid
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reswords
index|[
name|i
index|]
operator|.
name|disable
operator|&
name|mask
operator|)
condition|)
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_cp_pragma
parameter_list|()
block|{
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"vtable"
argument_list|,
name|handle_pragma_vtable
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"unit"
argument_list|,
name|handle_pragma_unit
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"interface"
argument_list|,
name|handle_pragma_interface
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|0
argument_list|,
literal|"implementation"
argument_list|,
name|handle_pragma_implementation
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|"GCC"
argument_list|,
literal|"interface"
argument_list|,
name|handle_pragma_interface
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|"GCC"
argument_list|,
literal|"implementation"
argument_list|,
name|handle_pragma_implementation
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|parse_in
argument_list|,
literal|"GCC"
argument_list|,
literal|"java_exceptions"
argument_list|,
name|handle_pragma_java_exceptions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the C++ front end.  This function is very sensitive to    the exact order that things are done here.  It would be nice if the    initialization done by this routine were moved to its subroutines,    and the ordering dependencies clarified and reduced.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cxx_init
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|input_filename
operator|=
literal|"<internal>"
expr_stmt|;
name|init_reswords
argument_list|()
expr_stmt|;
name|init_spew
argument_list|()
expr_stmt|;
name|init_tree
argument_list|()
expr_stmt|;
name|init_cp_semantics
argument_list|()
expr_stmt|;
name|init_operators
argument_list|()
expr_stmt|;
name|init_method
argument_list|()
expr_stmt|;
name|init_error
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|class_type_node
operator|=
name|build_int_2
argument_list|(
name|class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|class_type_node
argument_list|)
operator|=
name|class_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CLASS
index|]
operator|=
name|class_type_node
expr_stmt|;
name|record_type_node
operator|=
name|build_int_2
argument_list|(
name|record_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|record_type_node
argument_list|)
operator|=
name|record_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STRUCT
index|]
operator|=
name|record_type_node
expr_stmt|;
name|union_type_node
operator|=
name|build_int_2
argument_list|(
name|union_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|union_type_node
argument_list|)
operator|=
name|union_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNION
index|]
operator|=
name|union_type_node
expr_stmt|;
name|enum_type_node
operator|=
name|build_int_2
argument_list|(
name|enum_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|enum_type_node
argument_list|)
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ENUM
index|]
operator|=
name|enum_type_node
expr_stmt|;
name|cxx_init_decl_processing
argument_list|()
expr_stmt|;
comment|/* Create the built-in __null node.  */
name|null_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_node
argument_list|)
operator|=
name|c_common_type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ridpointers
index|[
name|RID_NULL
index|]
operator|=
name|null_node
expr_stmt|;
name|token_count
operator|=
name|init_cpp_parse
argument_list|()
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|filename
operator|=
name|c_common_init
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|init_cp_pragma
argument_list|()
expr_stmt|;
name|init_repo
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|inline
name|void
name|yyprint
parameter_list|(
name|file
parameter_list|,
name|yychar
parameter_list|,
name|yylval
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|yychar
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|tTYPENAME
case|:
case|case
name|TYPESPEC
case|:
case|case
name|PTYPENAME
case|:
case|case
name|PFUNCNAME
case|:
case|case
name|IDENTIFIER_DEFN
case|:
case|case
name|TYPENAME_DEFN
case|:
case|case
name|PTYPENAME_DEFN
case|:
case|case
name|SCSPEC
case|:
case|case
name|PRE_PARSED_CLASS_DECL
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|224
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGGR
case|:
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|class_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `class'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|record_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `struct'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|union_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `union'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|enum_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `enum'"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONSTANT
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
literal|" 0x%x%016x"
argument_list|,
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
literal|" 0x%lx%016lx"
argument_list|,
else|#
directive|else
literal|" 0x%llx%016llx"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
literal|" 0x%lx%08lx"
argument_list|,
else|#
directive|else
literal|" 0x%x%08x"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GATHER_STATISTICS
argument_list|)
operator|&&
name|defined
argument_list|(
name|REDUCE_LENGTH
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reduce_count
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|REDUCE_LENGTH
value|ARRAY_SIZE (yyr2)
end_define

begin_define
define|#
directive|define
name|TOKEN_LENGTH
value|(256 + ARRAY_SIZE (yytname))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
end_ifdef

begin_function
name|void
name|yyhook
parameter_list|(
name|yyn
parameter_list|)
name|int
name|yyn
decl_stmt|;
block|{
name|reduce_count
index|[
name|yyn
index|]
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|reduce_cmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
name|reduce_count
index|[
operator|*
name|q
index|]
operator|-
name|reduce_count
index|[
operator|*
name|p
index|]
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|token_cmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
name|token_count
index|[
operator|*
name|q
index|]
operator|-
name|token_count
index|[
operator|*
name|p
index|]
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_parse_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
ifdef|#
directive|ifdef
name|REDUCE_LENGTH
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|int
name|i
decl_stmt|;
name|int
name|maxlen
init|=
name|REDUCE_LENGTH
decl_stmt|;
name|unsigned
modifier|*
name|sorted
decl_stmt|;
if|if
condition|(
name|reduce_count
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TOKEN_LENGTH
operator|>
name|REDUCE_LENGTH
condition|)
name|maxlen
operator|=
name|TOKEN_LENGTH
expr_stmt|;
name|sorted
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|maxlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKEN_LENGTH
condition|;
name|i
operator|++
control|)
name|sorted
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|TOKEN_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|token_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKEN_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token_count
index|[
name|idx
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|token_count
index|[
name|idx
index|]
operator|<
name|token_count
index|[
operator|-
literal|1
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"token %d, `%s', count = %d\n"
argument_list|,
name|idx
argument_list|,
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|idx
argument_list|)
index|]
argument_list|,
name|token_count
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDUCE_LENGTH
condition|;
name|i
operator|++
control|)
name|sorted
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|REDUCE_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|reduce_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDUCE_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reduce_count
index|[
name|idx
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|reduce_count
index|[
name|idx
index|]
operator|<
name|reduce_count
index|[
operator|-
literal|1
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rule %d, line %d, count = %d\n"
argument_list|,
name|idx
argument_list|,
name|yyrline
index|[
name|idx
index|]
argument_list|,
name|reduce_count
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Helper function to load global variables with interface    information.  */
end_comment

begin_function
name|void
name|extract_interface_info
parameter_list|()
block|{
name|struct
name|c_fileinfo
modifier|*
name|finfo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag_alt_external_templates
condition|)
block|{
name|tree
name|til
init|=
name|tinst_for_decl
argument_list|()
decl_stmt|;
if|if
condition|(
name|til
condition|)
name|finfo
operator|=
name|get_fileinfo
argument_list|(
name|TINST_FILE
argument_list|(
name|til
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|finfo
condition|)
name|finfo
operator|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|finfo
operator|->
name|interface_only
expr_stmt|;
name|interface_unknown
operator|=
name|finfo
operator|->
name|interface_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if S is not considered part of an    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|interface_strcmp
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Set the interface/implementation bits for this scope.  */
name|struct
name|impl_files
modifier|*
name|ifiles
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
for|for
control|(
name|ifiles
operator|=
name|impl_file_chain
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|t1
init|=
name|ifiles
operator|->
name|filename
decl_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|t1
operator|||
operator|*
name|s1
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|)
name|s1
operator|++
operator|,
name|t1
operator|++
expr_stmt|;
comment|/* A match.  */
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
condition|)
return|return
literal|0
return|;
comment|/* Don't get faked out by xxx.yyy.cc vs xxx.zzz.cc.  */
if|if
condition|(
name|strchr
argument_list|(
name|s1
argument_list|,
literal|'.'
argument_list|)
operator|||
name|strchr
argument_list|(
name|t1
argument_list|,
literal|'.'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|||
name|s1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|t1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* A match.  */
return|return
literal|0
return|;
block|}
comment|/* No matches.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to tell whether the user is missing a semicolon    after a struct or enum declaration.  Emit an error message    if we know the user has blown it.  */
end_comment

begin_function
name|void
name|check_for_missing_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|yychar
operator|>
literal|255
operator|&&
name|yychar
operator|!=
name|SCSPEC
operator|&&
name|yychar
operator|!=
name|IDENTIFIER
operator|&&
name|yychar
operator|!=
name|tTYPENAME
operator|&&
name|yychar
operator|!=
name|CV_QUALIFIER
operator|&&
name|yychar
operator|!=
name|SELFNAME
operator|)
operator|||
name|yychar
operator|==
literal|0
comment|/* EOF */
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"semicolon missing after %s declaration"
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|?
literal|"enum"
else|:
literal|"struct"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"semicolon missing after declaration of `%T'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Could probably also hack cases where class { ... } f (); appears.  */
name|clear_anon_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_got_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_list_got_semicolon
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|note_got_semicolon
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|clear_anon_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a #pragma whose sole argument is a string constant.    If OPT is true, the argument is optional.  */
end_comment

begin_function
specifier|static
name|tree
name|parse_strconst_pragma
parameter_list|(
name|name
parameter_list|,
name|opt
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|opt
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|cpp_ttype
name|t
decl_stmt|;
name|t
operator|=
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|CPP_STRING
condition|)
block|{
name|result
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|t
operator|==
name|CPP_EOF
operator|&&
name|opt
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|"invalid #pragma %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_vtable
parameter_list|(
name|dfile
parameter_list|)
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|parse_strconst_pragma
argument_list|(
literal|"vtable"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sorry
argument_list|(
literal|"#pragma vtable no longer supported"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_unit
parameter_list|(
name|dfile
parameter_list|)
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Validate syntax, but don't do anything.  */
name|parse_strconst_pragma
argument_list|(
literal|"unit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_pragma_interface
parameter_list|(
name|dfile
parameter_list|)
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|fname
init|=
name|parse_strconst_pragma
argument_list|(
literal|"interface"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|c_fileinfo
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|main_filename
decl_stmt|;
if|if
condition|(
name|fname
operator|==
operator|(
name|tree
operator|)
operator|-
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
name|main_filename
operator|=
name|lbasename
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
else|else
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|finfo
operator|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
comment|/* If this is zero at this point, then we are 	 auto-implementing.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
block|}
name|interface_only
operator|=
name|interface_strcmp
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIPLE_SYMBOL_SPACES
if|if
condition|(
operator|!
name|interface_only
condition|)
endif|#
directive|endif
name|interface_unknown
operator|=
literal|0
expr_stmt|;
name|finfo
operator|->
name|interface_only
operator|=
name|interface_only
expr_stmt|;
name|finfo
operator|->
name|interface_unknown
operator|=
name|interface_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that we have seen a #pragma implementation for the key MAIN_FILENAME.    We used to only allow this at toplevel, but that restriction was buggy    in older compilers and it seems reasonable to allow it in the headers    themselves, too.  It only needs to precede the matching #p interface.     We don't touch interface_only or interface_unknown; the user must specify    a matching #p interface for this to have any effect.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_implementation
parameter_list|(
name|dfile
parameter_list|)
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|fname
init|=
name|parse_strconst_pragma
argument_list|(
literal|"implementation"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|main_filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
if|if
condition|(
name|fname
operator|==
operator|(
name|tree
operator|)
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|main_input_filename
condition|)
name|main_filename
operator|=
name|main_input_filename
expr_stmt|;
else|else
name|main_filename
operator|=
name|input_filename
expr_stmt|;
name|main_filename
operator|=
name|lbasename
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_included
argument_list|(
name|parse_in
argument_list|,
name|main_filename
argument_list|)
condition|)
name|warning
argument_list|(
literal|"#pragma implementation for %s appears after file is included"
argument_list|,
name|main_filename
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifiles
operator|->
name|filename
argument_list|,
name|main_filename
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ifiles
operator|==
literal|0
condition|)
block|{
name|ifiles
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|ifiles
operator|->
name|next
operator|=
name|impl_file_chain
expr_stmt|;
name|impl_file_chain
operator|=
name|ifiles
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Indicate that this file uses Java-personality exception handling.  */
end_comment

begin_function
specifier|static
name|void
name|handle_pragma_java_exceptions
parameter_list|(
name|dfile
parameter_list|)
name|cpp_reader
modifier|*
name|dfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
if|if
condition|(
name|c_lex
argument_list|(
operator|&
name|x
argument_list|)
operator|!=
name|CPP_EOF
condition|)
name|warning
argument_list|(
literal|"junk at end of #pragma GCC java_exceptions"
argument_list|)
expr_stmt|;
name|choose_personality_routine
argument_list|(
name|lang_java
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_pending_lang_change
parameter_list|()
block|{
for|for
control|(
init|;
name|pending_lang_change
operator|>
literal|0
condition|;
operator|--
name|pending_lang_change
control|)
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pending_lang_change
operator|<
literal|0
condition|;
operator|++
name|pending_lang_change
control|)
name|pop_lang_context
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if d is in a global scope.  */
end_comment

begin_function
specifier|static
name|int
name|is_global
parameter_list|(
name|d
parameter_list|)
name|tree
name|d
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
literal|1
return|;
case|case
name|OVERLOAD
case|:
name|d
operator|=
name|OVL_FUNCTION
argument_list|(
name|d
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TREE_LIST
case|:
name|d
operator|=
name|TREE_VALUE
argument_list|(
name|d
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|my_friendly_assert
argument_list|(
name|DECL_P
argument_list|(
name|d
argument_list|)
argument_list|,
literal|980629
argument_list|)
expr_stmt|;
return|return
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|d
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Issue an error message indicating that the lookup of NAME (an    IDENTIFIER_NODE) failed.  */
end_comment

begin_function
name|void
name|unqualified_name_lookup_error
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|!=
name|ansi_opname
argument_list|(
name|ERROR_MARK
argument_list|)
condition|)
name|error
argument_list|(
literal|"`%D' not defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"`%D' was not declared in this scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|error_mark_node
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
specifier|static
name|int
name|undeclared_variable_notice
decl_stmt|;
name|error
argument_list|(
literal|"`%D' undeclared (first use this function)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|undeclared_variable_notice
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once for each function it appears in.)"
argument_list|)
expr_stmt|;
name|undeclared_variable_notice
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Prevent repeated error messages.  */
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|name
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|name
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|do_identifier
parameter_list|(
name|token
parameter_list|,
name|parsing
parameter_list|,
name|args
parameter_list|)
specifier|register
name|tree
name|token
decl_stmt|;
name|int
name|parsing
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
specifier|register
name|tree
name|id
decl_stmt|;
name|int
name|lexing
init|=
operator|(
name|parsing
operator|==
literal|1
operator|||
name|parsing
operator|==
literal|3
operator|)
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lexing
condition|)
name|id
operator|=
name|lookup_name
argument_list|(
name|token
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|lastiddecl
expr_stmt|;
if|if
condition|(
name|lexing
operator|&&
name|id
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|id
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* Do Koenig lookup if appropriate (inside templates we build lookup      expressions instead).       [basic.lookup.koenig]: If the ordinary unqualified lookup of the name      finds the declaration of a class member function, the associated      namespaces and classes are not considered.  */
if|if
condition|(
name|args
operator|&&
operator|!
name|current_template_parms
operator|&&
operator|(
operator|!
name|id
operator|||
name|is_global
argument_list|(
name|id
argument_list|)
operator|)
condition|)
name|id
operator|=
name|lookup_arg_dependent
argument_list|(
name|token
argument_list|,
name|id
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Remember that this name has been used in the class definition, as per      [class.scope0] */
if|if
condition|(
name|id
operator|&&
name|parsing
operator|&&
name|parsing
operator|!=
literal|3
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|token
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|error_mark_node
condition|)
block|{
comment|/* lookup_name quietly returns error_mark_node if we're parsing, 	 as we don't want to complain about an identifier that ends up 	 being used as a declarator.  So we call it again to get the error 	 message.  */
name|id
operator|=
name|lookup_name
argument_list|(
name|token
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|id
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|id
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|current_template_parms
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|token
argument_list|)
condition|)
comment|/* A templated conversion operator might exist.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|token
argument_list|)
expr_stmt|;
else|else
block|{
name|unqualified_name_lookup_error
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
block|}
name|id
operator|=
name|check_for_out_of_scope_variable
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* TREE_USED is set in `hack_identifier'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
comment|/* Check access.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|token
argument_list|)
operator|==
name|id
condition|)
name|enforce_access
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
operator|||
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|id
argument_list|)
condition|)
name|id
operator|=
name|DECL_INITIAL
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|id
operator|=
name|hack_identifier
argument_list|(
name|id
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* We must look up dependent names when the template is      instantiated, not while parsing it.  For now, we don't      distinguish between dependent and independent names.  So, for      example, we look up all overloaded functions at      instantiation-time, even though in some cases we should just use      the DECL we have here.  We also use LOOKUP_EXPRs to find things      like local variables, rather than creating TEMPLATE_DECLs for the      local variables and then finding matching instantiations.  */
if|if
condition|(
name|current_template_parms
operator|&&
operator|(
name|is_overloaded_fn
argument_list|(
name|id
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|CP_DECL_CONTEXT
argument_list|(
name|id
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|id
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|USING_DECL
operator|)
condition|)
name|id
operator|=
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|do_scoped_id
parameter_list|(
name|token
parameter_list|,
name|id
parameter_list|)
name|tree
name|token
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ANTICIPATED
argument_list|(
name|id
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|id
operator|=
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|token
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"`::%D' undeclared (first use here)"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Prevent repeated error messages.  */
name|SET_IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|token
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|OVERLOAD
condition|)
name|mark_used
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|CONST_DECL
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* XXX CHS - should we set TREE_USED of the constant? */
name|id
operator|=
name|DECL_INITIAL
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* This is to prevent an enum whose value is 0 	 from being considered a null pointer constant.  */
name|id
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|id
operator|=
name|build_min_nt
argument_list|(
name|LOOKUP_EXPR
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|LOOKUP_EXPR_GLOBAL
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/* else just use the decl */
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|convert_from_reference
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|identifier_typedecl_value
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|IDENTIFIER_BINDING
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
return|return
name|t
return|;
block|}
if|if
condition|(
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_NAMESPACE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|type
condition|)
return|return
name|t
return|;
block|}
comment|/* Will this one ever happen?  */
if|if
condition|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
return|;
comment|/* We used to do an internal error of 62 here, but instead we will      handle the return of a null appropriately in the callers.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* The original for tree_node_kind is in the toplevel tree.c; changes there    need to be brought into here, unless this were actually put into a header    instead.  */
end_comment

begin_comment
comment|/* Statistics-gathering stuff.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|d_kind
block|,
name|t_kind
block|,
name|b_kind
block|,
name|s_kind
block|,
name|r_kind
block|,
name|e_kind
block|,
name|c_kind
block|,
name|id_kind
block|,
name|op_id_kind
block|,
name|perm_list_kind
block|,
name|temp_list_kind
block|,
name|vec_kind
block|,
name|x_kind
block|,
name|lang_decl
block|,
name|lang_type
block|,
name|all_kinds
block|}
name|tree_node_kind
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|tree_node_counts
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tree_node_sizes
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|tree
name|build_lang_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|retrofit_lang_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Add DECL_LANG_SPECIFIC info to T.  Called from build_lang_decl    and pushdecl (for functions generated by the backend).  */
end_comment

begin_function
name|void
name|retrofit_lang_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
name|ld
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|can_be_full
operator|=
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|t
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|u1sel
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ld
operator|->
name|decl_flags
operator|.
name|u2sel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|decl_flags
operator|.
name|can_be_full
condition|)
name|ld
operator|->
name|u
operator|.
name|f
operator|.
name|u3sel
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|ld
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_java
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|t
argument_list|,
name|lang_java
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cxx_dup_lang_specific_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|CAN_HAVE_FULL_LANG_DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|ld
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ld
argument_list|,
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
name|ld
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy DECL, including any language-specific parts.  */
end_comment

begin_function
name|tree
name|copy_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Replace the shared language-specific parts of NODE with a new copy.  */
end_comment

begin_function
specifier|static
name|void
name|copy_lang_type
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|lt
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|->
name|u
operator|.
name|h
operator|.
name|is_lang_type_class
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type_ptrmem
argument_list|)
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lt
argument_list|,
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
name|lt
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy TYPE, including any language-specific parts.  */
end_comment

begin_function
name|tree
name|copy_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|copy_lang_type
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
name|tree
name|cxx_make_type
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* Create lang_type structure.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|struct
name|lang_type
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
operator|(
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|pi
expr_stmt|;
name|pi
operator|->
name|u
operator|.
name|c
operator|.
name|h
operator|.
name|is_lang_type_class
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Set up some flags that give proper default behavior.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|interface_unknown
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
comment|/* Make sure this is laid out, for ease of use later.  In the 	 presence of parse errors, the normal was of assuring this 	 might not ever get executed, so we lay it out *immediately*.  */
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,        TYPE_ALIAS_SET is initialized to -1 by default, so we must        clear it here.  */
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We need to allocate a TYPE_BINFO even for TEMPLATE_TYPE_PARMs      since they can be virtual base types, and we then need a      canonical binfo for them.  Ideally, this would be done lazily for      all types.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
operator|||
name|code
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|code
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|||
name|code
operator|==
name|TYPENAME_TYPE
condition|)
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|size_zero_node
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|make_aggr_type
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
name|tree
name|t
init|=
name|cxx_make_type
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
name|SET_IS_AGGR_TYPE
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the type-qualifier corresponding to the identifier given by    RID.  */
end_comment

begin_function
name|int
name|cp_type_qual_from_rid
parameter_list|(
name|rid
parameter_list|)
name|tree
name|rid
decl_stmt|;
block|{
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
return|return
name|TYPE_QUAL_CONST
return|;
elseif|else
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
return|return
name|TYPE_QUAL_VOLATILE
return|;
elseif|else
if|if
condition|(
name|rid
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RESTRICT
index|]
condition|)
return|return
name|TYPE_QUAL_RESTRICT
return|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|TYPE_UNQUALIFIED
return|;
block|}
end_function

end_unit

