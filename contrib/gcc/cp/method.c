begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and variable name overloading.    Copyright (C) 1987, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PARM_CAN_BE_ARRAY_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PARM_CAN_BE_ARRAY_TYPE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"class.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_comment
comment|/* TREE_LIST of the current inline functions that need to be    processed.  */
end_comment

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_inlines
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Obstack where we build text strings for overloading, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OB_INIT
parameter_list|()
value|(scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)
end_define

begin_define
define|#
directive|define
name|OB_PUTC
parameter_list|(
name|C
parameter_list|)
value|(obstack_1grow (&scratch_obstack, (C)))
end_define

begin_define
define|#
directive|define
name|OB_PUTC2
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|(obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))
end_define

begin_define
define|#
directive|define
name|OB_PUTS
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))
end_define

begin_define
define|#
directive|define
name|OB_PUTID
parameter_list|(
name|ID
parameter_list|)
define|\
value|(obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),	\ 		 IDENTIFIER_LENGTH (ID)))
end_define

begin_define
define|#
directive|define
name|OB_PUTCP
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), strlen (S)))
end_define

begin_define
define|#
directive|define
name|OB_FINISH
parameter_list|()
value|(obstack_1grow (&scratch_obstack, '\0'))
end_define

begin_define
define|#
directive|define
name|OB_LAST
parameter_list|()
value|(obstack_next_free (&scratch_obstack)[-1])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
end_ifdef

begin_function_decl
name|int
name|is_overloaded
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_method
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This must be large enough to hold any printed integer or floating-point    value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digit_buffer
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move inline function definitions out of structure so that they    can be processed normally.  CNAME is the name of the class    we are working from, METHOD_LIST is the list of method lists    of the structure.  We delete friend methods here, after    saving away their inline function definitions (if any).  */
end_comment

begin_function
name|void
name|do_inline_function_hair
parameter_list|(
name|type
parameter_list|,
name|friend_list
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_list
decl_stmt|;
block|{
name|tree
name|method
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|&&
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|method
condition|)
block|{
comment|/* Do inline member functions.  */
name|struct
name|pending_inline
modifier|*
name|info
init|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|info
operator|->
name|fndecl
operator|==
name|method
argument_list|,
literal|238
argument_list|)
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|method
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Allow this decl to be seen in global scope.  Don't do this for              local class methods, though.  */
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|friend_list
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|friend_list
argument_list|)
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|info
init|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|info
operator|->
name|fndecl
operator|==
name|fndecl
argument_list|,
literal|239
argument_list|)
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Allow this decl to be seen in global scope */
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
block|}
name|friend_list
operator|=
name|TREE_CHAIN
argument_list|(
name|friend_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report an argument type mismatch between the best declared function    we could find and the current argument list that we have.  */
end_comment

begin_function
name|void
name|report_type_mismatch
parameter_list|(
name|cp
parameter_list|,
name|parmtypes
parameter_list|,
name|name_kind
parameter_list|)
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|char
modifier|*
name|name_kind
decl_stmt|;
block|{
name|int
name|i
init|=
name|cp
operator|->
name|u
operator|.
name|bad_arg
decl_stmt|;
name|tree
name|ttf
decl_stmt|,
name|tta
decl_stmt|;
name|char
modifier|*
name|tmp_firstobj
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
operator|-
literal|4
case|:
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|,
literal|240
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"type unification failed for function template `%#D'"
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|2
case|:
name|cp_error
argument_list|(
literal|"too few arguments for %s `%#D'"
argument_list|,
name|name_kind
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|1
case|:
name|cp_error
argument_list|(
literal|"too many arguments for %s `%#D'"
argument_list|,
name|name_kind
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
break|break;
case|case
operator|-
literal|3
case|:
comment|/* Happens when the implicit object parameter is rejected.  */
name|my_friendly_assert
argument_list|(
operator|!
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|241
argument_list|)
expr_stmt|;
name|cp_error
argument_list|(
literal|"call to non-const %s `%#D' with const object"
argument_list|,
name|name_kind
argument_list|,
name|cp
operator|->
name|function
argument_list|)
expr_stmt|;
return|return;
block|}
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tta
operator|=
name|parmtypes
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"bad argument "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|"%d"
argument_list|,
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|-
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" for function `"
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|decl_as_string
argument_list|(
name|cp
operator|->
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"' (type was "
argument_list|)
expr_stmt|;
comment|/* Reset `i' so that type printing routines do the right thing.  */
if|if
condition|(
name|tta
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
name|OB_PUTS
argument_list|(
literal|"(failed type instantiation)"
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
operator|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|type_as_string
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|tmp_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|obstack_object_size
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|,
name|tmp_firstobj
argument_list|,
name|obstack_object_size
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|tmp_firstobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here is where overload code starts.  */
end_comment

begin_comment
comment|/* Array of types seen so far in top-level call to `build_overload_name'.    Allocated and deallocated by caller.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of types interned by `build_overload_name' so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of occurrences of last type seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrepeats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should not try folding parameter types.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nofold
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALLOCATE_TYPEVEC
parameter_list|(
name|PARMTYPES
parameter_list|)
define|\
value|do { maxtype = 0, nrepeats = 0; \        typevec = (tree *)alloca (list_length (PARMTYPES) * sizeof (tree)); } while (0)
end_define

begin_define
define|#
directive|define
name|DEALLOCATE_TYPEVEC
parameter_list|(
name|PARMTYPES
parameter_list|)
define|\
value|do { tree t = (PARMTYPES); \        while (t) { TREE_USED (TREE_VALUE (t)) = 0; t = TREE_CHAIN (t); } \   } while (0)
end_define

begin_comment
comment|/* Code to concatenate an asciified integer to a string.  */
end_comment

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|void
name|icat
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
comment|/* Handle this case first, to go really quickly.  For many common values,      the result of i/10 below is 1.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|10
condition|)
name|OB_PUTC
argument_list|(
literal|'0'
operator|+
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|icat
argument_list|(
name|i
operator|/
literal|10
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'0'
operator|+
operator|(
name|i
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|void
name|flush_repeats
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|tindex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|typevec
index|[
name|tindex
index|]
operator|!=
name|type
condition|)
name|tindex
operator|++
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nrepeats
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTC
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|nrepeats
operator|=
literal|0
expr_stmt|;
name|icat
argument_list|(
name|tindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tindex
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|numeric_output_need_bar
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|build_overload_identifier
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|build_overload_nested_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|context
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|build_overload_nested_name
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
specifier|extern
name|int
name|var_labelno
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
if|if
condition|(
name|numeric_output_need_bar
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
block|}
name|icat
argument_list|(
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* TYPE_DECL */
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|build_overload_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Encoding for an INTEGER_CST value. */
end_comment

begin_function
specifier|static
name|void
name|build_overload_int
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
literal|243
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|value
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|,
operator|-
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* need to print a DImode value in decimal */
name|sorry
argument_list|(
literal|"conversion of long long as PT parameter"
argument_list|)
expr_stmt|;
block|}
comment|/* else fall through to print in smaller mode */
block|}
comment|/* Wordsize or smaller */
name|icat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_overload_value
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
name|tree
name|type
decl_stmt|,
name|value
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|PARM_DECL
argument_list|,
literal|242
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_output_need_bar
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Handle a pointer to data member as a template instantiation 	 parameter, boy, what fun!  */
name|type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|sorry
argument_list|(
literal|"unknown pointer to member constant"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
block|{
name|build_overload_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|REAL_IS_NOT_DOUBLE
case|case
name|REAL_TYPE
case|:
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|digit_buffer
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
argument_list|,
literal|244
argument_list|)
expr_stmt|;
name|val
operator|=
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
literal|'m'
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"%e"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|bufp
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|strcat
argument_list|(
name|digit_buffer
argument_list|,
literal|"e0"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|bufp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|==
literal|'-'
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'m'
expr_stmt|;
block|}
name|p
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|bufp
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|bufp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* This is dangerous code, crack built up pointer to members. */
name|tree
name|args
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|tree
name|a1
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|a2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|a3
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|a3
operator|=
name|TREE_VALUE
argument_list|(
name|a3
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|a3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|a2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|build_overload_int
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_overload_int
argument_list|(
name|a2
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a3
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|a3
operator|=
name|TREE_OPERAND
argument_list|(
name|a3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a3
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|a3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a3
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|build_overload_int
argument_list|(
name|a3
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
name|sorry
argument_list|(
literal|"template instantiation with pointer to method that is too complex"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|build_overload_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
argument_list|,
literal|245
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
argument_list|,
literal|246
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|71
argument_list|)
expr_stmt|;
break|break;
comment|/* not really needed */
default|default:
name|sorry
argument_list|(
literal|"conversion of %s as template parameter"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|type
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|72
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|build_overload_identifier
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|template
decl_stmt|,
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|,
name|tname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
name|template
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_VALUE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|template
operator|=
name|TREE_PURPOSE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|tname
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parmlist
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* This parameter is a type.  */
name|OB_PUTC
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parm
operator|=
name|tsubst
argument_list|(
name|parm
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* It's a PARM_DECL.  */
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|build_overload_value
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|numeric_output_need_bar
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
block|}
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a list of parameters in PARMTYPES, create an unambiguous    overload string. Should distinguish any type that C (or C++) can    distinguish. I.e., pointers to functions are treated correctly.     Caller must deal with whether a final `e' goes on the end or not.     Any default conversions must take place before this function    is called.     BEGIN and END control initialization and finalization of the    obstack where we build the string.  */
end_comment

begin_function
name|char
modifier|*
name|build_overload_name
parameter_list|(
name|parmtypes
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|)
name|tree
name|parmtypes
decl_stmt|;
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
block|{
name|int
name|just_one
decl_stmt|;
name|tree
name|parmtype
decl_stmt|;
if|if
condition|(
name|begin
condition|)
name|OB_INIT
argument_list|()
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|just_one
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|TREE_LIST
operator|)
operator|)
condition|)
block|{
name|parmtype
operator|=
name|parmtypes
expr_stmt|;
goto|goto
name|only_one
goto|;
block|}
while|while
condition|(
name|parmtypes
condition|)
block|{
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|only_one
label|:
if|if
condition|(
operator|!
name|nofold
operator|&&
operator|!
name|just_one
condition|)
block|{
comment|/* Every argument gets counted.  */
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|parmtype
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
operator|&&
name|parmtype
operator|==
name|typevec
index|[
name|maxtype
operator|-
literal|2
index|]
condition|)
block|{
name|nrepeats
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|typevec
index|[
name|maxtype
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
name|flush_repeats
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* Only cache types which take more than one character.  */
if|if
condition|(
name|parmtype
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|REAL_TYPE
operator|)
condition|)
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|parmtype
argument_list|)
condition|)
name|parmtype
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
case|case
name|OFFSET_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
case|case
name|ARRAY_TYPE
case|:
if|#
directive|if
name|PARM_CAN_BE_ARRAY_TYPE
block|{
name|tree
name|length
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parmtype
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"pointer or reference to array of unknown bound in parm type"
argument_list|)
expr_stmt|;
else|else
block|{
name|length
operator|=
name|array_type_nelts
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|length
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|icat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|length
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
block|}
else|#
directive|else
name|OB_PUTC
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|more
label|:
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|firstarg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
comment|/* Otherwise have to implement reentrant typevecs, 	       unmark and remark types, etc.  */
name|int
name|old_nofold
init|=
name|nofold
decl_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|typevec
index|[
name|maxtype
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* @@ It may be possible to pass a function type in 	       which is not preceded by a 'P'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstarg
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|firstarg
operator|==
name|void_list_node
condition|)
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
name|build_overload_name
argument_list|(
name|firstarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|firstarg
operator|=
name|TREE_CHAIN
argument_list|(
name|firstarg
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
condition|)
name|OB_PUTC
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
name|OB_PUTC
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
comment|/* For cfront 2.0 compatibility.  */
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstarg
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|firstarg
operator|==
name|void_list_node
condition|)
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
name|build_overload_name
argument_list|(
name|firstarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Separate args from return type.  */
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nofold
operator|=
name|old_nofold
expr_stmt|;
break|break;
block|}
case|case
name|INTEGER_TYPE
case|:
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtype
operator|==
name|integer_type_node
operator|||
name|parmtype
operator|==
name|unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|short_integer_type_node
operator|||
name|parmtype
operator|==
name|short_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|signed_char_type_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|char_type_node
operator|||
name|parmtype
operator|==
name|unsigned_char_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|wchar_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|long_long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_long_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* it would seem there is no way to enter these in source code, 	     yet.  (mrs) */
if|else if (parmtype == long_long_long_integer_type_node 	      || parmtype == long_long_long_unsigned_type_node) 	    OB_PUTC ('q');
endif|#
directive|endif
else|else
name|my_friendly_abort
argument_list|(
literal|73
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtype
operator|==
name|long_double_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|double_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|float_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|74
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
if|if
condition|(
operator|!
name|just_one
condition|)
block|{
if|#
directive|if
literal|0
block|extern tree void_list_node;
comment|/* See if anybody is wasting memory.  */
block|my_friendly_assert (parmtypes == void_list_node, 247);
endif|#
directive|endif
comment|/* This is the end of a parameter list.  */
if|if
condition|(
name|end
condition|)
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
comment|/* not right, but nothing is anyway */
break|break;
comment|/* have to do these */
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
operator|!
name|just_one
condition|)
comment|/* Make this type signature look incompatible 	       with AT&T.  */
name|OB_PUTC
argument_list|(
literal|'G'
argument_list|)
expr_stmt|;
goto|goto
name|common
goto|;
case|case
name|ENUMERAL_TYPE
case|:
name|common
label|:
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|context
init|=
name|name
decl_stmt|;
comment|/* If DECL_ASSEMBLER_NAME has been set properly, use it. */
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|context
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|OB_PUTID
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|i
operator|+=
literal|1
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|248
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'Q'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
name|build_overload_nested_name
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|build_overload_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNKNOWN_TYPE
case|:
comment|/* This will take some work.  */
name|OB_PUTC
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_CONST_PARM
case|:
case|case
name|UNINSTANTIATED_P_TYPE
case|:
comment|/* We don't ever want this output, but it's inconvenient not to 	     be able to build the string.  This should cause assembler 	     errors we'll notice.  */
block|{
specifier|static
name|int
name|n
decl_stmt|;
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|" *%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|75
argument_list|)
expr_stmt|;
block|}
name|next
label|:
if|if
condition|(
name|just_one
condition|)
break|break;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|just_one
condition|)
block|{
if|if
condition|(
name|nrepeats
condition|)
name|flush_repeats
argument_list|(
name|typevec
index|[
name|maxtype
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* To get here, parms must end with `...'. */
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|build_static_name
parameter_list|(
name|basetype
parameter_list|,
name|name
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|basename
init|=
name|build_overload_name
argument_list|(
name|basetype
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|STATIC_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|basename
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|STATIC_NAME_FORMAT
argument_list|,
name|basename
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an identifier that encodes the (ANSI) exception TYPE. */
end_comment

begin_comment
comment|/* This should be part of `ansi_opname', or at least be defined by the std.  */
end_comment

begin_define
define|#
directive|define
name|EXCEPTION_NAME_PREFIX
value|"__ex"
end_define

begin_define
define|#
directive|define
name|EXCEPTION_NAME_LENGTH
value|4
end_define

begin_function
name|tree
name|cplus_exception_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
name|EXCEPTION_NAME_PREFIX
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change the name of a function definition so that it may be    overloaded. NAME is the name of the function to overload,    PARMS is the parameter list (which determines what name the    final function obtains).     FOR_METHOD is 1 if this overload is being performed    for a method, rather than a function type.  It is 2 if    this overload is being performed for a constructor.  */
end_comment

begin_function
name|tree
name|build_decl_overload
parameter_list|(
name|dname
parameter_list|,
name|parms
parameter_list|,
name|for_method
parameter_list|)
name|tree
name|dname
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|for_method
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
decl_stmt|;
comment|/* member operators new and delete look like methods at this point.  */
if|if
condition|(
operator|!
name|for_method
operator|&&
name|parms
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_delete"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_vec_delete"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|void_list_node
condition|)
block|{
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_new"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_vec_new"
argument_list|)
return|;
block|}
block|}
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_method
operator|!=
literal|2
condition|)
name|OB_PUTCP
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Otherwise, we can divine that this is a constructor,      and figure out its name without any extra encoding.  */
name|OB_PUTC2
argument_list|(
literal|'_'
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We can get away without doing this.  */
block|OB_PUTC ('M');
endif|#
directive|endif
block|{
name|tree
name|this_type
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|this_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
comment|/* a signature pointer */
name|parms
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|SIGNATURE_TYPE
argument_list|(
name|this_type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|parms
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|this_type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC2
argument_list|(
literal|'e'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|OB_PUTC2
argument_list|(
literal|'v'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
else|else
block|{
name|ALLOCATE_TYPEVEC
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
name|build_overload_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
condition|)
name|build_overload_name
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|OB_PUTC2
argument_list|(
literal|'e'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
name|build_overload_name
argument_list|(
name|parms
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DEALLOCATE_TYPEVEC
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
name|n
init|=
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
condition|)
name|IDENTIFIER_OPNAME_P
argument_list|(
name|n
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build an overload name for the type expression TYPE.  */
end_comment

begin_function
name|tree
name|build_typename_overload
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTID
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|IDENTIFIER_GLOBAL_VALUE (id) = TYPE_NAME (type);
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|T_DESC_FORMAT
value|"TD$"
end_define

begin_define
define|#
directive|define
name|I_DESC_FORMAT
value|"ID$"
end_define

begin_define
define|#
directive|define
name|M_DESC_FORMAT
value|"MD$"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_DOT_IN_LABEL
argument_list|)
end_if

begin_define
define|#
directive|define
name|T_DESC_FORMAT
value|"TD."
end_define

begin_define
define|#
directive|define
name|I_DESC_FORMAT
value|"ID."
end_define

begin_define
define|#
directive|define
name|M_DESC_FORMAT
value|"MD."
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|T_DESC_FORMAT
value|"__t_desc_"
end_define

begin_define
define|#
directive|define
name|I_DESC_FORMAT
value|"__i_desc_"
end_define

begin_define
define|#
directive|define
name|M_DESC_FORMAT
value|"__m_desc_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build an overload name for the type expression TYPE.  */
end_comment

begin_function
name|tree
name|build_t_desc_overload
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
name|T_DESC_FORMAT
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Use a different format if the type isn't defined yet.  */
block|if (TYPE_SIZE (type) == NULL_TREE)     {       char *p;       int changed;        for (p = tname; *p; p++) 	if (isupper (*p)) 	  { 	    changed = 1; 	    *p = tolower (*p); 	  }
comment|/* If there's no change, we have an inappropriate T_DESC_FORMAT.  */
block|my_friendly_assert (changed != 0, 249);     }
endif|#
directive|endif
name|build_overload_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Top-level interface to explicit overload requests. Allow NAME    to be overloaded. Error if NAME is already declared for the current    scope. Warning if function is redundantly overloaded. */
end_comment

begin_function
name|void
name|declare_overloaded
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
if|if
condition|(
name|is_overloaded
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function `%s' already declared overloaded"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"overloading function `%s' that is already defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
if|if
condition|(
literal|0
condition|)
name|warning
argument_list|(
literal|"functions are implicitly overloaded in C++"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|error
argument_list|(
literal|"overloading function `%s' cannot be done in C language context"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|76
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
end_ifdef

begin_comment
comment|/* Check to see if NAME is overloaded. For first approximation,    check to see if its TREE_OVERLOADED is set.  This is used on    IDENTIFIER nodes.  */
end_comment

begin_function
name|int
name|is_overloaded
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
comment|/* @@ */
return|return
operator|(
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|&&
operator|(
operator|!
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|||
name|current_class_type
operator|==
literal|0
operator|)
operator|&&
operator|!
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Given a tree_code CODE, and some arguments (at least one),    attempt to use an overloaded operator on the arguments.     For unary operators, only the first argument need be checked.    For binary operators, both arguments may need to be checked.     Member functions can convert class references to class pointers,    for one-level deep indirection.  More than that is not supported.    Operators [](), ()(), and ->() must be member functions.     We call function call building calls with LOOKUP_COMPLAIN if they    are our only hope.  This is true when we see a vanilla operator    applied to something of aggregate type.  If this fails, we are free    to return `error_mark_node', because we will have reported the    error.     Operators NEW and DELETE overload in funny ways: operator new takes    a single `size' parameter, and operator delete takes a pointer to the    storage being deleted.  When overloading these operators, success is    assumed.  If there is a failure, report an error message and return    `error_mark_node'.  */
end_comment

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|tree
name|build_opfncall
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|xarg1
parameter_list|,
name|xarg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|xarg1
decl_stmt|,
name|xarg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
name|tree
name|rval
init|=
literal|0
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|,
name|fnname
decl_stmt|;
name|tree
name|fields1
init|=
literal|0
decl_stmt|,
name|parms
init|=
literal|0
decl_stmt|;
name|tree
name|global_fn
decl_stmt|;
name|int
name|try_second
decl_stmt|;
name|int
name|binary_is_unary
decl_stmt|;
if|if
condition|(
name|xarg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|COMPONENT_REF
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|rval
return|;
comment|/* First, see if we can work with the first argument */
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
expr_stmt|;
comment|/* Some tree codes have length> 1, but we really only want to      overload them if their first argument has a user defined type.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* ARRAY_REFs and CALL_EXPRs must overload successfully. 	 If they do not, return error_mark_node instead of NULL_TREE.  */
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
case|case
name|CALL_EXPR
case|:
name|rval
operator|=
name|error_mark_node
expr_stmt|;
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VEC_NEW_EXPR
case|:
case|case
name|NEW_EXPR
case|:
block|{
name|tree
name|args
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
decl_stmt|;
name|fnname
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
return|return
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|args
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
return|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|build_indirect_ref
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|xarg1
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
literal|"new"
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
comment|/* User might declare fancy operator new, but invoke it 	     like standard one.  */
return|return
name|rval
return|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|xarg1
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
break|break;
case|case
name|VEC_DELETE_EXPR
case|:
case|case
name|DELETE_EXPR
case|:
block|{
name|fnname
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
return|return
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|)
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
return|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|build_indirect_ref
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This can happen when operator delete is protected.  */
block|my_friendly_assert (rval != error_mark_node, 250); 	TREE_TYPE (rval) = void_type_node;
endif|#
directive|endif
return|return
name|rval
return|;
block|}
break|break;
default|default:
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
name|try_second
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|2
expr_stmt|;
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
break|break;
block|}
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* What ever it was, we do not know how to deal with it.  */
if|if
condition|(
name|type1
operator|==
name|NULL_TREE
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg1
operator|=
name|convert_from_reference
argument_list|(
name|xarg1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|xarg1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|||
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type1
argument_list|)
condition|)
block|{
comment|/* Try to fail. First, fail if unary */
if|if
condition|(
operator|!
name|try_second
condition|)
return|return
name|rval
return|;
comment|/* Second, see if second argument is non-aggregate. */
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|xarg2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
return|return
name|rval
return|;
name|try_second
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|try_second
condition|)
block|{
comment|/* First arg may succeed; see whether second should.  */
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|xarg2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
name|try_second
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|==
name|unknown_type_node
operator|||
operator|(
name|try_second
operator|&&
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|unknown_type_node
operator|)
condition|)
block|{
comment|/* This will not be implemented in the foreseeable future.  */
return|return
name|rval
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
name|fnname
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
index|]
expr_stmt|;
else|else
name|fnname
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|global_fn
operator|=
name|lookup_name_nonclass
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
comment|/* This is the last point where we will accept failure.  This      may be too eager if we wish an overloaded operator not to match,      but would rather a normal operator be called on a type-converted      argument.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|fields1
operator|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type1
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ARM $13.4.7, prefix/postfix ++/--.  */
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
name|xarg2
operator|=
name|integer_zero_node
expr_stmt|;
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fields1
condition|)
block|{
name|tree
name|t
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|have_postfix
init|=
literal|0
decl_stmt|;
comment|/* Look for an `operator++ (int)'.  If they didn't have 		 one, then we fall back to the old way of doing things.  */
for|for
control|(
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|fields1
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|t2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|==
name|integer_type_node
condition|)
block|{
name|have_postfix
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|have_postfix
condition|)
block|{
name|char
modifier|*
name|op
init|=
name|POSTINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
decl_stmt|;
comment|/* There's probably a LOT of code in the world that 		     relies upon this old behavior.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"no `operator%s (int)' declared for postfix `%s', using prefix operator instead"
argument_list|,
name|op
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|xarg2
operator|=
name|NULL_TREE
expr_stmt|;
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fields1
operator|==
name|NULL_TREE
operator|&&
name|global_fn
operator|==
name|NULL_TREE
condition|)
return|return
name|rval
return|;
comment|/* If RVAL winds up being `error_mark_node', we will return      that... There is no way that normal semantics of these      operators will succeed.  */
comment|/* This argument may be an uncommitted OFFSET_REF.  This is      the case for example when dealing with static class members      which are referenced from their class name rather than      from a class instance.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg1
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|xarg1
operator|=
name|TREE_OPERAND
argument_list|(
name|xarg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|&&
name|TREE_CODE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|xarg2
operator|=
name|TREE_OPERAND
argument_list|(
name|xarg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_fn
condition|)
name|flags
operator||=
name|LOOKUP_GLOBAL
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
block|{
comment|/* This can only be a member function.  */
return|return
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|xarg2
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|1
operator|||
name|binary_is_unary
condition|)
block|{
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|xarg2
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|METHOD_CALL_EXPR
condition|)
block|{
comment|/* must be a member function.  */
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fields1
condition|)
block|{
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|candidate
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function takes an identifier, ID, and attempts to figure out what    it means. There are a number of possible scenarios, presented in increasing    order of hair:     1) not in a class's scope    2) in class's scope, member name of the class's method    3) in class's scope, but not a member name of the class    4) in class's scope, member name of a class's variable     NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.    VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)    yychar is the pending input character (suitably encoded :-).     As a last ditch, try to look up the name as a label and return that    address.     Values which are declared as being of REFERENCE_TYPE are    automatically dereferenced here (as a hack to make the    compiler faster).  */
end_comment

begin_function
name|tree
name|hack_identifier
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|yychar
parameter_list|)
name|tree
name|value
decl_stmt|,
name|name
decl_stmt|;
name|int
name|yychar
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|current_class_name
condition|)
block|{
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|251
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"methods cannot be converted to function pointers"
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ambiguous request for method pointer `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
if|if
condition|(
name|flag_labels_ok
operator|&&
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' in static member function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|get_first_fn
argument_list|(
name|value
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|DECL_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
continue|continue;
name|assemble_external
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|t
init|=
name|value
decl_stmt|;
while|while
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|assemble_external
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assemble_external
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|enum
name|access_type
name|access
decl_stmt|;
specifier|register
name|tree
name|context
init|=
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|value
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|get_base_distance
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|access
operator|=
name|compute_access
argument_list|(
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|!=
name|access_public
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"static member `%s' is %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|value
argument_list|)
condition|?
literal|"private"
else|:
literal|"from a private base class"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"enum `%s' is from private base class"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_NONLOCAL_FLAG
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' is ambiguous in multiple inheritance lattice"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RESULT_DECL
argument_list|,
literal|252
argument_list|)
expr_stmt|;
return|return
name|convert_from_reference
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Given an object OF, and a type conversion operator COMPONENT    build a call to the conversion operator, if a call is requested,    or return the address (as a pointer to member function) if one is not.     OF can be a TYPE_DECL or any kind of datum that would normally    be passed to `build_component_ref'.  It may also be NULL_TREE,    in which case `current_class_type' and `current_class_decl'    provide default values.     BASETYPE_PATH, if non-null, is the path of basetypes    to go through before we get the the instance of interest.     PROTECT says whether we apply C++ scoping rules or not.  */
end_comment

begin_endif
unit|tree build_component_type_expr (of, component, basetype_path, protect)      tree of, component, basetype_path;      int protect; {   tree cname = NULL_TREE;   tree tmp, last;   tree name;   int flags = protect ? LOOKUP_NORMAL : LOOKUP_COMPLAIN;    if (of)     my_friendly_assert (IS_AGGR_TYPE (TREE_TYPE (of)), 253);   my_friendly_assert (TREE_CODE (component) == TYPE_EXPR, 254);    tmp = TREE_OPERAND (component, 0);   last = NULL_TREE;    while (tmp)     {       switch (TREE_CODE (tmp)) 	{ 	case CALL_EXPR: 	  if (last) 	    TREE_OPERAND (last, 0) = TREE_OPERAND (tmp, 0); 	  else 	    TREE_OPERAND (component, 0) = TREE_OPERAND (tmp, 0);  	  last = groktypename (build_tree_list (TREE_TYPE (component), 						TREE_OPERAND (component, 0))); 	  name = build_typename_overload (last); 	  TREE_TYPE (name) = last;  	  if (TREE_OPERAND (tmp, 0)&& TREE_OPERAND (tmp, 0) != void_list_node) 	    { 	      cp_error ("`operator %T' requires empty parameter list", last); 	      TREE_OPERAND (tmp, 0) = NULL_TREE; 	    }  	  if (of&& TREE_CODE (of) != TYPE_DECL) 	    return build_method_call (of, name, NULL_TREE, NULL_TREE, flags); 	  else if (of) 	    { 	      tree this_this;  	      if (current_class_decl == NULL_TREE) 		{ 		  cp_error ("object required for `operator %T' call", 			    TREE_TYPE (name)); 		  return error_mark_node; 		}  	      this_this = convert_pointer_to (TREE_TYPE (of), 					      current_class_decl); 	      this_this = build_indirect_ref (this_this, NULL_PTR); 	      return build_method_call (this_this, name, NULL_TREE, 					NULL_TREE, flags | LOOKUP_NONVIRTUAL); 	    } 	  else if (current_class_decl) 	    return build_method_call (tmp, name, NULL_TREE, NULL_TREE, flags);  	  cp_error ("object required for `operator %T' call", 		    TREE_TYPE (name)); 	  return error_mark_node;  	case INDIRECT_REF: 	case ADDR_EXPR: 	case ARRAY_REF: 	  break;  	case SCOPE_REF: 	  my_friendly_assert (cname == 0, 255); 	  cname = TREE_OPERAND (tmp, 0); 	  tmp = TREE_OPERAND (tmp, 1); 	  break;  	default: 	  my_friendly_abort (77); 	}       last = tmp;       tmp = TREE_OPERAND (tmp, 0);     }    last = groktypename (build_tree_list (TREE_TYPE (component), TREE_OPERAND (component, 0)));   name = build_typename_overload (last);   TREE_TYPE (name) = last;   if (of&& TREE_CODE (of) == TYPE_DECL)     {       if (cname == NULL_TREE) 	{ 	  cname = DECL_NAME (of); 	  of = NULL_TREE; 	}       else my_friendly_assert (cname == DECL_NAME (of), 256);     }    if (of)     {       tree this_this;        if (current_class_decl == NULL_TREE) 	{ 	  cp_error ("object required for `operator %T' call", 		    TREE_TYPE (name)); 	  return error_mark_node; 	}        this_this = convert_pointer_to (TREE_TYPE (of), current_class_decl);       return build_component_ref (this_this, name, 0, protect);     }   else if (cname)     return build_offset_ref (cname, name);   else if (current_class_name)     return build_offset_ref (current_class_name, name);    cp_error ("object required for `operator %T' member reference", 	    TREE_TYPE (name));   return error_mark_node; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|thunk_printable_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
literal|"<thunk function>"
return|;
block|}
end_function

begin_function
name|tree
name|make_thunk
parameter_list|(
name|function
parameter_list|,
name|delta
parameter_list|)
name|tree
name|function
decl_stmt|;
name|int
name|delta
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|250
index|]
decl_stmt|;
name|tree
name|thunk_fndecl
decl_stmt|,
name|thunk_id
decl_stmt|;
name|tree
name|thunk
decl_stmt|;
name|char
modifier|*
name|func_name
decl_stmt|;
specifier|static
name|int
name|thunk_number
init|=
literal|0
decl_stmt|;
name|tree
name|func_decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|func_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|func_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|func_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
literal|0
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"__thunk_%d_%s"
argument_list|,
operator|-
name|delta
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"__thunk_n%d_%s"
argument_list|,
name|delta
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|thunk_id
operator|=
name|get_identifier
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|thunk
operator|&&
name|TREE_CODE
argument_list|(
name|thunk
argument_list|)
operator|!=
name|THUNK_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
literal|"implementation-reserved name `%s' used"
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|)
operator|=
name|thunk
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|thunk
operator|==
name|NULL_TREE
condition|)
block|{
name|thunk
operator|=
name|build_decl
argument_list|(
name|THUNK_DECL
argument_list|,
name|thunk_id
argument_list|,
name|TREE_TYPE
argument_list|(
name|func_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|thunk
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|thunk
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
expr_stmt|;
name|make_function_rtl
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|thunk
argument_list|)
operator|=
name|function
expr_stmt|;
name|THUNK_DELTA
argument_list|(
name|thunk
argument_list|)
operator|=
name|delta
expr_stmt|;
comment|/* So that finish_file can write out any thunks that need to be: */
name|pushdecl_top_level
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
block|}
return|return
name|thunk
return|;
block|}
end_function

begin_function
name|void
name|emit_thunk
parameter_list|(
name|thunk_fndecl
parameter_list|)
name|tree
name|thunk_fndecl
decl_stmt|;
block|{
name|rtx
name|insns
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
name|char
name|buffer
index|[
literal|250
index|]
decl_stmt|;
name|tree
name|argp
decl_stmt|;
name|struct
name|args_size
name|stack_args_size
decl_stmt|;
name|tree
name|function
init|=
name|TREE_OPERAND
argument_list|(
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|delta
init|=
name|THUNK_DELTA
argument_list|(
name|thunk_fndecl
argument_list|)
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
name|int
name|current_call_is_indirect
init|=
literal|0
decl_stmt|;
comment|/* needed for HPPA FUNCTION_ARG */
comment|/* Used to remember which regs we need to emit a USE rtx for. */
name|rtx
name|need_use
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|need_use_count
init|=
literal|0
decl_stmt|;
comment|/* rtx for the 'this' parameter. */
name|rtx
name|this_rtx
init|=
literal|0
decl_stmt|,
name|this_reg_rtx
init|=
literal|0
decl_stmt|,
name|fixed_this_rtx
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|save_decl_printable_name
function_decl|)
parameter_list|()
init|=
name|decl_printable_name
function_decl|;
comment|/* Data on reg parms scanned so far.  */
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|assemble_external
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|decl_printable_name
operator|=
name|thunk_printable_name
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|thunk_fndecl
expr_stmt|;
name|init_function_start
argument_list|(
name|thunk_fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Start updating where the next arg would go.  */
name|INIT_CUMULATIVE_ARGS
argument_list|(
name|args_so_far
argument_list|,
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|stack_args_size
operator|.
name|constant
operator|=
literal|0
expr_stmt|;
name|stack_args_size
operator|.
name|var
operator|=
literal|0
expr_stmt|;
comment|/* SETUP for possible structure return address FIXME */
comment|/* Now look through all the parameters, make sure that we      don't clobber any registers used for parameters.      Also, pick up an rtx for the first "this" parameter. */
for|for
control|(
name|argp
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
init|;
name|argp
operator|!=
name|NULL_TREE
condition|;
name|argp
operator|=
name|TREE_CHAIN
argument_list|(
name|argp
argument_list|)
control|)
block|{
name|tree
name|passed_type
init|=
name|TREE_VALUE
argument_list|(
name|argp
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|entry_parm
decl_stmt|;
name|int
name|named
init|=
literal|1
decl_stmt|;
comment|/* FIXME */
name|struct
name|args_size
name|stack_offset
decl_stmt|;
name|struct
name|args_size
name|arg_size
decl_stmt|;
if|if
condition|(
name|passed_type
operator|==
name|void_type_node
condition|)
break|break;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|TYPE_SIZE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|FUNCTION_ARG_PASS_BY_REFERENCE
operator|||
name|FUNCTION_ARG_PASS_BY_REFERENCE
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|passed_type
argument_list|,
name|named
argument_list|)
endif|#
directive|endif
condition|)
name|passed_type
operator|=
name|build_pointer_type
argument_list|(
name|passed_type
argument_list|)
expr_stmt|;
name|entry_parm
operator|=
name|FUNCTION_ARG
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|passed_type
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_parm
operator|!=
literal|0
condition|)
name|need_use
index|[
name|need_use_count
operator|++
index|]
operator|=
name|entry_parm
expr_stmt|;
name|locate_and_pad_parm
argument_list|(
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|passed_type
argument_list|,
ifdef|#
directive|ifdef
name|STACK_PARMS_IN_REG_PARM_AREA
literal|1
argument_list|,
else|#
directive|else
name|entry_parm
operator|!=
literal|0
argument_list|,
endif|#
directive|endif
name|thunk_fndecl
argument_list|,
operator|&
name|stack_args_size
argument_list|,
operator|&
name|stack_offset
argument_list|,
operator|&
name|arg_size
argument_list|)
expr_stmt|;
comment|/*    REGNO (entry_parm);*/
if|if
condition|(
name|this_rtx
operator|==
literal|0
condition|)
block|{
name|this_reg_rtx
operator|=
name|entry_parm
expr_stmt|;
if|if
condition|(
operator|!
name|entry_parm
condition|)
block|{
name|rtx
name|offset_rtx
init|=
name|ARGS_SIZE_RTX
argument_list|(
name|stack_offset
argument_list|)
decl_stmt|;
name|rtx
name|internal_arg_pointer
decl_stmt|,
name|stack_parm
decl_stmt|;
if|if
condition|(
operator|(
name|ARG_POINTER_REGNUM
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|!
operator|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|||
name|ARG_POINTER_REGNUM
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
name|internal_arg_pointer
operator|=
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
else|else
name|internal_arg_pointer
operator|=
name|virtual_incoming_args_rtx
expr_stmt|;
if|if
condition|(
name|offset_rtx
operator|==
name|const0_rtx
condition|)
name|entry_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|internal_arg_pointer
argument_list|)
expr_stmt|;
else|else
name|entry_parm
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|internal_arg_pointer
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this_rtx
operator|=
name|entry_parm
expr_stmt|;
block|}
name|FUNCTION_ARG_ADVANCE
argument_list|(
name|args_so_far
argument_list|,
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|,
name|passed_type
argument_list|,
name|named
argument_list|)
expr_stmt|;
block|}
name|fixed_this_rtx
operator|=
name|plus_constant
argument_list|(
name|this_rtx
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_rtx
operator|!=
name|fixed_this_rtx
condition|)
name|emit_move_insn
argument_list|(
name|this_rtx
argument_list|,
name|fixed_this_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_reg_rtx
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|this_reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_indirect_jump
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|need_use_count
operator|>
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|need_use
index|[
operator|--
name|need_use_count
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* From now on, allocate rtl in current_obstack, not in saveable_obstack.      Note that that may have been done above, in save_for_inline_copying.      The call to resume_temporary_allocation near the end of this function      goes back to the usual state of affairs.  */
name|rtl_in_current_obstack
argument_list|()
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* Copy any shared structure that should not be shared.  */
name|unshare_all_rtl
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Instantiate all virtual registers.  */
name|instantiate_virtual_regs
argument_list|(
name|current_function_decl
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* We are no longer anticipating cse in this function, at least.  */
name|cse_not_expected
operator|=
literal|1
expr_stmt|;
comment|/* Now we choose between stupid (pcc-like) register allocation      (if we got the -noreg switch and not -opt)      and smart register allocation.  */
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
comment|/* Stupid allocation probably won't work */
name|obey_regdecls
operator|=
literal|0
expr_stmt|;
comment|/* if optimizations being done.  */
name|regclass_init
argument_list|()
expr_stmt|;
name|regclass
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
block|{
name|stupid_life_analysis
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|failure
operator|=
name|reload
argument_list|(
name|insns
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Do control and data flow analysis, 	 and write some of the results to dump file.  */
name|flow_analysis
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|local_alloc
argument_list|()
expr_stmt|;
name|failure
operator|=
name|global_alloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|reload_completed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
name|leaf_function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
condition|)
name|leaf_function
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If a machine dependent reorganization is needed, call it.  */
ifdef|#
directive|ifdef
name|MACHINE_DEPENDENT_REORG
name|MACHINE_DEPENDENT_REORG
argument_list|(
name|insns
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now turn the rtl into assembler code.  */
block|{
name|char
modifier|*
name|fnname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assemble_start_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insns
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_end_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|exit_rest_of_compilation
label|:
name|reload_completed
operator|=
literal|0
expr_stmt|;
comment|/* Cancel the effect of rtl_in_current_obstack.  */
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
name|decl_printable_name
operator|=
name|save_decl_printable_name
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for synthesizing methods which have default semantics defined.  */
end_comment

begin_comment
comment|/* For the anonymous union in TYPE, return the member that is at least as    large as the rest of the members, so we can copy it.  */
end_comment

begin_function
specifier|static
name|tree
name|largest_union_member
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|f
decl_stmt|,
name|type_size
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|DECL_SIZE
argument_list|(
name|f
argument_list|)
argument_list|,
name|type_size
argument_list|)
operator|==
literal|1
condition|)
return|return
name|f
return|;
comment|/* We should always find one.  */
name|my_friendly_abort
argument_list|(
literal|323
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
name|void
name|do_build_copy_constructor
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|C_C_D
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cplus_expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|t
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|p
init|=
name|convert_to_reference
argument_list|(
name|build_reference_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|parm
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_CONST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|p
operator|=
name|convert_from_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|tree_cons
argument_list|(
name|TYPE_NESTED_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|p
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|p
decl_stmt|,
name|basetype
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|)
continue|continue;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|p
operator|=
name|convert_to_reference
argument_list|(
name|build_reference_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|parm
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_CONST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|p
operator|=
name|convert_from_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|tree_cons
argument_list|(
name|TYPE_NESTED_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|p
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|name
decl_stmt|,
name|init
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|field
operator|=
name|largest_union_member
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
continue|continue;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|parm
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|init
argument_list|,
name|current_member_init_list
argument_list|)
expr_stmt|;
block|}
name|current_member_init_list
operator|=
name|nreverse
argument_list|(
name|current_member_init_list
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|nreverse
argument_list|(
name|current_base_init_list
argument_list|)
expr_stmt|;
name|setup_vtbl_ptr
argument_list|()
expr_stmt|;
block|}
name|pop_momentary
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_build_assign_ref
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|C_C_D
argument_list|,
name|parm
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cplus_expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|tree
name|p
init|=
name|convert_to_reference
argument_list|(
name|build_reference_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|parm
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_CONST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|p
operator|=
name|convert_from_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|build_member_call
argument_list|(
name|TYPE_NESTED_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|comp
decl_stmt|,
name|init
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|field
operator|=
name|largest_union_member
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
continue|continue;
name|comp
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|C_C_D
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|parm
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|comp
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|c_expand_return
argument_list|(
name|C_C_D
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|push_cp_function_context
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pop_cp_function_context
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|synthesize_method
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|int
name|nested
init|=
operator|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|input_filename
decl_stmt|;
name|tree
name|base
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|nested
condition|)
name|push_cp_function_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
condition|)
name|do_build_assign_ref
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|tree
name|arg_chain
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|arg_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_chain
operator|!=
name|void_list_node
condition|)
name|do_build_copy_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|setup_vtbl_ptr
argument_list|()
expr_stmt|;
block|}
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
name|nested
argument_list|)
expr_stmt|;
comment|/* Do we really *want* to inline this function?  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Turn off DECL_INLINE for the moment so function_cannot_inline_p          will check our size.  */
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|function_cannot_inline_p
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|input_filename
operator|=
name|f
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|nested
condition|)
name|pop_cp_function_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

