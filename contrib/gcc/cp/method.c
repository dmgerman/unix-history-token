begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and variable name overloading.    Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PARM_CAN_BE_ARRAY_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PARM_CAN_BE_ARRAY_TYPE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_comment
comment|/* TREE_LIST of the current inline functions that need to be    processed.  */
end_comment

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_inlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|static_labelno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Obstack where we build text strings for overloading, etc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|icat
name|PROTO
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dicat
name|PROTO
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_backref_index
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flush_repeats
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_overload_identifier
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_overload_nested_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_overload_int
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_overload_identifier
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_qualified_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_overload_value
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|issue_nrepeats
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_mangled_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_modifiers
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_overload_item
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_build_assign_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_build_copy_constructor
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|largest_union_member
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_template_template_parm_names
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_template_parm_names
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_underscore_int
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_squangling
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_squangling
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_ktype
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|issue_ktype
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_overload_scope_ref
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_mangled_template_parm_index
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
end_if

begin_decl_stmt
specifier|static
name|void
name|build_mangled_C9x_name
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|is_back_referenceable_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_btype
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_mangled_name_for_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_mangled_name_for_type_with_Gcode
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|build_base_path
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OB_INIT
parameter_list|()
value|(scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)
end_define

begin_define
define|#
directive|define
name|OB_PUTC
parameter_list|(
name|C
parameter_list|)
value|(obstack_1grow (&scratch_obstack, (C)))
end_define

begin_define
define|#
directive|define
name|OB_PUTC2
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
define|\
value|(obstack_1grow (&scratch_obstack, (C1)), obstack_1grow (&scratch_obstack, (C2)))
end_define

begin_define
define|#
directive|define
name|OB_PUTS
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), sizeof (S) - 1))
end_define

begin_define
define|#
directive|define
name|OB_PUTID
parameter_list|(
name|ID
parameter_list|)
define|\
value|(obstack_grow (&scratch_obstack, IDENTIFIER_POINTER (ID),	\ 		 IDENTIFIER_LENGTH (ID)))
end_define

begin_define
define|#
directive|define
name|OB_PUTCP
parameter_list|(
name|S
parameter_list|)
value|(obstack_grow (&scratch_obstack, (S), strlen (S)))
end_define

begin_define
define|#
directive|define
name|OB_FINISH
parameter_list|()
value|(obstack_1grow (&scratch_obstack, '\0'))
end_define

begin_define
define|#
directive|define
name|OB_LAST
parameter_list|()
value|(obstack_next_free (&scratch_obstack)[-1])
end_define

begin_function
name|void
name|init_method
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This must be large enough to hold any printed integer or floating-point    value.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digit_buffer
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move inline function definitions out of structure so that they    can be processed normally.  CNAME is the name of the class    we are working from, METHOD_LIST is the list of method lists    of the structure.  We delete friend methods here, after    saving away their inline function definitions (if any).  */
end_comment

begin_function
name|void
name|do_inline_function_hair
parameter_list|(
name|type
parameter_list|,
name|friend_list
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_list
decl_stmt|;
block|{
name|tree
name|method
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|&&
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
condition|)
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|method
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|method
condition|)
block|{
comment|/* Do inline member functions.  */
name|struct
name|pending_inline
modifier|*
name|info
init|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|info
operator|->
name|fndecl
operator|==
name|method
argument_list|,
literal|238
argument_list|)
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|method
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|friend_list
condition|)
block|{
name|tree
name|fndecl
init|=
name|TREE_VALUE
argument_list|(
name|friend_list
argument_list|)
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|info
init|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|info
operator|->
name|fndecl
operator|==
name|fndecl
argument_list|,
literal|239
argument_list|)
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
name|friend_list
operator|=
name|TREE_CHAIN
argument_list|(
name|friend_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here is where overload code starts.  */
end_comment

begin_comment
comment|/* type tables for K and B type compression */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|btypelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|ktypelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxbsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxksize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of each type seen */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxbtype
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxktype
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of types seen so far in top-level call to `build_mangled_name'.    Allocated and deallocated by caller.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|typevec
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typevec_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of types interned by `build_mangled_name' so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxtype
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should not try folding parameter types.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nofold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This appears to be set to true if an underscore is required to be    comcatenated before another number can be outputed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numeric_output_need_bar
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|start_squangling
parameter_list|()
block|{
if|if
condition|(
name|flag_do_squangling
condition|)
block|{
name|nofold
operator|=
literal|0
expr_stmt|;
name|maxbtype
operator|=
literal|0
expr_stmt|;
name|maxktype
operator|=
literal|0
expr_stmt|;
name|maxbsize
operator|=
literal|50
expr_stmt|;
name|maxksize
operator|=
literal|50
expr_stmt|;
name|btypelist
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|maxbsize
argument_list|)
expr_stmt|;
name|ktypelist
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|maxksize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|end_squangling
parameter_list|()
block|{
if|if
condition|(
name|flag_do_squangling
condition|)
block|{
if|if
condition|(
name|ktypelist
condition|)
name|free
argument_list|(
name|ktypelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|btypelist
condition|)
name|free
argument_list|(
name|btypelist
argument_list|)
expr_stmt|;
name|maxbsize
operator|=
literal|0
expr_stmt|;
name|maxksize
operator|=
literal|0
expr_stmt|;
name|maxbtype
operator|=
literal|0
expr_stmt|;
name|maxktype
operator|=
literal|0
expr_stmt|;
name|ktypelist
operator|=
name|NULL
expr_stmt|;
name|btypelist
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Code to concatenate an asciified integer to a string.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|icat
parameter_list|(
name|i
parameter_list|)
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|ui
decl_stmt|;
comment|/* Handle this case first, to go really quickly.  For many common values,      the result of ui/10 below is 1.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|ui
operator|=
name|i
expr_stmt|;
else|else
block|{
name|OB_PUTC
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
name|ui
operator|=
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ui
operator|>=
literal|10
condition|)
name|icat
argument_list|(
name|ui
operator|/
literal|10
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'0'
operator|+
operator|(
name|ui
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dicat
parameter_list|(
name|lo
parameter_list|,
name|hi
parameter_list|)
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|ulo
decl_stmt|,
name|uhi
decl_stmt|,
name|qlo
decl_stmt|,
name|qhi
decl_stmt|;
if|if
condition|(
name|hi
operator|>=
literal|0
condition|)
block|{
name|uhi
operator|=
name|hi
expr_stmt|;
name|ulo
operator|=
name|lo
expr_stmt|;
block|}
else|else
block|{
name|uhi
operator|=
operator|(
name|lo
operator|==
literal|0
condition|?
operator|-
name|hi
else|:
operator|-
name|hi
operator|-
literal|1
operator|)
expr_stmt|;
name|ulo
operator|=
operator|-
name|lo
expr_stmt|;
block|}
if|if
condition|(
name|uhi
operator|==
literal|0
operator|&&
name|ulo
operator|<
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|icat
argument_list|(
name|ulo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Divide 2^HOST_WIDE_INT*uhi+ulo by 10. */
name|qhi
operator|=
name|uhi
operator|/
literal|10
expr_stmt|;
name|uhi
operator|=
name|uhi
operator|%
literal|10
expr_stmt|;
name|qlo
operator|=
name|uhi
operator|*
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|/
literal|5
operator|)
expr_stmt|;
name|qlo
operator|+=
name|ulo
operator|/
literal|10
expr_stmt|;
name|ulo
operator|=
name|ulo
operator|%
literal|10
expr_stmt|;
name|ulo
operator|+=
name|uhi
operator|*
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|%
literal|5
operator|)
operator|*
literal|2
expr_stmt|;
name|qlo
operator|+=
name|ulo
operator|/
literal|10
expr_stmt|;
name|ulo
operator|=
name|ulo
operator|%
literal|10
expr_stmt|;
comment|/* Quotient is 2^HOST_WIDE_INT*qhi+qlo, remainder is ulo. */
name|dicat
argument_list|(
name|qlo
argument_list|,
name|qhi
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'0'
operator|+
name|ulo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the index of TYPE in the typevec, or -1 if it's not there.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|old_backref_index
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|tindex
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|is_back_referenceable_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The entry for this parm is at maxtype-1, so don't look there for      something to repeat.  */
for|for
control|(
name|tindex
operator|=
literal|0
init|;
name|tindex
operator|<
name|maxtype
operator|-
literal|1
condition|;
operator|++
name|tindex
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|typevec
index|[
name|tindex
index|]
argument_list|,
name|type
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tindex
operator|==
name|maxtype
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|tindex
return|;
block|}
end_function

begin_comment
comment|/* Old mangling style:  If TYPE has already been used in the parameter list,    emit a backward reference and return non-zero; otherwise, return 0.     NREPEATS is the number of repeats we've recorded of this type, or 0 if    this is the first time we've seen it and we're just looking to see if    it had been used before.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|flush_repeats
parameter_list|(
name|nrepeats
parameter_list|,
name|type
parameter_list|)
name|int
name|nrepeats
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|tindex
init|=
name|old_backref_index
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|tindex
operator|==
operator|-
literal|1
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|nrepeats
operator|==
literal|0
argument_list|,
literal|990316
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nrepeats
operator|>
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'N'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nrepeats
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
else|else
name|OB_PUTC
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|tindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tindex
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff this is a type to which we will want to make    back-references (using the `B' code).  */
end_comment

begin_function
specifier|static
name|int
name|is_back_referenceable_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* For some reason, the Java folks don't want back refs on these.  */
if|if
condition|(
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|BOOLEAN_TYPE
case|:
if|if
condition|(
operator|!
name|flag_do_squangling
condition|)
comment|/* Even though the mangling of this is just `b', we did 	   historically generate back-references for it.  */
return|return
literal|1
return|;
comment|/* Fall through.  */
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
comment|/* These types have single-character manglings, so there's no 	 point in generating back-references.  */
return|return
literal|0
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
comment|/* It would be a bit complex to demangle signatures correctly if 	 we generated back-references to these, and the manglings of 	 type parameters are short.  */
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Issue the squangling code indicating NREPEATS repetitions of TYPE,    which was the last parameter type output.  */
end_comment

begin_function
specifier|static
name|void
name|issue_nrepeats
parameter_list|(
name|nrepeats
parameter_list|,
name|type
parameter_list|)
name|int
name|nrepeats
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|nrepeats
operator|==
literal|1
operator|&&
operator|!
name|is_back_referenceable_type
argument_list|(
name|type
argument_list|)
condition|)
comment|/* For types whose manglings are short, don't bother using the        repetition code if there's only one repetition, since the        repetition code will be about as long as the ordinary mangling.  */
name|build_mangled_name_for_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|OB_PUTC
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nrepeats
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check to see if a tree node has been entered into the Kcode typelist.    If not, add it.  Returns -1 if it isn't found, otherwise returns the    index.  */
end_comment

begin_function
specifier|static
name|int
name|check_ktype
parameter_list|(
name|node
parameter_list|,
name|add
parameter_list|)
name|tree
name|node
decl_stmt|;
name|int
name|add
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|tree
name|localnode
init|=
name|node
decl_stmt|;
if|if
condition|(
name|ktypelist
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|localnode
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|maxktype
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|same_type_p
argument_list|(
name|localnode
argument_list|,
name|ktypelist
index|[
name|x
index|]
argument_list|)
condition|)
return|return
name|x
return|;
block|}
comment|/* Didn't find it, so add it here.  */
if|if
condition|(
name|add
condition|)
block|{
if|if
condition|(
name|maxksize
operator|<=
name|maxktype
condition|)
block|{
name|maxksize
operator|=
name|maxksize
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
name|ktypelist
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|ktypelist
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|maxksize
argument_list|)
expr_stmt|;
block|}
name|ktypelist
index|[
name|maxktype
operator|++
index|]
operator|=
name|localnode
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|issue_ktype
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|kindex
decl_stmt|;
name|kindex
operator|=
name|check_ktype
argument_list|(
name|decl
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kindex
operator|!=
operator|-
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'K'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|kindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|kindex
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Build a representation for DECL, which may be an entity not at    global scope.  If so, a marker indicating that the name is    qualified has already been output, but the qualifying context has    not.  */
end_comment

begin_function
specifier|static
name|void
name|build_overload_nested_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|ktypelist
operator|&&
name|issue_ktype
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|decl
operator|==
name|global_namespace
condition|)
return|return;
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* try to issue a K type, and if we can't continue the normal path */
if|if
condition|(
operator|!
operator|(
name|ktypelist
operator|&&
name|issue_ktype
argument_list|(
name|context
argument_list|)
operator|)
condition|)
block|{
comment|/* For a template type parameter, we want to output an 'Xn'        rather than 'T' or some such. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|build_mangled_name_for_type
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|build_overload_nested_name
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|static_labelno
argument_list|)
expr_stmt|;
name|static_labelno
operator|++
expr_stmt|;
if|if
condition|(
name|numeric_output_need_bar
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|build_overload_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* TYPE_DECL */
name|build_overload_identifier
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the decimal representation of I.  If I> 9, the decimal    representation is preceeded and followed by an underscore.  */
end_comment

begin_function
specifier|static
name|void
name|build_underscore_int
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_overload_scope_ref
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|OB_PUTC2
argument_list|(
literal|'Q'
argument_list|,
literal|'2'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Encoding for an INTEGER_CST value.  */
end_comment

begin_function
specifier|static
name|void
name|build_overload_int
parameter_list|(
name|value
parameter_list|,
name|in_template
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|in_template
decl_stmt|;
block|{
if|if
condition|(
name|in_template
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|build_overload_scope_ref
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|OB_PUTC
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|operands
init|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|value
argument_list|)
index|]
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|id
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|value
argument_list|)
index|]
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|id
operator|!=
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
comment|/* On some erroneous inputs, we can get here with VALUE a 	       LOOKUP_EXPR.  In that case, the NAME will be the 	       identifier for "<invalid operator>".  We must survive 	       this routine in order to issue a sensible error 	       message, so we fall through to the case below.  */
goto|goto
name|bad_value
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|operands
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|operand
decl_stmt|;
name|enum
name|tree_code
name|tc
decl_stmt|;
comment|/* We just outputted either the `E' or the name of the 		 operator.  */
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
comment|/* Skip the leading underscores.  */
name|OB_PUTCP
argument_list|(
name|name
operator|+
literal|2
argument_list|)
expr_stmt|;
name|operand
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|tc
argument_list|)
operator|==
literal|'t'
condition|)
comment|/* We can get here with sizeof, e.g.: 		      		   template<class T> void f(A<sizeof(T)>);  */
name|build_mangled_name_for_type
argument_list|(
name|operand
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|tc
argument_list|)
argument_list|)
condition|)
name|build_overload_int
argument_list|(
name|operand
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
else|else
name|build_overload_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|,
name|operand
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We don't ever want this output, but it's 	     inconvenient not to be able to build the string. 	     This should cause assembler errors we'll notice.  */
specifier|static
name|int
name|n
decl_stmt|;
name|bad_value
label|:
name|sprintf
argument_list|(
name|digit_buffer
argument_list|,
literal|" *%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'W'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
argument_list|,
literal|243
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
operator|!=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* need to print a DImode value in decimal */
name|dicat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* else fall through to print in smaller mode */
block|}
comment|/* Wordsize or smaller */
name|icat
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output S followed by a representation of the TEMPLATE_PARM_INDEX    supplied in INDEX.  */
end_comment

begin_function
specifier|static
name|void
name|build_mangled_template_parm_index
parameter_list|(
name|s
parameter_list|,
name|index
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|tree
name|index
decl_stmt|;
block|{
name|OB_PUTCP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|build_underscore_int
argument_list|(
name|TEMPLATE_PARM_IDX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use the LEVEL, not the ORIG_LEVEL, because the mangling is a      representation of the function from the point of view of its      type.  */
name|build_underscore_int
argument_list|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mangling for C9X integer types (and Cygnus extensions for 128-bit    and other types) is based on the letter "I" followed by the hex    representations of the bitsize for the type in question. For    encodings that result in larger than two digits, a leading and    trailing underscore is added.     Thus:    int1_t   = 001 = I01    int8_t   = 008 = I08     int16_t  = 010 = I10    int24_t  = 018 = I18    int32_t  = 020 = I20    int64_t  = 040 = I40    int80_t  = 050 = I50    int128_t = 080 = I80    int256_t = 100 = I_100_    int512_t = 200 = I_200_     Given an integer in decimal format, mangle according to this scheme. */
end_comment

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
end_if

begin_function
specifier|static
name|void
name|build_mangled_C9x_name
parameter_list|(
name|bits
parameter_list|)
name|int
name|bits
decl_stmt|;
block|{
name|char
name|mangled
index|[
literal|10
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|bits
operator|>
literal|255
condition|)
name|sprintf
argument_list|(
name|mangled
argument_list|,
literal|"I_%x_"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|mangled
argument_list|,
literal|"I%.2x"
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|build_overload_value
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|,
name|in_template
parameter_list|)
name|tree
name|type
decl_stmt|,
name|value
decl_stmt|;
name|int
name|in_template
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_output_need_bar
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|build_mangled_template_parm_index
argument_list|(
literal|"Y"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|PTRMEM_CST
condition|)
comment|/* We should have already rejected this pointer to member, 	   since it is not a constant.  */
name|my_friendly_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the actual FIELD_DECL.  */
name|value
operator|=
name|PTRMEM_CST_MEMBER
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the name of the field.  */
name|build_overload_identifier
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
block|{
name|build_overload_int
argument_list|(
name|value
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|REAL_TYPE
case|:
block|{
name|REAL_VALUE_TYPE
name|val
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|digit_buffer
decl_stmt|;
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids floating-point template arguments"
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
argument_list|,
literal|244
argument_list|)
expr_stmt|;
name|val
operator|=
name|TREE_REAL_CST
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"NaN"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|val
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
literal|'m'
expr_stmt|;
block|}
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"Infinity"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|val
argument_list|,
literal|"%.20e"
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|bufp
argument_list|,
literal|'e'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|strcat
argument_list|(
name|digit_buffer
argument_list|,
literal|"e0"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|bufp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|==
literal|'-'
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'m'
expr_stmt|;
block|}
name|p
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|bufp
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|bufp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|NO_DOT_IN_LABEL
name|bufp
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|bufp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
condition|)
operator|*
name|bufp
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|OB_PUTCP
argument_list|(
name|digit_buffer
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|build_overload_int
argument_list|(
name|value
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|build_mangled_template_parm_index
argument_list|(
literal|""
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
argument_list|,
literal|245
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
argument_list|,
literal|246
argument_list|)
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|build_overload_scope_ref
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|71
argument_list|)
expr_stmt|;
break|break;
comment|/* not really needed */
case|case
name|RECORD_TYPE
case|:
block|{
name|tree
name|delta
decl_stmt|;
name|tree
name|idx
decl_stmt|;
name|tree
name|pfn
decl_stmt|;
name|tree
name|delta2
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We'll get a ADDR_EXPR of a SCOPE_REF here if we're 	   mangling, an instantiation of something like:  	     template<class T, void (T::*fp)()> class C {}; 	     template<class T> C<T,&T::f> x();   	 	   We mangle the return type of the function, and that 	   contains template parameters.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|build_overload_scope_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PTRMEM_CST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_ptrmemfunc_cst
argument_list|(
name|value
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|pfn
argument_list|,
operator|&
name|delta2
argument_list|)
expr_stmt|;
name|build_overload_int
argument_list|(
name|delta
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_overload_int
argument_list|(
name|idx
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
condition|)
block|{
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
name|build_overload_identifier
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|PTRMEM_CST_MEMBER
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OB_PUTC
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|build_overload_int
argument_list|(
name|delta2
argument_list|,
name|in_template
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|sorry
argument_list|(
literal|"conversion of %s as template parameter"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|type
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|my_friendly_abort
argument_list|(
literal|72
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add encodings for the declaration of template template parameters.    PARMLIST must be a TREE_VEC.  */
end_comment

begin_function
specifier|static
name|void
name|build_template_template_parm_names
parameter_list|(
name|parmlist
parameter_list|)
name|tree
name|parmlist
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parmlist
argument_list|)
operator|==
name|TREE_VEC
argument_list|,
literal|246.5
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parmlist
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* This parameter is a type.  */
name|OB_PUTC
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This parameter is a template. */
name|OB_PUTC
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
name|build_template_template_parm_names
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* It's a PARM_DECL.  */
name|build_mangled_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add encodings for the vector of template parameters in PARMLIST,    given the vector of arguments to be substituted in ARGLIST.  */
end_comment

begin_function
specifier|static
name|void
name|build_template_parm_names
parameter_list|(
name|parmlist
parameter_list|,
name|arglist
parameter_list|)
name|tree
name|parmlist
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
name|tree
name|inner_args
init|=
name|innermost_args
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parmlist
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* This parameter is a type.  */
name|OB_PUTC
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This parameter is a template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
comment|/* Output parameter declaration, argument index and level.  */
name|build_mangled_name_for_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* A TEMPLATE_DECL node, output the parameter declaration  		 and template name */
name|OB_PUTC
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
name|build_template_template_parm_names
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|parm
operator|=
name|tsubst
argument_list|(
name|parm
argument_list|,
name|arglist
argument_list|,
comment|/*complain=*/
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* It's a PARM_DECL.  */
name|build_mangled_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|build_overload_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output the representation for NAME, which is either a TYPE_DECL or    an IDENTIFIER.  */
end_comment

begin_function
specifier|static
name|void
name|build_overload_identifier
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|&&
operator|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|)
condition|)
block|{
comment|/* NAME is the TYPE_DECL for a template specialization.  */
name|tree
name|template
decl_stmt|,
name|parmlist
decl_stmt|,
name|arglist
decl_stmt|,
name|tname
decl_stmt|;
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|tname
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|tname
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|build_template_parm_names
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_output_need_bar
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
block|}
name|icat
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given DECL, either a class TYPE, TYPE_DECL or FUNCTION_DECL, produce    the mangling for it.  Used by build_mangled_name and build_static_name.  */
end_comment

begin_function
specifier|static
name|void
name|build_qualified_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If DECL_ASSEMBLER_NAME has been set properly, use it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_do_squangling
condition|)
block|{
name|tree
name|id
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|OB_PUTID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
index|[
name|IDENTIFIER_LENGTH
argument_list|(
name|id
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|numeric_output_need_bar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|context
operator|=
name|decl
expr_stmt|;
comment|/* If we can't find a Ktype, do it the hard way.  */
if|if
condition|(
name|check_ktype
argument_list|(
name|context
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Count type and namespace scopes.  */
while|while
condition|(
literal|1
condition|)
block|{
name|context
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|global_namespace
condition|)
break|break;
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|check_ktype
argument_list|(
name|context
argument_list|,
name|FALSE
argument_list|)
operator|!=
operator|-
literal|1
condition|)
comment|/* Found one!  */
break|break;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|context
operator|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'Q'
argument_list|)
expr_stmt|;
name|build_underscore_int
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
block|}
name|build_overload_nested_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the mangled representation for TYPE.  If EXTRA_GCODE is    non-zero, mangled names for structure/union types are intentionally    mangled differently from the method described in the ARM.  */
end_comment

begin_function
specifier|static
name|void
name|build_mangled_name_for_type_with_Gcode
parameter_list|(
name|type
parameter_list|,
name|extra_Gcode
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|extra_Gcode
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|process_modifiers
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|process_overload_item
argument_list|(
name|type
argument_list|,
name|extra_Gcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like build_mangled_name_for_type_with_Gcode, but never outputs the    `G'.  */
end_comment

begin_function
specifier|static
name|void
name|build_mangled_name_for_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|build_mangled_name_for_type_with_Gcode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a list of parameters in PARMTYPES, create an unambiguous    overload string. Should distinguish any type that C (or C++) can    distinguish. I.e., pointers to functions are treated correctly.     Caller must deal with whether a final `e' goes on the end or not.     Any default conversions must take place before this function    is called.     BEGIN and END control initialization and finalization of the    obstack where we build the string.  */
end_comment

begin_function
name|char
modifier|*
name|build_overload_name
parameter_list|(
name|parmtypes
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|)
name|tree
name|parmtypes
decl_stmt|;
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|start_squangling
argument_list|()
expr_stmt|;
name|ret
operator|=
name|build_mangled_name
argument_list|(
name|parmtypes
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|end_squangling
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Output the mangled representation for PARMTYPES.  If PARMTYPES is a    TREE_LIST, then it is a list of parameter types.  Otherwise,    PARMTYPES must be a single type.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_mangled_name
parameter_list|(
name|parmtypes
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|)
name|tree
name|parmtypes
decl_stmt|;
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|begin
condition|)
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|TREE_LIST
condition|)
comment|/* There is only one type.  */
name|build_mangled_name_for_type
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* There are several types in a parameter list.  */
name|int
name|nrepeats
init|=
literal|0
decl_stmt|;
name|int
name|old_style_repeats
init|=
operator|!
name|flag_do_squangling
operator|&&
operator|!
name|nofold
operator|&&
name|typevec
decl_stmt|;
name|tree
name|last_type
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
init|;
name|parmtypes
operator|&&
name|parmtypes
operator|!=
name|void_list_node
condition|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
control|)
block|{
comment|/* We used to call canonical_type_variant here, but that isn't 	     good enough; it doesn't handle pointers to typedef types.  So 	     we can't just set TREE_USED to say we've seen a type already; 	     we have to check each of the earlier types with same_type_p.  */
name|tree
name|parmtype
init|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_style_repeats
condition|)
block|{
comment|/* Every argument gets counted.  */
name|my_friendly_assert
argument_list|(
name|maxtype
operator|<
name|typevec_size
argument_list|,
literal|387
argument_list|)
expr_stmt|;
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|parmtype
expr_stmt|;
block|}
if|if
condition|(
name|last_type
operator|&&
name|same_type_p
argument_list|(
name|parmtype
argument_list|,
name|last_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_do_squangling
operator|||
operator|(
name|old_style_repeats
operator|&&
name|is_back_referenceable_type
argument_list|(
name|parmtype
argument_list|)
operator|)
condition|)
block|{
comment|/* The next type is the same as this one.  Keep 		     track of the repetition, and output the repeat 		     count later.  */
name|nrepeats
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|nrepeats
operator|!=
literal|0
condition|)
block|{
comment|/* Indicate how many times the previous parameter was 		 repeated.  */
if|if
condition|(
name|old_style_repeats
condition|)
name|flush_repeats
argument_list|(
name|nrepeats
argument_list|,
name|last_type
argument_list|)
expr_stmt|;
else|else
name|issue_nrepeats
argument_list|(
name|nrepeats
argument_list|,
name|last_type
argument_list|)
expr_stmt|;
name|nrepeats
operator|=
literal|0
expr_stmt|;
block|}
name|last_type
operator|=
name|parmtype
expr_stmt|;
comment|/* Note that for bug-compatibility with 2.7.2, we can't build up 	     repeats of types other than the most recent one.  So we call 	     flush_repeats every round, if we get this far.  */
if|if
condition|(
name|old_style_repeats
operator|&&
name|flush_repeats
argument_list|(
literal|0
argument_list|,
name|parmtype
argument_list|)
condition|)
continue|continue;
comment|/* Output the PARMTYPE.  */
name|build_mangled_name_for_type_with_Gcode
argument_list|(
name|parmtype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the repeat count for the last parameter, if 	 necessary.  */
if|if
condition|(
name|nrepeats
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|old_style_repeats
condition|)
name|flush_repeats
argument_list|(
name|nrepeats
argument_list|,
name|last_type
argument_list|)
expr_stmt|;
else|else
name|issue_nrepeats
argument_list|(
name|nrepeats
argument_list|,
name|last_type
argument_list|)
expr_stmt|;
name|nrepeats
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parmtypes
condition|)
comment|/* The parameter list ends in an ellipsis.  */
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit modifiers such as constant, read-only, and volatile.  */
end_comment

begin_function
specifier|static
name|void
name|process_modifiers
parameter_list|(
name|parmtype
parameter_list|)
name|tree
name|parmtype
decl_stmt|;
block|{
comment|/* Note that here we do not use CP_TYPE_CONST_P and friends because      we describe types recursively; we will get the `const' in       `const int ()[10]' when processing the `const int' part.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|parmtype
operator|!=
name|char_type_node
operator|&&
name|parmtype
operator|!=
name|wchar_type_node
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
comment|/* It would be better to use `R' for `restrict', but that's already      used for reference types.  And `r' is used for `long double'.  */
if|if
condition|(
name|TYPE_RESTRICT
argument_list|(
name|parmtype
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see if TYPE has been entered into the Bcode typelist.  If    so, return 1 and emit a backreference to TYPE.  Otherwise, add TYPE    to the list of back-referenceable types and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|check_btype
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|btypelist
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|is_back_referenceable_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|maxbtype
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|btypelist
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|9
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|maxbsize
operator|<=
name|maxbtype
condition|)
block|{
comment|/* Enlarge the table.  */
name|maxbsize
operator|=
name|maxbsize
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
name|btypelist
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|btypelist
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|maxbsize
argument_list|)
expr_stmt|;
block|}
comment|/* Register the TYPE.  */
name|btypelist
index|[
name|maxbtype
operator|++
index|]
operator|=
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Emit the correct code for various node types.  */
end_comment

begin_function
specifier|static
name|void
name|process_overload_item
parameter_list|(
name|parmtype
parameter_list|,
name|extra_Gcode
parameter_list|)
name|tree
name|parmtype
decl_stmt|;
name|int
name|extra_Gcode
decl_stmt|;
block|{
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
comment|/* Our caller should have already handed any qualifiers, so pull out the      TYPE_MAIN_VARIANT to avoid typedef confusion.  Except we can't do that      for arrays, because they are transparent to qualifiers.  Sigh.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|parmtype
operator|=
name|canonical_type_variant
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
else|else
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
comment|/* These tree types are considered modifiers for B code squangling,      and therefore should not get entries in the Btypelist.  They are,      however, repeatable types.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
case|case
name|REFERENCE_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
case|case
name|ARRAY_TYPE
case|:
if|#
directive|if
name|PARM_CAN_BE_ARRAY_TYPE
block|{
name|OB_PUTC
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parmtype
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|length
init|=
name|array_type_nelts
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|length
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|flag_do_squangling
condition|)
block|{
name|length
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|length
argument_list|)
argument_list|,
name|length
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
name|build_overload_value
argument_list|(
name|sizetype
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numeric_output_need_bar
operator|&&
operator|!
name|flag_do_squangling
condition|)
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
block|}
else|#
directive|else
name|OB_PUTC
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
goto|goto
name|more
goto|;
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
comment|/* Even though the vlist_type_node is PPPFe (i.e. `int 	 (***)(...)'), it is different from the any other occurence of 	 the pointer type, because the underlying function type is 	 different.  */
if|if
condition|(
name|parmtype
operator|==
name|vlist_type_node
condition|)
block|{
name|OB_PUTS
argument_list|(
name|VLIST_TYPE_NAME
argument_list|)
expr_stmt|;
return|return;
block|}
name|OB_PUTC
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|more
label|:
name|build_mangled_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
return|return;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|flag_do_squangling
operator|&&
name|check_btype
argument_list|(
name|parmtype
argument_list|)
condition|)
comment|/* If PARMTYPE is already in the list of back-referenceable types,        then check_btype will output the appropriate reference, and        there's nothing more to do.  */
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
case|case
name|OFFSET_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
comment|/* Rather than implementing a reentrant TYPEVEC, we turn off 	   repeat codes here, unless we're squangling.  Squangling 	   doesn't make use of the TYPEVEC, so there's no reentrancy 	   problem.  */
name|int
name|old_nofold
init|=
name|nofold
decl_stmt|;
if|if
condition|(
operator|!
name|flag_do_squangling
condition|)
name|nofold
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Mark this as a method.  */
name|OB_PUTC
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
comment|/* Output the class of which this method is a member.  */
name|build_mangled_name_for_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output any qualifiers for the `this' parameter.  */
name|process_modifiers
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Output the parameter types.  */
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
name|build_mangled_name
argument_list|(
name|parms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the return type.  */
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
name|nofold
operator|=
name|old_nofold
expr_stmt|;
break|break;
block|}
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|parmtype
operator|==
name|integer_type_node
operator|||
name|parmtype
operator|==
name|unsigned_type_node
operator|||
name|parmtype
operator|==
name|java_int_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_unsigned_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|short_integer_type_node
operator|||
name|parmtype
operator|==
name|short_unsigned_type_node
operator|||
name|parmtype
operator|==
name|java_short_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|signed_char_type_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|char_type_node
operator|||
name|parmtype
operator|==
name|unsigned_char_type_node
operator|||
name|parmtype
operator|==
name|java_byte_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|wchar_type_node
operator|||
name|parmtype
operator|==
name|java_char_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|long_long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_long_unsigned_type_node
operator|||
name|parmtype
operator|==
name|java_long_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|java_boolean_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|intTI_type_node
operator|||
name|parmtype
operator|==
name|unsigned_intTI_type_node
condition|)
block|{
comment|/* Should just check a flag here instead of specific 	   *_type_nodes, because all C9x types could use this. */
name|int
name|bits
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
decl_stmt|;
name|build_mangled_C9x_name
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|my_friendly_abort
argument_list|(
literal|73
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|parmtype
operator|==
name|long_double_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|double_type_node
operator|||
name|parmtype
operator|==
name|java_double_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|float_type_node
operator|||
name|parmtype
operator|==
name|java_float_type_node
condition|)
name|OB_PUTC
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|74
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'J'
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
comment|/* not right, but nothing is anyway */
break|break;
comment|/* have to do these */
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
block|{
if|if
condition|(
name|extra_Gcode
condition|)
name|OB_PUTC
argument_list|(
literal|'G'
argument_list|)
expr_stmt|;
comment|/* make it look incompatible with AT&T */
comment|/* drop through into next case */
block|}
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
argument_list|,
literal|248
argument_list|)
expr_stmt|;
name|build_qualified_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNKNOWN_TYPE
case|:
comment|/* This will take some work.  */
name|OB_PUTC
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
comment|/* Find and output the original template parameter           declaration. */
if|if
condition|(
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
name|build_mangled_template_parm_index
argument_list|(
literal|"tzX"
argument_list|,
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
name|build_template_parm_names
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_TI_ARGS
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|build_mangled_template_parm_index
argument_list|(
literal|"ZzX"
argument_list|,
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
name|build_template_template_parm_names
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|parmtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TEMPLATE_TYPE_PARM
case|:
name|build_mangled_template_parm_index
argument_list|(
literal|"X"
argument_list|,
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|parmtype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
comment|/* When mangling the type of a function template whose          declaration looks like:           template<class T> void foo(typename T::U)                    we have to mangle these.  */
name|build_qualified_name
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|75
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Produce the mangling for a variable named NAME in CONTEXT, which can    be either a class TYPE or a FUNCTION_DECL.  */
end_comment

begin_function
name|tree
name|build_static_name
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|)
name|tree
name|context
decl_stmt|,
name|name
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
name|start_squangling
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|JOINER
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_qualified_name
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
name|JOINER
argument_list|)
expr_stmt|;
else|#
directive|else
name|OB_PUTS
argument_list|(
literal|"__static_"
argument_list|)
expr_stmt|;
name|build_qualified_name
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|end_squangling
argument_list|()
expr_stmt|;
return|return
name|get_identifier
argument_list|(
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FOR_METHOD should be 1 if the declaration in question is for a member    of a class (including a static member) and 2 if the declaration is    for a constructor.  */
end_comment

begin_function
name|tree
name|build_decl_overload_real
parameter_list|(
name|dname
parameter_list|,
name|parms
parameter_list|,
name|ret_type
parameter_list|,
name|tparms
parameter_list|,
name|targs
parameter_list|,
name|for_method
parameter_list|)
name|tree
name|dname
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|tree
name|ret_type
decl_stmt|;
name|tree
name|tparms
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|int
name|for_method
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|dname
argument_list|)
decl_stmt|;
comment|/* member operators new and delete look like methods at this point.  */
if|if
condition|(
operator|!
name|for_method
operator|&&
name|parms
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|parms
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
name|void_list_node
condition|)
block|{
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_delete"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_DELETE_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_vec_delete"
argument_list|)
return|;
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_new"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|dname
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|VEC_NEW_EXPR
index|]
condition|)
return|return
name|get_identifier
argument_list|(
literal|"__builtin_vec_new"
argument_list|)
return|;
block|}
name|start_squangling
argument_list|()
expr_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_method
operator|!=
literal|2
condition|)
name|OB_PUTCP
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Otherwise, we can divine that this is a constructor,      and figure out its name without any extra encoding.  */
name|OB_PUTC2
argument_list|(
literal|'_'
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|numeric_output_need_bar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tparms
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
name|build_template_parm_names
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|for_method
operator|&&
name|current_namespace
operator|==
name|global_namespace
condition|)
comment|/* XXX this works only if we call this in the same namespace        as the declaration. Unfortunately, we don't have the _DECL,        only its name */
name|OB_PUTC
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_method
operator|&&
name|current_namespace
operator|!=
name|global_namespace
condition|)
comment|/* qualify with namespace */
name|build_qualified_name
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|OB_PUTC
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|flag_do_squangling
condition|)
block|{
comment|/* Allocate typevec array.  */
name|maxtype
operator|=
literal|0
expr_stmt|;
name|typevec_size
operator|=
name|list_length
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_method
operator|&&
name|current_namespace
operator|!=
name|global_namespace
condition|)
comment|/* The namespace of a global function needs one slot.  */
name|typevec_size
operator|++
expr_stmt|;
name|typevec
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|typevec_size
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nofold
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
name|tree
name|this_type
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|this_type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
comment|/* a signature pointer */
name|this_type
operator|=
name|SIGNATURE_TYPE
argument_list|(
name|this_type
argument_list|)
expr_stmt|;
else|else
name|this_type
operator|=
name|TREE_TYPE
argument_list|(
name|this_type
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|this_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_do_squangling
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|maxtype
operator|<
name|typevec_size
argument_list|,
literal|387
argument_list|)
expr_stmt|;
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|this_type
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
condition|)
name|build_mangled_name
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|OB_PUTC
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the namespace qualifier for a global function  	     will count as type */
if|if
condition|(
name|current_namespace
operator|!=
name|global_namespace
operator|&&
operator|!
name|flag_do_squangling
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|maxtype
operator|<
name|typevec_size
argument_list|,
literal|387
argument_list|)
expr_stmt|;
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|current_namespace
expr_stmt|;
block|}
name|build_mangled_name
argument_list|(
name|parms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_do_squangling
condition|)
comment|/* Deallocate typevec array.  */
name|typevec
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret_type
operator|!=
name|NULL_TREE
operator|&&
name|for_method
operator|!=
literal|2
condition|)
block|{
comment|/* Add the return type. */
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|ret_type
argument_list|)
expr_stmt|;
block|}
name|OB_FINISH
argument_list|()
expr_stmt|;
name|end_squangling
argument_list|()
expr_stmt|;
block|{
name|tree
name|n
init|=
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|dname
argument_list|)
condition|)
name|IDENTIFIER_OPNAME_P
argument_list|(
name|n
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
end_function

begin_comment
comment|/* Change the name of a function definition so that it may be    overloaded. NAME is the name of the function to overload,    PARMS is the parameter list (which determines what name the    final function obtains).     FOR_METHOD is 1 if this overload is being performed    for a method, rather than a function type.  It is 2 if    this overload is being performed for a constructor.  */
end_comment

begin_function
name|tree
name|build_decl_overload
parameter_list|(
name|dname
parameter_list|,
name|parms
parameter_list|,
name|for_method
parameter_list|)
name|tree
name|dname
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|for_method
decl_stmt|;
block|{
return|return
name|build_decl_overload_real
argument_list|(
name|dname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|for_method
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */
end_comment

begin_function
name|void
name|set_mangled_name_for_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|parm_types
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* There's no need to mangle the name of a template function.  */
return|return;
name|parm_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|parm_types
operator|=
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|parm_types
argument_list|)
expr_stmt|;
else|else
comment|/* The only member functions whose type is a FUNCTION_TYPE, rather        than a METHOD_TYPE, should be static members.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|parm_types
argument_list|,
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|+
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build an overload name for the type expression TYPE.  */
end_comment

begin_function
name|tree
name|build_typename_overload
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTID
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
name|start_squangling
argument_list|()
expr_stmt|;
name|build_mangled_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|id
operator|=
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|IDENTIFIER_GLOBAL_VALUE (id) = TYPE_MAIN_DECL (type);
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|=
name|type
expr_stmt|;
name|end_squangling
argument_list|()
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
name|tree
name|build_overload_with_type
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTID
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
name|start_squangling
argument_list|()
expr_stmt|;
name|build_mangled_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end_squangling
argument_list|()
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|get_id_2
parameter_list|(
name|name
parameter_list|,
name|name2
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|name2
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a binfo path T, starting with the most derived class. If    OMIT_LAST is set, drop and return the most derived class.  */
end_comment

begin_function
specifier|static
name|tree
name|build_base_path
parameter_list|(
name|t
parameter_list|,
name|omit_last
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|omit_last
decl_stmt|;
block|{
name|tree
name|ret
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|ret
operator|=
name|build_base_path
argument_list|(
name|BINFO_INHERITANCE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|omit_last
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|omit_last
condition|)
return|return
name|t
return|;
name|process_overload_item
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a mangled name for a vlist vtable, using the path of both    BASE and VBASE.  */
end_comment

begin_function
name|tree
name|get_vlist_vtable_id
parameter_list|(
name|base
parameter_list|,
name|vbase
parameter_list|)
name|tree
name|base
decl_stmt|,
name|vbase
decl_stmt|;
block|{
name|tree
name|last
decl_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
name|VCTABLE_NAME
argument_list|)
expr_stmt|;
name|build_base_path
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
comment|/* Since the base path should end where the vbase path starts, we      can omit the most-derived class in the vbase path. Check below      that this really happens.  */
name|last
operator|=
name|build_base_path
argument_list|(
name|vbase
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|BINFO_TYPE
argument_list|(
name|last
argument_list|)
operator|==
name|BINFO_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
literal|990402
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a DECL_ASSEMBLER_NAME for the destructor of type TYPE. If    HAS_VLIST is set, also add the vlist argument.  */
end_comment

begin_function
name|tree
name|build_destructor_name
parameter_list|(
name|type
parameter_list|,
name|has_vlist
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|has_vlist
decl_stmt|;
block|{
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
name|DESTRUCTOR_DECL_PREFIX
argument_list|)
expr_stmt|;
name|start_squangling
argument_list|()
expr_stmt|;
name|build_mangled_name_for_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If we need backwards compatibility, we can get aways by      not linking type-safely, as the dtor will check whether      the argument was provided.  */
if|if
condition|(
name|has_vlist
operator|&&
operator|!
name|flag_vtable_thunks_compat
condition|)
name|OB_PUTS
argument_list|(
name|VLIST_TYPE_NAME
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|end_squangling
argument_list|()
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree_code CODE, and some arguments (at least one),    attempt to use an overloaded operator on the arguments.     For unary operators, only the first argument need be checked.    For binary operators, both arguments may need to be checked.     Member functions can convert class references to class pointers,    for one-level deep indirection.  More than that is not supported.    Operators [](), ()(), and ->() must be member functions.     We call function call building calls with LOOKUP_COMPLAIN if they    are our only hope.  This is true when we see a vanilla operator    applied to something of aggregate type.  If this fails, we are free    to return `error_mark_node', because we will have reported the    error.     Operators NEW and DELETE overload in funny ways: operator new takes    a single `size' parameter, and operator delete takes a pointer to the    storage being deleted.  When overloading these operators, success is    assumed.  If there is a failure, report an error message and return    `error_mark_node'.  */
end_comment

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|tree
name|build_opfncall
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|xarg1
parameter_list|,
name|xarg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|xarg1
decl_stmt|,
name|xarg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|flags
argument_list|,
name|xarg1
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function takes an identifier, ID, and attempts to figure out what    it means. There are a number of possible scenarios, presented in increasing    order of hair:     1) not in a class's scope    2) in class's scope, member name of the class's method    3) in class's scope, but not a member name of the class    4) in class's scope, member name of a class's variable     NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.    VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)     As a last ditch, try to look up the name as a label and return that    address.     Values which are declared as being of REFERENCE_TYPE are    automatically dereferenced here (as a hack to make the    compiler faster).  */
end_comment

begin_function
name|tree
name|hack_identifier
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|)
name|tree
name|value
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|current_class_name
condition|)
block|{
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|fields
condition|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|251
argument_list|)
expr_stmt|;
comment|/* I could not trigger this code. MvL */
name|my_friendly_abort
argument_list|(
literal|980325
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEAD
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"methods cannot be converted to function pointers"
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ambiguous request for method pointer `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|flag_labels_ok
operator|&&
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|current_class_ptr
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"invalid use of member `%D' in static member function"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
comment|/* We can get here when processing a bad default 	       argument, like: 	         struct S { int a; void f(int i = a); }  */
name|cp_error
argument_list|(
literal|"invalid use of member `%D'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|value
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|value
operator|=
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SIGNATURE
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
return|return
name|value
return|;
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_component_ref
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|value
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
comment|/* not really overloaded function */
name|mark_used
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Ambiguous reference to base members, possibly other cases?.  */
name|tree
name|t
init|=
name|value
decl_stmt|;
while|while
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|mark_used
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"use of namespace `%D' as expression"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"use of class template `%T' as expression"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|mark_used
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|cp_error
argument_list|(
literal|"use of %s from containing function"
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|?
literal|"`auto' variable"
else|:
literal|"parameter"
operator|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  `%#D' declared here"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|value
argument_list|)
operator|&&
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|path
decl_stmt|;
specifier|register
name|tree
name|context
init|=
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|value
argument_list|)
operator|)
condition|?
name|DECL_CLASS_CONTEXT
argument_list|(
name|value
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|get_base_distance
argument_list|(
name|context
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|&&
operator|!
name|enforce_access
argument_list|(
name|current_class_type
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' is ambiguous in multiple inheritance lattice"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|value
operator|=
name|convert_from_reference
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|make_thunk
parameter_list|(
name|function
parameter_list|,
name|delta
parameter_list|)
name|tree
name|function
decl_stmt|;
name|int
name|delta
decl_stmt|;
block|{
name|tree
name|thunk_id
decl_stmt|;
name|tree
name|thunk
decl_stmt|;
name|tree
name|func_decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|func_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"__thunk_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|icat
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
name|icat
argument_list|(
operator|-
name|delta
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|OB_PUTID
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|func_decl
argument_list|)
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|thunk_id
operator|=
name|get_identifier
argument_list|(
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|thunk
operator|&&
name|TREE_CODE
argument_list|(
name|thunk
argument_list|)
operator|!=
name|THUNK_DECL
condition|)
block|{
name|cp_error
argument_list|(
literal|"implementation-reserved name `%D' used"
argument_list|,
name|thunk_id
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|NULL_TREE
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|,
name|thunk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thunk
operator|==
name|NULL_TREE
condition|)
block|{
name|thunk
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|thunk_id
argument_list|,
name|TREE_TYPE
argument_list|(
name|func_decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|comdat_linkage
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|thunk
argument_list|,
name|THUNK_DECL
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|thunk
argument_list|)
operator|=
name|function
expr_stmt|;
name|THUNK_DELTA
argument_list|(
name|thunk
argument_list|)
operator|=
name|delta
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* So that finish_file can write out any thunks that need to be: */
name|pushdecl_top_level
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
block|}
return|return
name|thunk
return|;
block|}
end_function

begin_comment
comment|/* Emit the definition of a C++ multiple inheritance vtable thunk.  */
end_comment

begin_function
name|void
name|emit_thunk
parameter_list|(
name|thunk_fndecl
parameter_list|)
name|tree
name|thunk_fndecl
decl_stmt|;
block|{
name|tree
name|function
init|=
name|TREE_OPERAND
argument_list|(
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|delta
init|=
name|THUNK_DELTA
argument_list|(
name|thunk_fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|thunk_fndecl
argument_list|,
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
name|char
modifier|*
name|fnname
decl_stmt|;
name|current_function_decl
operator|=
name|thunk_fndecl
expr_stmt|;
comment|/* Make sure we build up its RTL before we go onto the        temporary obstack.  */
name|make_function_rtl
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|temporary_allocation
argument_list|()
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_function_start
argument_list|(
name|thunk_fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|current_function_is_thunk
operator|=
literal|1
expr_stmt|;
name|assemble_start_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_MI_THUNK
argument_list|(
name|asm_out_file
argument_list|,
name|thunk_fndecl
argument_list|,
name|delta
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|assemble_end_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ASM_OUTPUT_MI_THUNK */
comment|/* If we don't have the necessary macro for efficient thunks, generate a      thunk function that just makes a call to the real function.      Unfortunately, this doesn't work for varargs.  */
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|varargs_function_p
argument_list|(
name|function
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"generic thunk code fails for method `%#D' which uses `...'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Set up clone argument trees for the thunk.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|function
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|x
init|=
name|copy_node
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|thunk_fndecl
expr_stmt|;
name|t
operator|=
name|x
expr_stmt|;
block|}
name|a
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|a
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|thunk_fndecl
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|current_function_is_thunk
operator|=
literal|1
expr_stmt|;
comment|/* Build up the call to the real function.  */
name|t
operator|=
name|build_int_2
argument_list|(
name|delta
argument_list|,
operator|-
literal|1
operator|*
operator|(
name|delta
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|signed_type
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
argument_list|,
name|a
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
name|t
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|a
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|function
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|c_expand_return
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't let the backend defer this function.  */
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
block|{
name|output_inline_function
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ASM_OUTPUT_MI_THUNK */
block|}
name|TREE_SET_CODE
argument_list|(
name|thunk_fndecl
argument_list|,
name|THUNK_DECL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|maybe_vlist_ctor_wrapper
parameter_list|(
name|fn
parameter_list|,
name|definep
parameter_list|)
name|tree
name|fn
decl_stmt|;
name|int
name|definep
decl_stmt|;
block|{
name|tree
name|fntype
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|arg_types
decl_stmt|,
name|parms
decl_stmt|,
name|parm
decl_stmt|,
name|basetype
decl_stmt|,
name|pbasetype
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|ctors
decl_stmt|;
if|if
condition|(
operator|!
name|flag_vtable_thunks_compat
operator|||
operator|!
name|DECL_CONSTRUCTOR_FOR_PVBASE_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|pbasetype
operator|=
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|pbasetype
argument_list|)
expr_stmt|;
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Skip this, __in_chrg, and _vlist */
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add __in_charge.  */
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
comment|/* Don't add this to arg_types, as build_cplus_method_type does so. */
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
argument_list|,
name|fntype
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|->
name|decl_flags
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|fn
argument_list|)
operator|->
name|decl_flags
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONSTRUCTOR_FOR_VBASE
argument_list|(
name|decl
argument_list|)
operator|=
name|CONSTRUCTOR_FOR_VBASE
expr_stmt|;
comment|/* Claim that this is never a template instantiation.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Set up clone argument trees for the thunk.  */
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this */
name|t
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|this_identifier
argument_list|,
name|pbasetype
argument_list|)
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|pbasetype
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Add __in_charge.  */
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|in_charge_identifier
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|SET_DECL_ARTIFICIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|parm
expr_stmt|;
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|x
init|=
name|copy_node
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|decl
expr_stmt|;
name|t
operator|=
name|x
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
operator|=
name|parms
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ctors
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctors
condition|)
name|ctors
operator|=
name|TREE_VEC_ELT
argument_list|(
name|ctors
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ctors
condition|;
name|ctors
operator|=
name|OVL_NEXT
argument_list|(
name|ctors
argument_list|)
control|)
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ctors
condition|)
block|{
name|add_method
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|decl
operator|=
name|OVL_CURRENT
argument_list|(
name|ctors
argument_list|)
expr_stmt|;
comment|/* Remember the original function.  */
name|DECL_VLIST_CTOR_WRAPPED
argument_list|(
name|decl
argument_list|)
operator|=
name|fn
expr_stmt|;
comment|/* If this is called from start_method, definep is -1. Then we      are inside the class, and fn is inline by default.  */
if|if
condition|(
name|definep
condition|)
block|{
comment|/* Record that the ctor is being defined, so we also emit the 	 wrapper later. */
if|if
condition|(
name|DECL_THIS_INLINE
argument_list|(
name|fn
argument_list|)
operator|||
operator|(
name|definep
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|DECL_THIS_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|mark_inline_for_output
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_vlist_ctor_wrapper
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|parms
decl_stmt|,
name|fn
decl_stmt|;
name|current_function_is_thunk
operator|=
literal|1
expr_stmt|;
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|fn
operator|=
name|DECL_VLIST_CTOR_WRAPPED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Build up the call to the real function.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Push this, __in_charge.  */
name|t
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parms
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|t
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parms
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Push 0 as __vlist.  */
name|t
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|vlist_zero_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Push rest of arguments.  */
while|while
condition|(
name|parms
condition|)
block|{
name|t
operator|=
name|expr_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parms
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|fn
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for synthesizing methods which have default semantics defined.  */
end_comment

begin_comment
comment|/* For the anonymous union in TYPE, return the member that is at least as    large as the rest of the members, so we can copy it.  */
end_comment

begin_function
specifier|static
name|tree
name|largest_union_member
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|f
decl_stmt|,
name|type_size
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|DECL_SIZE
argument_list|(
name|f
argument_list|)
argument_list|,
name|type_size
argument_list|)
operator|==
literal|1
condition|)
return|return
name|f
return|;
comment|/* We should always find one.  */
name|my_friendly_abort
argument_list|(
literal|323
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
specifier|static
name|void
name|do_build_copy_constructor
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_PVBASES
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cplus_expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize all the base-classes.  */
for|for
control|(
name|t
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|current_base_init_list
operator|=
name|tree_cons
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|parm
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|t
operator|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
name|current_base_init_list
operator|=
name|tree_cons
argument_list|(
name|BINFO_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|parm
argument_list|,
name|current_base_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|init
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|init
operator|=
name|parm
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
do|do
block|{
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|t
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|field
operator|=
name|largest_union_member
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
do|;
block|}
else|else
continue|continue;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|current_member_init_list
operator|=
name|tree_cons
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|init
argument_list|,
name|current_member_init_list
argument_list|)
expr_stmt|;
block|}
name|current_member_init_list
operator|=
name|nreverse
argument_list|(
name|current_member_init_list
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|nreverse
argument_list|(
name|current_base_init_list
argument_list|)
expr_stmt|;
name|setup_vtbl_ptr
argument_list|()
expr_stmt|;
block|}
name|pop_momentary
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_build_assign_ref
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cplus_expand_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p
init|=
name|convert_to_reference
argument_list|(
name|build_reference_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|parm
argument_list|,
name|CONV_IMPLICIT
operator||
name|CONV_CONST
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|p
operator|=
name|convert_from_reference
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|build_member_call
argument_list|(
name|basetype
argument_list|,
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
argument_list|,
name|build_expr_list
argument_list|(
name|NULL_TREE
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|comp
decl_stmt|,
name|init
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"non-static const member `%#D', can't use default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"non-static const member in type `%T', can't use default assignment operator"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|cp_error
argument_list|(
literal|"non-static reference member `%#D', can't use default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
else|else
name|cp_error
argument_list|(
literal|"non-static reference member in type `%T', can't use default assignment operator"
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|comp
operator|=
name|current_class_ref
expr_stmt|;
name|init
operator|=
name|parm
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|VBASE_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
do|do
block|{
name|comp
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|t
argument_list|,
name|comp
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|t
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|field
operator|=
name|largest_union_member
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|ANON_UNION_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
do|;
block|}
else|else
continue|continue;
name|comp
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|comp
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|comp
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|c_expand_return
argument_list|(
name|current_class_ref
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|synthesize_method
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|int
name|nested
init|=
operator|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
name|tree
name|context
init|=
name|hack_decl_function_context
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* If this is a wrapper around a undefined vlist ctor, don't emit it      even if it is used.  */
if|if
condition|(
name|DECL_VLIST_CTOR_WRAPPER_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|orig_fn
init|=
name|DECL_VLIST_CTOR_WRAPPED
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|mark_used
argument_list|(
name|orig_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|orig_fn
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
block|}
if|if
condition|(
name|at_eof
condition|)
name|import_export_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|push_cp_function_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|ansi_opname
index|[
name|MODIFY_EXPR
index|]
condition|)
name|do_build_assign_ref
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|tree
name|arg_chain
init|=
name|FUNCTION_ARG_CHAIN
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|arg_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_PVBASE_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|arg_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VLIST_CTOR_WRAPPER_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|emit_vlist_ctor_wrapper
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg_chain
operator|!=
name|void_list_node
condition|)
name|do_build_copy_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|setup_vtbl_ptr
argument_list|()
expr_stmt|;
block|}
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|,
name|nested
argument_list|)
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|pop_cp_function_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

