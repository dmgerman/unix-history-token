begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and variable name overloading.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,     1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Various flags to control the mangling process.  */
end_comment

begin_enum
enum|enum
name|mangling_flags
block|{
comment|/* No flags.  */
name|mf_none
init|=
literal|0
block|,
comment|/* The thing we are presently mangling is part of a template type,      rather than a fully instantiated type.  Therefore, we may see      complex expressions where we would normally expect to see a      simple integer constant.  */
name|mf_maybe_uninstantiated
init|=
literal|1
block|,
comment|/* When mangling a numeric value, use the form `_XX_' (instead of      just `XX') if the value has more than one digit.  */
name|mf_use_underscores_around_value
init|=
literal|2
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|mangling_flags
name|mangling_flags
typedef|;
end_typedef

begin_function_decl
specifier|static
name|tree
name|thunk_adjust
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_build_assign_ref
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_build_copy_constructor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|synthesize_exception_spec
parameter_list|(
name|tree
parameter_list|,
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|locate_dtor
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|locate_ctor
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|locate_copy
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
end_ifdef

begin_function_decl
specifier|static
name|tree
name|make_alias_for_thunk
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called once to initialize method.c.  */
end_comment

begin_function
name|void
name|init_method
parameter_list|(
name|void
parameter_list|)
block|{
name|init_mangle
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */
end_comment

begin_function
name|void
name|set_mangled_name_for_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* There's no need to mangle the name of a template function.  */
return|return;
name|mangle_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a this or result adjusting thunk to FUNCTION.  THIS_ADJUSTING    indicates whether it is a this or result adjusting thunk.    FIXED_OFFSET and VIRTUAL_OFFSET indicate how to do the adjustment    (see thunk_adjust).  VIRTUAL_OFFSET can be NULL, but FIXED_OFFSET    never is.  VIRTUAL_OFFSET is the /index/ into the vtable for this    adjusting thunks, we scale it to a byte offset. For covariant    thunks VIRTUAL_OFFSET is the virtual binfo.  You must post process    the returned thunk with finish_thunk.  */
end_comment

begin_function
name|tree
name|make_thunk
parameter_list|(
name|tree
name|function
parameter_list|,
name|bool
name|this_adjusting
parameter_list|,
name|tree
name|fixed_offset
parameter_list|,
name|tree
name|virtual_offset
parameter_list|)
block|{
name|HOST_WIDE_INT
name|d
decl_stmt|;
name|tree
name|thunk
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|20021025
argument_list|)
expr_stmt|;
comment|/* We can have this thunks to covariant thunks, but not vice versa.  */
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_THIS_THUNK_P
argument_list|(
name|function
argument_list|)
argument_list|,
literal|20021127
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_RESULT_THUNK_P
argument_list|(
name|function
argument_list|)
operator|||
name|this_adjusting
argument_list|,
literal|20031123
argument_list|)
expr_stmt|;
comment|/* Scale the VIRTUAL_OFFSET to be in terms of bytes.  */
if|if
condition|(
name|this_adjusting
operator|&&
name|virtual_offset
condition|)
name|virtual_offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|virtual_offset
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|tree_low_cst
argument_list|(
name|fixed_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if we already have the thunk in question.  For this_adjusting      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it      will be a BINFO.  */
for|for
control|(
name|thunk
operator|=
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
init|;
name|thunk
condition|;
name|thunk
operator|=
name|TREE_CHAIN
argument_list|(
name|thunk
argument_list|)
control|)
if|if
condition|(
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk
argument_list|)
operator|==
name|this_adjusting
operator|&&
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|==
name|d
operator|&&
operator|!
name|virtual_offset
operator|==
operator|!
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|&&
operator|(
operator|!
name|virtual_offset
operator|||
operator|(
name|this_adjusting
condition|?
name|tree_int_cst_equal
argument_list|(
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
argument_list|,
name|virtual_offset
argument_list|)
else|:
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|==
name|virtual_offset
operator|)
operator|)
condition|)
return|return
name|thunk
return|;
comment|/* All thunks must be created before FUNCTION is actually emitted;      the ABI requires that all thunks be emitted together with the      function to which they transfer control.  */
name|my_friendly_assert
argument_list|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|function
argument_list|)
argument_list|,
literal|20021025
argument_list|)
expr_stmt|;
comment|/* Likewise, we can only be adding thunks to a function declared in      the class currently being laid out.  */
name|my_friendly_assert
argument_list|(
name|TYPE_SIZE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
literal|20031211
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|SET_DECL_THUNK_P
argument_list|(
name|thunk
argument_list|,
name|this_adjusting
argument_list|)
expr_stmt|;
name|THUNK_TARGET
argument_list|(
name|thunk
argument_list|)
operator|=
name|function
expr_stmt|;
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|=
name|d
expr_stmt|;
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|=
name|virtual_offset
expr_stmt|;
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The thunk itself is not a constructor or destructor, even if      the thing it is thunking to is.  */
name|DECL_INTERFACE_KNOWN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_DESTRUCTOR_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* And neither is it a clone.  */
name|DECL_CLONED_FUNCTION
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if this thunk is a member of a local class, we don't      need a static chain.  */
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The THUNK is not a pending inline, even if the FUNCTION is.  */
name|DECL_PENDING_INLINE_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Nor has it been deferred.  */
name|DECL_DEFERRED_FN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Add it to the list of thunks associated with FUNCTION.  */
name|TREE_CHAIN
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
operator|=
name|thunk
expr_stmt|;
return|return
name|thunk
return|;
block|}
end_function

begin_comment
comment|/* Finish THUNK, a thunk decl.  */
end_comment

begin_function
name|void
name|finish_thunk
parameter_list|(
name|tree
name|thunk
parameter_list|)
block|{
name|tree
name|function
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|fixed_offset
init|=
name|ssize_int
argument_list|(
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|virtual_offset
init|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_NAME
argument_list|(
name|thunk
argument_list|)
operator|&&
name|DECL_THUNK_P
argument_list|(
name|thunk
argument_list|)
argument_list|,
literal|20021127
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_offset
operator|&&
name|DECL_RESULT_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
name|virtual_offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|virtual_offset
argument_list|)
expr_stmt|;
name|function
operator|=
name|THUNK_TARGET
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|name
operator|=
name|mangle_thunk
argument_list|(
name|function
argument_list|,
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk
argument_list|)
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* We can end up with declarations of (logically) different      covariant thunks, that do identical adjustments.  The two thunks      will be adjusting between within different hierarchies, which      happen to have the same layout.  We must nullify one of them to      refer to the other.  */
if|if
condition|(
name|DECL_RESULT_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|tree
name|cov_probe
decl_stmt|;
for|for
control|(
name|cov_probe
operator|=
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
init|;
name|cov_probe
condition|;
name|cov_probe
operator|=
name|TREE_CHAIN
argument_list|(
name|cov_probe
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|cov_probe
argument_list|)
operator|==
name|name
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|!
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
argument_list|,
literal|20031023
argument_list|)
expr_stmt|;
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
operator|=
operator|(
name|THUNK_ALIAS
argument_list|(
name|cov_probe
argument_list|)
condition|?
name|THUNK_ALIAS
argument_list|(
name|cov_probe
argument_list|)
else|:
name|cov_probe
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|DECL_NAME
argument_list|(
name|thunk
argument_list|)
operator|=
name|name
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|thunk
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust PTR by the constant FIXED_OFFSET, and by the vtable    offset indicated by VIRTUAL_OFFSET, if that is    non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and    zero for a result adjusting thunk.  */
end_comment

begin_function
specifier|static
name|tree
name|thunk_adjust
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|bool
name|this_adjusting
parameter_list|,
name|HOST_WIDE_INT
name|fixed_offset
parameter_list|,
name|tree
name|virtual_offset
parameter_list|)
block|{
if|if
condition|(
name|this_adjusting
condition|)
comment|/* Adjust the pointer by the constant.  */
name|ptr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|ssize_int
argument_list|(
name|fixed_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's a virtual offset, look up that value in the vtable and      adjust the pointer again.  */
if|if
condition|(
name|virtual_offset
condition|)
block|{
name|tree
name|vtable
decl_stmt|;
name|ptr
operator|=
name|save_expr
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* The vptr is always at offset zero in the object.  */
name|vtable
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Form the vtable address.  */
name|vtable
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|)
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
comment|/* Find the entry with the vcall offset.  */
name|vtable
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|,
name|vtable
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* Get the offset itself.  */
name|vtable
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|)
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
comment|/* Adjust the `this' pointer.  */
name|ptr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|vtable
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_adjusting
condition|)
comment|/* Adjust the pointer by the constant.  */
name|ptr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|ssize_int
argument_list|(
name|fixed_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Garbage collector tables contains thunk_labelno even when places    inside ifdef block.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|thunk_labelno
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
end_ifdef

begin_comment
comment|/* Create a static alias to function.  */
end_comment

begin_function
specifier|static
name|tree
name|make_alias_for_thunk
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|alias
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TARGET_IS_PE_COFF
argument_list|)
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|function
argument_list|)
condition|)
return|return
name|function
return|;
endif|#
directive|endif
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LTHUNK"
argument_list|,
name|thunk_labelno
argument_list|)
expr_stmt|;
name|thunk_labelno
operator|++
expr_stmt|;
name|alias
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|alias
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|alias
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|alias
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_THIS_STATIC
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_DESTRUCTOR_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CLONED_FUNCTION
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DEFERRED_FN
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|alias
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|alias
argument_list|,
name|DECL_NAME
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
name|assemble_alias
argument_list|(
name|alias
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Emit the definition of a C++ multiple inheritance or covariant    return vtable thunk.  If EMIT_P is nonzero, the thunk is emitted    immediately.  */
end_comment

begin_function
name|void
name|use_thunk
parameter_list|(
name|tree
name|thunk_fndecl
parameter_list|,
name|bool
name|emit_p
parameter_list|)
block|{
name|tree
name|function
decl_stmt|,
name|alias
decl_stmt|;
name|tree
name|virtual_offset
decl_stmt|;
name|HOST_WIDE_INT
name|fixed_offset
decl_stmt|,
name|virtual_value
decl_stmt|;
name|bool
name|this_adjusting
init|=
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk_fndecl
argument_list|)
decl_stmt|;
comment|/* We should have called finish_thunk to give it a name.  */
name|my_friendly_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|20021127
argument_list|)
expr_stmt|;
comment|/* We should never be using an alias, always refer to the      aliased thunk.  */
name|my_friendly_assert
argument_list|(
operator|!
name|THUNK_ALIAS
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|20031023
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
return|return;
name|function
operator|=
name|THUNK_TARGET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
comment|/* We already turned this thunk into an ordinary function.        There's no need to process this thunk again.  */
return|return;
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|function
argument_list|)
condition|)
comment|/* The target is itself a thunk, process it now.  */
name|use_thunk
argument_list|(
name|function
argument_list|,
name|emit_p
argument_list|)
expr_stmt|;
comment|/* Thunks are always addressable; they only appear in vtables.  */
name|TREE_ADDRESSABLE
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Figure out what function is being thunked to.  It's referenced in      this translation unit.  */
name|TREE_ADDRESSABLE
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emit_p
condition|)
return|return;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEF
name|alias
operator|=
name|make_alias_for_thunk
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|#
directive|else
name|alias
operator|=
name|function
expr_stmt|;
endif|#
directive|endif
name|fixed_offset
operator|=
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|virtual_offset
operator|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_offset
condition|)
block|{
if|if
condition|(
operator|!
name|this_adjusting
condition|)
name|virtual_offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|virtual_offset
argument_list|)
expr_stmt|;
name|virtual_value
operator|=
name|tree_low_cst
argument_list|(
name|virtual_offset
argument_list|,
comment|/*pos=*/
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|virtual_value
argument_list|,
literal|20021026
argument_list|)
expr_stmt|;
block|}
else|else
name|virtual_value
operator|=
literal|0
expr_stmt|;
comment|/* And, if we need to emit the thunk, it's used.  */
name|mark_used
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
comment|/* This thunk is actually defined.  */
name|DECL_EXTERNAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The linkage of the function may have changed.  FIXME in linkage      rewrite.  */
name|TREE_PUBLIC
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|push_to_top_level
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_DEF
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|TARGET_IS_PE_COFF
argument_list|)
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
name|resolve_unique_section
argument_list|(
name|function
argument_list|,
literal|0
argument_list|,
name|flag_function_sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|function
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|resolve_unique_section
argument_list|(
name|thunk_fndecl
argument_list|,
literal|0
argument_list|,
name|flag_function_sections
argument_list|)
expr_stmt|;
comment|/* Output the thunk into the same section as function.  */
name|DECL_SECTION_NAME
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* The back-end expects DECL_INITIAL to contain a BLOCK, so we      create one.  */
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_adjusting
operator|&&
name|targetm
operator|.
name|asm_out
operator|.
name|can_output_mi_thunk
argument_list|(
name|thunk_fndecl
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_value
argument_list|,
name|alias
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|current_function_decl
operator|=
name|thunk_fndecl
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_function_start
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|current_function_is_thunk
operator|=
literal|1
expr_stmt|;
name|assemble_start_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|output_mi_thunk
argument_list|(
name|asm_out_file
argument_list|,
name|thunk_fndecl
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_value
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|assemble_end_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
comment|/* Because init_function_start increments this, we must 	 decrement it.  */
name|immediate_size_expand
operator|--
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is a covariant thunk, or we don't have the necessary 	 code for efficient thunks, generate a thunk function that 	 just makes a call to the real function.  Unfortunately, this 	 doesn't work for varargs.  */
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|varargs_function_p
argument_list|(
name|function
argument_list|)
condition|)
name|error
argument_list|(
literal|"generic thunk code fails for method `%#D' which uses `...'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Set up cloned argument trees for the thunk.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|function
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|x
init|=
name|copy_node
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|thunk_fndecl
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|t
operator|=
name|x
expr_stmt|;
block|}
name|a
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|a
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|thunk_fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* We don't bother with a body block for thunks.  */
comment|/* There's no need to check accessibility inside the thunk body.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|t
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|this_adjusting
condition|)
name|t
operator|=
name|thunk_adjust
argument_list|(
name|t
argument_list|,
comment|/*this_adjusting=*/
literal|1
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* Build up the call to the real function.  */
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|a
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|alias
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|CALL_FROM_THUNK_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|force_target_expr
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_adjusting
condition|)
name|t
operator|=
name|thunk_adjust
argument_list|(
name|t
argument_list|,
comment|/*this_adjusting=*/
literal|0
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|finish_return_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Since we want to emit the thunk, we explicitly mark its name as 	 referenced.  */
name|mark_referenced
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But we don't want debugging information about it.  */
name|DECL_IGNORED_P
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Re-enable access control.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
name|expand_body
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for synthesizing methods which have default semantics defined.  */
end_comment

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
specifier|static
name|void
name|do_build_copy_constructor
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|parm
init|=
name|FUNCTION_FIRST_USER_PARM
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|cvquals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize all the base-classes with the parameter converted 	 to their type so that we get their copy constructor and not 	 another constructor that takes current_class_type.  We must 	 deal with the binfo's directly as a direct base might be 	 inaccessible due to ambiguity.  */
for|for
control|(
name|t
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
continue|continue;
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|init
init|=
name|parm
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
name|tree
name|expr_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|expr_type
argument_list|)
condition|)
comment|/* Just use the field; anonymous types can't have 	       nontrivial copy ctors or assignment ops.  */
empty_stmt|;
else|else
continue|continue;
comment|/* Compute the type of "init->field".  If the copy-constructor 	     parameter is, for example, "const S&", and the type of 	     the field is "T", then the type will usually be "const 	     T".  (There are no cv-qualified variants of reference 	     types.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|int
name|quals
init|=
name|cvquals
decl_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|expr_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|expr_type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|expr_type
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|init
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|finish_mem_initializers
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_build_assign_ref
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
name|false
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
decl_stmt|;
name|int
name|cvquals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Assign to each of the direct base classes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|converted_parm
decl_stmt|;
name|binfo
operator|=
name|BINFO_BASETYPE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* We must convert PARM directly to the base class 	     explicitly since the base class may be ambiguous.  */
name|converted_parm
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Call the base class assignment operator.  */
name|finish_expr_stmt
argument_list|(
name|build_special_member_call
argument_list|(
name|current_class_ref
argument_list|,
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|converted_parm
argument_list|)
argument_list|,
name|binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Assign to each of the non-static data members.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|comp
init|=
name|current_class_ref
decl_stmt|;
name|tree
name|init
init|=
name|parm
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
name|tree
name|expr_type
decl_stmt|;
name|int
name|quals
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-static const member `%#D', can't use default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-static reference member `%#D', can't use default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|expr_type
argument_list|)
condition|)
comment|/* Just use the field; anonymous types can't have 	       nontrivial copy ctors or assignment ops.  */
empty_stmt|;
else|else
continue|continue;
name|comp
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|comp
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* Compute the type of init->field  */
name|quals
operator|=
name|cvquals
expr_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|expr_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|expr_type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|expr_type
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|init
operator|=
name|build_modify_expr
argument_list|(
name|comp
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|comp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_return_stmt
argument_list|(
name|current_class_ref
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|synthesize_method
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|bool
name|nested
init|=
operator|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|bool
name|need_body
init|=
name|true
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|at_eof
condition|)
name|import_export_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* If we've been asked to synthesize a clone, just synthesize the      cloned function instead.  Doing so will automatically fill in the      body for the clone.  */
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|synthesize_method
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We may be in the middle of deferred access check.  Disable      it now.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|push_function_context_to
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Put the function definition at the position where it is needed,      rather than within the body of the class.  That way, an error      during the generation of the implicit body points at the place      where the attempt to generate the function occurs, giving the      user a hint as to why we are attempting to generate the      function.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|fndecl
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_DEFAULT
operator||
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|do_build_assign_ref
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|need_body
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|arg_chain
init|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_chain
operator|!=
name|void_list_node
condition|)
name|do_build_copy_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|finish_mem_initializers
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't yet generated the body of the function, just      generate an empty compound statement.  */
if|if
condition|(
name|need_body
condition|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
name|false
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
name|finish_function_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|expand_or_defer_fn
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|pop_function_context_from
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use EXTRACTOR to locate the relevant function called for each base&    class field of TYPE. CLIENT allows additional information to be passed    to EXTRACTOR.  Generates the union of all exceptions generated by those    functions.  Note that we haven't updated TYPE_FIELDS and such of any    variants yet, so we need to look at the main one.  */
end_comment

begin_function
specifier|static
name|tree
name|synthesize_exception_spec
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
function_decl|(
modifier|*
name|extractor
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|client
parameter_list|)
block|{
name|tree
name|raises
init|=
name|empty_except_spec
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_bases
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
call|(
modifier|*
name|extractor
call|)
argument_list|(
name|base
argument_list|,
name|client
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|fn_raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|raises
operator|=
name|merge_exception_specifiers
argument_list|(
name|raises
argument_list|,
name|fn_raises
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|fields
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
continue|continue;
name|fn
operator|=
call|(
modifier|*
name|extractor
call|)
argument_list|(
name|type
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|fn_raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|raises
operator|=
name|merge_exception_specifiers
argument_list|(
name|raises
argument_list|,
name|fn_raises
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|raises
return|;
block|}
end_function

begin_comment
comment|/* Locate the dtor of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_dtor
parameter_list|(
name|tree
name|type
parameter_list|,
name|void
modifier|*
name|client
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|CLASSTYPE_DESTRUCTOR_SLOT
argument_list|)
expr_stmt|;
return|return
name|fns
return|;
block|}
end_function

begin_comment
comment|/* Locate the default ctor of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_ctor
parameter_list|(
name|tree
name|type
parameter_list|,
name|void
modifier|*
name|client
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|CLASSTYPE_CONSTRUCTOR_SLOT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sufficient_parms_p
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_struct
struct|struct
name|copy_data
block|{
name|tree
name|name
decl_stmt|;
name|int
name|quals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Locate the copy ctor or copy assignment of TYPE. CLIENT_    points to a COPY_DATA holding the name (NULL for the ctor)    and desired qualifiers of the source operand.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_copy
parameter_list|(
name|tree
name|type
parameter_list|,
name|void
modifier|*
name|client_
parameter_list|)
block|{
name|struct
name|copy_data
modifier|*
name|client
init|=
operator|(
expr|struct
name|copy_data
operator|*
operator|)
name|client_
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|int
name|ix
init|=
operator|-
literal|1
decl_stmt|;
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|excess_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|ix
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
name|ix
operator|=
name|CLASSTYPE_CONSTRUCTOR_SLOT
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|src_type
decl_stmt|;
name|int
name|excess
decl_stmt|;
name|int
name|quals
decl_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parms
condition|)
continue|continue;
name|src_type
operator|=
name|non_reference
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|src_type
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
continue|continue;
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|quals
operator|&
operator|~
name|quals
condition|)
continue|continue;
name|excess
operator|=
name|quals
operator|&
operator|~
name|client
operator|->
name|quals
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
operator|(
name|excess_p
operator|&&
operator|!
name|excess
operator|)
condition|)
block|{
name|best
operator|=
name|fn
expr_stmt|;
name|excess_p
operator|=
name|excess
expr_stmt|;
block|}
else|else
comment|/* Ambiguous */
return|return
name|NULL_TREE
return|;
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Implicitly declare the special function indicated by KIND, as a    member of TYPE.  For copy constructors and assignment operators,    CONST_P indicates whether these functions should take a const    reference argument or a non-const reference.  */
end_comment

begin_function
name|tree
name|implicitly_declare_fn
parameter_list|(
name|special_function_kind
name|kind
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|const_p
parameter_list|)
block|{
name|tree
name|declspecs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|raises
init|=
name|empty_except_spec
decl_stmt|;
name|bool
name|retref
init|=
name|false
decl_stmt|;
name|bool
name|has_parm
init|=
name|false
decl_stmt|;
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|sfk_destructor
case|:
comment|/* Destructor.  */
name|name
operator|=
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|args
operator|=
name|void_list_node
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_dtor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|sfk_constructor
case|:
comment|/* Default constructor.  */
name|args
operator|=
name|void_list_node
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_ctor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|sfk_copy_constructor
case|:
case|case
name|sfk_assignment_operator
case|:
block|{
name|struct
name|copy_data
name|data
decl_stmt|;
name|tree
name|argtype
init|=
name|type
decl_stmt|;
name|has_parm
operator|=
name|true
expr_stmt|;
name|data
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|quals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|sfk_assignment_operator
condition|)
block|{
name|retref
operator|=
name|true
expr_stmt|;
name|declspecs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
expr_stmt|;
name|data
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|const_p
condition|)
block|{
name|data
operator|.
name|quals
operator|=
name|TYPE_QUAL_CONST
expr_stmt|;
name|argtype
operator|=
name|build_qualified_type
argument_list|(
name|argtype
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|build_reference_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|hash_tree_chain
argument_list|(
name|argtype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"_ctor_arg"
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_copy
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_PARMLIST
argument_list|(
name|args
argument_list|)
operator|=
literal|1
expr_stmt|;
block|{
name|tree
name|declarator
init|=
name|make_call_declarator
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|raises
argument_list|)
decl_stmt|;
if|if
condition|(
name|retref
condition|)
name|declarator
operator|=
name|build_nt
argument_list|(
name|ADDR_EXPR
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|fn
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_parm
condition|)
name|TREE_USED
argument_list|(
name|FUNCTION_FIRST_USER_PARM
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|20000408
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|defer_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Given a FUNCTION_DECL FN and a chain LIST, skip as many elements of LIST    as there are artificial parms in FN.  */
end_comment

begin_function
name|tree
name|skip_artificial_parms_for
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
return|return
name|list
return|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-method.h"
end_include

end_unit

