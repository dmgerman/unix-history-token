begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and variable name overloading.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* Various flags to control the mangling process.  */
end_comment

begin_enum
enum|enum
name|mangling_flags
block|{
comment|/* No flags.  */
name|mf_none
init|=
literal|0
block|,
comment|/* The thing we are presently mangling is part of a template type,      rather than a fully instantiated type.  Therefore, we may see      complex expressions where we would normally expect to see a      simple integer constant.  */
name|mf_maybe_uninstantiated
init|=
literal|1
block|,
comment|/* When mangling a numeric value, use the form `_XX_' (instead of      just `XX') if the value has more than one digit.  */
name|mf_use_underscores_around_value
init|=
literal|2
block|, }
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|mangling_flags
name|mangling_flags
typedef|;
end_typedef

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|static
name|void
name|do_build_assign_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_build_copy_constructor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|synthesize_exception_spec
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
argument_list|(
operator|*
argument_list|)
argument_list|(
name|tree
argument_list|,
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|locate_dtor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|locate_ctor
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|locate_copy
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called once to initialize method.c.  */
end_comment

begin_function
name|void
name|init_method
parameter_list|()
block|{
name|init_mangle
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */
end_comment

begin_function
name|void
name|set_mangled_name_for_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|processing_template_decl
condition|)
comment|/* There's no need to mangle the name of a template function.  */
return|return;
name|mangle_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree_code CODE, and some arguments (at least one),    attempt to use an overloaded operator on the arguments.     For unary operators, only the first argument need be checked.    For binary operators, both arguments may need to be checked.     Member functions can convert class references to class pointers,    for one-level deep indirection.  More than that is not supported.    Operators [](), ()(), and ->() must be member functions.     We call function call building calls with LOOKUP_COMPLAIN if they    are our only hope.  This is true when we see a vanilla operator    applied to something of aggregate type.  If this fails, we are free    to return `error_mark_node', because we will have reported the    error.     Operators NEW and DELETE overload in funny ways: operator new takes    a single `size' parameter, and operator delete takes a pointer to the    storage being deleted.  When overloading these operators, success is    assumed.  If there is a failure, report an error message and return    `error_mark_node'.  */
end_comment

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|tree
name|build_opfncall
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|xarg1
parameter_list|,
name|xarg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|tree
name|xarg1
decl_stmt|,
name|xarg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
return|return
name|build_new_op
argument_list|(
name|code
argument_list|,
name|flags
argument_list|,
name|xarg1
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function takes an identifier, ID, and attempts to figure out what    it means. There are a number of possible scenarios, presented in increasing    order of hair:     1) not in a class's scope    2) in class's scope, member name of the class's method    3) in class's scope, but not a member name of the class    4) in class's scope, member name of a class's variable     NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.    VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)     As a last ditch, try to look up the name as a label and return that    address.     Values which are declared as being of REFERENCE_TYPE are    automatically dereferenced here (as a hack to make the    compiler faster).  */
end_comment

begin_function
name|tree
name|hack_identifier
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|)
name|tree
name|value
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|current_class_ptr
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of member `%D' in static member function"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
comment|/* We can get here when processing a bad default 	       argument, like: 	         struct S { int a; void f(int i = a); }  */
name|error
argument_list|(
literal|"invalid use of member `%D'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark so that if we are in a constructor, and then find that 	 this field was initialized by a base initializer, 	 we can emit an error message.  */
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|build_component_ref
argument_list|(
name|current_class_ref
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|value
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|value
operator|=
name|OVL_CURRENT
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|build_component_ref
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|really_overloaded_fn
argument_list|(
name|value
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|OVERLOAD
condition|)
comment|/* not really overloaded function */
name|mark_used
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Ambiguous reference to base members, possibly other cases?.  */
name|tree
name|t
init|=
name|value
decl_stmt|;
while|while
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|mark_used
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"use of namespace `%D' as expression"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use of class template `%T' as expression"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|mark_used
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use of %s from containing function"
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|?
literal|"`auto' variable"
else|:
literal|"parameter"
operator|)
argument_list|)
expr_stmt|;
name|cp_error_at
argument_list|(
literal|"  `%#D' declared here"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|value
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|value
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|path
operator|=
name|currently_open_derived_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|enforce_access
argument_list|(
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"\ request for member `%D' is ambiguous in multiple inheritance lattice"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|value
operator|=
name|convert_from_reference
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a thunk to FUNCTION.  For a virtual thunk, DELTA is the    offset to this used to locate the vptr, and VCALL_INDEX is used to    look up the eventual subobject location.  For a non-virtual thunk,    DELTA is the offset to this and VCALL_INDEX is NULL.  */
end_comment

begin_function
name|tree
name|make_thunk
parameter_list|(
name|function
parameter_list|,
name|delta
parameter_list|,
name|vcall_index
parameter_list|)
name|tree
name|function
decl_stmt|;
name|tree
name|delta
decl_stmt|;
name|tree
name|vcall_index
decl_stmt|;
block|{
name|tree
name|thunk_id
decl_stmt|;
name|tree
name|thunk
decl_stmt|;
name|tree
name|func_decl
decl_stmt|;
name|tree
name|vcall_offset
decl_stmt|;
name|HOST_WIDE_INT
name|d
decl_stmt|;
comment|/* Scale the VCALL_INDEX to be in terms of bytes.  */
if|if
condition|(
name|vcall_index
condition|)
name|vcall_offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|vcall_index
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vcall_offset
operator|=
name|NULL_TREE
expr_stmt|;
name|d
operator|=
name|tree_low_cst
argument_list|(
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|func_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|thunk_id
operator|=
name|mangle_thunk
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|,
name|delta
argument_list|,
name|vcall_offset
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|thunk
operator|&&
operator|!
name|DECL_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"implementation-reserved name `%D' used"
argument_list|,
name|thunk_id
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|NULL_TREE
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|,
name|thunk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thunk
operator|==
name|NULL_TREE
condition|)
block|{
name|thunk
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|thunk_id
argument_list|,
name|TREE_TYPE
argument_list|(
name|func_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|copy_lang_decl
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|thunk
argument_list|,
name|thunk_id
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|func_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|SET_DECL_THUNK_P
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|thunk
argument_list|)
operator|=
name|function
expr_stmt|;
name|THUNK_DELTA
argument_list|(
name|thunk
argument_list|)
operator|=
name|d
expr_stmt|;
name|THUNK_VCALL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|=
name|vcall_offset
expr_stmt|;
comment|/* The thunk itself is not a constructor or destructor, even if          the thing it is thunking to is.  */
name|DECL_INTERFACE_KNOWN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_DESTRUCTOR_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* And neither is it a clone.  */
name|DECL_CLONED_FUNCTION
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if this thunk is a member of a local class, we don't 	 need a static chain.  */
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The THUNK is not a pending inline, even if the FUNC_DECL is.  */
name|DECL_PENDING_INLINE_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Nor has it been deferred.  */
name|DECL_DEFERRED_FN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* So that finish_file can write out any thunks that need to be: */
name|pushdecl_top_level
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|thunk_id
argument_list|,
name|thunk
argument_list|)
expr_stmt|;
block|}
return|return
name|thunk
return|;
block|}
end_function

begin_comment
comment|/* Emit the definition of a C++ multiple inheritance vtable thunk.  If    EMIT_P is non-zero, the thunk is emitted immediately.  */
end_comment

begin_function
name|void
name|use_thunk
parameter_list|(
name|thunk_fndecl
parameter_list|,
name|emit_p
parameter_list|)
name|tree
name|thunk_fndecl
decl_stmt|;
name|int
name|emit_p
decl_stmt|;
block|{
name|tree
name|fnaddr
decl_stmt|;
name|tree
name|function
decl_stmt|;
name|tree
name|vcall_offset
decl_stmt|;
name|HOST_WIDE_INT
name|delta
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
return|return;
name|fnaddr
operator|=
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
comment|/* We already turned this thunk into an ordinary function.        There's no need to process this thunk again.  */
return|return;
comment|/* Thunks are always addressable; they only appear in vtables.  */
name|TREE_ADDRESSABLE
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Figure out what function is being thunked to.  It's referenced in      this translation unit.  */
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|emit_p
condition|)
return|return;
name|delta
operator|=
name|THUNK_DELTA
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|vcall_offset
operator|=
name|THUNK_VCALL_OFFSET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
comment|/* And, if we need to emit the thunk, it's used.  */
name|mark_used
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
comment|/* This thunk is actually defined.  */
name|DECL_EXTERNAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The linkage of the function may have changed.  FIXME in linkage      rewrite.  */
name|TREE_PUBLIC
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|push_to_top_level
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MI_THUNK
if|if
condition|(
operator|!
name|vcall_offset
condition|)
block|{
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|current_function_decl
operator|=
name|thunk_fndecl
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_function_start
argument_list|(
name|thunk_fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|current_function_is_thunk
operator|=
literal|1
expr_stmt|;
name|assemble_start_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_MI_THUNK
argument_list|(
name|asm_out_file
argument_list|,
name|thunk_fndecl
argument_list|,
name|delta
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|assemble_end_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ASM_OUTPUT_MI_THUNK */
block|{
comment|/* If we don't have the necessary macro for efficient thunks, generate a      thunk function that just makes a call to the real function.      Unfortunately, this doesn't work for varargs.  */
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|varargs_function_p
argument_list|(
name|function
argument_list|)
condition|)
name|error
argument_list|(
literal|"generic thunk code fails for method `%#D' which uses `...'"
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* Set up clone argument trees for the thunk.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|function
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|x
init|=
name|copy_node
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|thunk_fndecl
expr_stmt|;
name|t
operator|=
name|x
expr_stmt|;
block|}
name|a
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|a
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|thunk_fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* We don't bother with a body block for thunks.  */
comment|/* Adjust the this pointer by the constant.  */
name|t
operator|=
name|ssize_int
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
argument_list|,
name|a
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's a vcall offset, look up that value in the vtable and        adjust the `this' pointer again.  */
if|if
condition|(
name|vcall_offset
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|tree
name|orig_this
decl_stmt|;
name|t
operator|=
name|save_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|orig_this
operator|=
name|t
expr_stmt|;
comment|/* The vptr is always at offset zero in the object.  */
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Form the vtable address.  */
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Find the entry with the vcall offset.  */
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|vcall_offset
argument_list|)
expr_stmt|;
comment|/* Calculate the offset itself.  */
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Adjust the `this' pointer.  */
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_this
argument_list|)
argument_list|,
name|orig_this
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Build up the call to the real function.  */
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|a
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|function
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|finish_return_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* The back-end expects DECL_INITIAL to contain a BLOCK, so we        create one.  */
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
comment|/* Since we want to emit the thunk, we explicitly mark its name as        referenced.  */
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* But we don't want debugging information about it.  */
name|DECL_IGNORED_P
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_body
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for synthesizing methods which have default semantics defined.  */
end_comment

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
specifier|static
name|void
name|do_build_copy_constructor
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|FUNCTION_FIRST_USER_PARM
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|base_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|cvquals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize all the base-classes with the parameter converted 	 to their type so that we get their copy constructor and not 	 another constructor that takes current_class_type.  We must 	 deal with the binfo's directly as a direct base might be 	 inaccessible due to ambiguity.  */
for|for
control|(
name|t
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
continue|continue;
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|init
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|init
operator|=
name|parm
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* Just use the field; anonymous types can't have 	       nontrivial copy ctors or assignment ops.  */
empty_stmt|;
else|else
continue|continue;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|cvquals
argument_list|)
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|init
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|member_init_list
operator|=
name|nreverse
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
name|base_init_list
operator|=
name|nreverse
argument_list|(
name|base_init_list
argument_list|)
expr_stmt|;
name|emit_base_init
argument_list|(
name|member_init_list
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_build_assign_ref
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|int
name|cvquals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
comment|/* We must deal with the binfo's directly as a direct base 	     might be inaccessible due to ambiguity.  */
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|src
init|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|dst
init|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|current_class_ref
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|expr
init|=
name|build_method_call
argument_list|(
name|dst
argument_list|,
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|src
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|comp
decl_stmt|,
name|init
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-static const member `%#D', can't use default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-static reference member `%#D', can't use default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|comp
operator|=
name|current_class_ref
expr_stmt|;
name|init
operator|=
name|parm
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* True for duplicate members.  */
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|field
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|NULL_TREE
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* Just use the field; anonymous types can't have 	       nontrivial copy ctors or assignment ops.  */
empty_stmt|;
else|else
continue|continue;
name|comp
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|comp
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|cvquals
argument_list|)
argument_list|,
name|init
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|finish_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|comp
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|finish_expr_stmt
argument_list|(
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|comp
argument_list|,
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_return_stmt
argument_list|(
name|current_class_ref
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|synthesize_method
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
name|int
name|nested
init|=
operator|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|int
name|need_body
init|=
literal|1
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|at_eof
condition|)
name|import_export_decl
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* If we've been asked to synthesize a clone, just synthesize the      cloned function instead.  Doing so will automatically fill in the      body for the clone.  */
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|synthesize_method
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|context
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|push_function_context_to
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* Put the function definition at the position where it is needed,      rather than within the body of the class.  That way, an error      during the generation of the implicit body points at the place      where the attempt to generate the function occurs, giving the      user a hint as to why we are attempting to generate the      function. */
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_DEFAULT
operator||
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|do_build_assign_ref
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|need_body
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|arg_chain
init|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_chain
operator|!=
name|void_list_node
condition|)
name|do_build_copy_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|current_class_type
argument_list|)
condition|)
name|finish_mem_initializers
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't yet generated the body of the function, just      generate an empty compound statement.  */
if|if
condition|(
name|need_body
condition|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
comment|/*has_no_scope=*/
literal|0
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
name|finish_function_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|expand_body
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extract_interface_info
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|pop_function_context_from
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use EXTRACTOR to locate the relevant function called for each base&    class field of TYPE. CLIENT allows additional information to be passed    to EXTRACTOR.  Generates the union of all exceptions generated by    those functions.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
name|extractor
argument_list|,
name|client
argument_list|)
name|tree
name|type
decl_stmt|;
end_decl_stmt

begin_function_decl
name|tree
function_decl|(
modifier|*
name|extractor
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|client
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|raises
init|=
name|empty_except_spec
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_bases
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|n_bases
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
call|(
modifier|*
name|extractor
call|)
argument_list|(
name|base
argument_list|,
name|client
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|fn_raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|raises
operator|=
name|merge_exception_specifiers
argument_list|(
name|raises
argument_list|,
name|fn_raises
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
continue|continue;
name|fn
operator|=
call|(
modifier|*
name|extractor
call|)
argument_list|(
name|type
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|fn_raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|raises
operator|=
name|merge_exception_specifiers
argument_list|(
name|raises
argument_list|,
name|fn_raises
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|raises
return|;
block|}
end_block

begin_comment
comment|/* Locate the dtor of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_dtor
parameter_list|(
name|type
parameter_list|,
name|client
parameter_list|)
name|tree
name|type
decl_stmt|;
name|void
modifier|*
name|client
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|fns
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|CLASSTYPE_DESTRUCTOR_SLOT
argument_list|)
expr_stmt|;
return|return
name|fns
return|;
block|}
end_function

begin_comment
comment|/* Locate the default ctor of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_ctor
parameter_list|(
name|type
parameter_list|,
name|client
parameter_list|)
name|tree
name|type
decl_stmt|;
name|void
modifier|*
name|client
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|fns
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|CLASSTYPE_CONSTRUCTOR_SLOT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sufficient_parms_p
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_struct
struct|struct
name|copy_data
block|{
name|tree
name|name
decl_stmt|;
name|int
name|quals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Locate the copy ctor or copy assignment of TYPE. CLIENT_    points to a COPY_DATA holding the name (NULL for the ctor)    and desired qualifiers of the source operand.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_copy
parameter_list|(
name|type
parameter_list|,
name|client_
parameter_list|)
name|tree
name|type
decl_stmt|;
name|void
modifier|*
name|client_
decl_stmt|;
block|{
name|struct
name|copy_data
modifier|*
name|client
init|=
operator|(
expr|struct
name|copy_data
operator|*
operator|)
name|client_
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|int
name|ix
init|=
operator|-
literal|1
decl_stmt|;
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|excess_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
condition|)
name|ix
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
name|ix
operator|=
name|CLASSTYPE_CONSTRUCTOR_SLOT
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|src_type
decl_stmt|;
name|int
name|excess
decl_stmt|;
name|int
name|quals
decl_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parms
condition|)
continue|continue;
name|src_type
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|src_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|src_type
operator|=
name|TREE_TYPE
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|src_type
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
continue|continue;
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|quals
operator|&
operator|~
name|quals
condition|)
continue|continue;
name|excess
operator|=
name|quals
operator|&
operator|~
name|client
operator|->
name|quals
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
operator|(
name|excess_p
operator|&&
operator|!
name|excess
operator|)
condition|)
block|{
name|best
operator|=
name|fn
expr_stmt|;
name|excess_p
operator|=
name|excess
expr_stmt|;
block|}
else|else
comment|/* Ambiguous */
return|return
name|NULL_TREE
return|;
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Implicitly declare the special function indicated by KIND, as a    member of TYPE.  For copy constructors and assignment operators,    CONST_P indicates whether these functions should take a const    reference argument or a non-const reference.  */
end_comment

begin_function
name|tree
name|implicitly_declare_fn
parameter_list|(
name|kind
parameter_list|,
name|type
parameter_list|,
name|const_p
parameter_list|)
name|special_function_kind
name|kind
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|const_p
decl_stmt|;
block|{
name|tree
name|declspecs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|raises
init|=
name|empty_except_spec
decl_stmt|;
name|int
name|retref
init|=
literal|0
decl_stmt|;
name|int
name|has_parm
init|=
literal|0
decl_stmt|;
name|tree
name|name
init|=
name|constructor_name
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|sfk_destructor
case|:
comment|/* Destructor.  */
name|name
operator|=
name|build_nt
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|args
operator|=
name|void_list_node
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_dtor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|sfk_constructor
case|:
comment|/* Default constructor.  */
name|args
operator|=
name|void_list_node
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_ctor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|sfk_copy_constructor
case|:
case|case
name|sfk_assignment_operator
case|:
block|{
name|struct
name|copy_data
name|data
decl_stmt|;
name|tree
name|argtype
decl_stmt|;
name|has_parm
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|quals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|sfk_assignment_operator
condition|)
block|{
name|retref
operator|=
literal|1
expr_stmt|;
name|declspecs
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
expr_stmt|;
name|data
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|const_p
condition|)
block|{
name|data
operator|.
name|quals
operator|=
name|TYPE_QUAL_CONST
expr_stmt|;
name|type
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_tree_list
argument_list|(
name|hash_tree_chain
argument_list|(
name|argtype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"_ctor_arg"
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|args
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_copy
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_PARMLIST
argument_list|(
name|args
argument_list|)
operator|=
literal|1
expr_stmt|;
block|{
name|tree
name|declarator
init|=
name|make_call_declarator
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|raises
argument_list|)
decl_stmt|;
if|if
condition|(
name|retref
condition|)
name|declarator
operator|=
name|build_nt
argument_list|(
name|ADDR_EXPR
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
name|fn
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_parm
condition|)
name|TREE_USED
argument_list|(
name|FUNCTION_FIRST_USER_PARM
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|,
literal|20000408
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|defer_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Given a FUNCTION_DECL FN and a chain LIST, skip as many elements of LIST    as there are artificial parms in FN.  */
end_comment

begin_function
name|tree
name|skip_artificial_parms_for
parameter_list|(
name|fn
parameter_list|,
name|list
parameter_list|)
name|tree
name|fn
decl_stmt|,
name|list
decl_stmt|;
block|{
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
return|return
name|list
return|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

end_unit

